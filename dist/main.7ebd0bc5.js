// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/three/build/three.module.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DstAlphaFactor = exports.DoubleSide = exports.DodecahedronGeometry = exports.DisplayP3ColorSpace = exports.DiscreteInterpolant = exports.DirectionalLightHelper = exports.DirectionalLight = exports.DetachedBindMode = exports.DepthTexture = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.DataUtils = exports.DataTextureLoader = exports.DataTexture = exports.DataArrayTexture = exports.Data3DTexture = exports.Cylindrical = exports.CylinderGeometry = exports.CustomToneMapping = exports.CustomBlending = exports.CurvePath = exports.Curve = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubicInterpolant = exports.CubicBezierCurve3 = exports.CubicBezierCurve = exports.CubeUVReflectionMapping = exports.CubeTextureLoader = exports.CubeTexture = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.CubeCamera = exports.ConstantColorFactor = exports.ConstantAlphaFactor = exports.ConeGeometry = exports.CompressedTextureLoader = exports.CompressedTexture = exports.CompressedCubeTexture = exports.CompressedArrayTexture = exports.ColorManagement = exports.ColorKeyframeTrack = exports.Color = exports.Clock = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CineonToneMapping = exports.CatmullRomCurve3 = exports.CapsuleGeometry = exports.CanvasTexture = exports.CameraHelper = exports.Camera = exports.Cache = exports.ByteType = exports.BufferGeometryLoader = exports.BufferGeometry = exports.BufferAttribute = exports.BoxHelper = exports.BoxGeometry = exports.Box3Helper = exports.Box3 = exports.Box2 = exports.BooleanKeyframeTrack = exports.Bone = exports.BatchedMesh = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AxesHelper = exports.AudioLoader = exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.AttachedBindMode = exports.ArrowHelper = exports.ArrayCamera = exports.ArcCurve = exports.AnimationUtils = exports.AnimationObjectGroup = exports.AnimationMixer = exports.AnimationLoader = exports.AnimationClip = exports.AnimationAction = exports.AmbientLight = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlwaysCompare = exports.AlphaFormat = exports.AgXToneMapping = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.MaterialLoader = exports.Material = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LoadingManager = exports.LoaderUtils = exports.Loader = exports.LinearTransfer = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearInterpolant = exports.LinearFilter = exports.LinearDisplayP3ColorSpace = exports.LineSegments = exports.LineLoop = exports.LineDashedMaterial = exports.LineCurve3 = exports.LineCurve = exports.LineBasicMaterial = exports.Line3 = exports.Line = exports.LightProbe = exports.Light = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessEqualCompare = exports.LessDepth = exports.LessCompare = exports.Layers = exports.LatheGeometry = exports.LOD = exports.KeyframeTrack = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.Interpolant = exports.InterleavedBufferAttribute = exports.InterleavedBuffer = exports.IntType = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.InstancedMesh = exports.InstancedInterleavedBuffer = exports.InstancedBufferGeometry = exports.InstancedBufferAttribute = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.ImageUtils = exports.ImageLoader = exports.ImageBitmapLoader = exports.IcosahedronGeometry = exports.HemisphereLightHelper = exports.HemisphereLight = exports.HalfFloatType = exports.Group = exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterEqualCompare = exports.GreaterDepth = exports.GreaterCompare = exports.GLSL3 = exports.GLSL1 = exports.GLBufferAttribute = exports.Frustum = exports.FrontSide = exports.FramebufferTexture = exports.FogExp2 = exports.Fog = exports.FloatType = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.FileLoader = exports.ExtrudeGeometry = exports.EventDispatcher = exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EqualCompare = exports.EllipseCurve = exports.EdgesGeometry = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = void 0;
exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.RED_RGTC1_Format = exports.RED_GREEN_RGTC2_Format = exports.QuaternionLinearInterpolant = exports.QuaternionKeyframeTrack = exports.Quaternion = exports.QuadraticBezierCurve3 = exports.QuadraticBezierCurve = exports.PropertyMixer = exports.PropertyBinding = exports.PositionalAudio = exports.PolyhedronGeometry = exports.PolarGridHelper = exports.PointsMaterial = exports.Points = exports.PointLightHelper = exports.PointLight = exports.PlaneHelper = exports.PlaneGeometry = exports.Plane = exports.PerspectiveCamera = exports.Path = exports.PMREMGenerator = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.P3Primaries = exports.OrthographicCamera = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneMinusConstantColorFactor = exports.OneMinusConstantAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.ObjectSpaceNormalMap = exports.ObjectLoader = exports.Object3D = exports.NumberKeyframeTrack = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NotEqualCompare = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NeverCompare = exports.NeutralToneMapping = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MeshToonMaterial = exports.MeshStandardMaterial = exports.MeshPhysicalMaterial = exports.MeshPhongMaterial = exports.MeshNormalMaterial = exports.MeshMatcapMaterial = exports.MeshLambertMaterial = exports.MeshDistanceMaterial = exports.MeshDepthMaterial = exports.MeshBasicMaterial = exports.Mesh = exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.Matrix2 = exports.MathUtils = void 0;
exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt5999Type = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = exports.UniformsGroup = exports.Uniform = exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.UVMapping = exports.TubeGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TorusKnotGeometry = exports.TorusGeometry = exports.TextureUtils = exports.TextureLoader = exports.Texture = exports.TetrahedronGeometry = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StringKeyframeTrack = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StereoCamera = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SpriteMaterial = exports.Sprite = exports.SpotLightHelper = exports.SpotLight = exports.SplineCurve = exports.SphericalHarmonics3 = exports.Spherical = exports.SphereGeometry = exports.Sphere = exports.Source = exports.SkinnedMesh = exports.SkeletonHelper = exports.Skeleton = exports.ShortType = exports.ShapeUtils = exports.ShapePath = exports.ShapeGeometry = exports.Shape = exports.ShadowMaterial = exports.ShaderMaterial = exports.ShaderLib = exports.ShaderChunk = exports.Scene = exports.SRGBTransfer = exports.SRGBColorSpace = exports.SIGNED_RED_RGTC1_Format = exports.SIGNED_RED_GREEN_RGTC2_Format = exports.RingGeometry = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.RenderTarget = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RectAreaLight = exports.Rec709Primaries = exports.Raycaster = exports.Ray = exports.RawShaderMaterial = exports.RGIntegerFormat = exports.RGFormat = exports.RGDepthPacking = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGB_BPTC_UNSIGNED_Format = exports.RGB_BPTC_SIGNED_Format = exports.RGBIntegerFormat = exports.RGBFormat = exports.RGBDepthPacking = exports.RGBA_S3TC_DXT5_Format = void 0;
exports.WebGLRenderer = exports.WebGLRenderTarget = exports.WebGLMultipleRenderTargets = exports.WebGLCubeRenderTarget = exports.WebGLCoordinateSystem = exports.WebGLArrayRenderTarget = exports.WebGL3DRenderTarget = exports.VideoTexture = exports.VectorKeyframeTrack = void 0;
exports.WebGLUtils = WebGLUtils;
exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WireframeGeometry = exports.WebGPUCoordinateSystem = void 0;
exports.createCanvasElement = createCanvasElement;
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
var REVISION = exports.REVISION = '167';
var MOUSE = exports.MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
var TOUCH = exports.TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
var CullFaceNone = exports.CullFaceNone = 0;
var CullFaceBack = exports.CullFaceBack = 1;
var CullFaceFront = exports.CullFaceFront = 2;
var CullFaceFrontBack = exports.CullFaceFrontBack = 3;
var BasicShadowMap = exports.BasicShadowMap = 0;
var PCFShadowMap = exports.PCFShadowMap = 1;
var PCFSoftShadowMap = exports.PCFSoftShadowMap = 2;
var VSMShadowMap = exports.VSMShadowMap = 3;
var FrontSide = exports.FrontSide = 0;
var BackSide = exports.BackSide = 1;
var DoubleSide = exports.DoubleSide = 2;
var NoBlending = exports.NoBlending = 0;
var NormalBlending = exports.NormalBlending = 1;
var AdditiveBlending = exports.AdditiveBlending = 2;
var SubtractiveBlending = exports.SubtractiveBlending = 3;
var MultiplyBlending = exports.MultiplyBlending = 4;
var CustomBlending = exports.CustomBlending = 5;
var AddEquation = exports.AddEquation = 100;
var SubtractEquation = exports.SubtractEquation = 101;
var ReverseSubtractEquation = exports.ReverseSubtractEquation = 102;
var MinEquation = exports.MinEquation = 103;
var MaxEquation = exports.MaxEquation = 104;
var ZeroFactor = exports.ZeroFactor = 200;
var OneFactor = exports.OneFactor = 201;
var SrcColorFactor = exports.SrcColorFactor = 202;
var OneMinusSrcColorFactor = exports.OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = exports.SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = exports.OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = exports.DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = exports.OneMinusDstAlphaFactor = 207;
var DstColorFactor = exports.DstColorFactor = 208;
var OneMinusDstColorFactor = exports.OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = exports.SrcAlphaSaturateFactor = 210;
var ConstantColorFactor = exports.ConstantColorFactor = 211;
var OneMinusConstantColorFactor = exports.OneMinusConstantColorFactor = 212;
var ConstantAlphaFactor = exports.ConstantAlphaFactor = 213;
var OneMinusConstantAlphaFactor = exports.OneMinusConstantAlphaFactor = 214;
var NeverDepth = exports.NeverDepth = 0;
var AlwaysDepth = exports.AlwaysDepth = 1;
var LessDepth = exports.LessDepth = 2;
var LessEqualDepth = exports.LessEqualDepth = 3;
var EqualDepth = exports.EqualDepth = 4;
var GreaterEqualDepth = exports.GreaterEqualDepth = 5;
var GreaterDepth = exports.GreaterDepth = 6;
var NotEqualDepth = exports.NotEqualDepth = 7;
var MultiplyOperation = exports.MultiplyOperation = 0;
var MixOperation = exports.MixOperation = 1;
var AddOperation = exports.AddOperation = 2;
var NoToneMapping = exports.NoToneMapping = 0;
var LinearToneMapping = exports.LinearToneMapping = 1;
var ReinhardToneMapping = exports.ReinhardToneMapping = 2;
var CineonToneMapping = exports.CineonToneMapping = 3;
var ACESFilmicToneMapping = exports.ACESFilmicToneMapping = 4;
var CustomToneMapping = exports.CustomToneMapping = 5;
var AgXToneMapping = exports.AgXToneMapping = 6;
var NeutralToneMapping = exports.NeutralToneMapping = 7;
var AttachedBindMode = exports.AttachedBindMode = 'attached';
var DetachedBindMode = exports.DetachedBindMode = 'detached';
var UVMapping = exports.UVMapping = 300;
var CubeReflectionMapping = exports.CubeReflectionMapping = 301;
var CubeRefractionMapping = exports.CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = exports.EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = exports.EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = exports.CubeUVReflectionMapping = 306;
var RepeatWrapping = exports.RepeatWrapping = 1000;
var ClampToEdgeWrapping = exports.ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = exports.MirroredRepeatWrapping = 1002;
var NearestFilter = exports.NearestFilter = 1003;
var NearestMipmapNearestFilter = exports.NearestMipmapNearestFilter = 1004;
var NearestMipMapNearestFilter = exports.NearestMipMapNearestFilter = 1004;
var NearestMipmapLinearFilter = exports.NearestMipmapLinearFilter = 1005;
var NearestMipMapLinearFilter = exports.NearestMipMapLinearFilter = 1005;
var LinearFilter = exports.LinearFilter = 1006;
var LinearMipmapNearestFilter = exports.LinearMipmapNearestFilter = 1007;
var LinearMipMapNearestFilter = exports.LinearMipMapNearestFilter = 1007;
var LinearMipmapLinearFilter = exports.LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = exports.LinearMipMapLinearFilter = 1008;
var UnsignedByteType = exports.UnsignedByteType = 1009;
var ByteType = exports.ByteType = 1010;
var ShortType = exports.ShortType = 1011;
var UnsignedShortType = exports.UnsignedShortType = 1012;
var IntType = exports.IntType = 1013;
var UnsignedIntType = exports.UnsignedIntType = 1014;
var FloatType = exports.FloatType = 1015;
var HalfFloatType = exports.HalfFloatType = 1016;
var UnsignedShort4444Type = exports.UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = exports.UnsignedShort5551Type = 1018;
var UnsignedInt248Type = exports.UnsignedInt248Type = 1020;
var UnsignedInt5999Type = exports.UnsignedInt5999Type = 35902;
var AlphaFormat = exports.AlphaFormat = 1021;
var RGBFormat = exports.RGBFormat = 1022;
var RGBAFormat = exports.RGBAFormat = 1023;
var LuminanceFormat = exports.LuminanceFormat = 1024;
var LuminanceAlphaFormat = exports.LuminanceAlphaFormat = 1025;
var DepthFormat = exports.DepthFormat = 1026;
var DepthStencilFormat = exports.DepthStencilFormat = 1027;
var RedFormat = exports.RedFormat = 1028;
var RedIntegerFormat = exports.RedIntegerFormat = 1029;
var RGFormat = exports.RGFormat = 1030;
var RGIntegerFormat = exports.RGIntegerFormat = 1031;
var RGBIntegerFormat = exports.RGBIntegerFormat = 1032;
var RGBAIntegerFormat = exports.RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = exports.RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = exports.RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = exports.RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = exports.RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = exports.RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = exports.RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = exports.RGBA_BPTC_Format = 36492;
var RGB_BPTC_SIGNED_Format = exports.RGB_BPTC_SIGNED_Format = 36494;
var RGB_BPTC_UNSIGNED_Format = exports.RGB_BPTC_UNSIGNED_Format = 36495;
var RED_RGTC1_Format = exports.RED_RGTC1_Format = 36283;
var SIGNED_RED_RGTC1_Format = exports.SIGNED_RED_RGTC1_Format = 36284;
var RED_GREEN_RGTC2_Format = exports.RED_GREEN_RGTC2_Format = 36285;
var SIGNED_RED_GREEN_RGTC2_Format = exports.SIGNED_RED_GREEN_RGTC2_Format = 36286;
var LoopOnce = exports.LoopOnce = 2200;
var LoopRepeat = exports.LoopRepeat = 2201;
var LoopPingPong = exports.LoopPingPong = 2202;
var InterpolateDiscrete = exports.InterpolateDiscrete = 2300;
var InterpolateLinear = exports.InterpolateLinear = 2301;
var InterpolateSmooth = exports.InterpolateSmooth = 2302;
var ZeroCurvatureEnding = exports.ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = exports.ZeroSlopeEnding = 2401;
var WrapAroundEnding = exports.WrapAroundEnding = 2402;
var NormalAnimationBlendMode = exports.NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = exports.AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = exports.TrianglesDrawMode = 0;
var TriangleStripDrawMode = exports.TriangleStripDrawMode = 1;
var TriangleFanDrawMode = exports.TriangleFanDrawMode = 2;
var BasicDepthPacking = exports.BasicDepthPacking = 3200;
var RGBADepthPacking = exports.RGBADepthPacking = 3201;
var RGBDepthPacking = exports.RGBDepthPacking = 3202;
var RGDepthPacking = exports.RGDepthPacking = 3203;
var TangentSpaceNormalMap = exports.TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = exports.ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
var NoColorSpace = exports.NoColorSpace = '';
var SRGBColorSpace = exports.SRGBColorSpace = 'srgb';
var LinearSRGBColorSpace = exports.LinearSRGBColorSpace = 'srgb-linear';
var DisplayP3ColorSpace = exports.DisplayP3ColorSpace = 'display-p3';
var LinearDisplayP3ColorSpace = exports.LinearDisplayP3ColorSpace = 'display-p3-linear';
var LinearTransfer = exports.LinearTransfer = 'linear';
var SRGBTransfer = exports.SRGBTransfer = 'srgb';
var Rec709Primaries = exports.Rec709Primaries = 'rec709';
var P3Primaries = exports.P3Primaries = 'p3';
var ZeroStencilOp = exports.ZeroStencilOp = 0;
var KeepStencilOp = exports.KeepStencilOp = 7680;
var ReplaceStencilOp = exports.ReplaceStencilOp = 7681;
var IncrementStencilOp = exports.IncrementStencilOp = 7682;
var DecrementStencilOp = exports.DecrementStencilOp = 7683;
var IncrementWrapStencilOp = exports.IncrementWrapStencilOp = 34055;
var DecrementWrapStencilOp = exports.DecrementWrapStencilOp = 34056;
var InvertStencilOp = exports.InvertStencilOp = 5386;
var NeverStencilFunc = exports.NeverStencilFunc = 512;
var LessStencilFunc = exports.LessStencilFunc = 513;
var EqualStencilFunc = exports.EqualStencilFunc = 514;
var LessEqualStencilFunc = exports.LessEqualStencilFunc = 515;
var GreaterStencilFunc = exports.GreaterStencilFunc = 516;
var NotEqualStencilFunc = exports.NotEqualStencilFunc = 517;
var GreaterEqualStencilFunc = exports.GreaterEqualStencilFunc = 518;
var AlwaysStencilFunc = exports.AlwaysStencilFunc = 519;
var NeverCompare = exports.NeverCompare = 512;
var LessCompare = exports.LessCompare = 513;
var EqualCompare = exports.EqualCompare = 514;
var LessEqualCompare = exports.LessEqualCompare = 515;
var GreaterCompare = exports.GreaterCompare = 516;
var NotEqualCompare = exports.NotEqualCompare = 517;
var GreaterEqualCompare = exports.GreaterEqualCompare = 518;
var AlwaysCompare = exports.AlwaysCompare = 519;
var StaticDrawUsage = exports.StaticDrawUsage = 35044;
var DynamicDrawUsage = exports.DynamicDrawUsage = 35048;
var StreamDrawUsage = exports.StreamDrawUsage = 35040;
var StaticReadUsage = exports.StaticReadUsage = 35045;
var DynamicReadUsage = exports.DynamicReadUsage = 35049;
var StreamReadUsage = exports.StreamReadUsage = 35041;
var StaticCopyUsage = exports.StaticCopyUsage = 35046;
var DynamicCopyUsage = exports.DynamicCopyUsage = 35050;
var StreamCopyUsage = exports.StreamCopyUsage = 35042;
var GLSL1 = exports.GLSL1 = '100';
var GLSL3 = exports.GLSL3 = '300 es';
var WebGLCoordinateSystem = exports.WebGLCoordinateSystem = 2000;
var WebGPUCoordinateSystem = exports.WebGPUCoordinateSystem = 2001;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
var EventDispatcher = exports.EventDispatcher = /*#__PURE__*/function () {
  function EventDispatcher() {
    _classCallCheck(this, EventDispatcher);
  }
  return _createClass(EventDispatcher, [{
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      if (this._listeners === undefined) this._listeners = {};
      var listeners = this._listeners;
      if (listeners[type] === undefined) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
  }, {
    key: "hasEventListener",
    value: function hasEventListener(type, listener) {
      if (this._listeners === undefined) return false;
      var listeners = this._listeners;
      return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[type];
      if (listenerArray !== undefined) {
        var index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[event.type];
      if (listenerArray !== undefined) {
        event.target = this;

        // Make a copy, in case listeners are removed while iterating.
        var array = listenerArray.slice(0);
        for (var i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
        event.target = null;
      }
    }
  }]);
}();
var _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {
  var d0 = Math.random() * 0xffffffff | 0;
  var d1 = Math.random() * 0xffffffff | 0;
  var d2 = Math.random() * 0xffffffff | 0;
  var d3 = Math.random() * 0xffffffff | 0;
  var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

  // .toLowerCase() here flattens concatenated strings to save heap memory space.
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong(x) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}

// Random integer from <low, high> interval
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}

// Random float from <low, high> interval
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}

// Random float from <-range/2, range/2> interval
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom(s) {
  if (s !== undefined) _seed = s;

  // Mulberry32 generator

  var t = _seed += 0x6D2B79F5;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

  // rotations are applied to the axes in the order specified by 'order'
  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  // angles are in radians

  var cos = Math.cos;
  var sin = Math.sin;
  var c2 = cos(b / 2);
  var s2 = sin(b / 2);
  var c13 = cos((a + c) / 2);
  var s13 = sin((a + c) / 2);
  var c1_3 = cos((a - c) / 2);
  var s1_3 = sin((a - c) / 2);
  var c3_1 = cos((c - a) / 2);
  var s3_1 = sin((c - a) / 2);
  switch (order) {
    case 'XYX':
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case 'YZY':
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case 'ZXZ':
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case 'XZX':
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case 'YXY':
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case 'ZYZ':
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295.0;
    case Uint16Array:
      return value / 65535.0;
    case Uint8Array:
      return value / 255.0;
    case Int32Array:
      return Math.max(value / 2147483647.0, -1.0);
    case Int16Array:
      return Math.max(value / 32767.0, -1.0);
    case Int8Array:
      return Math.max(value / 127.0, -1.0);
    default:
      throw new Error('Invalid component type.');
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295.0);
    case Uint16Array:
      return Math.round(value * 65535.0);
    case Uint8Array:
      return Math.round(value * 255.0);
    case Int32Array:
      return Math.round(value * 2147483647.0);
    case Int16Array:
      return Math.round(value * 32767.0);
    case Int8Array:
      return Math.round(value * 127.0);
    default:
      throw new Error('Invalid component type.');
  }
}
var MathUtils = exports.MathUtils = {
  DEG2RAD: DEG2RAD,
  RAD2DEG: RAD2DEG,
  generateUUID: generateUUID,
  clamp: clamp,
  euclideanModulo: euclideanModulo,
  mapLinear: mapLinear,
  inverseLerp: inverseLerp,
  lerp: lerp,
  damp: damp,
  pingpong: pingpong,
  smoothstep: smoothstep,
  smootherstep: smootherstep,
  randInt: randInt,
  randFloat: randFloat,
  randFloatSpread: randFloatSpread,
  seededRandom: seededRandom,
  degToRad: degToRad,
  radToDeg: radToDeg,
  isPowerOfTwo: isPowerOfTwo,
  ceilPowerOfTwo: ceilPowerOfTwo,
  floorPowerOfTwo: floorPowerOfTwo,
  setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  normalize: normalize,
  denormalize: denormalize
};
var Vector2 = exports.Vector2 = /*#__PURE__*/function () {
  function Vector2() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, Vector2);
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  return _createClass(Vector2, [{
    key: "width",
    get: function get() {
      return this.x;
    },
    set: function set(value) {
      this.x = value;
    }
  }, {
    key: "height",
    get: function get() {
      return this.y;
    },
    set: function set(value) {
      this.y = value;
    }
  }, {
    key: "set",
    value: function set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(x) {
      this.x = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
      return this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error('index is out of range: ' + index);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error('index is out of range: ' + index);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y);
    }
  }, {
    key: "copy",
    value: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
  }, {
    key: "add",
    value: function add(v) {
      this.x += v.x;
      this.y += v.y;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
  }, {
    key: "divide",
    value: function divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      var x = this.x,
        y = this.y;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    }
  }, {
    key: "min",
    value: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
  }, {
    key: "max",
    value: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
  }, {
    key: "clamp",
    value: function clamp(min, max) {
      // assumes min < max, componentwise

      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
  }, {
    key: "floor",
    value: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
  }, {
    key: "round",
    value: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this.x * v.x + this.y * v.y;
    }
  }, {
    key: "cross",
    value: function cross(v) {
      return this.x * v.y - this.y * v.x;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "angle",
    value: function angle() {
      // computes the angle in radians with respect to the positive x-axis

      var angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
  }, {
    key: "angleTo",
    value: function angleTo(v) {
      var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      var theta = this.dot(v) / denominator;

      // clamp, to handle numerical problems

      return Math.acos(clamp(theta, -1, 1));
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(v) {
      var dx = this.x - v.x,
        dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
  }, {
    key: "lerp",
    value: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return v.x === this.x && v.y === this.y;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
  }, {
    key: "rotateAround",
    value: function rotateAround(center, angle) {
      var c = Math.cos(angle),
        s = Math.sin(angle);
      var x = this.x - center.x;
      var y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
  }, {
    key: "random",
    value: function random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.x;
          case 2:
            _context2.next = 4;
            return this.y;
          case 4:
          case "end":
            return _context2.stop();
        }
      }, value, this);
    })
  }]);
}();
var Matrix3 = exports.Matrix3 = /*#__PURE__*/function () {
  function Matrix3(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    _classCallCheck(this, Matrix3);
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (n11 !== undefined) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  return _createClass(Matrix3, [{
    key: "set",
    value: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      var te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
  }, {
    key: "setFromMatrix4",
    value: function setFromMatrix4(m) {
      var me = m.elements;
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(m) {
      return this.multiplyMatrices(this, m);
    }
  }, {
    key: "premultiply",
    value: function premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0],
        a12 = ae[3],
        a13 = ae[6];
      var a21 = ae[1],
        a22 = ae[4],
        a23 = ae[7];
      var a31 = ae[2],
        a32 = ae[5],
        a33 = ae[8];
      var b11 = be[0],
        b12 = be[3],
        b13 = be[6];
      var b21 = be[1],
        b22 = be[4],
        b23 = be[7];
      var b31 = be[2],
        b32 = be[5],
        b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(s) {
      var te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var te = this.elements;
      var a = te[0],
        b = te[1],
        c = te[2],
        d = te[3],
        e = te[4],
        f = te[5],
        g = te[6],
        h = te[7],
        i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }
  }, {
    key: "invert",
    value: function invert() {
      var te = this.elements,
        n11 = te[0],
        n21 = te[1],
        n31 = te[2],
        n12 = te[3],
        n22 = te[4],
        n32 = te[5],
        n13 = te[6],
        n23 = te[7],
        n33 = te[8],
        t11 = n33 * n22 - n32 * n23,
        t12 = n32 * n13 - n33 * n12,
        t13 = n23 * n12 - n22 * n13,
        det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var tmp;
      var m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    }
  }, {
    key: "getNormalMatrix",
    value: function getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
  }, {
    key: "transposeIntoArray",
    value: function transposeIntoArray(r) {
      var m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
  }, {
    key: "setUvTransform",
    value: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      var c = Math.cos(rotation);
      var s = Math.sin(rotation);
      this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
      return this;
    }

    //
  }, {
    key: "scale",
    value: function scale(sx, sy) {
      this.premultiply(_m3.makeScale(sx, sy));
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(theta) {
      this.premultiply(_m3.makeRotation(-theta));
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      this.premultiply(_m3.makeTranslation(tx, ty));
      return this;
    }

    // for 2D Transforms
  }, {
    key: "makeTranslation",
    value: function makeTranslation(x, y) {
      if (x.isVector2) {
        this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
      } else {
        this.set(1, 0, x, 0, 1, y, 0, 0, 1);
      }
      return this;
    }
  }, {
    key: "makeRotation",
    value: function makeRotation(theta) {
      // counterclockwise

      var c = Math.cos(theta);
      var s = Math.sin(theta);
      this.set(c, -s, 0, s, c, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeScale",
    value: function makeScale(x, y) {
      this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
      return this;
    }

    //
  }, {
    key: "equals",
    value: function equals(matrix) {
      var te = this.elements;
      var me = matrix.elements;
      for (var i = 0; i < 9; i++) {
        if (te[i] !== me[i]) return false;
      }
      return true;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }]);
}();
var _m3 = /*@__PURE__*/new Matrix3();
function arrayNeedsUint32(array) {
  // assumes larger values usually on last

  for (var i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
  }
  return false;
}
var TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
function createElementNS(name) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', name);
}
function createCanvasElement() {
  var canvas = createElementNS('canvas');
  canvas.style.display = 'block';
  return canvas;
}
var _cache = {};
function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}
function probeAsync(gl, sync, interval) {
  return new Promise(function (resolve, reject) {
    function probe() {
      switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case gl.WAIT_FAILED:
          reject();
          break;
        case gl.TIMEOUT_EXPIRED:
          setTimeout(probe, interval);
          break;
        default:
          resolve();
      }
    }
    setTimeout(probe, interval);
  });
}

/**
 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
 * or clipping. Based on W3C specifications for sRGB and Display P3,
 * and ICC specifications for the D50 connection space. Values in/out
 * are _linear_ sRGB and _linear_ Display P3.
 *
 * Note that both sRGB and Display P3 use the sRGB transfer functions.
 *
 * Reference:
 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
 */

var LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/new Matrix3().set(0.8224621, 0.177538, 0.0, 0.0331941, 0.9668058, 0.0, 0.0170827, 0.0723974, 0.9105199);
var LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/new Matrix3().set(1.2249401, -0.2249404, 0.0, -0.0420569, 1.0420571, 0.0, -0.0196376, -0.0786361, 1.0982735);

/**
 * Defines supported color spaces by transfer function and primaries,
 * and provides conversions to/from the Linear-sRGB reference space.
 */
var COLOR_SPACES = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, LinearSRGBColorSpace, {
  transfer: LinearTransfer,
  primaries: Rec709Primaries,
  luminanceCoefficients: [0.2126, 0.7152, 0.0722],
  toReference: function toReference(color) {
    return color;
  },
  fromReference: function fromReference(color) {
    return color;
  }
}), SRGBColorSpace, {
  transfer: SRGBTransfer,
  primaries: Rec709Primaries,
  luminanceCoefficients: [0.2126, 0.7152, 0.0722],
  toReference: function toReference(color) {
    return color.convertSRGBToLinear();
  },
  fromReference: function fromReference(color) {
    return color.convertLinearToSRGB();
  }
}), LinearDisplayP3ColorSpace, {
  transfer: LinearTransfer,
  primaries: P3Primaries,
  luminanceCoefficients: [0.2289, 0.6917, 0.0793],
  toReference: function toReference(color) {
    return color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);
  },
  fromReference: function fromReference(color) {
    return color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3);
  }
}), DisplayP3ColorSpace, {
  transfer: SRGBTransfer,
  primaries: P3Primaries,
  luminanceCoefficients: [0.2289, 0.6917, 0.0793],
  toReference: function toReference(color) {
    return color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);
  },
  fromReference: function fromReference(color) {
    return color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB();
  }
});
var SUPPORTED_WORKING_COLOR_SPACES = new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
var ColorManagement = exports.ColorManagement = {
  enabled: true,
  _workingColorSpace: LinearSRGBColorSpace,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(colorSpace) {
    if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
      throw new Error("Unsupported working color space, \"".concat(colorSpace, "\"."));
    }
    this._workingColorSpace = colorSpace;
  },
  convert: function convert(color, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    var sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
    var targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
    return targetFromReference(sourceToReference(color));
  },
  fromWorkingColorSpace: function fromWorkingColorSpace(color, targetColorSpace) {
    return this.convert(color, this._workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function toWorkingColorSpace(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this._workingColorSpace);
  },
  getPrimaries: function getPrimaries(colorSpace) {
    return COLOR_SPACES[colorSpace].primaries;
  },
  getTransfer: function getTransfer(colorSpace) {
    if (colorSpace === NoColorSpace) return LinearTransfer;
    return COLOR_SPACES[colorSpace].transfer;
  },
  getLuminanceCoefficients: function getLuminanceCoefficients(target) {
    var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._workingColorSpace;
    return target.fromArray(COLOR_SPACES[colorSpace].luminanceCoefficients);
  }
};
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
var _canvas;
var ImageUtils = exports.ImageUtils = /*#__PURE__*/function () {
  function ImageUtils() {
    _classCallCheck(this, ImageUtils);
  }
  return _createClass(ImageUtils, null, [{
    key: "getDataURL",
    value: function getDataURL(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }
      if (typeof HTMLCanvasElement === 'undefined') {
        return image.src;
      }
      var canvas;
      if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === undefined) _canvas = createElementNS('canvas');
        _canvas.width = image.width;
        _canvas.height = image.height;
        var context = _canvas.getContext('2d');
        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas = _canvas;
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
        return canvas.toDataURL('image/jpeg', 0.6);
      } else {
        return canvas.toDataURL('image/png');
      }
    }
  }, {
    key: "sRGBToLinear",
    value: function sRGBToLinear(image) {
      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        var canvas = createElementNS('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, image.width, image.height);
        var imageData = context.getImageData(0, 0, image.width, image.height);
        var data = imageData.data;
        for (var i = 0; i < data.length; i++) {
          data[i] = SRGBToLinear(data[i] / 255) * 255;
        }
        context.putImageData(imageData, 0, 0);
        return canvas;
      } else if (image.data) {
        var _data = image.data.slice(0);
        for (var _i = 0; _i < _data.length; _i++) {
          if (_data instanceof Uint8Array || _data instanceof Uint8ClampedArray) {
            _data[_i] = Math.floor(SRGBToLinear(_data[_i] / 255) * 255);
          } else {
            // assuming float

            _data[_i] = SRGBToLinear(_data[_i]);
          }
        }
        return {
          data: _data,
          width: image.width,
          height: image.height
        };
      } else {
        console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
        return image;
      }
    }
  }]);
}();
var _sourceId = 0;
var Source = exports.Source = /*#__PURE__*/function () {
  function Source() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    _classCallCheck(this, Source);
    this.isSource = true;
    Object.defineProperty(this, 'id', {
      value: _sourceId++
    });
    this.uuid = generateUUID();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  return _createClass(Source, [{
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';
      if (!isRootObject && meta.images[this.uuid] !== undefined) {
        return meta.images[this.uuid];
      }
      var output = {
        uuid: this.uuid,
        url: ''
      };
      var data = this.data;
      if (data !== null) {
        var url;
        if (Array.isArray(data)) {
          // cube texture

          url = [];
          for (var i = 0, l = data.length; i < l; i++) {
            if (data[i].isDataTexture) {
              url.push(serializeImage(data[i].image));
            } else {
              url.push(serializeImage(data[i]));
            }
          }
        } else {
          // texture

          url = serializeImage(data);
        }
        output.url = url;
      }
      if (!isRootObject) {
        meta.images[this.uuid] = output;
      }
      return output;
    }
  }]);
}();
function serializeImage(image) {
  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    // default images

    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      // images of DataTexture

      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn('THREE.Texture: Unable to serialize Texture.');
      return {};
    }
  }
}
var _textureId = 0;
var Texture = exports.Texture = /*#__PURE__*/function (_EventDispatcher) {
  function Texture() {
    var _this2;
    var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Texture.DEFAULT_IMAGE;
    var mapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Texture.DEFAULT_MAPPING;
    var wrapS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ClampToEdgeWrapping;
    var wrapT = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ClampToEdgeWrapping;
    var magFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : LinearFilter;
    var minFilter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : LinearMipmapLinearFilter;
    var format = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : RGBAFormat;
    var type = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : UnsignedByteType;
    var anisotropy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Texture.DEFAULT_ANISOTROPY;
    var colorSpace = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : NoColorSpace;
    _classCallCheck(this, Texture);
    _this2 = _callSuper(this, Texture);
    _this2.isTexture = true;
    Object.defineProperty(_this2, 'id', {
      value: _textureId++
    });
    _this2.uuid = generateUUID();
    _this2.name = '';
    _this2.source = new Source(image);
    _this2.mipmaps = [];
    _this2.mapping = mapping;
    _this2.channel = 0;
    _this2.wrapS = wrapS;
    _this2.wrapT = wrapT;
    _this2.magFilter = magFilter;
    _this2.minFilter = minFilter;
    _this2.anisotropy = anisotropy;
    _this2.format = format;
    _this2.internalFormat = null;
    _this2.type = type;
    _this2.offset = new Vector2(0, 0);
    _this2.repeat = new Vector2(1, 1);
    _this2.center = new Vector2(0, 0);
    _this2.rotation = 0;
    _this2.matrixAutoUpdate = true;
    _this2.matrix = new Matrix3();
    _this2.generateMipmaps = true;
    _this2.premultiplyAlpha = false;
    _this2.flipY = true;
    _this2.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

    _this2.colorSpace = colorSpace;
    _this2.userData = {};
    _this2.version = 0;
    _this2.onUpdate = null;
    _this2.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
    _this2.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
    return _this2;
  }
  _inherits(Texture, _EventDispatcher);
  return _createClass(Texture, [{
    key: "image",
    get: function get() {
      return this.source.data;
    },
    set: function set() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.source.data = value;
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.source = source.source;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.channel = source.channel;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.colorSpace = source.colorSpace;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      this.needsUpdate = true;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';
      if (!isRootObject && meta.textures[this.uuid] !== undefined) {
        return meta.textures[this.uuid];
      }
      var output = {
        metadata: {
          version: 4.6,
          type: 'Texture',
          generator: 'Texture.toJSON'
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(meta).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (Object.keys(this.userData).length > 0) output.userData = this.userData;
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }, {
    key: "transformUv",
    value: function transformUv(uv) {
      if (this.mapping !== UVMapping) return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) {
        this.version++;
        this.source.needsUpdate = true;
      }
    }
  }, {
    key: "needsPMREMUpdate",
    set: function set(value) {
      if (value === true) {
        this.pmremVersion++;
      }
    }
  }]);
}(EventDispatcher);
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
var Vector4 = exports.Vector4 = /*#__PURE__*/function () {
  function Vector4() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, Vector4);
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  return _createClass(Vector4, [{
    key: "width",
    get: function get() {
      return this.z;
    },
    set: function set(value) {
      this.z = value;
    }
  }, {
    key: "height",
    get: function get() {
      return this.w;
    },
    set: function set(value) {
      this.w = value;
    }
  }, {
    key: "set",
    value: function set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(x) {
      this.x = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
      return this;
    }
  }, {
    key: "setZ",
    value: function setZ(z) {
      this.z = z;
      return this;
    }
  }, {
    key: "setW",
    value: function setW(w) {
      this.w = w;
      return this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error('index is out of range: ' + index);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error('index is out of range: ' + index);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
  }, {
    key: "copy",
    value: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== undefined ? v.w : 1;
      return this;
    }
  }, {
    key: "add",
    value: function add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      this.w *= v.w;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      var x = this.x,
        y = this.y,
        z = this.z,
        w = this.w;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
  }, {
    key: "setAxisAngleFromQuaternion",
    value: function setAxisAngleFromQuaternion(q) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

      // q is assumed to be normalized

      this.w = 2 * Math.acos(q.w);
      var s = Math.sqrt(1 - q.w * q.w);
      if (s < 0.0001) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }
      return this;
    }
  }, {
    key: "setAxisAngleFromRotationMatrix",
    value: function setAxisAngleFromRotationMatrix(m) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var angle, x, y, z; // variables for result
      var epsilon = 0.01,
        // margin to allow for rounding errors
        epsilon2 = 0.1,
        // margin to distinguish between 0 and 180 degrees

        te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        // singularity found
        // first check for identity matrix which must have +1 for all terms
        // in leading diagonal and zero in other terms

        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          // this singularity is identity matrix so angle = 0

          this.set(1, 0, 0, 0);
          return this; // zero angle, arbitrary axis
        }

        // otherwise this singularity is angle = 180

        angle = Math.PI;
        var xx = (m11 + 1) / 2;
        var yy = (m22 + 1) / 2;
        var zz = (m33 + 1) / 2;
        var xy = (m12 + m21) / 4;
        var xz = (m13 + m31) / 4;
        var yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          // m11 is the largest diagonal term

          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          // m22 is the largest diagonal term

          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          // m33 is the largest diagonal term so base result on this

          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }
        this.set(x, y, z, angle);
        return this; // return 180 deg rotation
      }

      // as we have reached here there are no singularities so we can handle normally

      var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

      if (Math.abs(s) < 0.001) s = 1;

      // prevent divide by zero, should not happen if matrix is orthogonal and should be
      // caught by singularity test above, but I've left it in just in case

      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
  }, {
    key: "setFromMatrixPosition",
    value: function setFromMatrixPosition(m) {
      var e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      this.w = e[15];
      return this;
    }
  }, {
    key: "min",
    value: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    }
  }, {
    key: "max",
    value: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    }
  }, {
    key: "clamp",
    value: function clamp(min, max) {
      // assumes min < max, componentwise

      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
  }, {
    key: "floor",
    value: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
  }, {
    key: "round",
    value: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      this.w = Math.trunc(this.w);
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
  }, {
    key: "lerp",
    value: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
  }, {
    key: "random",
    value: function random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this.x;
          case 2:
            _context3.next = 4;
            return this.y;
          case 4:
            _context3.next = 6;
            return this.z;
          case 6:
            _context3.next = 8;
            return this.w;
          case 8:
          case "end":
            return _context3.stop();
        }
      }, value, this);
    })
  }]);
}();
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
var RenderTarget = exports.RenderTarget = /*#__PURE__*/function (_EventDispatcher2) {
  function RenderTarget() {
    var _this3;
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, RenderTarget);
    _this3 = _callSuper(this, RenderTarget);
    _this3.isRenderTarget = true;
    _this3.width = width;
    _this3.height = height;
    _this3.depth = 1;
    _this3.scissor = new Vector4(0, 0, width, height);
    _this3.scissorTest = false;
    _this3.viewport = new Vector4(0, 0, width, height);
    var image = {
      width: width,
      height: height,
      depth: 1
    };
    options = Object.assign({
      generateMipmaps: false,
      internalFormat: null,
      minFilter: LinearFilter,
      depthBuffer: true,
      stencilBuffer: false,
      resolveDepthBuffer: true,
      resolveStencilBuffer: true,
      depthTexture: null,
      samples: 0,
      count: 1
    }, options);
    var texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    texture.flipY = false;
    texture.generateMipmaps = options.generateMipmaps;
    texture.internalFormat = options.internalFormat;
    _this3.textures = [];
    var count = options.count;
    for (var i = 0; i < count; i++) {
      _this3.textures[i] = texture.clone();
      _this3.textures[i].isRenderTargetTexture = true;
    }
    _this3.depthBuffer = options.depthBuffer;
    _this3.stencilBuffer = options.stencilBuffer;
    _this3.resolveDepthBuffer = options.resolveDepthBuffer;
    _this3.resolveStencilBuffer = options.resolveStencilBuffer;
    _this3.depthTexture = options.depthTexture;
    _this3.samples = options.samples;
    return _this3;
  }
  _inherits(RenderTarget, _EventDispatcher2);
  return _createClass(RenderTarget, [{
    key: "texture",
    get: function get() {
      return this.textures[0];
    },
    set: function set(value) {
      this.textures[0] = value;
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      if (this.width !== width || this.height !== height || this.depth !== depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        for (var i = 0, il = this.textures.length; i < il; i++) {
          this.textures[i].image.width = width;
          this.textures[i].image.height = height;
          this.textures[i].image.depth = depth;
        }
        this.dispose();
      }
      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.scissor.copy(source.scissor);
      this.scissorTest = source.scissorTest;
      this.viewport.copy(source.viewport);
      this.textures.length = 0;
      for (var i = 0, il = source.textures.length; i < il; i++) {
        this.textures[i] = source.textures[i].clone();
        this.textures[i].isRenderTargetTexture = true;
      }

      // ensure image object is not shared, see #20328

      var image = Object.assign({}, source.texture.image);
      this.texture.source = new Source(image);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.resolveDepthBuffer = source.resolveDepthBuffer;
      this.resolveStencilBuffer = source.resolveStencilBuffer;
      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
      this.samples = source.samples;
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }]);
}(EventDispatcher);
var WebGLRenderTarget = exports.WebGLRenderTarget = /*#__PURE__*/function (_RenderTarget) {
  function WebGLRenderTarget() {
    var _this4;
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, WebGLRenderTarget);
    _this4 = _callSuper(this, WebGLRenderTarget, [width, height, options]);
    _this4.isWebGLRenderTarget = true;
    return _this4;
  }
  _inherits(WebGLRenderTarget, _RenderTarget);
  return _createClass(WebGLRenderTarget);
}(RenderTarget);
var DataArrayTexture = exports.DataArrayTexture = /*#__PURE__*/function (_Texture) {
  function DataArrayTexture() {
    var _this5;
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, DataArrayTexture);
    _this5 = _callSuper(this, DataArrayTexture, [null]);
    _this5.isDataArrayTexture = true;
    _this5.image = {
      data: data,
      width: width,
      height: height,
      depth: depth
    };
    _this5.magFilter = NearestFilter;
    _this5.minFilter = NearestFilter;
    _this5.wrapR = ClampToEdgeWrapping;
    _this5.generateMipmaps = false;
    _this5.flipY = false;
    _this5.unpackAlignment = 1;
    _this5.layerUpdates = new Set();
    return _this5;
  }
  _inherits(DataArrayTexture, _Texture);
  return _createClass(DataArrayTexture, [{
    key: "addLayerUpdate",
    value: function addLayerUpdate(layerIndex) {
      this.layerUpdates.add(layerIndex);
    }
  }, {
    key: "clearLayerUpdates",
    value: function clearLayerUpdates() {
      this.layerUpdates.clear();
    }
  }]);
}(Texture);
var WebGLArrayRenderTarget = exports.WebGLArrayRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {
  function WebGLArrayRenderTarget() {
    var _this6;
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    _classCallCheck(this, WebGLArrayRenderTarget);
    _this6 = _callSuper(this, WebGLArrayRenderTarget, [width, height, options]);
    _this6.isWebGLArrayRenderTarget = true;
    _this6.depth = depth;
    _this6.texture = new DataArrayTexture(null, width, height, depth);
    _this6.texture.isRenderTargetTexture = true;
    return _this6;
  }
  _inherits(WebGLArrayRenderTarget, _WebGLRenderTarget);
  return _createClass(WebGLArrayRenderTarget);
}(WebGLRenderTarget);
var Data3DTexture = exports.Data3DTexture = /*#__PURE__*/function (_Texture2) {
  function Data3DTexture() {
    var _this7;
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, Data3DTexture);
    // We're going to add .setXXX() methods for setting properties later.
    // Users can still set in DataTexture3D directly.
    //
    //	const texture = new THREE.DataTexture3D( data, width, height, depth );
    // 	texture.anisotropy = 16;
    //
    // See #14839

    _this7 = _callSuper(this, Data3DTexture, [null]);
    _this7.isData3DTexture = true;
    _this7.image = {
      data: data,
      width: width,
      height: height,
      depth: depth
    };
    _this7.magFilter = NearestFilter;
    _this7.minFilter = NearestFilter;
    _this7.wrapR = ClampToEdgeWrapping;
    _this7.generateMipmaps = false;
    _this7.flipY = false;
    _this7.unpackAlignment = 1;
    return _this7;
  }
  _inherits(Data3DTexture, _Texture2);
  return _createClass(Data3DTexture);
}(Texture);
var WebGL3DRenderTarget = exports.WebGL3DRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget2) {
  function WebGL3DRenderTarget() {
    var _this8;
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    _classCallCheck(this, WebGL3DRenderTarget);
    _this8 = _callSuper(this, WebGL3DRenderTarget, [width, height, options]);
    _this8.isWebGL3DRenderTarget = true;
    _this8.depth = depth;
    _this8.texture = new Data3DTexture(null, width, height, depth);
    _this8.texture.isRenderTargetTexture = true;
    return _this8;
  }
  _inherits(WebGL3DRenderTarget, _WebGLRenderTarget2);
  return _createClass(WebGL3DRenderTarget);
}(WebGLRenderTarget);
var Quaternion = exports.Quaternion = /*#__PURE__*/function () {
  function Quaternion() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, Quaternion);
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  return _createClass(Quaternion, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(value) {
      this._x = value;
      this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(value) {
      this._y = value;
      this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(value) {
      this._z = value;
      this._onChangeCallback();
    }
  }, {
    key: "w",
    get: function get() {
      return this._w;
    },
    set: function set(value) {
      this._w = value;
      this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
  }, {
    key: "copy",
    value: function copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromEuler",
    value: function setFromEuler(euler) {
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var x = euler._x,
        y = euler._y,
        z = euler._z,
        order = euler._order;

      // http://www.mathworks.com/matlabcentral/fileexchange/
      // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
      //	content/SpinCalc.m

      var cos = Math.cos;
      var sin = Math.sin;
      var c1 = cos(x / 2);
      var c2 = cos(y / 2);
      var c3 = cos(z / 2);
      var s1 = sin(x / 2);
      var s2 = sin(y / 2);
      var s3 = sin(z / 2);
      switch (order) {
        case 'XYZ':
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case 'YXZ':
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case 'ZXY':
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case 'ZYX':
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case 'YZX':
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case 'XZY':
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
      }
      if (update === true) this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromAxisAngle",
    value: function setFromAxisAngle(axis, angle) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

      // assumes axis is normalized

      var halfAngle = angle / 2,
        s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(m) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10],
        trace = m11 + m22 + m33;
      if (trace > 0) {
        var s = 0.5 / Math.sqrt(trace + 1.0);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
        this._w = (m32 - m23) / _s;
        this._x = 0.25 * _s;
        this._y = (m12 + m21) / _s;
        this._z = (m13 + m31) / _s;
      } else if (m22 > m33) {
        var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
        this._w = (m13 - m31) / _s2;
        this._x = (m12 + m21) / _s2;
        this._y = 0.25 * _s2;
        this._z = (m23 + m32) / _s2;
      } else {
        var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
        this._w = (m21 - m12) / _s3;
        this._x = (m13 + m31) / _s3;
        this._y = (m23 + m32) / _s3;
        this._z = 0.25 * _s3;
      }
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromUnitVectors",
    value: function setFromUnitVectors(vFrom, vTo) {
      // assumes direction vectors vFrom and vTo are normalized

      var r = vFrom.dot(vTo) + 1;
      if (r < Number.EPSILON) {
        // vFrom and vTo point in opposite directions

        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
  }, {
    key: "angleTo",
    value: function angleTo(q) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
  }, {
    key: "rotateTowards",
    value: function rotateTowards(q, step) {
      var angle = this.angleTo(q);
      if (angle === 0) return this;
      var t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.set(0, 0, 0, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      // quaternion is assumed to have unit length

      return this.conjugate();
    }
  }, {
    key: "conjugate",
    value: function conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(q) {
      return this.multiplyQuaternions(this, q);
    }
  }, {
    key: "premultiply",
    value: function premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
  }, {
    key: "multiplyQuaternions",
    value: function multiplyQuaternions(a, b) {
      // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

      var qax = a._x,
        qay = a._y,
        qaz = a._z,
        qaw = a._w;
      var qbx = b._x,
        qby = b._y,
        qbz = b._z,
        qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "slerp",
    value: function slerp(qb, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(qb);
      var x = this._x,
        y = this._y,
        z = this._z,
        w = this._w;

      // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1.0) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        var s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize(); // normalize calls _onChangeCallback()

        return this;
      }
      var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "slerpQuaternions",
    value: function slerpQuaternions(qa, qb, t) {
      return this.copy(qa).slerp(qb, t);
    }
  }, {
    key: "random",
    value: function random() {
      // sets this quaternion to a uniform random unit quaternnion

      // Ken Shoemake
      // Uniform random rotations
      // D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

      var theta1 = 2 * Math.PI * Math.random();
      var theta2 = 2 * Math.PI * Math.random();
      var x0 = Math.random();
      var r1 = Math.sqrt(1 - x0);
      var r2 = Math.sqrt(x0);
      return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2));
    }
  }, {
    key: "equals",
    value: function equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toArray();
    }
  }, {
    key: "_onChange",
    value: function _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this._x;
          case 2:
            _context4.next = 4;
            return this._y;
          case 4:
            _context4.next = 6;
            return this._z;
          case 6:
            _context4.next = 8;
            return this._w;
          case 8:
          case "end":
            return _context4.stop();
        }
      }, value, this);
    })
  }], [{
    key: "slerpFlat",
    value: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      // fuzz-free, array-based Quaternion SLERP operation

      var x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3];
      var x1 = src1[srcOffset1 + 0],
        y1 = src1[srcOffset1 + 1],
        z1 = src1[srcOffset1 + 2],
        w1 = src1[srcOffset1 + 3];
      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        var s = 1 - t;
        var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
          dir = cos >= 0 ? 1 : -1,
          sqrSin = 1 - cos * cos;

        // Skip the Slerp for tiny steps to avoid numeric problems:
        if (sqrSin > Number.EPSILON) {
          var sin = Math.sqrt(sqrSin),
            len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        var tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;

        // Normalize in case we just did a lerp:
        if (s === 1 - t) {
          var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
  }, {
    key: "multiplyQuaternionsFlat",
    value: function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      var x0 = src0[srcOffset0];
      var y0 = src0[srcOffset0 + 1];
      var z0 = src0[srcOffset0 + 2];
      var w0 = src0[srcOffset0 + 3];
      var x1 = src1[srcOffset1];
      var y1 = src1[srcOffset1 + 1];
      var z1 = src1[srcOffset1 + 2];
      var w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
  }]);
}();
var Vector3 = exports.Vector3 = /*#__PURE__*/function () {
  function Vector3() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    _classCallCheck(this, Vector3);
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  return _createClass(Vector3, [{
    key: "set",
    value: function set(x, y, z) {
      if (z === undefined) z = this.z; // sprite.scale.set(x,y)

      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(x) {
      this.x = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
      return this;
    }
  }, {
    key: "setZ",
    value: function setZ(z) {
      this.z = z;
      return this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error('index is out of range: ' + index);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error('index is out of range: ' + index);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
  }, {
    key: "copy",
    value: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
  }, {
    key: "add",
    value: function add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
  }, {
    key: "multiplyVectors",
    value: function multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
  }, {
    key: "applyEuler",
    value: function applyEuler(euler) {
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
  }, {
    key: "applyAxisAngle",
    value: function applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      var x = this.x,
        y = this.y,
        z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      var x = this.x,
        y = this.y,
        z = this.z;
      var e = m.elements;
      var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(q) {
      // quaternion q is assumed to have unit length

      var vx = this.x,
        vy = this.y,
        vz = this.z;
      var qx = q.x,
        qy = q.y,
        qz = q.z,
        qw = q.w;

      // t = 2 * cross( q.xyz, v );
      var tx = 2 * (qy * vz - qz * vy);
      var ty = 2 * (qz * vx - qx * vz);
      var tz = 2 * (qx * vy - qy * vx);

      // v + q.w * t + cross( q.xyz, t );
      this.x = vx + qw * tx + qy * tz - qz * ty;
      this.y = vy + qw * ty + qz * tx - qx * tz;
      this.z = vz + qw * tz + qx * ty - qy * tx;
      return this;
    }
  }, {
    key: "project",
    value: function project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
  }, {
    key: "unproject",
    value: function unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(m) {
      // input: THREE.Matrix4 affine matrix
      // vector interpreted as a direction

      var x = this.x,
        y = this.y,
        z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
  }, {
    key: "divide",
    value: function divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
  }, {
    key: "min",
    value: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
  }, {
    key: "max",
    value: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
  }, {
    key: "clamp",
    value: function clamp(min, max) {
      // assumes min < max, componentwise

      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
  }, {
    key: "floor",
    value: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
  }, {
    key: "round",
    value: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }

    // TODO lengthSquared?
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
  }, {
    key: "lerp",
    value: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
  }, {
    key: "cross",
    value: function cross(v) {
      return this.crossVectors(this, v);
    }
  }, {
    key: "crossVectors",
    value: function crossVectors(a, b) {
      var ax = a.x,
        ay = a.y,
        az = a.z;
      var bx = b.x,
        by = b.y,
        bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
  }, {
    key: "projectOnVector",
    value: function projectOnVector(v) {
      var denominator = v.lengthSq();
      if (denominator === 0) return this.set(0, 0, 0);
      var scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
  }, {
    key: "projectOnPlane",
    value: function projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
  }, {
    key: "reflect",
    value: function reflect(normal) {
      // reflect incident vector off plane orthogonal to normal
      // normal is assumed to have unit length

      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
  }, {
    key: "angleTo",
    value: function angleTo(v) {
      var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      var theta = this.dot(v) / denominator;

      // clamp, to handle numerical problems

      return Math.acos(clamp(theta, -1, 1));
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(v) {
      var dx = this.x - v.x,
        dy = this.y - v.y,
        dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
  }, {
    key: "setFromSpherical",
    value: function setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
  }, {
    key: "setFromSphericalCoords",
    value: function setFromSphericalCoords(radius, phi, theta) {
      var sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
  }, {
    key: "setFromCylindrical",
    value: function setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
  }, {
    key: "setFromCylindricalCoords",
    value: function setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
  }, {
    key: "setFromMatrixPosition",
    value: function setFromMatrixPosition(m) {
      var e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
  }, {
    key: "setFromMatrixScale",
    value: function setFromMatrixScale(m) {
      var sx = this.setFromMatrixColumn(m, 0).length();
      var sy = this.setFromMatrixColumn(m, 1).length();
      var sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
  }, {
    key: "setFromMatrixColumn",
    value: function setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
  }, {
    key: "setFromMatrix3Column",
    value: function setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
  }, {
    key: "setFromEuler",
    value: function setFromEuler(e) {
      this.x = e._x;
      this.y = e._y;
      this.z = e._z;
      return this;
    }
  }, {
    key: "setFromColor",
    value: function setFromColor(c) {
      this.x = c.r;
      this.y = c.g;
      this.z = c.b;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
  }, {
    key: "random",
    value: function random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
  }, {
    key: "randomDirection",
    value: function randomDirection() {
      // https://mathworld.wolfram.com/SpherePointPicking.html

      var theta = Math.random() * Math.PI * 2;
      var u = Math.random() * 2 - 1;
      var c = Math.sqrt(1 - u * u);
      this.x = c * Math.cos(theta);
      this.y = u;
      this.z = c * Math.sin(theta);
      return this;
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.x;
          case 2:
            _context5.next = 4;
            return this.y;
          case 4:
            _context5.next = 6;
            return this.z;
          case 6:
          case "end":
            return _context5.stop();
        }
      }, value, this);
    })
  }]);
}();
var _vector$c = /*@__PURE__*/new Vector3();
var _quaternion$4 = /*@__PURE__*/new Quaternion();
var Box3 = exports.Box3 = /*#__PURE__*/function () {
  function Box3() {
    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(+Infinity, +Infinity, +Infinity);
    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(-Infinity, -Infinity, -Infinity);
    _classCallCheck(this, Box3);
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  return _createClass(Box3, [{
    key: "set",
    value: function set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
  }, {
    key: "setFromArray",
    value: function setFromArray(array) {
      this.makeEmpty();
      for (var i = 0, il = array.length; i < il; i += 3) {
        this.expandByPoint(_vector$b.fromArray(array, i));
      }
      return this;
    }
  }, {
    key: "setFromBufferAttribute",
    value: function setFromBufferAttribute(attribute) {
      this.makeEmpty();
      for (var i = 0, il = attribute.count; i < il; i++) {
        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
      }
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points) {
      this.makeEmpty();
      for (var i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
  }, {
    key: "setFromCenterAndSize",
    value: function setFromCenterAndSize(center, size) {
      var halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
  }, {
    key: "setFromObject",
    value: function setFromObject(object) {
      var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      this.min.x = this.min.y = this.min.z = +Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
  }, {
    key: "getCenter",
    value: function getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
  }, {
    key: "getSize",
    value: function getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
  }, {
    key: "expandByVector",
    value: function expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
  }, {
    key: "expandByScalar",
    value: function expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
  }, {
    key: "expandByObject",
    value: function expandByObject(object) {
      var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      // Computes the world-axis-aligned bounding box of an object (including its children),
      // accounting for both the object's, and children's, world transforms

      object.updateWorldMatrix(false, false);
      var geometry = object.geometry;
      if (geometry !== undefined) {
        var positionAttribute = geometry.getAttribute('position');

        // precise AABB computation based on vertex data requires at least a position attribute.
        // instancing isn't supported so far and uses the normal (conservative) code path.

        if (precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true) {
          for (var i = 0, l = positionAttribute.count; i < l; i++) {
            if (object.isMesh === true) {
              object.getVertexPosition(i, _vector$b);
            } else {
              _vector$b.fromBufferAttribute(positionAttribute, i);
            }
            _vector$b.applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$b);
          }
        } else {
          if (object.boundingBox !== undefined) {
            // object-level bounding box

            if (object.boundingBox === null) {
              object.computeBoundingBox();
            }
            _box$4.copy(object.boundingBox);
          } else {
            // geometry-level bounding box

            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$4.copy(geometry.boundingBox);
          }
          _box$4.applyMatrix4(object.matrixWorld);
          this.union(_box$4);
        }
      }
      var children = object.children;
      for (var _i2 = 0, _l = children.length; _i2 < _l; _i2++) {
        this.expandByObject(children[_i2], precise);
      }
      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
    }
  }, {
    key: "containsBox",
    value: function containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
  }, {
    key: "getParameter",
    value: function getParameter(point, target) {
      // This can potentially have a divide by zero if the box
      // has a size dimension of 0.

      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      // using 6 splitting planes to rule out intersections.
      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      // Find the point on the AABB closest to the sphere center.
      this.clampPoint(sphere.center, _vector$b);

      // If that point is inside the sphere, the AABB and sphere intersect.
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(plane) {
      // We compute the minimum and maximum dot product values. If those values
      // are on the same side (back or front) of the plane, then there is no intersection.

      var min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    }
  }, {
    key: "intersectsTriangle",
    value: function intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }

      // compute box center and extents
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);

      // translate triangle to aabb origin
      _v0$3.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$4.subVectors(triangle.c, _center);

      // compute edge vectors for triangle
      _f0.subVectors(_v1$7, _v0$3);
      _f1.subVectors(_v2$4, _v1$7);
      _f2.subVectors(_v0$3, _v2$4);

      // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
      // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
      // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
      var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
      if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
        return false;
      }

      // test 3 face normals from the aabb
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
        return false;
      }

      // finally testing the face normal of the triangle
      // use already existing triangle edge vectors here
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents);
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return this.clampPoint(point, _vector$b).distanceTo(point);
    }
  }, {
    key: "getBoundingSphere",
    value: function getBoundingSphere(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
      } else {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
      }
      return target;
    }
  }, {
    key: "intersect",
    value: function intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);

      // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
      if (this.isEmpty()) this.makeEmpty();
      return this;
    }
  }, {
    key: "union",
    value: function union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      // transform of empty box is an empty box.
      if (this.isEmpty()) return this;

      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

      this.setFromPoints(_points);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  }]);
}();
var _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];
var _vector$b = /*@__PURE__*/new Vector3();
var _box$4 = /*@__PURE__*/new Box3();

// triangle centered vertices

var _v0$3 = /*@__PURE__*/new Vector3();
var _v1$7 = /*@__PURE__*/new Vector3();
var _v2$4 = /*@__PURE__*/new Vector3();

// triangle edge vectors

var _f0 = /*@__PURE__*/new Vector3();
var _f1 = /*@__PURE__*/new Vector3();
var _f2 = /*@__PURE__*/new Vector3();
var _center = /*@__PURE__*/new Vector3();
var _extents = /*@__PURE__*/new Vector3();
var _triangleNormal = /*@__PURE__*/new Vector3();
var _testAxis = /*@__PURE__*/new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (var i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    // project the aabb onto the separating axis
    var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    // project all 3 vertices of the triangle onto the separating axis
    var p0 = v0.dot(_testAxis);
    var p1 = v1.dot(_testAxis);
    var p2 = v2.dot(_testAxis);
    // actual test, basically see if either of the most extreme of the triangle points intersects r
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is separating and we can exit
      return false;
    }
  }
  return true;
}
var _box$3 = /*@__PURE__*/new Box3();
var _v1$6 = /*@__PURE__*/new Vector3();
var _v2$3 = /*@__PURE__*/new Vector3();
var Sphere = exports.Sphere = /*#__PURE__*/function () {
  function Sphere() {
    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    _classCallCheck(this, Sphere);
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  return _createClass(Sphere, [{
    key: "set",
    value: function set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points, optionalCenter) {
      var center = this.center;
      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        _box$3.setFromPoints(points).getCenter(center);
      }
      var maxRadiusSq = 0;
      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.radius < 0;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      var radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return box.intersectsSphere(this);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(point, target) {
      var deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(target) {
      if (this.isEmpty()) {
        // Empty sphere produces empty bounding box
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.center.add(offset);
      return this;
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(point) {
      if (this.isEmpty()) {
        this.center.copy(point);
        this.radius = 0;
        return this;
      }
      _v1$6.subVectors(point, this.center);
      var lengthSq = _v1$6.lengthSq();
      if (lengthSq > this.radius * this.radius) {
        // calculate the minimal sphere

        var length = Math.sqrt(lengthSq);
        var delta = (length - this.radius) * 0.5;
        this.center.addScaledVector(_v1$6, delta / length);
        this.radius += delta;
      }
      return this;
    }
  }, {
    key: "union",
    value: function union(sphere) {
      if (sphere.isEmpty()) {
        return this;
      }
      if (this.isEmpty()) {
        this.copy(sphere);
        return this;
      }
      if (this.center.equals(sphere.center) === true) {
        this.radius = Math.max(this.radius, sphere.radius);
      } else {
        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
      }
      return this;
    }
  }, {
    key: "equals",
    value: function equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var _vector$a = /*@__PURE__*/new Vector3();
var _segCenter = /*@__PURE__*/new Vector3();
var _segDir = /*@__PURE__*/new Vector3();
var _diff = /*@__PURE__*/new Vector3();
var _edge1 = /*@__PURE__*/new Vector3();
var _edge2 = /*@__PURE__*/new Vector3();
var _normal$1 = /*@__PURE__*/new Vector3();
var Ray = exports.Ray = /*#__PURE__*/function () {
  function Ray() {
    var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, -1);
    _classCallCheck(this, Ray);
    this.origin = origin;
    this.direction = direction;
  }
  return _createClass(Ray, [{
    key: "set",
    value: function set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
  }, {
    key: "at",
    value: function at(t, target) {
      return target.copy(this.origin).addScaledVector(this.direction, t);
    }
  }, {
    key: "lookAt",
    value: function lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
  }, {
    key: "recast",
    value: function recast(t) {
      this.origin.copy(this.at(t, _vector$a));
      return this;
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(point, target) {
      target.subVectors(point, this.origin);
      var directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
  }, {
    key: "distanceSqToPoint",
    value: function distanceSqToPoint(point) {
      var directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);

      // point behind the ray

      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
      return _vector$a.distanceToSquared(point);
    }
  }, {
    key: "distanceSqToSegment",
    value: function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment

      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(_segDir);
      var b0 = _diff.dot(this.direction);
      var b1 = -_diff.dot(_segDir);
      var c = _diff.lengthSq();
      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;
      if (det > 0) {
        // The ray and segment are not parallel.

        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              // region 0
              // Minimum at interior points of ray and segment.

              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              // region 1

              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            // region 5

            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            // region 4

            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            // region 3

            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            // region 2

            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        // Ray and segment are parallel.

        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
      }
      return sqrDist;
    }
  }, {
    key: "intersectSphere",
    value: function intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);
      var tca = _vector$a.dot(this.direction);
      var d2 = _vector$a.dot(_vector$a) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) return null;
      var thc = Math.sqrt(radius2 - d2);

      // t0 = first intersect point - entrance on front of sphere
      var t0 = tca - thc;

      // t1 = second intersect point - exit point on back of sphere
      var t1 = tca + thc;

      // test to see if t1 is behind the ray - if so, return null
      if (t1 < 0) return null;

      // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.
      if (t0 < 0) return this.at(t1, target);

      // else t0 is in front of the ray, so return the first collision point scaled by t0
      return this.at(t0, target);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
  }, {
    key: "distanceToPlane",
    value: function distanceToPlane(plane) {
      var denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        // line is coplanar, return origin
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }

        // Null is preferable to undefined since undefined means.... it is undefined

        return null;
      }
      var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

      // Return if the ray never intersects the plane

      return t >= 0 ? t : null;
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane, target) {
      var t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, target);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(plane) {
      // check if the ray lies on the plane first

      var distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      var denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }

      // ray origin is behind the plane (and is pointing behind it)

      return false;
    }
  }, {
    key: "intersectBox",
    value: function intersectBox(box, target) {
      var tmin, tmax, tymin, tymax, tzmin, tzmax;
      var invdirx = 1 / this.direction.x,
        invdiry = 1 / this.direction.y,
        invdirz = 1 / this.direction.z;
      var origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax) return null;
      if (tymin > tmin || isNaN(tmin)) tmin = tymin;
      if (tymax < tmax || isNaN(tmax)) tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax) return null;
      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

      //return point closest to the ray (positive side)

      if (tmax < 0) return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
  }, {
    key: "intersectTriangle",
    value: function intersectTriangle(a, b, c, backfaceCulling, target) {
      // Compute the offset origin, edges, and normal.

      // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

      _edge1.subVectors(b, a);
      _edge2.subVectors(c, a);
      _normal$1.crossVectors(_edge1, _edge2);

      // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
      var DdN = this.direction.dot(_normal$1);
      var sign;
      if (DdN > 0) {
        if (backfaceCulling) return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

      // b1 < 0, no intersection
      if (DdQxE2 < 0) {
        return null;
      }
      var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

      // b2 < 0, no intersection
      if (DdE1xQ < 0) {
        return null;
      }

      // b1+b2 > 1, no intersection
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }

      // Line intersects triangle, check if ray does.
      var QdN = -sign * _diff.dot(_normal$1);

      // t < 0, no intersection
      if (QdN < 0) {
        return null;
      }

      // Ray intersects triangle.
      return this.at(QdN / DdN, target);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var Matrix4 = exports.Matrix4 = /*#__PURE__*/function () {
  function Matrix4(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    _classCallCheck(this, Matrix4);
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    if (n11 !== undefined) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  return _createClass(Matrix4, [{
    key: "set",
    value: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      var te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Matrix4().fromArray(this.elements);
    }
  }, {
    key: "copy",
    value: function copy(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
  }, {
    key: "copyPosition",
    value: function copyPosition(m) {
      var te = this.elements,
        me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
  }, {
    key: "setFromMatrix3",
    value: function setFromMatrix3(m) {
      var me = m.elements;
      this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
  }, {
    key: "makeBasis",
    value: function makeBasis(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "extractRotation",
    value: function extractRotation(m) {
      // this method does not support reflection matrices

      var te = this.elements;
      var me = m.elements;
      var scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
      var scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
      var scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "makeRotationFromEuler",
    value: function makeRotationFromEuler(euler) {
      var te = this.elements;
      var x = euler.x,
        y = euler.y,
        z = euler.z;
      var a = Math.cos(x),
        b = Math.sin(x);
      var c = Math.cos(y),
        d = Math.sin(y);
      var e = Math.cos(z),
        f = Math.sin(z);
      if (euler.order === 'XYZ') {
        var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === 'YXZ') {
        var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === 'ZXY') {
        var _ce = c * e,
          _cf = c * f,
          _de = d * e,
          _df = d * f;
        te[0] = _ce - _df * b;
        te[4] = -a * f;
        te[8] = _de + _cf * b;
        te[1] = _cf + _de * b;
        te[5] = a * e;
        te[9] = _df - _ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === 'ZYX') {
        var _ae = a * e,
          _af = a * f,
          _be = b * e,
          _bf = b * f;
        te[0] = c * e;
        te[4] = _be * d - _af;
        te[8] = _ae * d + _bf;
        te[1] = c * f;
        te[5] = _bf * d + _ae;
        te[9] = _af * d - _be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === 'YZX') {
        var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === 'XZY') {
        var _ac = a * c,
          _ad = a * d,
          _bc = b * c,
          _bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = _ac * f + _bd;
        te[5] = a * e;
        te[9] = _ad * f - _bc;
        te[2] = _bc * f - _ad;
        te[6] = b * e;
        te[10] = _bd * f + _ac;
      }

      // bottom row
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;

      // last column
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "makeRotationFromQuaternion",
    value: function makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    }
  }, {
    key: "lookAt",
    value: function lookAt(eye, target, up) {
      var te = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        // eye and target are in the same position

        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        // up and z are parallel

        if (Math.abs(up.z) === 1) {
          _z.x += 0.0001;
        } else {
          _z.z += 0.0001;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(m) {
      return this.multiplyMatrices(this, m);
    }
  }, {
    key: "premultiply",
    value: function premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0],
        a12 = ae[4],
        a13 = ae[8],
        a14 = ae[12];
      var a21 = ae[1],
        a22 = ae[5],
        a23 = ae[9],
        a24 = ae[13];
      var a31 = ae[2],
        a32 = ae[6],
        a33 = ae[10],
        a34 = ae[14];
      var a41 = ae[3],
        a42 = ae[7],
        a43 = ae[11],
        a44 = ae[15];
      var b11 = be[0],
        b12 = be[4],
        b13 = be[8],
        b14 = be[12];
      var b21 = be[1],
        b22 = be[5],
        b23 = be[9],
        b24 = be[13];
      var b31 = be[2],
        b32 = be[6],
        b33 = be[10],
        b34 = be[14];
      var b41 = be[3],
        b42 = be[7],
        b43 = be[11],
        b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(s) {
      var te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var te = this.elements;
      var n11 = te[0],
        n12 = te[4],
        n13 = te[8],
        n14 = te[12];
      var n21 = te[1],
        n22 = te[5],
        n23 = te[9],
        n24 = te[13];
      var n31 = te[2],
        n32 = te[6],
        n33 = te[10],
        n34 = te[14];
      var n41 = te[3],
        n42 = te[7],
        n43 = te[11],
        n44 = te[15];

      //TODO: make this more efficient
      //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var te = this.elements;
      var tmp;
      tmp = te[1];
      te[1] = te[4];
      te[4] = tmp;
      tmp = te[2];
      te[2] = te[8];
      te[8] = tmp;
      tmp = te[6];
      te[6] = te[9];
      te[9] = tmp;
      tmp = te[3];
      te[3] = te[12];
      te[12] = tmp;
      tmp = te[7];
      te[7] = te[13];
      te[13] = tmp;
      tmp = te[11];
      te[11] = te[14];
      te[14] = tmp;
      return this;
    }
  }, {
    key: "setPosition",
    value: function setPosition(x, y, z) {
      var te = this.elements;
      if (x.isVector3) {
        te[12] = x.x;
        te[13] = x.y;
        te[14] = x.z;
      } else {
        te[12] = x;
        te[13] = y;
        te[14] = z;
      }
      return this;
    }
  }, {
    key: "invert",
    value: function invert() {
      // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
      var te = this.elements,
        n11 = te[0],
        n21 = te[1],
        n31 = te[2],
        n41 = te[3],
        n12 = te[4],
        n22 = te[5],
        n32 = te[6],
        n42 = te[7],
        n13 = te[8],
        n23 = te[9],
        n33 = te[10],
        n43 = te[11],
        n14 = te[12],
        n24 = te[13],
        n34 = te[14],
        n44 = te[15],
        t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
        t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
        t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
        t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
  }, {
    key: "scale",
    value: function scale(v) {
      var te = this.elements;
      var x = v.x,
        y = v.y,
        z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
  }, {
    key: "getMaxScaleOnAxis",
    value: function getMaxScaleOnAxis() {
      var te = this.elements;
      var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(x, y, z) {
      if (x.isVector3) {
        this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
      } else {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      }
      return this;
    }
  }, {
    key: "makeRotationX",
    value: function makeRotationX(theta) {
      var c = Math.cos(theta),
        s = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationY",
    value: function makeRotationY(theta) {
      var c = Math.cos(theta),
        s = Math.sin(theta);
      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationZ",
    value: function makeRotationZ(theta) {
      var c = Math.cos(theta),
        s = Math.sin(theta);
      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationAxis",
    value: function makeRotationAxis(axis, angle) {
      // Based on http://www.gamedev.net/reference/articles/article1199.asp

      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var t = 1 - c;
      var x = axis.x,
        y = axis.y,
        z = axis.z;
      var tx = t * x,
        ty = t * y;
      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeScale",
    value: function makeScale(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeShear",
    value: function makeShear(xy, xz, yx, yz, zx, zy) {
      this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "compose",
    value: function compose(position, quaternion, scale) {
      var te = this.elements;
      var x = quaternion._x,
        y = quaternion._y,
        z = quaternion._z,
        w = quaternion._w;
      var x2 = x + x,
        y2 = y + y,
        z2 = z + z;
      var xx = x * x2,
        xy = x * y2,
        xz = x * z2;
      var yy = y * y2,
        yz = y * z2,
        zz = z * z2;
      var wx = w * x2,
        wy = w * y2,
        wz = w * z2;
      var sx = scale.x,
        sy = scale.y,
        sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    }
  }, {
    key: "decompose",
    value: function decompose(position, quaternion, scale) {
      var te = this.elements;
      var sx = _v1$5.set(te[0], te[1], te[2]).length();
      var sy = _v1$5.set(te[4], te[5], te[6]).length();
      var sz = _v1$5.set(te[8], te[9], te[10]).length();

      // if determine is negative, we need to invert one scale
      var det = this.determinant();
      if (det < 0) sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];

      // scale the rotation part
      _m1$4.copy(this);
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      _m1$4.elements[0] *= invSX;
      _m1$4.elements[1] *= invSX;
      _m1$4.elements[2] *= invSX;
      _m1$4.elements[4] *= invSY;
      _m1$4.elements[5] *= invSY;
      _m1$4.elements[6] *= invSY;
      _m1$4.elements[8] *= invSZ;
      _m1$4.elements[9] *= invSZ;
      _m1$4.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$4);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
  }, {
    key: "makePerspective",
    value: function makePerspective(left, right, top, bottom, near, far) {
      var coordinateSystem = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : WebGLCoordinateSystem;
      var te = this.elements;
      var x = 2 * near / (right - left);
      var y = 2 * near / (top - bottom);
      var a = (right + left) / (right - left);
      var b = (top + bottom) / (top - bottom);
      var c, d;
      if (coordinateSystem === WebGLCoordinateSystem) {
        c = -(far + near) / (far - near);
        d = -2 * far * near / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c = -far / (far - near);
        d = -far * near / (far - near);
      } else {
        throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
      }
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
  }, {
    key: "makeOrthographic",
    value: function makeOrthographic(left, right, top, bottom, near, far) {
      var coordinateSystem = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : WebGLCoordinateSystem;
      var te = this.elements;
      var w = 1.0 / (right - left);
      var h = 1.0 / (top - bottom);
      var p = 1.0 / (far - near);
      var x = (right + left) * w;
      var y = (top + bottom) * h;
      var z, zInv;
      if (coordinateSystem === WebGLCoordinateSystem) {
        z = (far + near) * p;
        zInv = -2 * p;
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        z = near * p;
        zInv = -1 * p;
      } else {
        throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
      }
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = zInv;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(matrix) {
      var te = this.elements;
      var me = matrix.elements;
      for (var i = 0; i < 16; i++) {
        if (te[i] !== me[i]) return false;
      }
      return true;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = 0; i < 16; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  }]);
}();
var _v1$5 = /*@__PURE__*/new Vector3();
var _m1$4 = /*@__PURE__*/new Matrix4();
var _zero = /*@__PURE__*/new Vector3(0, 0, 0);
var _one = /*@__PURE__*/new Vector3(1, 1, 1);
var _x = /*@__PURE__*/new Vector3();
var _y = /*@__PURE__*/new Vector3();
var _z = /*@__PURE__*/new Vector3();
var _matrix$2 = /*@__PURE__*/new Matrix4();
var _quaternion$3 = /*@__PURE__*/new Quaternion();
var Euler = exports.Euler = /*#__PURE__*/function () {
  function Euler() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DEFAULT_ORDER;
    _classCallCheck(this, Euler);
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  return _createClass(Euler, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(value) {
      this._x = value;
      this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(value) {
      this._y = value;
      this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(value) {
      this._z = value;
      this._onChangeCallback();
    }
  }, {
    key: "order",
    get: function get() {
      return this._order;
    },
    set: function set(value) {
      this._order = value;
      this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(x, y, z) {
      var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._order;
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
  }, {
    key: "copy",
    value: function copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
      var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var te = m.elements;
      var m11 = te[0],
        m12 = te[4],
        m13 = te[8];
      var m21 = te[1],
        m22 = te[5],
        m23 = te[9];
      var m31 = te[2],
        m32 = te[6],
        m33 = te[10];
      switch (order) {
        case 'XYZ':
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case 'YXZ':
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case 'ZXY':
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case 'ZYX':
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case 'YZX':
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case 'XZY':
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
      }
      this._order = order;
      if (update === true) this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromQuaternion",
    value: function setFromQuaternion(q, order, update) {
      _matrix$2.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(_matrix$2, order, update);
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
      return this.set(v.x, v.y, v.z, order);
    }
  }, {
    key: "reorder",
    value: function reorder(newOrder) {
      // WARNING: this discards revolution information -bhouston

      _quaternion$3.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
  }, {
    key: "equals",
    value: function equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== undefined) this._order = array[3];
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
  }, {
    key: "_onChange",
    value: function _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this._x;
          case 2:
            _context6.next = 4;
            return this._y;
          case 4:
            _context6.next = 6;
            return this._z;
          case 6:
            _context6.next = 8;
            return this._order;
          case 8:
          case "end":
            return _context6.stop();
        }
      }, value, this);
    })
  }]);
}();
Euler.DEFAULT_ORDER = 'XYZ';
var Layers = exports.Layers = /*#__PURE__*/function () {
  function Layers() {
    _classCallCheck(this, Layers);
    this.mask = 1 | 0;
  }
  return _createClass(Layers, [{
    key: "set",
    value: function set(channel) {
      this.mask = (1 << channel | 0) >>> 0;
    }
  }, {
    key: "enable",
    value: function enable(channel) {
      this.mask |= 1 << channel | 0;
    }
  }, {
    key: "enableAll",
    value: function enableAll() {
      this.mask = 0xffffffff | 0;
    }
  }, {
    key: "toggle",
    value: function toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
  }, {
    key: "disable",
    value: function disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
  }, {
    key: "disableAll",
    value: function disableAll() {
      this.mask = 0;
    }
  }, {
    key: "test",
    value: function test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
  }, {
    key: "isEnabled",
    value: function isEnabled(channel) {
      return (this.mask & (1 << channel | 0)) !== 0;
    }
  }]);
}();
var _object3DId = 0;
var _v1$4 = /*@__PURE__*/new Vector3();
var _q1 = /*@__PURE__*/new Quaternion();
var _m1$3 = /*@__PURE__*/new Matrix4();
var _target = /*@__PURE__*/new Vector3();
var _position$3 = /*@__PURE__*/new Vector3();
var _scale$2 = /*@__PURE__*/new Vector3();
var _quaternion$2 = /*@__PURE__*/new Quaternion();
var _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);
var _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);
var _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);
var _addedEvent = {
  type: 'added'
};
var _removedEvent = {
  type: 'removed'
};
var _childaddedEvent = {
  type: 'childadded',
  child: null
};
var _childremovedEvent = {
  type: 'childremoved',
  child: null
};
var Object3D = exports.Object3D = /*#__PURE__*/function (_EventDispatcher3) {
  function Object3D() {
    var _this9;
    _classCallCheck(this, Object3D);
    _this9 = _callSuper(this, Object3D);
    _this9.isObject3D = true;
    Object.defineProperty(_this9, 'id', {
      value: _object3DId++
    });
    _this9.uuid = generateUUID();
    _this9.name = '';
    _this9.type = 'Object3D';
    _this9.parent = null;
    _this9.children = [];
    _this9.up = Object3D.DEFAULT_UP.clone();
    var position = new Vector3();
    var rotation = new Euler();
    var quaternion = new Quaternion();
    var scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(_this9, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    _this9.matrix = new Matrix4();
    _this9.matrixWorld = new Matrix4();
    _this9.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    _this9.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
    _this9.matrixWorldNeedsUpdate = false;
    _this9.layers = new Layers();
    _this9.visible = true;
    _this9.castShadow = false;
    _this9.receiveShadow = false;
    _this9.frustumCulled = true;
    _this9.renderOrder = 0;
    _this9.animations = [];
    _this9.userData = {};
    return _this9;
  }
  _inherits(Object3D, _EventDispatcher3);
  return _createClass(Object3D, [{
    key: "onBeforeShadow",
    value: function onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
  }, {
    key: "onAfterShadow",
    value: function onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender( /* renderer, scene, camera, geometry, material, group */) {}
  }, {
    key: "onAfterRender",
    value: function onAfterRender( /* renderer, scene, camera, geometry, material, group */) {}
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(q) {
      this.quaternion.premultiply(q);
      return this;
    }
  }, {
    key: "setRotationFromAxisAngle",
    value: function setRotationFromAxisAngle(axis, angle) {
      // assumes axis is normalized

      this.quaternion.setFromAxisAngle(axis, angle);
    }
  }, {
    key: "setRotationFromEuler",
    value: function setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    }
  }, {
    key: "setRotationFromMatrix",
    value: function setRotationFromMatrix(m) {
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      this.quaternion.setFromRotationMatrix(m);
    }
  }, {
    key: "setRotationFromQuaternion",
    value: function setRotationFromQuaternion(q) {
      // assumes q is normalized

      this.quaternion.copy(q);
    }
  }, {
    key: "rotateOnAxis",
    value: function rotateOnAxis(axis, angle) {
      // rotate object on axis in object space
      // axis is assumed to be normalized

      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    }
  }, {
    key: "rotateOnWorldAxis",
    value: function rotateOnWorldAxis(axis, angle) {
      // rotate object on axis in world space
      // axis is assumed to be normalized
      // method assumes no rotated parent

      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    }
  }, {
    key: "rotateY",
    value: function rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    }
  }, {
    key: "translateOnAxis",
    value: function translateOnAxis(axis, distance) {
      // translate object by distance along axis in object space
      // axis is assumed to be normalized

      _v1$4.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    }
  }, {
    key: "translateX",
    value: function translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    }
  }, {
    key: "translateY",
    value: function translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    }
  }, {
    key: "translateZ",
    value: function translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    }
  }, {
    key: "localToWorld",
    value: function localToWorld(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(this.matrixWorld);
    }
  }, {
    key: "worldToLocal",
    value: function worldToLocal(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
    }
  }, {
    key: "lookAt",
    value: function lookAt(x, y, z) {
      // This method does not support objects having non-uniformly-scaled parent(s)

      if (x.isVector3) {
        _target.copy(x);
      } else {
        _target.set(x, y, z);
      }
      var parent = this.parent;
      this.updateWorldMatrix(true, false);
      _position$3.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$3.lookAt(_position$3, _target, this.up);
      } else {
        _m1$3.lookAt(_target, _position$3, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$3);
      if (parent) {
        _m1$3.extractRotation(parent.matrixWorld);
        _q1.setFromRotationMatrix(_m1$3);
        this.quaternion.premultiply(_q1.invert());
      }
    }
  }, {
    key: "add",
    value: function add(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
        return this;
      }
      if (object && object.isObject3D) {
        object.removeFromParent();
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
        _childaddedEvent.child = object;
        this.dispatchEvent(_childaddedEvent);
        _childaddedEvent.child = null;
      } else {
        console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
      }
      return this;
    }
  }, {
    key: "remove",
    value: function remove(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
        return this;
      }
      var index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
        _childremovedEvent.child = object;
        this.dispatchEvent(_childremovedEvent);
        _childremovedEvent.child = null;
      }
      return this;
    }
  }, {
    key: "removeFromParent",
    value: function removeFromParent() {
      var parent = this.parent;
      if (parent !== null) {
        parent.remove(this);
      }
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      return this.remove.apply(this, _toConsumableArray(this.children));
    }
  }, {
    key: "attach",
    value: function attach(object) {
      // adds object as a child of this, while maintaining the object's world transform

      // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

      this.updateWorldMatrix(true, false);
      _m1$3.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$3.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$3);
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.updateWorldMatrix(false, true);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
      return this;
    }
  }, {
    key: "getObjectById",
    value: function getObjectById(id) {
      return this.getObjectByProperty('id', id);
    }
  }, {
    key: "getObjectByName",
    value: function getObjectByName(name) {
      return this.getObjectByProperty('name', name);
    }
  }, {
    key: "getObjectByProperty",
    value: function getObjectByProperty(name, value) {
      if (this[name] === value) return this;
      for (var i = 0, l = this.children.length; i < l; i++) {
        var child = this.children[i];
        var object = child.getObjectByProperty(name, value);
        if (object !== undefined) {
          return object;
        }
      }
      return undefined;
    }
  }, {
    key: "getObjectsByProperty",
    value: function getObjectsByProperty(name, value) {
      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      if (this[name] === value) result.push(this);
      var children = this.children;
      for (var i = 0, l = children.length; i < l; i++) {
        children[i].getObjectsByProperty(name, value, result);
      }
      return result;
    }
  }, {
    key: "getWorldPosition",
    value: function getWorldPosition(target) {
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    }
  }, {
    key: "getWorldQuaternion",
    value: function getWorldQuaternion(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    }
  }, {
    key: "getWorldScale",
    value: function getWorldScale(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      var e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    }
  }, {
    key: "raycast",
    value: function raycast( /* raycaster, intersects */) {}
  }, {
    key: "traverse",
    value: function traverse(callback) {
      callback(this);
      var children = this.children;
      for (var i = 0, l = children.length; i < l; i++) {
        children[i].traverse(callback);
      }
    }
  }, {
    key: "traverseVisible",
    value: function traverseVisible(callback) {
      if (this.visible === false) return;
      callback(this);
      var children = this.children;
      for (var i = 0, l = children.length; i < l; i++) {
        children[i].traverseVisible(callback);
      }
    }
  }, {
    key: "traverseAncestors",
    value: function traverseAncestors(callback) {
      var parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.matrixWorldAutoUpdate === true) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }

      // make sure descendants are updated if required

      var children = this.children;
      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        child.updateMatrixWorld(force);
      }
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(updateParents, updateChildren) {
      var parent = this.parent;
      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate) this.updateMatrix();
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
      }

      // make sure descendants are updated

      if (updateChildren === true) {
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
          var child = children[i];
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      // meta is a string when called from JSON.stringify
      var isRootObject = meta === undefined || typeof meta === 'string';
      var output = {};

      // meta is a hash used to collect geometries, materials.
      // not providing it implies that this is the root object
      // being serialized.
      if (isRootObject) {
        // initialize meta obj
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        };
        output.metadata = {
          version: 4.6,
          type: 'Object',
          generator: 'Object3D.toJSON'
        };
      }

      // standard Object3D serialization

      var object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== '') object.name = this.name;
      if (this.castShadow === true) object.castShadow = true;
      if (this.receiveShadow === true) object.receiveShadow = true;
      if (this.visible === false) object.visible = false;
      if (this.frustumCulled === false) object.frustumCulled = false;
      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
      if (Object.keys(this.userData).length > 0) object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      object.up = this.up.toArray();
      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

      // object specific properties

      if (this.isInstancedMesh) {
        object.type = 'InstancedMesh';
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
      }
      if (this.isBatchedMesh) {
        object.type = 'BatchedMesh';
        object.perObjectFrustumCulled = this.perObjectFrustumCulled;
        object.sortObjects = this.sortObjects;
        object.drawRanges = this._drawRanges;
        object.reservedRanges = this._reservedRanges;
        object.visibility = this._visibility;
        object.active = this._active;
        object.bounds = this._bounds.map(function (bound) {
          return {
            boxInitialized: bound.boxInitialized,
            boxMin: bound.box.min.toArray(),
            boxMax: bound.box.max.toArray(),
            sphereInitialized: bound.sphereInitialized,
            sphereRadius: bound.sphere.radius,
            sphereCenter: bound.sphere.center.toArray()
          };
        });
        object.maxInstanceCount = this._maxInstanceCount;
        object.maxVertexCount = this._maxVertexCount;
        object.maxIndexCount = this._maxIndexCount;
        object.geometryInitialized = this._geometryInitialized;
        object.geometryCount = this._geometryCount;
        object.matricesTexture = this._matricesTexture.toJSON(meta);
        if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
        if (this.boundingSphere !== null) {
          object.boundingSphere = {
            center: object.boundingSphere.center.toArray(),
            radius: object.boundingSphere.radius
          };
        }
        if (this.boundingBox !== null) {
          object.boundingBox = {
            min: object.boundingBox.min.toArray(),
            max: object.boundingBox.max.toArray()
          };
        }
      }

      //

      function serialize(library, element) {
        if (library[element.uuid] === undefined) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isScene) {
        if (this.background) {
          if (this.background.isColor) {
            object.background = this.background.toJSON();
          } else if (this.background.isTexture) {
            object.background = this.background.toJSON(meta).uuid;
          }
        }
        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
          object.environment = this.environment.toJSON(meta).uuid;
        }
      } else if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        var parameters = this.geometry.parameters;
        if (parameters !== undefined && parameters.shapes !== undefined) {
          var shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
              var shape = shapes[i];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== undefined) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== undefined) {
        if (Array.isArray(this.material)) {
          var uuids = [];
          for (var _i3 = 0, _l2 = this.material.length; _i3 < _l2; _i3++) {
            uuids.push(serialize(meta.materials, this.material[_i3]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }

      //

      if (this.children.length > 0) {
        object.children = [];
        for (var _i4 = 0; _i4 < this.children.length; _i4++) {
          object.children.push(this.children[_i4].toJSON(meta).object);
        }
      }

      //

      if (this.animations.length > 0) {
        object.animations = [];
        for (var _i5 = 0; _i5 < this.animations.length; _i5++) {
          var animation = this.animations[_i5];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        var geometries = extractFromCache(meta.geometries);
        var materials = extractFromCache(meta.materials);
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        var _shapes = extractFromCache(meta.shapes);
        var skeletons = extractFromCache(meta.skeletons);
        var animations = extractFromCache(meta.animations);
        var nodes = extractFromCache(meta.nodes);
        if (geometries.length > 0) output.geometries = geometries;
        if (materials.length > 0) output.materials = materials;
        if (textures.length > 0) output.textures = textures;
        if (images.length > 0) output.images = images;
        if (_shapes.length > 0) output.shapes = _shapes;
        if (skeletons.length > 0) output.skeletons = skeletons;
        if (animations.length > 0) output.animations = animations;
        if (nodes.length > 0) output.nodes = nodes;
      }
      output.object = object;
      return output;

      // extract data from the cache hash
      // remove metadata on each item
      // and return as array
      function extractFromCache(cache) {
        var values = [];
        for (var key in cache) {
          var data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    }
  }, {
    key: "clone",
    value: function clone(recursive) {
      return new this.constructor().copy(this, recursive);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.animations = source.animations.slice();
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (var i = 0; i < source.children.length; i++) {
          var child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
  }]);
}(EventDispatcher);
Object3D.DEFAULT_UP = /*@__PURE__*/new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
var _v0$2 = /*@__PURE__*/new Vector3();
var _v1$3 = /*@__PURE__*/new Vector3();
var _v2$2 = /*@__PURE__*/new Vector3();
var _v3$2 = /*@__PURE__*/new Vector3();
var _vab = /*@__PURE__*/new Vector3();
var _vac = /*@__PURE__*/new Vector3();
var _vbc = /*@__PURE__*/new Vector3();
var _vap = /*@__PURE__*/new Vector3();
var _vbp = /*@__PURE__*/new Vector3();
var _vcp = /*@__PURE__*/new Vector3();
var Triangle = exports.Triangle = /*#__PURE__*/function () {
  function Triangle() {
    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
    _classCallCheck(this, Triangle);
    this.a = a;
    this.b = b;
    this.c = c;
  }
  return _createClass(Triangle, [{
    key: "set",
    value: function set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    }
  }, {
    key: "setFromPointsAndIndices",
    value: function setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
  }, {
    key: "setFromAttributeAndIndices",
    value: function setFromAttributeAndIndices(attribute, i0, i1, i2) {
      this.a.fromBufferAttribute(attribute, i0);
      this.b.fromBufferAttribute(attribute, i1);
      this.c.fromBufferAttribute(attribute, i2);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
  }, {
    key: "getArea",
    value: function getArea() {
      _v0$2.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$2.cross(_v1$3).length() * 0.5;
    }
  }, {
    key: "getMidpoint",
    value: function getMidpoint(target) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
  }, {
    key: "getNormal",
    value: function getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
  }, {
    key: "getPlane",
    value: function getPlane(target) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
  }, {
    key: "getBarycoord",
    value: function getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation(point, v1, v2, v3, target) {
      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(p, target) {
      var a = this.a,
        b = this.b,
        c = this.c;
      var v, w;

      // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
      // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
      // under the accompanying license; see chapter 5.1.5 for detailed explanation.
      // basically, we're distinguishing which of the voronoi regions of the triangle
      // the point lies in with the minimum amount of redundant computation.

      _vab.subVectors(b, a);
      _vac.subVectors(c, a);
      _vap.subVectors(p, a);
      var d1 = _vab.dot(_vap);
      var d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a);
      }
      _vbp.subVectors(p, b);
      var d3 = _vab.dot(_vbp);
      var d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b);
      }
      var vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        // edge region of AB; barycentric coords (1-v, v, 0)
        return target.copy(a).addScaledVector(_vab, v);
      }
      _vcp.subVectors(p, c);
      var d5 = _vab.dot(_vcp);
      var d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c);
      }
      var vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        // edge region of AC; barycentric coords (1-w, 0, w)
        return target.copy(a).addScaledVector(_vac, w);
      }
      var va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        // edge region of BC; barycentric coords (0, 1-w, w)
        return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
      }

      // face region
      var denom = 1 / (va + vb + vc);
      // u = va * denom
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
  }, {
    key: "equals",
    value: function equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  }], [{
    key: "getNormal",
    value: function getNormal(a, b, c, target) {
      target.subVectors(c, b);
      _v0$2.subVectors(a, b);
      target.cross(_v0$2);
      var targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }

    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  }, {
    key: "getBarycoord",
    value: function getBarycoord(point, a, b, c, target) {
      _v0$2.subVectors(c, a);
      _v1$3.subVectors(b, a);
      _v2$2.subVectors(point, a);
      var dot00 = _v0$2.dot(_v0$2);
      var dot01 = _v0$2.dot(_v1$3);
      var dot02 = _v0$2.dot(_v2$2);
      var dot11 = _v1$3.dot(_v1$3);
      var dot12 = _v1$3.dot(_v2$2);
      var denom = dot00 * dot11 - dot01 * dot01;

      // collinear or singular triangle
      if (denom === 0) {
        target.set(0, 0, 0);
        return null;
      }
      var invDenom = 1 / denom;
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

      // barycentric coordinates must always sum to 1
      return target.set(1 - u - v, v, u);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point, a, b, c) {
      // if the triangle is degenerate then we can't contain a point
      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
        return false;
      }
      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
        target.x = 0;
        target.y = 0;
        if ('z' in target) target.z = 0;
        if ('w' in target) target.w = 0;
        return null;
      }
      target.setScalar(0);
      target.addScaledVector(v1, _v3$2.x);
      target.addScaledVector(v2, _v3$2.y);
      target.addScaledVector(v3, _v3$2.z);
      return target;
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(a, b, c, direction) {
      _v0$2.subVectors(c, b);
      _v1$3.subVectors(a, b);

      // strictly front facing
      return _v0$2.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
  }]);
}();
var _colorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};
var _hslA = {
  h: 0,
  s: 0,
  l: 0
};
var _hslB = {
  h: 0,
  s: 0,
  l: 0
};
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
var Color = exports.Color = /*#__PURE__*/function () {
  function Color(r, g, b) {
    _classCallCheck(this, Color);
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  return _createClass(Color, [{
    key: "set",
    value: function set(r, g, b) {
      if (g === undefined && b === undefined) {
        // r is THREE.Color, hex or string

        var value = r;
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === 'number') {
          this.setHex(value);
        } else if (typeof value === 'string') {
          this.setStyle(value);
        }
      } else {
        this.setRGB(r, g, b);
      }
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
  }, {
    key: "setHex",
    value: function setHex(hex) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
  }, {
    key: "setRGB",
    value: function setRGB(r, g, b) {
      var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ColorManagement.workingColorSpace;
      this.r = r;
      this.g = g;
      this.b = b;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
  }, {
    key: "setHSL",
    value: function setHSL(h, s, l) {
      var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ColorManagement.workingColorSpace;
      // h,s,l ranges are in 0.0 - 1.0
      h = euclideanModulo(h, 1);
      s = clamp(s, 0, 1);
      l = clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
      function handleAlpha(string) {
        if (string === undefined) return;
        if (parseFloat(string) < 1) {
          console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
      }
      var m;
      if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
        // rgb / hsl

        var color;
        var name = m[1];
        var components = m[2];
        switch (name) {
          case 'rgb':
          case 'rgba':
            if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              // rgb(255,0,0) rgba(255,0,0,0.5)

              handleAlpha(color[4]);
              return this.setRGB(Math.min(255, parseInt(color[1], 10)) / 255, Math.min(255, parseInt(color[2], 10)) / 255, Math.min(255, parseInt(color[3], 10)) / 255, colorSpace);
            }
            if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

              handleAlpha(color[4]);
              return this.setRGB(Math.min(100, parseInt(color[1], 10)) / 100, Math.min(100, parseInt(color[2], 10)) / 100, Math.min(100, parseInt(color[3], 10)) / 100, colorSpace);
            }
            break;
          case 'hsl':
          case 'hsla':
            if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              // hsl(120,50%,50%) hsla(120,50%,50%,0.5)

              handleAlpha(color[4]);
              return this.setHSL(parseFloat(color[1]) / 360, parseFloat(color[2]) / 100, parseFloat(color[3]) / 100, colorSpace);
            }
            break;
          default:
            console.warn('THREE.Color: Unknown color model ' + style);
        }
      } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
        // hex color

        var hex = m[1];
        var size = hex.length;
        if (size === 3) {
          // #ff0
          return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace);
        } else if (size === 6) {
          // #ff0000
          return this.setHex(parseInt(hex, 16), colorSpace);
        } else {
          console.warn('THREE.Color: Invalid hex color ' + style);
        }
      } else if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }
      return this;
    }
  }, {
    key: "setColorName",
    value: function setColorName(style) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
      // color keywords
      var hex = _colorKeywords[style.toLowerCase()];
      if (hex !== undefined) {
        // red
        this.setHex(hex, colorSpace);
      } else {
        // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
      }
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
  }, {
    key: "copy",
    value: function copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
  }, {
    key: "copySRGBToLinear",
    value: function copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
  }, {
    key: "copyLinearToSRGB",
    value: function copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
  }, {
    key: "convertSRGBToLinear",
    value: function convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
  }, {
    key: "convertLinearToSRGB",
    value: function convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
  }, {
    key: "getHex",
    value: function getHex() {
      var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
    }
  }, {
    key: "getHexString",
    value: function getHexString() {
      var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
      return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
    }
  }, {
    key: "getHSL",
    value: function getHSL(target) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorManagement.workingColorSpace;
      // h,s,l ranges are in 0.0 - 1.0

      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      var r = _color.r,
        g = _color.g,
        b = _color.b;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var hue, saturation;
      var lightness = (min + max) / 2.0;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        var delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
  }, {
    key: "getRGB",
    value: function getRGB(target) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorManagement.workingColorSpace;
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      target.r = _color.r;
      target.g = _color.g;
      target.b = _color.b;
      return target;
    }
  }, {
    key: "getStyle",
    value: function getStyle() {
      var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      var r = _color.r,
        g = _color.g,
        b = _color.b;
      if (colorSpace !== SRGBColorSpace) {
        // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
        return "color(".concat(colorSpace, " ").concat(r.toFixed(3), " ").concat(g.toFixed(3), " ").concat(b.toFixed(3), ")");
      }
      return "rgb(".concat(Math.round(r * 255), ",").concat(Math.round(g * 255), ",").concat(Math.round(b * 255), ")");
    }
  }, {
    key: "offsetHSL",
    value: function offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
    }
  }, {
    key: "add",
    value: function add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
  }, {
    key: "addColors",
    value: function addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
  }, {
    key: "lerp",
    value: function lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
  }, {
    key: "lerpColors",
    value: function lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
  }, {
    key: "lerpHSL",
    value: function lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      var h = lerp(_hslA.h, _hslB.h, alpha);
      var s = lerp(_hslA.s, _hslB.s, alpha);
      var l = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v) {
      this.r = v.x;
      this.g = v.y;
      this.b = v.z;
      return this;
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      var r = this.r,
        g = this.g,
        b = this.b;
      var e = m.elements;
      this.r = e[0] * r + e[3] * g + e[6] * b;
      this.g = e[1] * r + e[4] * g + e[7] * b;
      this.b = e[2] * r + e[5] * g + e[8] * b;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.getHex();
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return this.r;
          case 2:
            _context7.next = 4;
            return this.g;
          case 4:
            _context7.next = 6;
            return this.b;
          case 6:
          case "end":
            return _context7.stop();
        }
      }, value, this);
    })
  }]);
}();
var _color = /*@__PURE__*/new Color();
Color.NAMES = _colorKeywords;
var _materialId = 0;
var Material = exports.Material = /*#__PURE__*/function (_EventDispatcher4) {
  function Material() {
    var _this10;
    _classCallCheck(this, Material);
    _this10 = _callSuper(this, Material);
    _this10.isMaterial = true;
    Object.defineProperty(_this10, 'id', {
      value: _materialId++
    });
    _this10.uuid = generateUUID();
    _this10.name = '';
    _this10.type = 'Material';
    _this10.blending = NormalBlending;
    _this10.side = FrontSide;
    _this10.vertexColors = false;
    _this10.opacity = 1;
    _this10.transparent = false;
    _this10.alphaHash = false;
    _this10.blendSrc = SrcAlphaFactor;
    _this10.blendDst = OneMinusSrcAlphaFactor;
    _this10.blendEquation = AddEquation;
    _this10.blendSrcAlpha = null;
    _this10.blendDstAlpha = null;
    _this10.blendEquationAlpha = null;
    _this10.blendColor = new Color(0, 0, 0);
    _this10.blendAlpha = 0;
    _this10.depthFunc = LessEqualDepth;
    _this10.depthTest = true;
    _this10.depthWrite = true;
    _this10.stencilWriteMask = 0xff;
    _this10.stencilFunc = AlwaysStencilFunc;
    _this10.stencilRef = 0;
    _this10.stencilFuncMask = 0xff;
    _this10.stencilFail = KeepStencilOp;
    _this10.stencilZFail = KeepStencilOp;
    _this10.stencilZPass = KeepStencilOp;
    _this10.stencilWrite = false;
    _this10.clippingPlanes = null;
    _this10.clipIntersection = false;
    _this10.clipShadows = false;
    _this10.shadowSide = null;
    _this10.colorWrite = true;
    _this10.precision = null; // override the renderer's default precision for this material

    _this10.polygonOffset = false;
    _this10.polygonOffsetFactor = 0;
    _this10.polygonOffsetUnits = 0;
    _this10.dithering = false;
    _this10.alphaToCoverage = false;
    _this10.premultipliedAlpha = false;
    _this10.forceSinglePass = false;
    _this10.visible = true;
    _this10.toneMapped = true;
    _this10.userData = {};
    _this10.version = 0;
    _this10._alphaTest = 0;
    return _this10;
  }
  _inherits(Material, _EventDispatcher4);
  return _createClass(Material, [{
    key: "alphaTest",
    get: function get() {
      return this._alphaTest;
    },
    set: function set(value) {
      if (this._alphaTest > 0 !== value > 0) {
        this.version++;
      }
      this._alphaTest = value;
    }
  }, {
    key: "onBeforeCompile",
    value: function onBeforeCompile( /* shaderobject, renderer */) {}
  }, {
    key: "customProgramCacheKey",
    value: function customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
  }, {
    key: "setValues",
    value: function setValues(values) {
      if (values === undefined) return;
      for (var key in values) {
        var newValue = values[key];
        if (newValue === undefined) {
          console.warn("THREE.Material: parameter '".concat(key, "' has value of undefined."));
          continue;
        }
        var currentValue = this[key];
        if (currentValue === undefined) {
          console.warn("THREE.Material: '".concat(key, "' is not a property of THREE.").concat(this.type, "."));
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';
      if (isRootObject) {
        meta = {
          textures: {},
          images: {}
        };
      }
      var data = {
        metadata: {
          version: 4.6,
          type: 'Material',
          generator: 'Material.toJSON'
        }
      };

      // standard Material serialization
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '') data.name = this.name;
      if (this.color && this.color.isColor) data.color = this.color.getHex();
      if (this.roughness !== undefined) data.roughness = this.roughness;
      if (this.metalness !== undefined) data.metalness = this.metalness;
      if (this.sheen !== undefined) data.sheen = this.sheen;
      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
      if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
      if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
      if (this.shininess !== undefined) data.shininess = this.shininess;
      if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.dispersion !== undefined) data.dispersion = this.dispersion;
      if (this.iridescence !== undefined) data.iridescence = this.iridescence;
      if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;
      if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
      if (this.iridescenceMap && this.iridescenceMap.isTexture) {
        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
      }
      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
      }
      if (this.anisotropy !== undefined) data.anisotropy = this.anisotropy;
      if (this.anisotropyRotation !== undefined) data.anisotropyRotation = this.anisotropyRotation;
      if (this.anisotropyMap && this.anisotropyMap.isTexture) {
        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
      }
      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        if (this.combine !== undefined) data.combine = this.combine;
      }
      if (this.envMapRotation !== undefined) data.envMapRotation = this.envMapRotation.toArray();
      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
      if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
      if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.transmission !== undefined) data.transmission = this.transmission;
      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
      if (this.thickness !== undefined) data.thickness = this.thickness;
      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
      if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
      if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
      if (this.size !== undefined) data.size = this.size;
      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending) data.blending = this.blending;
      if (this.side !== FrontSide) data.side = this.side;
      if (this.vertexColors === true) data.vertexColors = true;
      if (this.opacity < 1) data.opacity = this.opacity;
      if (this.transparent === true) data.transparent = true;
      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
      if (this.depthTest === false) data.depthTest = this.depthTest;
      if (this.depthWrite === false) data.depthWrite = this.depthWrite;
      if (this.colorWrite === false) data.colorWrite = this.colorWrite;
      if (this.stencilWriteMask !== 0xff) data.stencilWriteMask = this.stencilWriteMask;
      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
      if (this.stencilFuncMask !== 0xff) data.stencilFuncMask = this.stencilFuncMask;
      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;

      // rotation (SpriteMaterial)
      if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
      if (this.polygonOffset === true) data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
      if (this.dashSize !== undefined) data.dashSize = this.dashSize;
      if (this.gapSize !== undefined) data.gapSize = this.gapSize;
      if (this.scale !== undefined) data.scale = this.scale;
      if (this.dithering === true) data.dithering = true;
      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
      if (this.alphaHash === true) data.alphaHash = true;
      if (this.alphaToCoverage === true) data.alphaToCoverage = true;
      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
      if (this.forceSinglePass === true) data.forceSinglePass = true;
      if (this.wireframe === true) data.wireframe = true;
      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.flatShading === true) data.flatShading = true;
      if (this.visible === false) data.visible = false;
      if (this.toneMapped === false) data.toneMapped = false;
      if (this.fog === false) data.fog = false;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;

      // TODO: Copied from Object3D.toJSON

      function extractFromCache(cache) {
        var values = [];
        for (var key in cache) {
          var _data2 = cache[key];
          delete _data2.metadata;
          values.push(_data2);
        }
        return values;
      }
      if (isRootObject) {
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        if (textures.length > 0) data.textures = textures;
        if (images.length > 0) data.images = images;
      }
      return data;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.blendColor.copy(source.blendColor);
      this.blendAlpha = source.blendAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      var srcPlanes = source.clippingPlanes;
      var dstPlanes = null;
      if (srcPlanes !== null) {
        var n = srcPlanes.length;
        dstPlanes = new Array(n);
        for (var i = 0; i !== n; ++i) {
          dstPlanes[i] = srcPlanes[i].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaHash = source.alphaHash;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.forceSinglePass = source.forceSinglePass;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "onBuild",
    value: function onBuild( /* shaderobject, renderer */
    ) {
      console.warn('Material: onBuild() has been removed.'); // @deprecated, r166
    }
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender( /* renderer, scene, camera, geometry, object, group */
    ) {
      console.warn('Material: onBeforeRender() has been removed.'); // @deprecated, r166
    }
  }]);
}(EventDispatcher);
var MeshBasicMaterial = exports.MeshBasicMaterial = /*#__PURE__*/function (_Material) {
  function MeshBasicMaterial(parameters) {
    var _this11;
    _classCallCheck(this, MeshBasicMaterial);
    _this11 = _callSuper(this, MeshBasicMaterial);
    _this11.isMeshBasicMaterial = true;
    _this11.type = 'MeshBasicMaterial';
    _this11.color = new Color(0xffffff); // emissive

    _this11.map = null;
    _this11.lightMap = null;
    _this11.lightMapIntensity = 1.0;
    _this11.aoMap = null;
    _this11.aoMapIntensity = 1.0;
    _this11.specularMap = null;
    _this11.alphaMap = null;
    _this11.envMap = null;
    _this11.envMapRotation = new Euler();
    _this11.combine = MultiplyOperation;
    _this11.reflectivity = 1;
    _this11.refractionRatio = 0.98;
    _this11.wireframe = false;
    _this11.wireframeLinewidth = 1;
    _this11.wireframeLinecap = 'round';
    _this11.wireframeLinejoin = 'round';
    _this11.fog = true;
    _this11.setValues(parameters);
    return _this11;
  }
  _inherits(MeshBasicMaterial, _Material);
  return _createClass(MeshBasicMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshBasicMaterial, "copy", this, 3)([source]);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapRotation.copy(source.envMapRotation);
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material); // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
var _tables = /*@__PURE__*/_generateTables();
function _generateTables() {
  // float32 to float16 helpers

  var buffer = new ArrayBuffer(4);
  var floatView = new Float32Array(buffer);
  var uint32View = new Uint32Array(buffer);
  var baseTable = new Uint32Array(512);
  var shiftTable = new Uint32Array(512);
  for (var i = 0; i < 256; ++i) {
    var _e = i - 127;

    // very small number (0, -0)

    if (_e < -27) {
      baseTable[i] = 0x0000;
      baseTable[i | 0x100] = 0x8000;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24;

      // small number (denorm)
    } else if (_e < -14) {
      baseTable[i] = 0x0400 >> -_e - 14;
      baseTable[i | 0x100] = 0x0400 >> -_e - 14 | 0x8000;
      shiftTable[i] = -_e - 1;
      shiftTable[i | 0x100] = -_e - 1;

      // normal number
    } else if (_e <= 15) {
      baseTable[i] = _e + 15 << 10;
      baseTable[i | 0x100] = _e + 15 << 10 | 0x8000;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13;

      // large number (Infinity, -Infinity)
    } else if (_e < 128) {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24;

      // stay (NaN, Infinity, -Infinity)
    } else {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13;
    }
  }

  // float16 to float32 helpers

  var mantissaTable = new Uint32Array(2048);
  var exponentTable = new Uint32Array(64);
  var offsetTable = new Uint32Array(64);
  for (var _i6 = 1; _i6 < 1024; ++_i6) {
    var m = _i6 << 13; // zero pad mantissa bits
    var _e2 = 0; // zero exponent

    // normalized
    while ((m & 0x00800000) === 0) {
      m <<= 1;
      _e2 -= 0x00800000; // decrement exponent
    }
    m &= ~0x00800000; // clear leading 1 bit
    _e2 += 0x38800000; // adjust bias

    mantissaTable[_i6] = m | _e2;
  }
  for (var _i7 = 1024; _i7 < 2048; ++_i7) {
    mantissaTable[_i7] = 0x38000000 + (_i7 - 1024 << 13);
  }
  for (var _i8 = 1; _i8 < 31; ++_i8) {
    exponentTable[_i8] = _i8 << 23;
  }
  exponentTable[31] = 0x47800000;
  exponentTable[32] = 0x80000000;
  for (var _i9 = 33; _i9 < 63; ++_i9) {
    exponentTable[_i9] = 0x80000000 + (_i9 - 32 << 23);
  }
  exponentTable[63] = 0xc7800000;
  for (var _i10 = 1; _i10 < 64; ++_i10) {
    if (_i10 !== 32) {
      offsetTable[_i10] = 1024;
    }
  }
  return {
    floatView: floatView,
    uint32View: uint32View,
    baseTable: baseTable,
    shiftTable: shiftTable,
    mantissaTable: mantissaTable,
    exponentTable: exponentTable,
    offsetTable: offsetTable
  };
}

// float32 to float16

function toHalfFloat(val) {
  if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
  val = clamp(val, -65504, 65504);
  _tables.floatView[0] = val;
  var f = _tables.uint32View[0];
  var e = f >> 23 & 0x1ff;
  return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
}

// float16 to float32

function fromHalfFloat(val) {
  var m = val >> 10;
  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
  return _tables.floatView[0];
}
var DataUtils = exports.DataUtils = {
  toHalfFloat: toHalfFloat,
  fromHalfFloat: fromHalfFloat
};
var _vector$9 = /*@__PURE__*/new Vector3();
var _vector2$1 = /*@__PURE__*/new Vector2();
var BufferAttribute = exports.BufferAttribute = /*#__PURE__*/function () {
  function BufferAttribute(array, itemSize) {
    var normalized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    _classCallCheck(this, BufferAttribute);
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }
    this.isBufferAttribute = true;
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this._updateRange = {
      offset: 0,
      count: -1
    };
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  return _createClass(BufferAttribute, [{
    key: "onUploadCallback",
    value: function onUploadCallback() {}
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "updateRange",
    get: function get() {
      warnOnce('THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'); // @deprecated, r159
      return this._updateRange;
    }
  }, {
    key: "setUsage",
    value: function setUsage(value) {
      this.usage = value;
      return this;
    }
  }, {
    key: "addUpdateRange",
    value: function addUpdateRange(start, count) {
      this.updateRanges.push({
        start: start,
        count: count
      });
    }
  }, {
    key: "clearUpdateRanges",
    value: function clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      this.gpuType = source.gpuType;
      return this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (var i = 0, l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    }
  }, {
    key: "copyArray",
    value: function copyArray(array) {
      this.array.set(array);
      return this;
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      if (this.itemSize === 2) {
        for (var i = 0, l = this.count; i < l; i++) {
          _vector2$1.fromBufferAttribute(this, i);
          _vector2$1.applyMatrix3(m);
          this.setXY(i, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (var _i11 = 0, _l3 = this.count; _i11 < _l3; _i11++) {
          _vector$9.fromBufferAttribute(this, _i11);
          _vector$9.applyMatrix3(m);
          this.setXYZ(_i11, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix4(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyNormalMatrix(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.transformDirection(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
  }, {
    key: "set",
    value: function set(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Matching BufferAttribute constructor, do not normalize the array.
      this.array.set(value, offset);
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index, component) {
      var value = this.array[index * this.itemSize + component];
      if (this.normalized) value = denormalize(value, this.array);
      return value;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, component, value) {
      if (this.normalized) value = normalize(value, this.array);
      this.array[index * this.itemSize + component] = value;
      return this;
    }
  }, {
    key: "getX",
    value: function getX(index) {
      var x = this.array[index * this.itemSize];
      if (this.normalized) x = denormalize(x, this.array);
      return x;
    }
  }, {
    key: "setX",
    value: function setX(index, x) {
      if (this.normalized) x = normalize(x, this.array);
      this.array[index * this.itemSize] = x;
      return this;
    }
  }, {
    key: "getY",
    value: function getY(index) {
      var y = this.array[index * this.itemSize + 1];
      if (this.normalized) y = denormalize(y, this.array);
      return y;
    }
  }, {
    key: "setY",
    value: function setY(index, y) {
      if (this.normalized) y = normalize(y, this.array);
      this.array[index * this.itemSize + 1] = y;
      return this;
    }
  }, {
    key: "getZ",
    value: function getZ(index) {
      var z = this.array[index * this.itemSize + 2];
      if (this.normalized) z = denormalize(z, this.array);
      return z;
    }
  }, {
    key: "setZ",
    value: function setZ(index, z) {
      if (this.normalized) z = normalize(z, this.array);
      this.array[index * this.itemSize + 2] = z;
      return this;
    }
  }, {
    key: "getW",
    value: function getW(index) {
      var w = this.array[index * this.itemSize + 3];
      if (this.normalized) w = denormalize(w, this.array);
      return w;
    }
  }, {
    key: "setW",
    value: function setW(index, w) {
      if (this.normalized) w = normalize(w, this.array);
      this.array[index * this.itemSize + 3] = w;
      return this;
    }
  }, {
    key: "setXY",
    value: function setXY(index, x, y) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
      }
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(index, x, y, z) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
      }
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(index, x, y, z, w) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
        w = normalize(w, this.array);
      }
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    }
  }, {
    key: "onUpload",
    value: function onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      if (this.name !== '') data.name = this.name;
      if (this.usage !== StaticDrawUsage) data.usage = this.usage;
      return data;
    }
  }]);
}(); //
var Int8BufferAttribute = exports.Int8BufferAttribute = /*#__PURE__*/function (_BufferAttribute) {
  function Int8BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Int8BufferAttribute);
    return _callSuper(this, Int8BufferAttribute, [new Int8Array(array), itemSize, normalized]);
  }
  _inherits(Int8BufferAttribute, _BufferAttribute);
  return _createClass(Int8BufferAttribute);
}(BufferAttribute);
var Uint8BufferAttribute = exports.Uint8BufferAttribute = /*#__PURE__*/function (_BufferAttribute2) {
  function Uint8BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint8BufferAttribute);
    return _callSuper(this, Uint8BufferAttribute, [new Uint8Array(array), itemSize, normalized]);
  }
  _inherits(Uint8BufferAttribute, _BufferAttribute2);
  return _createClass(Uint8BufferAttribute);
}(BufferAttribute);
var Uint8ClampedBufferAttribute = exports.Uint8ClampedBufferAttribute = /*#__PURE__*/function (_BufferAttribute3) {
  function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint8ClampedBufferAttribute);
    return _callSuper(this, Uint8ClampedBufferAttribute, [new Uint8ClampedArray(array), itemSize, normalized]);
  }
  _inherits(Uint8ClampedBufferAttribute, _BufferAttribute3);
  return _createClass(Uint8ClampedBufferAttribute);
}(BufferAttribute);
var Int16BufferAttribute = exports.Int16BufferAttribute = /*#__PURE__*/function (_BufferAttribute4) {
  function Int16BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Int16BufferAttribute);
    return _callSuper(this, Int16BufferAttribute, [new Int16Array(array), itemSize, normalized]);
  }
  _inherits(Int16BufferAttribute, _BufferAttribute4);
  return _createClass(Int16BufferAttribute);
}(BufferAttribute);
var Uint16BufferAttribute = exports.Uint16BufferAttribute = /*#__PURE__*/function (_BufferAttribute5) {
  function Uint16BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint16BufferAttribute);
    return _callSuper(this, Uint16BufferAttribute, [new Uint16Array(array), itemSize, normalized]);
  }
  _inherits(Uint16BufferAttribute, _BufferAttribute5);
  return _createClass(Uint16BufferAttribute);
}(BufferAttribute);
var Int32BufferAttribute = exports.Int32BufferAttribute = /*#__PURE__*/function (_BufferAttribute6) {
  function Int32BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Int32BufferAttribute);
    return _callSuper(this, Int32BufferAttribute, [new Int32Array(array), itemSize, normalized]);
  }
  _inherits(Int32BufferAttribute, _BufferAttribute6);
  return _createClass(Int32BufferAttribute);
}(BufferAttribute);
var Uint32BufferAttribute = exports.Uint32BufferAttribute = /*#__PURE__*/function (_BufferAttribute7) {
  function Uint32BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint32BufferAttribute);
    return _callSuper(this, Uint32BufferAttribute, [new Uint32Array(array), itemSize, normalized]);
  }
  _inherits(Uint32BufferAttribute, _BufferAttribute7);
  return _createClass(Uint32BufferAttribute);
}(BufferAttribute);
var Float16BufferAttribute = exports.Float16BufferAttribute = /*#__PURE__*/function (_BufferAttribute8) {
  function Float16BufferAttribute(array, itemSize, normalized) {
    var _this12;
    _classCallCheck(this, Float16BufferAttribute);
    _this12 = _callSuper(this, Float16BufferAttribute, [new Uint16Array(array), itemSize, normalized]);
    _this12.isFloat16BufferAttribute = true;
    return _this12;
  }
  _inherits(Float16BufferAttribute, _BufferAttribute8);
  return _createClass(Float16BufferAttribute, [{
    key: "getX",
    value: function getX(index) {
      var x = fromHalfFloat(this.array[index * this.itemSize]);
      if (this.normalized) x = denormalize(x, this.array);
      return x;
    }
  }, {
    key: "setX",
    value: function setX(index, x) {
      if (this.normalized) x = normalize(x, this.array);
      this.array[index * this.itemSize] = toHalfFloat(x);
      return this;
    }
  }, {
    key: "getY",
    value: function getY(index) {
      var y = fromHalfFloat(this.array[index * this.itemSize + 1]);
      if (this.normalized) y = denormalize(y, this.array);
      return y;
    }
  }, {
    key: "setY",
    value: function setY(index, y) {
      if (this.normalized) y = normalize(y, this.array);
      this.array[index * this.itemSize + 1] = toHalfFloat(y);
      return this;
    }
  }, {
    key: "getZ",
    value: function getZ(index) {
      var z = fromHalfFloat(this.array[index * this.itemSize + 2]);
      if (this.normalized) z = denormalize(z, this.array);
      return z;
    }
  }, {
    key: "setZ",
    value: function setZ(index, z) {
      if (this.normalized) z = normalize(z, this.array);
      this.array[index * this.itemSize + 2] = toHalfFloat(z);
      return this;
    }
  }, {
    key: "getW",
    value: function getW(index) {
      var w = fromHalfFloat(this.array[index * this.itemSize + 3]);
      if (this.normalized) w = denormalize(w, this.array);
      return w;
    }
  }, {
    key: "setW",
    value: function setW(index, w) {
      if (this.normalized) w = normalize(w, this.array);
      this.array[index * this.itemSize + 3] = toHalfFloat(w);
      return this;
    }
  }, {
    key: "setXY",
    value: function setXY(index, x, y) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
      }
      this.array[index + 0] = toHalfFloat(x);
      this.array[index + 1] = toHalfFloat(y);
      return this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(index, x, y, z) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
      }
      this.array[index + 0] = toHalfFloat(x);
      this.array[index + 1] = toHalfFloat(y);
      this.array[index + 2] = toHalfFloat(z);
      return this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(index, x, y, z, w) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
        w = normalize(w, this.array);
      }
      this.array[index + 0] = toHalfFloat(x);
      this.array[index + 1] = toHalfFloat(y);
      this.array[index + 2] = toHalfFloat(z);
      this.array[index + 3] = toHalfFloat(w);
      return this;
    }
  }]);
}(BufferAttribute);
var Float32BufferAttribute = exports.Float32BufferAttribute = /*#__PURE__*/function (_BufferAttribute9) {
  function Float32BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Float32BufferAttribute);
    return _callSuper(this, Float32BufferAttribute, [new Float32Array(array), itemSize, normalized]);
  }
  _inherits(Float32BufferAttribute, _BufferAttribute9);
  return _createClass(Float32BufferAttribute);
}(BufferAttribute);
var _id$2 = 0;
var _m1$2 = /*@__PURE__*/new Matrix4();
var _obj = /*@__PURE__*/new Object3D();
var _offset = /*@__PURE__*/new Vector3();
var _box$2 = /*@__PURE__*/new Box3();
var _boxMorphTargets = /*@__PURE__*/new Box3();
var _vector$8 = /*@__PURE__*/new Vector3();
var BufferGeometry = exports.BufferGeometry = /*#__PURE__*/function (_EventDispatcher5) {
  function BufferGeometry() {
    var _this13;
    _classCallCheck(this, BufferGeometry);
    _this13 = _callSuper(this, BufferGeometry);
    _this13.isBufferGeometry = true;
    Object.defineProperty(_this13, 'id', {
      value: _id$2++
    });
    _this13.uuid = generateUUID();
    _this13.name = '';
    _this13.type = 'BufferGeometry';
    _this13.index = null;
    _this13.attributes = {};
    _this13.morphAttributes = {};
    _this13.morphTargetsRelative = false;
    _this13.groups = [];
    _this13.boundingBox = null;
    _this13.boundingSphere = null;
    _this13.drawRange = {
      start: 0,
      count: Infinity
    };
    _this13.userData = {};
    return _this13;
  }
  _inherits(BufferGeometry, _EventDispatcher5);
  return _createClass(BufferGeometry, [{
    key: "getIndex",
    value: function getIndex() {
      return this.index;
    }
  }, {
    key: "setIndex",
    value: function setIndex(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
      return this;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return this.attributes[name];
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    }
  }, {
    key: "deleteAttribute",
    value: function deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    }
  }, {
    key: "hasAttribute",
    value: function hasAttribute(name) {
      return this.attributes[name] !== undefined;
    }
  }, {
    key: "addGroup",
    value: function addGroup(start, count) {
      var materialIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.groups.push({
        start: start,
        count: count,
        materialIndex: materialIndex
      });
    }
  }, {
    key: "clearGroups",
    value: function clearGroups() {
      this.groups = [];
    }
  }, {
    key: "setDrawRange",
    value: function setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      var position = this.attributes.position;
      if (position !== undefined) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      var normal = this.attributes.normal;
      if (normal !== undefined) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      var tangent = this.attributes.tangent;
      if (tangent !== undefined) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(q) {
      _m1$2.makeRotationFromQuaternion(q);
      this.applyMatrix4(_m1$2);
      return this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(angle) {
      // rotate geometry around world x-axis

      _m1$2.makeRotationX(angle);
      this.applyMatrix4(_m1$2);
      return this;
    }
  }, {
    key: "rotateY",
    value: function rotateY(angle) {
      // rotate geometry around world y-axis

      _m1$2.makeRotationY(angle);
      this.applyMatrix4(_m1$2);
      return this;
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(angle) {
      // rotate geometry around world z-axis

      _m1$2.makeRotationZ(angle);
      this.applyMatrix4(_m1$2);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(x, y, z) {
      // translate geometry

      _m1$2.makeTranslation(x, y, z);
      this.applyMatrix4(_m1$2);
      return this;
    }
  }, {
    key: "scale",
    value: function scale(x, y, z) {
      // scale geometry

      _m1$2.makeScale(x, y, z);
      this.applyMatrix4(_m1$2);
      return this;
    }
  }, {
    key: "lookAt",
    value: function lookAt(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    }
  }, {
    key: "center",
    value: function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points) {
      var position = [];
      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute('position', new Float32BufferAttribute(position, 3));
      return this;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this);
        this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
        return;
      }
      if (position !== undefined) {
        this.boundingBox.setFromBufferAttribute(position);

        // process morph attributes if present

        if (morphAttributesPosition) {
          for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
            var morphAttribute = morphAttributesPosition[i];
            _box$2.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$2.min);
              this.boundingBox.expandByPoint(_vector$8);
              _vector$8.addVectors(this.boundingBox.max, _box$2.max);
              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$2.min);
              this.boundingBox.expandByPoint(_box$2.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        // first, find the center of the bounding sphere

        var center = this.boundingSphere.center;
        _box$2.setFromBufferAttribute(position);

        // process morph attributes if present

        if (morphAttributesPosition) {
          for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
            var morphAttribute = morphAttributesPosition[i];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
              _box$2.expandByPoint(_vector$8);
              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
              _box$2.expandByPoint(_vector$8);
            } else {
              _box$2.expandByPoint(_boxMorphTargets.min);
              _box$2.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$2.getCenter(center);

        // second, try to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

        var maxRadiusSq = 0;
        for (var _i12 = 0, _il = position.count; _i12 < _il; _i12++) {
          _vector$8.fromBufferAttribute(position, _i12);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        }

        // process morph attributes if present

        if (morphAttributesPosition) {
          for (var _i13 = 0, _il2 = morphAttributesPosition.length; _i13 < _il2; _i13++) {
            var _morphAttribute = morphAttributesPosition[_i13];
            var morphTargetsRelative = this.morphTargetsRelative;
            for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {
              _vector$8.fromBufferAttribute(_morphAttribute, j);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);
                _vector$8.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }
  }, {
    key: "computeTangents",
    value: function computeTangents() {
      var index = this.index;
      var attributes = this.attributes;

      // based on http://www.terathon.com/code/tangent.html
      // (per vertex tangents)

      if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
        console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
        return;
      }
      var positionAttribute = attributes.position;
      var normalAttribute = attributes.normal;
      var uvAttribute = attributes.uv;
      if (this.hasAttribute('tangent') === false) {
        this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
      }
      var tangentAttribute = this.getAttribute('tangent');
      var tan1 = [],
        tan2 = [];
      for (var i = 0; i < positionAttribute.count; i++) {
        tan1[i] = new Vector3();
        tan2[i] = new Vector3();
      }
      var vA = new Vector3(),
        vB = new Vector3(),
        vC = new Vector3(),
        uvA = new Vector2(),
        uvB = new Vector2(),
        uvC = new Vector2(),
        sdir = new Vector3(),
        tdir = new Vector3();
      function handleTriangle(a, b, c) {
        vA.fromBufferAttribute(positionAttribute, a);
        vB.fromBufferAttribute(positionAttribute, b);
        vC.fromBufferAttribute(positionAttribute, c);
        uvA.fromBufferAttribute(uvAttribute, a);
        uvB.fromBufferAttribute(uvAttribute, b);
        uvC.fromBufferAttribute(uvAttribute, c);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

        // silently ignore degenerate uv triangles having coincident or colinear vertices

        if (!isFinite(r)) return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
        tan1[a].add(sdir);
        tan1[b].add(sdir);
        tan1[c].add(sdir);
        tan2[a].add(tdir);
        tan2[b].add(tdir);
        tan2[c].add(tdir);
      }
      var groups = this.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: index.count
        }];
      }
      for (var _i14 = 0, il = groups.length; _i14 < il; ++_i14) {
        var group = groups[_i14];
        var start = group.start;
        var count = group.count;
        for (var j = start, jl = start + count; j < jl; j += 3) {
          handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));
        }
      }
      var tmp = new Vector3(),
        tmp2 = new Vector3();
      var n = new Vector3(),
        n2 = new Vector3();
      function handleVertex(v) {
        n.fromBufferAttribute(normalAttribute, v);
        n2.copy(n);
        var t = tan1[v];

        // Gram-Schmidt orthogonalize

        tmp.copy(t);
        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

        // Calculate handedness

        tmp2.crossVectors(n2, t);
        var test = tmp2.dot(tan2[v]);
        var w = test < 0.0 ? -1.0 : 1.0;
        tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
      }
      for (var _i15 = 0, _il3 = groups.length; _i15 < _il3; ++_i15) {
        var _group = groups[_i15];
        var _start2 = _group.start;
        var _count = _group.count;
        for (var _j = _start2, _jl = _start2 + _count; _j < _jl; _j += 3) {
          handleVertex(index.getX(_j + 0));
          handleVertex(index.getX(_j + 1));
          handleVertex(index.getX(_j + 2));
        }
      }
    }
  }, {
    key: "computeVertexNormals",
    value: function computeVertexNormals() {
      var index = this.index;
      var positionAttribute = this.getAttribute('position');
      if (positionAttribute !== undefined) {
        var normalAttribute = this.getAttribute('normal');
        if (normalAttribute === undefined) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute('normal', normalAttribute);
        } else {
          // reset existing normals to zero

          for (var i = 0, il = normalAttribute.count; i < il; i++) {
            normalAttribute.setXYZ(i, 0, 0, 0);
          }
        }
        var pA = new Vector3(),
          pB = new Vector3(),
          pC = new Vector3();
        var nA = new Vector3(),
          nB = new Vector3(),
          nC = new Vector3();
        var cb = new Vector3(),
          ab = new Vector3();

        // indexed elements

        if (index) {
          for (var _i16 = 0, _il4 = index.count; _i16 < _il4; _i16 += 3) {
            var vA = index.getX(_i16 + 0);
            var vB = index.getX(_i16 + 1);
            var vC = index.getX(_i16 + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          // non-indexed elements (unconnected triangle soup)

          for (var _i17 = 0, _il5 = positionAttribute.count; _i17 < _il5; _i17 += 3) {
            pA.fromBufferAttribute(positionAttribute, _i17 + 0);
            pB.fromBufferAttribute(positionAttribute, _i17 + 1);
            pC.fromBufferAttribute(positionAttribute, _i17 + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(_i17 + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(_i17 + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(_i17 + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    }
  }, {
    key: "normalizeNormals",
    value: function normalizeNormals() {
      var normals = this.attributes.normal;
      for (var i = 0, il = normals.count; i < il; i++) {
        _vector$8.fromBufferAttribute(normals, i);
        _vector$8.normalize();
        normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
  }, {
    key: "toNonIndexed",
    value: function toNonIndexed() {
      function convertBufferAttribute(attribute, indices) {
        var array = attribute.array;
        var itemSize = attribute.itemSize;
        var normalized = attribute.normalized;
        var array2 = new array.constructor(indices.length * itemSize);
        var index = 0,
          index2 = 0;
        for (var i = 0, l = indices.length; i < l; i++) {
          if (attribute.isInterleavedBufferAttribute) {
            index = indices[i] * attribute.data.stride + attribute.offset;
          } else {
            index = indices[i] * itemSize;
          }
          for (var j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }

      //

      if (this.index === null) {
        console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
        return this;
      }
      var geometry2 = new BufferGeometry();
      var indices = this.index.array;
      var attributes = this.attributes;

      // attributes

      for (var name in attributes) {
        var attribute = attributes[name];
        var newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }

      // morph attributes

      var morphAttributes = this.morphAttributes;
      for (var _name in morphAttributes) {
        var morphArray = [];
        var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes

        for (var i = 0, il = morphAttribute.length; i < il; i++) {
          var _attribute = morphAttribute[i];
          var _newAttribute = convertBufferAttribute(_attribute, indices);
          morphArray.push(_newAttribute);
        }
        geometry2.morphAttributes[_name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;

      // groups

      var groups = this.groups;
      for (var _i18 = 0, l = groups.length; _i18 < l; _i18++) {
        var group = groups[_i18];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        metadata: {
          version: 4.6,
          type: 'BufferGeometry',
          generator: 'BufferGeometry.toJSON'
        }
      };

      // standard BufferGeometry serialization

      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '') data.name = this.name;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;
      if (this.parameters !== undefined) {
        var parameters = this.parameters;
        for (var key in parameters) {
          if (parameters[key] !== undefined) data[key] = parameters[key];
        }
        return data;
      }

      // for simplicity the code assumes attributes are not shared across geometries, see #15811

      data.data = {
        attributes: {}
      };
      var index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      var attributes = this.attributes;
      for (var _key in attributes) {
        var attribute = attributes[_key];
        data.data.attributes[_key] = attribute.toJSON(data.data);
      }
      var morphAttributes = {};
      var hasMorphAttributes = false;
      for (var _key2 in this.morphAttributes) {
        var attributeArray = this.morphAttributes[_key2];
        var array = [];
        for (var i = 0, il = attributeArray.length; i < il; i++) {
          var _attribute2 = attributeArray[i];
          array.push(_attribute2.toJSON(data.data));
        }
        if (array.length > 0) {
          morphAttributes[_key2] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      var groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      var boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      // reset

      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;

      // used for storing cloned, shared data

      var data = {};

      // name

      this.name = source.name;

      // index

      var index = source.index;
      if (index !== null) {
        this.setIndex(index.clone(data));
      }

      // attributes

      var attributes = source.attributes;
      for (var name in attributes) {
        var attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }

      // morph attributes

      var morphAttributes = source.morphAttributes;
      for (var _name2 in morphAttributes) {
        var array = [];
        var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes

        for (var i = 0, l = morphAttribute.length; i < l; i++) {
          array.push(morphAttribute[i].clone(data));
        }
        this.morphAttributes[_name2] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;

      // groups

      var groups = source.groups;
      for (var _i19 = 0, _l4 = groups.length; _i19 < _l4; _i19++) {
        var group = groups[_i19];
        this.addGroup(group.start, group.count, group.materialIndex);
      }

      // bounding box

      var boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }

      // bounding sphere

      var boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }

      // draw range

      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;

      // user data

      this.userData = source.userData;
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }]);
}(EventDispatcher);
var _inverseMatrix$3 = /*@__PURE__*/new Matrix4();
var _ray$3 = /*@__PURE__*/new Ray();
var _sphere$6 = /*@__PURE__*/new Sphere();
var _sphereHitAt = /*@__PURE__*/new Vector3();
var _vA$1 = /*@__PURE__*/new Vector3();
var _vB$1 = /*@__PURE__*/new Vector3();
var _vC$1 = /*@__PURE__*/new Vector3();
var _tempA = /*@__PURE__*/new Vector3();
var _morphA = /*@__PURE__*/new Vector3();
var _uvA$1 = /*@__PURE__*/new Vector2();
var _uvB$1 = /*@__PURE__*/new Vector2();
var _uvC$1 = /*@__PURE__*/new Vector2();
var _normalA = /*@__PURE__*/new Vector3();
var _normalB = /*@__PURE__*/new Vector3();
var _normalC = /*@__PURE__*/new Vector3();
var _intersectionPoint = /*@__PURE__*/new Vector3();
var _intersectionPointWorld = /*@__PURE__*/new Vector3();
var Mesh = exports.Mesh = /*#__PURE__*/function (_Object3D) {
  function Mesh() {
    var _this14;
    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MeshBasicMaterial();
    _classCallCheck(this, Mesh);
    _this14 = _callSuper(this, Mesh);
    _this14.isMesh = true;
    _this14.type = 'Mesh';
    _this14.geometry = geometry;
    _this14.material = material;
    _this14.updateMorphTargets();
    return _this14;
  }
  _inherits(Mesh, _Object3D);
  return _createClass(Mesh, [{
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(Mesh, "copy", this, 3)([source, recursive]);
      if (source.morphTargetInfluences !== undefined) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== undefined) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
      this.geometry = source.geometry;
      return this;
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var geometry = this.geometry;
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
            var name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    }
  }, {
    key: "getVertexPosition",
    value: function getVertexPosition(index, target) {
      var geometry = this.geometry;
      var position = geometry.attributes.position;
      var morphPosition = geometry.morphAttributes.position;
      var morphTargetsRelative = geometry.morphTargetsRelative;
      target.fromBufferAttribute(position, index);
      var morphInfluences = this.morphTargetInfluences;
      if (morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        for (var i = 0, il = morphPosition.length; i < il; i++) {
          var influence = morphInfluences[i];
          var morphAttribute = morphPosition[i];
          if (influence === 0) continue;
          _tempA.fromBufferAttribute(morphAttribute, index);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(target), influence);
          }
        }
        target.add(_morphA);
      }
      return target;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === undefined) return;

      // test with bounding sphere in world space

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$6.copy(geometry.boundingSphere);
      _sphere$6.applyMatrix4(matrixWorld);

      // check distance from ray origin to bounding sphere

      _ray$3.copy(raycaster.ray).recast(raycaster.near);
      if (_sphere$6.containsPoint(_ray$3.origin) === false) {
        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > Math.pow(raycaster.far - raycaster.near, 2)) return;
      }

      // convert ray to local space of mesh

      _inverseMatrix$3.copy(matrixWorld).invert();
      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);

      // test with bounding box in local space

      if (geometry.boundingBox !== null) {
        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
      }

      // test for intersections with geometry

      this._computeIntersections(raycaster, intersects, _ray$3);
    }
  }, {
    key: "_computeIntersections",
    value: function _computeIntersections(raycaster, intersects, rayLocalSpace) {
      var intersection;
      var geometry = this.geometry;
      var material = this.material;
      var index = geometry.index;
      var position = geometry.attributes.position;
      var uv = geometry.attributes.uv;
      var uv1 = geometry.attributes.uv1;
      var normal = geometry.attributes.normal;
      var groups = geometry.groups;
      var drawRange = geometry.drawRange;
      if (index !== null) {
        // indexed buffer geometry

        if (Array.isArray(material)) {
          for (var i = 0, il = groups.length; i < il; i++) {
            var group = groups[i];
            var groupMaterial = material[group.materialIndex];
            var start = Math.max(group.start, drawRange.start);
            var end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (var j = start, jl = end; j < jl; j += 3) {
              var a = index.getX(j);
              var b = index.getX(j + 1);
              var c = index.getX(j + 2);
              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          var _start3 = Math.max(0, drawRange.start);
          var _end2 = Math.min(index.count, drawRange.start + drawRange.count);
          for (var _i20 = _start3, _il6 = _end2; _i20 < _il6; _i20 += 3) {
            var _a = index.getX(_i20);
            var _b = index.getX(_i20 + 1);
            var _c = index.getX(_i20 + 2);
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, _a, _b, _c);
            if (intersection) {
              intersection.faceIndex = Math.floor(_i20 / 3); // triangle number in indexed buffer semantics
              intersects.push(intersection);
            }
          }
        }
      } else if (position !== undefined) {
        // non-indexed buffer geometry

        if (Array.isArray(material)) {
          for (var _i21 = 0, _il7 = groups.length; _i21 < _il7; _i21++) {
            var _group2 = groups[_i21];
            var _groupMaterial = material[_group2.materialIndex];
            var _start4 = Math.max(_group2.start, drawRange.start);
            var _end3 = Math.min(position.count, Math.min(_group2.start + _group2.count, drawRange.start + drawRange.count));
            for (var _j2 = _start4, _jl2 = _end3; _j2 < _jl2; _j2 += 3) {
              var _a2 = _j2;
              var _b2 = _j2 + 1;
              var _c2 = _j2 + 2;
              intersection = checkGeometryIntersection(this, _groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, _a2, _b2, _c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(_j2 / 3); // triangle number in non-indexed buffer semantics
                intersection.face.materialIndex = _group2.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          var _start5 = Math.max(0, drawRange.start);
          var _end4 = Math.min(position.count, drawRange.start + drawRange.count);
          for (var _i22 = _start5, _il8 = _end4; _i22 < _il8; _i22 += 3) {
            var _a3 = _i22;
            var _b3 = _i22 + 1;
            var _c3 = _i22 + 2;
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, _a3, _b3, _c3);
            if (intersection) {
              intersection.faceIndex = Math.floor(_i22 / 3); // triangle number in non-indexed buffer semantics
              intersects.push(intersection);
            }
          }
        }
      }
    }
  }]);
}(Object3D);
function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
  var intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
  }
  if (intersect === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance: distance,
    point: _intersectionPointWorld.clone(),
    object: object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c, _vC$1);
  var intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b);
      _uvC$1.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv1) {
      _uvA$1.fromBufferAttribute(uv1, a);
      _uvB$1.fromBufferAttribute(uv1, b);
      _uvC$1.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    var face = {
      a: a,
      b: b,
      c: c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
var BoxGeometry = exports.BoxGeometry = /*#__PURE__*/function (_BufferGeometry) {
  function BoxGeometry() {
    var _this15;
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var widthSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var depthSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    _classCallCheck(this, BoxGeometry);
    _this15 = _callSuper(this, BoxGeometry);
    _this15.type = 'BoxGeometry';
    _this15.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    var scope = _this15;

    // segments

    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var numberOfVertices = 0;
    var groupStart = 0;

    // build each side of the box geometry

    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

    // build geometry

    _this15.setIndex(indices);
    _this15.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this15.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this15.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
      var segmentWidth = width / gridX;
      var segmentHeight = height / gridY;
      var widthHalf = width / 2;
      var heightHalf = height / 2;
      var depthHalf = depth / 2;
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var vertexCounter = 0;
      var groupCount = 0;
      var vector = new Vector3();

      // generate vertices, normals and uvs

      for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segmentHeight - heightHalf;
        for (var ix = 0; ix < gridX1; ix++) {
          var x = ix * segmentWidth - widthHalf;

          // set values to correct vector component

          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;

          // now apply vector to vertex buffer

          vertices.push(vector.x, vector.y, vector.z);

          // set values to correct vector component

          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth > 0 ? 1 : -1;

          // now apply vector to normal buffer

          normals.push(vector.x, vector.y, vector.z);

          // uvs

          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);

          // counters

          vertexCounter += 1;
        }
      }

      // indices

      // 1. you need three indices to draw a single face
      // 2. a single segment consists of two faces
      // 3. so we need to generate six (2*3) indices per segment

      for (var _iy = 0; _iy < gridY; _iy++) {
        for (var _ix = 0; _ix < gridX; _ix++) {
          var a = numberOfVertices + _ix + gridX1 * _iy;
          var b = numberOfVertices + _ix + gridX1 * (_iy + 1);
          var c = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);
          var d = numberOfVertices + (_ix + 1) + gridX1 * _iy;

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);

          // increase counter

          groupCount += 6;
        }
      }

      // add a group to the geometry. this will ensure multi material support

      scope.addGroup(groupStart, groupCount, materialIndex);

      // calculate new start value for groups

      groupStart += groupCount;

      // update total number of vertices

      numberOfVertices += vertexCounter;
    }
    return _this15;
  }
  _inherits(BoxGeometry, _BufferGeometry);
  return _createClass(BoxGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(BoxGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
  }]);
}(BufferGeometry);
/**
 * Uniform Utilities
 */
function cloneUniforms(src) {
  var dst = {};
  for (var u in src) {
    dst[u] = {};
    for (var p in src[u]) {
      var property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().');
          dst[u][p] = null;
        } else {
          dst[u][p] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  var merged = {};
  for (var u = 0; u < uniforms.length; u++) {
    var _tmp = cloneUniforms(uniforms[u]);
    for (var p in _tmp) {
      merged[p] = _tmp[p];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  var dst = [];
  for (var u = 0; u < src.length; u++) {
    dst.push(src[u].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  var currentRenderTarget = renderer.getRenderTarget();
  if (currentRenderTarget === null) {
    // https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
    return renderer.outputColorSpace;
  }

  // https://github.com/mrdoob/three.js/issues/27868
  if (currentRenderTarget.isXRRenderTarget === true) {
    return currentRenderTarget.texture.colorSpace;
  }
  return ColorManagement.workingColorSpace;
}

// Legacy

var UniformsUtils = exports.UniformsUtils = {
  clone: cloneUniforms,
  merge: mergeUniforms
};
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
var ShaderMaterial = exports.ShaderMaterial = /*#__PURE__*/function (_Material2) {
  function ShaderMaterial(parameters) {
    var _this16;
    _classCallCheck(this, ShaderMaterial);
    _this16 = _callSuper(this, ShaderMaterial);
    _this16.isShaderMaterial = true;
    _this16.type = 'ShaderMaterial';
    _this16.defines = {};
    _this16.uniforms = {};
    _this16.uniformsGroups = [];
    _this16.vertexShader = default_vertex;
    _this16.fragmentShader = default_fragment;
    _this16.linewidth = 1;
    _this16.wireframe = false;
    _this16.wireframeLinewidth = 1;
    _this16.fog = false; // set to use scene fog
    _this16.lights = false; // set to use scene lights
    _this16.clipping = false; // set to use user-defined clipping planes

    _this16.forceSinglePass = true;
    _this16.extensions = {
      clipCullDistance: false,
      // set to use vertex shader clipping
      multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
    };

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    _this16.defaultAttributeValues = {
      'color': [1, 1, 1],
      'uv': [0, 0],
      'uv1': [0, 0]
    };
    _this16.index0AttributeName = undefined;
    _this16.uniformsNeedUpdate = false;
    _this16.glslVersion = null;
    if (parameters !== undefined) {
      _this16.setValues(parameters);
    }
    return _this16;
  }
  _inherits(ShaderMaterial, _Material2);
  return _createClass(ShaderMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(ShaderMaterial, "copy", this, 3)([source]);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.fog = source.fog;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _superPropGet(ShaderMaterial, "toJSON", this, 3)([meta]);
      data.glslVersion = this.glslVersion;
      data.uniforms = {};
      for (var name in this.uniforms) {
        var uniform = this.uniforms[name];
        var value = uniform.value;
        if (value && value.isTexture) {
          data.uniforms[name] = {
            type: 't',
            value: value.toJSON(meta).uuid
          };
        } else if (value && value.isColor) {
          data.uniforms[name] = {
            type: 'c',
            value: value.getHex()
          };
        } else if (value && value.isVector2) {
          data.uniforms[name] = {
            type: 'v2',
            value: value.toArray()
          };
        } else if (value && value.isVector3) {
          data.uniforms[name] = {
            type: 'v3',
            value: value.toArray()
          };
        } else if (value && value.isVector4) {
          data.uniforms[name] = {
            type: 'v4',
            value: value.toArray()
          };
        } else if (value && value.isMatrix3) {
          data.uniforms[name] = {
            type: 'm3',
            value: value.toArray()
          };
        } else if (value && value.isMatrix4) {
          data.uniforms[name] = {
            type: 'm4',
            value: value.toArray()
          };
        } else {
          data.uniforms[name] = {
            value: value
          };

          // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
        }
      }
      if (Object.keys(this.defines).length > 0) data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      data.lights = this.lights;
      data.clipping = this.clipping;
      var extensions = {};
      for (var key in this.extensions) {
        if (this.extensions[key] === true) extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0) data.extensions = extensions;
      return data;
    }
  }]);
}(Material);
var Camera = exports.Camera = /*#__PURE__*/function (_Object3D2) {
  function Camera() {
    var _this17;
    _classCallCheck(this, Camera);
    _this17 = _callSuper(this, Camera);
    _this17.isCamera = true;
    _this17.type = 'Camera';
    _this17.matrixWorldInverse = new Matrix4();
    _this17.projectionMatrix = new Matrix4();
    _this17.projectionMatrixInverse = new Matrix4();
    _this17.coordinateSystem = WebGLCoordinateSystem;
    return _this17;
  }
  _inherits(Camera, _Object3D2);
  return _createClass(Camera, [{
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(Camera, "copy", this, 3)([source, recursive]);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      this.coordinateSystem = source.coordinateSystem;
      return this;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(target) {
      return _superPropGet(Camera, "getWorldDirection", this, 3)([target]).negate();
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      _superPropGet(Camera, "updateMatrixWorld", this, 3)([force]);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(updateParents, updateChildren) {
      _superPropGet(Camera, "updateWorldMatrix", this, 3)([updateParents, updateChildren]);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}(Object3D);
var _v3$1 = /*@__PURE__*/new Vector3();
var _minTarget = /*@__PURE__*/new Vector2();
var _maxTarget = /*@__PURE__*/new Vector2();
var PerspectiveCamera = exports.PerspectiveCamera = /*#__PURE__*/function (_Camera) {
  function PerspectiveCamera() {
    var _this18;
    var fov = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
    var aspect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
    var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2000;
    _classCallCheck(this, PerspectiveCamera);
    _this18 = _callSuper(this, PerspectiveCamera);
    _this18.isPerspectiveCamera = true;
    _this18.type = 'PerspectiveCamera';
    _this18.fov = fov;
    _this18.zoom = 1;
    _this18.near = near;
    _this18.far = far;
    _this18.focus = 10;
    _this18.aspect = aspect;
    _this18.view = null;
    _this18.filmGauge = 35; // width of the film (default in millimeters)
    _this18.filmOffset = 0; // horizontal film offset (same unit as gauge)

    _this18.updateProjectionMatrix();
    return _this18;
  }
  _inherits(PerspectiveCamera, _Camera);
  return _createClass(PerspectiveCamera, [{
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(PerspectiveCamera, "copy", this, 3)([source, recursive]);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    }

    /**
     * Sets the FOV by focal length in respect to the current .filmGauge.
     *
     * The default film gauge is 35, so that the focal length can be specified for
     * a 35mm (full frame) camera.
     *
     * Values for focal length and film gauge must have the same unit.
     */
  }, {
    key: "setFocalLength",
    value: function setFocalLength(focalLength) {
      /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
      var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    }

    /**
     * Calculates the focal length from the current .fov and .filmGauge.
     */
  }, {
    key: "getFocalLength",
    value: function getFocalLength() {
      var vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
  }, {
    key: "getEffectiveFOV",
    value: function getEffectiveFOV() {
      return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
    }
  }, {
    key: "getFilmWidth",
    value: function getFilmWidth() {
      // film not completely covered in portrait format (aspect < 1)
      return this.filmGauge * Math.min(this.aspect, 1);
    }
  }, {
    key: "getFilmHeight",
    value: function getFilmHeight() {
      // film not completely covered in landscape format (aspect > 1)
      return this.filmGauge / Math.max(this.aspect, 1);
    }

    /**
     * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
     * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
     */
  }, {
    key: "getViewBounds",
    value: function getViewBounds(distance, minTarget, maxTarget) {
      _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
      minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
      _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
      maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
    }

    /**
     * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
     * Copies the result into the target Vector2, where x is width and y is height.
     */
  }, {
    key: "getViewSize",
    value: function getViewSize(distance, target) {
      this.getViewBounds(distance, _minTarget, _maxTarget);
      return target.subVectors(_maxTarget, _minTarget);
    }

    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   const w = 1920;
     *   const h = 1080;
     *   const fullWidth = w * 3;
     *   const fullHeight = h * 2;
     *
     *   --A--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
     *   --B--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
     *   --C--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
     *   --D--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
     *   --E--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
     *   --F--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     */
  }, {
    key: "setViewOffset",
    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
  }, {
    key: "updateProjectionMatrix",
    value: function updateProjectionMatrix() {
      var near = this.near;
      var top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
      var height = 2 * top;
      var width = this.aspect * height;
      var left = -0.5 * width;
      var view = this.view;
      if (this.view !== null && this.view.enabled) {
        var fullWidth = view.fullWidth,
          fullHeight = view.fullHeight;
        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }
      var skew = this.filmOffset;
      if (skew !== 0) left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _superPropGet(PerspectiveCamera, "toJSON", this, 3)([meta]);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null) data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  }]);
}(Camera);
var fov = -90; // negative fov is not an error
var aspect = 1;
var CubeCamera = exports.CubeCamera = /*#__PURE__*/function (_Object3D3) {
  function CubeCamera(near, far, renderTarget) {
    var _this19;
    _classCallCheck(this, CubeCamera);
    _this19 = _callSuper(this, CubeCamera);
    _this19.type = 'CubeCamera';
    _this19.renderTarget = renderTarget;
    _this19.coordinateSystem = null;
    _this19.activeMipmapLevel = 0;
    var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = _this19.layers;
    _this19.add(cameraPX);
    var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = _this19.layers;
    _this19.add(cameraNX);
    var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = _this19.layers;
    _this19.add(cameraPY);
    var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = _this19.layers;
    _this19.add(cameraNY);
    var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = _this19.layers;
    _this19.add(cameraPZ);
    var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = _this19.layers;
    _this19.add(cameraNZ);
    return _this19;
  }
  _inherits(CubeCamera, _Object3D3);
  return _createClass(CubeCamera, [{
    key: "updateCoordinateSystem",
    value: function updateCoordinateSystem() {
      var coordinateSystem = this.coordinateSystem;
      var cameras = this.children.concat();
      var _cameras = _slicedToArray(cameras, 6),
        cameraPX = _cameras[0],
        cameraNX = _cameras[1],
        cameraPY = _cameras[2],
        cameraNY = _cameras[3],
        cameraPZ = _cameras[4],
        cameraNZ = _cameras[5];
      var _iterator = _createForOfIteratorHelper(cameras),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var camera = _step.value;
          this.remove(camera);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (coordinateSystem === WebGLCoordinateSystem) {
        cameraPX.up.set(0, 1, 0);
        cameraPX.lookAt(1, 0, 0);
        cameraNX.up.set(0, 1, 0);
        cameraNX.lookAt(-1, 0, 0);
        cameraPY.up.set(0, 0, -1);
        cameraPY.lookAt(0, 1, 0);
        cameraNY.up.set(0, 0, 1);
        cameraNY.lookAt(0, -1, 0);
        cameraPZ.up.set(0, 1, 0);
        cameraPZ.lookAt(0, 0, 1);
        cameraNZ.up.set(0, 1, 0);
        cameraNZ.lookAt(0, 0, -1);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(-1, 0, 0);
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(1, 0, 0);
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(0, 1, 0);
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(0, -1, 0);
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(0, 0, 1);
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(0, 0, -1);
      } else {
        throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem);
      }
      var _iterator2 = _createForOfIteratorHelper(cameras),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _camera2 = _step2.value;
          this.add(_camera2);
          _camera2.updateMatrixWorld();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "update",
    value: function update(renderer, scene) {
      if (this.parent === null) this.updateMatrixWorld();
      var renderTarget = this.renderTarget,
        activeMipmapLevel = this.activeMipmapLevel;
      if (this.coordinateSystem !== renderer.coordinateSystem) {
        this.coordinateSystem = renderer.coordinateSystem;
        this.updateCoordinateSystem();
      }
      var _this$children = _slicedToArray(this.children, 6),
        cameraPX = _this$children[0],
        cameraNX = _this$children[1],
        cameraPY = _this$children[2],
        cameraNY = _this$children[3],
        cameraPZ = _this$children[4],
        cameraNZ = _this$children[5];
      var currentRenderTarget = renderer.getRenderTarget();
      var currentActiveCubeFace = renderer.getActiveCubeFace();
      var currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
      var currentXrEnabled = renderer.xr.enabled;
      renderer.xr.enabled = false;
      var generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
      renderer.render(scene, cameraPX);
      renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
      renderer.render(scene, cameraNX);
      renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
      renderer.render(scene, cameraPY);
      renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
      renderer.render(scene, cameraNY);
      renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
      renderer.render(scene, cameraPZ);

      // mipmaps are generated during the last call of render()
      // at this point, all sides of the cube render target are defined

      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
      renderer.render(scene, cameraNZ);
      renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
      renderer.xr.enabled = currentXrEnabled;
      renderTarget.texture.needsPMREMUpdate = true;
    }
  }]);
}(Object3D);
var CubeTexture = exports.CubeTexture = /*#__PURE__*/function (_Texture3) {
  function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    var _this20;
    _classCallCheck(this, CubeTexture);
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    _this20 = _callSuper(this, CubeTexture, [images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace]);
    _this20.isCubeTexture = true;
    _this20.flipY = false;
    return _this20;
  }
  _inherits(CubeTexture, _Texture3);
  return _createClass(CubeTexture, [{
    key: "images",
    get: function get() {
      return this.image;
    },
    set: function set(value) {
      this.image = value;
    }
  }]);
}(Texture);
var WebGLCubeRenderTarget = exports.WebGLCubeRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget3) {
  function WebGLCubeRenderTarget() {
    var _this21;
    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, WebGLCubeRenderTarget);
    _this21 = _callSuper(this, WebGLCubeRenderTarget, [size, size, options]);
    _this21.isWebGLCubeRenderTarget = true;
    var image = {
      width: size,
      height: size,
      depth: 1
    };
    var images = [image, image, image, image, image, image];
    _this21.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);

    // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

    _this21.texture.isRenderTargetTexture = true;
    _this21.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    _this21.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    return _this21;
  }
  _inherits(WebGLCubeRenderTarget, _WebGLRenderTarget3);
  return _createClass(WebGLCubeRenderTarget, [{
    key: "fromEquirectangularTexture",
    value: function fromEquirectangularTexture(renderer, texture) {
      this.texture.type = texture.type;
      this.texture.colorSpace = texture.colorSpace;
      this.texture.generateMipmaps = texture.generateMipmaps;
      this.texture.minFilter = texture.minFilter;
      this.texture.magFilter = texture.magFilter;
      var shader = {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: /* glsl */"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        fragmentShader: /* glsl */"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
      };
      var geometry = new BoxGeometry(5, 5, 5);
      var material = new ShaderMaterial({
        name: 'CubemapFromEquirect',
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material.uniforms.tEquirect.value = texture;
      var mesh = new Mesh(geometry, material);
      var currentMinFilter = texture.minFilter;

      // Avoid blurred poles
      if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
      var camera = new CubeCamera(1, 10, this);
      camera.update(renderer, mesh);
      texture.minFilter = currentMinFilter;
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    }
  }, {
    key: "clear",
    value: function clear(renderer, color, depth, stencil) {
      var currentRenderTarget = renderer.getRenderTarget();
      for (var i = 0; i < 6; i++) {
        renderer.setRenderTarget(this, i);
        renderer.clear(color, depth, stencil);
      }
      renderer.setRenderTarget(currentRenderTarget);
    }
  }]);
}(WebGLRenderTarget);
var _vector1 = /*@__PURE__*/new Vector3();
var _vector2 = /*@__PURE__*/new Vector3();
var _normalMatrix = /*@__PURE__*/new Matrix3();
var Plane = exports.Plane = /*#__PURE__*/function () {
  function Plane() {
    var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);
    var constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, Plane);
    this.isPlane = true;

    // normal is assumed to be normalized

    this.normal = normal;
    this.constant = constant;
  }
  return _createClass(Plane, [{
    key: "set",
    value: function set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
  }, {
    key: "setComponents",
    value: function setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    }
  }, {
    key: "setFromNormalAndCoplanarPoint",
    value: function setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
  }, {
    key: "setFromCoplanarPoints",
    value: function setFromCoplanarPoints(a, b, c) {
      var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();

      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
  }, {
    key: "normalize",
    value: function normalize() {
      // Note: will lead to a divide by zero if the plane is invalid.

      var inverseNormalLength = 1.0 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
  }, {
    key: "distanceToSphere",
    value: function distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
  }, {
    key: "projectPoint",
    value: function projectPoint(point, target) {
      return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
    }
  }, {
    key: "intersectLine",
    value: function intersectLine(line, target) {
      var direction = line.delta(_vector1);
      var denominator = this.normal.dot(direction);
      if (denominator === 0) {
        // line is coplanar, return origin
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }

        // Unsure if this is the correct method to handle this case.
        return null;
      }
      var t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return null;
      }
      return target.copy(line.start).addScaledVector(direction, t);
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(line) {
      // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

      var startSign = this.distanceToPoint(line.start);
      var endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return box.intersectsPlane(this);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
  }, {
    key: "coplanarPoint",
    value: function coplanarPoint(target) {
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix, optionalNormalMatrix) {
      var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
      var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var _sphere$5 = /*@__PURE__*/new Sphere();
var _vector$7 = /*@__PURE__*/new Vector3();
var Frustum = exports.Frustum = /*#__PURE__*/function () {
  function Frustum() {
    var p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Plane();
    var p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Plane();
    var p2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Plane();
    var p3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Plane();
    var p4 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Plane();
    var p5 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Plane();
    _classCallCheck(this, Frustum);
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  return _createClass(Frustum, [{
    key: "set",
    value: function set(p0, p1, p2, p3, p4, p5) {
      var planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(frustum) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    }
  }, {
    key: "setFromProjectionMatrix",
    value: function setFromProjectionMatrix(m) {
      var coordinateSystem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WebGLCoordinateSystem;
      var planes = this.planes;
      var me = m.elements;
      var me0 = me[0],
        me1 = me[1],
        me2 = me[2],
        me3 = me[3];
      var me4 = me[4],
        me5 = me[5],
        me6 = me[6],
        me7 = me[7];
      var me8 = me[8],
        me9 = me[9],
        me10 = me[10],
        me11 = me[11];
      var me12 = me[12],
        me13 = me[13],
        me14 = me[14],
        me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      if (coordinateSystem === WebGLCoordinateSystem) {
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        planes[5].setComponents(me2, me6, me10, me14).normalize();
      } else {
        throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem);
      }
      return this;
    }
  }, {
    key: "intersectsObject",
    value: function intersectsObject(object) {
      if (object.boundingSphere !== undefined) {
        if (object.boundingSphere === null) object.computeBoundingSphere();
        _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
      } else {
        var geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      }
      return this.intersectsSphere(_sphere$5);
    }
  }, {
    key: "intersectsSprite",
    value: function intersectsSprite(sprite) {
      _sphere$5.center.set(0, 0, 0);
      _sphere$5.radius = 0.7071067811865476;
      _sphere$5.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(_sphere$5);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      var planes = this.planes;
      var center = sphere.center;
      var negRadius = -sphere.radius;
      for (var i = 0; i < 6; i++) {
        var distance = planes[i].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        var plane = planes[i];

        // corner at max distance

        _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(_vector$7) < 0) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
function WebGLAnimation() {
  var context = null;
  var isAnimating = false;
  var animationLoop = null;
  var requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function start() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function stop() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function setAnimationLoop(callback) {
      animationLoop = callback;
    },
    setContext: function setContext(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl) {
  var buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    var array = attribute.array;
    var usage = attribute.usage;
    var size = array.byteLength;
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    var type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + array);
    }
    return {
      buffer: buffer,
      type: type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
      size: size
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    var array = attribute.array;
    var updateRange = attribute._updateRange; // @deprecated, r159
    var updateRanges = attribute.updateRanges;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1 && updateRanges.length === 0) {
      // Not using update ranges
      gl.bufferSubData(bufferType, 0, array);
    }
    if (updateRanges.length !== 0) {
      for (var i = 0, l = updateRanges.length; i < l; i++) {
        var range = updateRanges[i];
        gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT, array, range.start, range.count);
      }
      attribute.clearUpdateRanges();
    }

    // @deprecated, r159
    if (updateRange.count !== -1) {
      gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      updateRange.count = -1; // reset range
    }
    attribute.onUploadCallback();
  }

  //

  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    if (attribute.isGLBufferAttribute) {
      var cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    var data = buffers.get(attribute);
    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      if (data.size !== attribute.array.byteLength) {
        throw new Error('THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.');
      }
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get: get,
    remove: remove,
    update: update
  };
}
var PlaneGeometry = exports.PlaneGeometry = /*#__PURE__*/function (_BufferGeometry2) {
  function PlaneGeometry() {
    var _this22;
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, PlaneGeometry);
    _this22 = _callSuper(this, PlaneGeometry);
    _this22.type = 'PlaneGeometry';
    _this22.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    var width_half = width / 2;
    var height_half = height / 2;
    var gridX = Math.floor(widthSegments);
    var gridY = Math.floor(heightSegments);
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segment_width = width / gridX;
    var segment_height = height / gridY;

    //

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    for (var iy = 0; iy < gridY1; iy++) {
      var y = iy * segment_height - height_half;
      for (var ix = 0; ix < gridX1; ix++) {
        var x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (var _iy2 = 0; _iy2 < gridY; _iy2++) {
      for (var _ix2 = 0; _ix2 < gridX; _ix2++) {
        var a = _ix2 + gridX1 * _iy2;
        var b = _ix2 + gridX1 * (_iy2 + 1);
        var c = _ix2 + 1 + gridX1 * (_iy2 + 1);
        var d = _ix2 + 1 + gridX1 * _iy2;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    _this22.setIndex(indices);
    _this22.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this22.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this22.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    return _this22;
  }
  _inherits(PlaneGeometry, _BufferGeometry2);
  return _createClass(PlaneGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(PlaneGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
  }]);
}(BufferGeometry);
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var batching_pars_vertex = "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif";
var batching_vertex = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
var vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
var vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";
var ShaderChunk = exports.ShaderChunk = {
  alphahash_fragment: alphahash_fragment,
  alphahash_pars_fragment: alphahash_pars_fragment,
  alphamap_fragment: alphamap_fragment,
  alphamap_pars_fragment: alphamap_pars_fragment,
  alphatest_fragment: alphatest_fragment,
  alphatest_pars_fragment: alphatest_pars_fragment,
  aomap_fragment: aomap_fragment,
  aomap_pars_fragment: aomap_pars_fragment,
  batching_pars_vertex: batching_pars_vertex,
  batching_vertex: batching_vertex,
  begin_vertex: begin_vertex,
  beginnormal_vertex: beginnormal_vertex,
  bsdfs: bsdfs,
  iridescence_fragment: iridescence_fragment,
  bumpmap_pars_fragment: bumpmap_pars_fragment,
  clipping_planes_fragment: clipping_planes_fragment,
  clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  clipping_planes_vertex: clipping_planes_vertex,
  color_fragment: color_fragment,
  color_pars_fragment: color_pars_fragment,
  color_pars_vertex: color_pars_vertex,
  color_vertex: color_vertex,
  common: common,
  cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  defaultnormal_vertex: defaultnormal_vertex,
  displacementmap_pars_vertex: displacementmap_pars_vertex,
  displacementmap_vertex: displacementmap_vertex,
  emissivemap_fragment: emissivemap_fragment,
  emissivemap_pars_fragment: emissivemap_pars_fragment,
  colorspace_fragment: colorspace_fragment,
  colorspace_pars_fragment: colorspace_pars_fragment,
  envmap_fragment: envmap_fragment,
  envmap_common_pars_fragment: envmap_common_pars_fragment,
  envmap_pars_fragment: envmap_pars_fragment,
  envmap_pars_vertex: envmap_pars_vertex,
  envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  envmap_vertex: envmap_vertex,
  fog_vertex: fog_vertex,
  fog_pars_vertex: fog_pars_vertex,
  fog_fragment: fog_fragment,
  fog_pars_fragment: fog_pars_fragment,
  gradientmap_pars_fragment: gradientmap_pars_fragment,
  lightmap_pars_fragment: lightmap_pars_fragment,
  lights_lambert_fragment: lights_lambert_fragment,
  lights_lambert_pars_fragment: lights_lambert_pars_fragment,
  lights_pars_begin: lights_pars_begin,
  lights_toon_fragment: lights_toon_fragment,
  lights_toon_pars_fragment: lights_toon_pars_fragment,
  lights_phong_fragment: lights_phong_fragment,
  lights_phong_pars_fragment: lights_phong_pars_fragment,
  lights_physical_fragment: lights_physical_fragment,
  lights_physical_pars_fragment: lights_physical_pars_fragment,
  lights_fragment_begin: lights_fragment_begin,
  lights_fragment_maps: lights_fragment_maps,
  lights_fragment_end: lights_fragment_end,
  logdepthbuf_fragment: logdepthbuf_fragment,
  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  logdepthbuf_vertex: logdepthbuf_vertex,
  map_fragment: map_fragment,
  map_pars_fragment: map_pars_fragment,
  map_particle_fragment: map_particle_fragment,
  map_particle_pars_fragment: map_particle_pars_fragment,
  metalnessmap_fragment: metalnessmap_fragment,
  metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  morphinstance_vertex: morphinstance_vertex,
  morphcolor_vertex: morphcolor_vertex,
  morphnormal_vertex: morphnormal_vertex,
  morphtarget_pars_vertex: morphtarget_pars_vertex,
  morphtarget_vertex: morphtarget_vertex,
  normal_fragment_begin: normal_fragment_begin,
  normal_fragment_maps: normal_fragment_maps,
  normal_pars_fragment: normal_pars_fragment,
  normal_pars_vertex: normal_pars_vertex,
  normal_vertex: normal_vertex,
  normalmap_pars_fragment: normalmap_pars_fragment,
  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment: clearcoat_pars_fragment,
  iridescence_pars_fragment: iridescence_pars_fragment,
  opaque_fragment: opaque_fragment,
  packing: packing,
  premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  project_vertex: project_vertex,
  dithering_fragment: dithering_fragment,
  dithering_pars_fragment: dithering_pars_fragment,
  roughnessmap_fragment: roughnessmap_fragment,
  roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  shadowmap_pars_fragment: shadowmap_pars_fragment,
  shadowmap_pars_vertex: shadowmap_pars_vertex,
  shadowmap_vertex: shadowmap_vertex,
  shadowmask_pars_fragment: shadowmask_pars_fragment,
  skinbase_vertex: skinbase_vertex,
  skinning_pars_vertex: skinning_pars_vertex,
  skinning_vertex: skinning_vertex,
  skinnormal_vertex: skinnormal_vertex,
  specularmap_fragment: specularmap_fragment,
  specularmap_pars_fragment: specularmap_pars_fragment,
  tonemapping_fragment: tonemapping_fragment,
  tonemapping_pars_fragment: tonemapping_pars_fragment,
  transmission_fragment: transmission_fragment,
  transmission_pars_fragment: transmission_pars_fragment,
  uv_pars_fragment: uv_pars_fragment,
  uv_pars_vertex: uv_pars_vertex,
  uv_vertex: uv_vertex,
  worldpos_vertex: worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib = exports.UniformsLib = {
  common: {
    diffuse: {
      value: /*@__PURE__*/new Color(0xffffff)
    },
    opacity: {
      value: 1.0
    },
    map: {
      value: null
    },
    mapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    alphaMap: {
      value: null
    },
    alphaMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    alphaTest: {
      value: 0
    }
  },
  specularmap: {
    specularMap: {
      value: null
    },
    specularMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    envMapRotation: {
      value: /*@__PURE__*/new Matrix3()
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1.0
    },
    // basic, lambert, phong
    ior: {
      value: 1.5
    },
    // physical
    refractionRatio: {
      value: 0.98
    } // basic, lambert, phong
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    },
    aoMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    },
    lightMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    normalScale: {
      value: /*@__PURE__*/new Vector2(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    },
    emissiveMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    },
    metalnessMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    },
    roughnessMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 0.00025
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2000
    },
    fogColor: {
      value: /*@__PURE__*/new Color(0xffffff)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    lightProbe: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {}
      }
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowIntensity: 1,
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      }
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowIntensity: 1,
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotLightMap: {
      value: []
    },
    spotShadowMap: {
      value: []
    },
    spotLightMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      }
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowIntensity: 1,
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    },
    ltc_1: {
      value: null
    },
    ltc_2: {
      value: null
    }
  },
  points: {
    diffuse: {
      value: /*@__PURE__*/new Color(0xffffff)
    },
    opacity: {
      value: 1.0
    },
    size: {
      value: 1.0
    },
    scale: {
      value: 1.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    alphaMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    alphaTest: {
      value: 0
    },
    uvTransform: {
      value: /*@__PURE__*/new Matrix3()
    }
  },
  sprite: {
    diffuse: {
      value: /*@__PURE__*/new Color(0xffffff)
    },
    opacity: {
      value: 1.0
    },
    center: {
      value: /*@__PURE__*/new Vector2(0.5, 0.5)
    },
    rotation: {
      value: 0.0
    },
    map: {
      value: null
    },
    mapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    alphaMap: {
      value: null
    },
    alphaMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    alphaTest: {
      value: 0
    }
  }
};
var ShaderLib = exports.ShaderLib = {
  basic: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: /*@__PURE__*/new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: /*@__PURE__*/new Color(0x000000)
      },
      specular: {
        value: /*@__PURE__*/new Color(0x111111)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: /*@__PURE__*/new Color(0x000000)
      },
      roughness: {
        value: 1.0
      },
      metalness: {
        value: 0.0
      },
      envMapIntensity: {
        value: 1
      }
    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: /*@__PURE__*/new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.points, UniformsLib.fog]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: /*@__PURE__*/new Matrix3()
      },
      t2D: {
        value: null
      },
      backgroundIntensity: {
        value: 1
      }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: {
        value: null
      },
      flipEnvMap: {
        value: -1
      },
      backgroundBlurriness: {
        value: 0
      },
      backgroundIntensity: {
        value: 1
      },
      backgroundRotation: {
        value: /*@__PURE__*/new Matrix3()
      }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: {
        value: null
      },
      tFlip: {
        value: -1
      },
      opacity: {
        value: 1.0
      }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
      referencePosition: {
        value: /*@__PURE__*/new Vector3()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1000
      }
    }]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: /*@__PURE__*/mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
      color: {
        value: /*@__PURE__*/new Color(0x00000)
      },
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: /*@__PURE__*/mergeUniforms([ShaderLib.standard.uniforms, {
    clearcoat: {
      value: 0
    },
    clearcoatMap: {
      value: null
    },
    clearcoatMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    clearcoatNormalMap: {
      value: null
    },
    clearcoatNormalMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    clearcoatNormalScale: {
      value: /*@__PURE__*/new Vector2(1, 1)
    },
    clearcoatRoughness: {
      value: 0
    },
    clearcoatRoughnessMap: {
      value: null
    },
    clearcoatRoughnessMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    dispersion: {
      value: 0
    },
    iridescence: {
      value: 0
    },
    iridescenceMap: {
      value: null
    },
    iridescenceMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    iridescenceIOR: {
      value: 1.3
    },
    iridescenceThicknessMinimum: {
      value: 100
    },
    iridescenceThicknessMaximum: {
      value: 400
    },
    iridescenceThicknessMap: {
      value: null
    },
    iridescenceThicknessMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    sheen: {
      value: 0
    },
    sheenColor: {
      value: /*@__PURE__*/new Color(0x000000)
    },
    sheenColorMap: {
      value: null
    },
    sheenColorMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    sheenRoughness: {
      value: 1
    },
    sheenRoughnessMap: {
      value: null
    },
    sheenRoughnessMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    transmission: {
      value: 0
    },
    transmissionMap: {
      value: null
    },
    transmissionMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    transmissionSamplerSize: {
      value: /*@__PURE__*/new Vector2()
    },
    transmissionSamplerMap: {
      value: null
    },
    thickness: {
      value: 0
    },
    thicknessMap: {
      value: null
    },
    thicknessMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    attenuationDistance: {
      value: 0
    },
    attenuationColor: {
      value: /*@__PURE__*/new Color(0x000000)
    },
    specularColor: {
      value: /*@__PURE__*/new Color(1, 1, 1)
    },
    specularColorMap: {
      value: null
    },
    specularColorMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    specularIntensity: {
      value: 1
    },
    specularIntensityMap: {
      value: null
    },
    specularIntensityMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    },
    anisotropyVector: {
      value: /*@__PURE__*/new Vector2()
    },
    anisotropyMap: {
      value: null
    },
    anisotropyMapTransform: {
      value: /*@__PURE__*/new Matrix3()
    }
  }]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
var _rgb = {
  r: 0,
  b: 0,
  g: 0
};
var _e1$1 = /*@__PURE__*/new Euler();
var _m1$1 = /*@__PURE__*/new Matrix4();
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  var clearColor = new Color(0x000000);
  var clearAlpha = alpha === true ? 0 : 1;
  var planeMesh;
  var boxMesh;
  var currentBackground = null;
  var currentBackgroundVersion = 0;
  var currentTonemapping = null;
  function getBackground(scene) {
    var background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      var usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    return background;
  }
  function render(scene) {
    var forceClear = false;
    var background = getBackground(scene);
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    var environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === 'additive') {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === 'alpha-blend') {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      // buffers might not be writable which is required to ensure a correct clear

      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
  }
  function addToRenderList(renderList, scene) {
    var background = getBackground(scene);
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === undefined) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: 'BackgroundCubeMaterial',
          uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
          vertexShader: ShaderLib.backgroundCube.vertexShader,
          fragmentShader: ShaderLib.backgroundCube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute('normal');
        boxMesh.geometry.deleteAttribute('uv');
        boxMesh.onBeforeRender = function (renderer, scene, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };

        // add "envMap" material property so the renderer can evaluate it like for built-in materials
        Object.defineProperty(boxMesh.material, 'envMap', {
          get: function get() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      _e1$1.copy(scene.backgroundRotation);

      // accommodate left-handed frame
      _e1$1.x *= -1;
      _e1$1.y *= -1;
      _e1$1.z *= -1;
      if (background.isCubeTexture && background.isRenderTargetTexture === false) {
        // environment maps which are not cube render targets or PMREMs follow a different convention
        _e1$1.y *= -1;
        _e1$1.z *= -1;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
      boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();

      // push to the pre-sorted opaque render list
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === undefined) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: 'BackgroundMaterial',
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute('normal');

        // add "map" material property so the renderer can evaluate it like for built-in materials
        Object.defineProperty(planeMesh.material, 'map', {
          get: function get() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();

      // push to the pre-sorted opaque render list
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function getClearColor() {
      return clearColor;
    },
    setClearColor: function setClearColor(color) {
      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function getClearAlpha() {
      return clearAlpha;
    },
    setClearAlpha: function setClearAlpha(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render,
    addToRenderList: addToRenderList
  };
}
function WebGLBindingStates(gl, attributes) {
  var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  var bindingStates = {};
  var defaultState = createBindingState(null);
  var currentState = defaultState;
  var forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    var updateBuffers = false;
    var state = getBindingState(geometry, program, material);
    if (currentState !== state) {
      currentState = state;
      bindVertexArrayObject(currentState.object);
    }
    updateBuffers = needsUpdate(object, geometry, program, index);
    if (updateBuffers) saveCache(object, geometry, program, index);
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    return gl.createVertexArray();
  }
  function bindVertexArrayObject(vao) {
    return gl.bindVertexArray(vao);
  }
  function deleteVertexArrayObject(vao) {
    return gl.deleteVertexArray(vao);
  }
  function getBindingState(geometry, program, material) {
    var wireframe = material.wireframe === true;
    var programMap = bindingStates[geometry.id];
    if (programMap === undefined) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    var stateMap = programMap[program.id];
    if (stateMap === undefined) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    var state = stateMap[wireframe];
    if (state === undefined) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    var newAttributes = [];
    var enabledAttributes = [];
    var attributeDivisors = [];
    for (var i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes: newAttributes,
      enabledAttributes: enabledAttributes,
      attributeDivisors: attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    var cachedAttributes = currentState.attributes;
    var geometryAttributes = geometry.attributes;
    var attributesNum = 0;
    var programAttributes = program.getAttributes();
    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        var cachedAttribute = cachedAttributes[name];
        var geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === undefined) {
          if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === undefined) return true;
        if (cachedAttribute.attribute !== geometryAttribute) return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    var cache = {};
    var attributes = geometry.attributes;
    var attributesNum = 0;
    var programAttributes = program.getAttributes();
    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        var attribute = attributes[name];
        if (attribute === undefined) {
          if (name === 'instanceMatrix' && object.instanceMatrix) attribute = object.instanceMatrix;
          if (name === 'instanceColor' && object.instanceColor) attribute = object.instanceColor;
        }
        var data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    var newAttributes = currentState.newAttributes;
    for (var i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    var newAttributes = currentState.newAttributes;
    var enabledAttributes = currentState.enabledAttributes;
    var attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      gl.vertexAttribDivisor(attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    var newAttributes = currentState.newAttributes;
    var enabledAttributes = currentState.enabledAttributes;
    for (var i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    initAttributes();
    var geometryAttributes = geometry.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;
    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        var geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === undefined) {
          if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== undefined) {
          var normalized = geometryAttribute.normalized;
          var size = geometryAttribute.itemSize;
          var attribute = attributes.get(geometryAttribute);

          // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          var buffer = attribute.buffer;
          var type = attribute.type;
          var bytesPerElement = attribute.bytesPerElement;

          // check for integer attributes

          var integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (var i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (var _i23 = 0; _i23 < programAttribute.locationSize; _i23++) {
                enableAttribute(programAttribute.location + _i23);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (var _i24 = 0; _i24 < programAttribute.locationSize; _i24++) {
              vertexAttribPointer(programAttribute.location + _i24, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * _i24) * bytesPerElement, integer);
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (var _i25 = 0; _i25 < programAttribute.locationSize; _i25++) {
                enableAttributeAndDivisor(programAttribute.location + _i25, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (var _i26 = 0; _i26 < programAttribute.locationSize; _i26++) {
                enableAttribute(programAttribute.location + _i26);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (var _i27 = 0; _i27 < programAttribute.locationSize; _i27++) {
              vertexAttribPointer(programAttribute.location + _i27, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * _i27 * bytesPerElement, integer);
            }
          }
        } else if (materialDefaultAttributeValues !== undefined) {
          var value = materialDefaultAttributeValues[name];
          if (value !== undefined) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (var geometryId in bindingStates) {
      var programMap = bindingStates[geometryId];
      for (var programId in programMap) {
        var stateMap = programMap[programId];
        for (var wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === undefined) return;
    var programMap = bindingStates[geometry.id];
    for (var programId in programMap) {
      var stateMap = programMap[programId];
      for (var wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (var geometryId in bindingStates) {
      var programMap = bindingStates[geometryId];
      if (programMap[program.id] === undefined) continue;
      var stateMap = programMap[program.id];
      for (var wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }

  // for backward-compatibility

  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup: setup,
    reset: reset,
    resetDefaultState: resetDefaultState,
    dispose: dispose,
    releaseStatesOfGeometry: releaseStatesOfGeometry,
    releaseStatesOfProgram: releaseStatesOfProgram,
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    disableUnusedAttributes: disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info) {
  var mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawArraysInstanced(mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    var extension = extensions.get('WEBGL_multi_draw');
    extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
    var elementCount = 0;
    for (var i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    var extension = extensions.get('WEBGL_multi_draw');
    if (extension === null) {
      for (var i = 0; i < starts.length; i++) {
        renderInstances(starts[i], counts[i], primcount[i]);
      }
    } else {
      extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
      var elementCount = 0;
      for (var _i28 = 0; _i28 < drawCount; _i28++) {
        elementCount += counts[_i28];
      }
      for (var _i29 = 0; _i29 < primcount.length; _i29++) {
        info.update(elementCount, mode, primcount[_i29]);
      }
    }
  }

  //

  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLCapabilities(gl, extensions, parameters, utils) {
  var maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;
    if (extensions.has('EXT_texture_filter_anisotropic') === true) {
      var extension = extensions.get('EXT_texture_filter_anisotropic');
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function textureFormatReadable(textureFormat) {
    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
      return false;
    }
    return true;
  }
  function textureTypeReadable(textureType) {
    var halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || extensions.has('EXT_color_buffer_float'));
    if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) &&
    // Edge and Chrome Mac < 52 (#9513)
    textureType !== FloatType && !halfFloatSupportedByExt) {
      return false;
    }
    return true;
  }
  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return 'highp';
      }
      precision = 'mediump';
    }
    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return 'mediump';
      }
    }
    return 'lowp';
  }
  var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  var maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }
  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  var vertexTextures = maxVertexTextures > 0;
  var maxSamples = gl.getParameter(gl.MAX_SAMPLES);
  return {
    isWebGL2: true,
    // keeping this for backwards compatibility

    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    textureFormatReadable: textureFormatReadable,
    textureTypeReadable: textureTypeReadable,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    maxSamples: maxSamples
  };
}
function WebGLClipping(properties) {
  var scope = this;
  var globalState = null,
    numGlobalPlanes = 0,
    localClippingEnabled = false,
    renderingShadows = false;
  var plane = new Plane(),
    viewNormalMatrix = new Matrix3(),
    uniform = {
      value: null,
      needsUpdate: false
    };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function (planes, enableLocalClipping) {
    var enabled = planes.length !== 0 || enableLocalClipping ||
    // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function () {
    renderingShadows = false;
  };
  this.setGlobalState = function (planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function (material, camera, useCache) {
    var planes = material.clippingPlanes,
      clipIntersection = material.clipIntersection,
      clipShadows = material.clipShadows;
    var materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping

      if (renderingShadows) {
        // there's no global clipping

        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
        lGlobal = nGlobal * 4;
      var dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (var i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0;
    var dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        var flatSize = dstOffset + nPlanes * 4,
          viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  var cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      var mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          var cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          var image = texture.image;
          if (image && image.height > 0) {
            var renderTarget = new WebGLCubeRenderTarget(image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener('dispose', onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            // image not yet ready. try the conversion next frame

            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    var cubemap = cubemaps.get(texture);
    if (cubemap !== undefined) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = new WeakMap();
  }
  return {
    get: get,
    dispose: dispose
  };
}
var OrthographicCamera = exports.OrthographicCamera = /*#__PURE__*/function (_Camera2) {
  function OrthographicCamera() {
    var _this23;
    var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    var right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var bottom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
    var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
    var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2000;
    _classCallCheck(this, OrthographicCamera);
    _this23 = _callSuper(this, OrthographicCamera);
    _this23.isOrthographicCamera = true;
    _this23.type = 'OrthographicCamera';
    _this23.zoom = 1;
    _this23.view = null;
    _this23.left = left;
    _this23.right = right;
    _this23.top = top;
    _this23.bottom = bottom;
    _this23.near = near;
    _this23.far = far;
    _this23.updateProjectionMatrix();
    return _this23;
  }
  _inherits(OrthographicCamera, _Camera2);
  return _createClass(OrthographicCamera, [{
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(OrthographicCamera, "copy", this, 3)([source, recursive]);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    }
  }, {
    key: "setViewOffset",
    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
  }, {
    key: "updateProjectionMatrix",
    value: function updateProjectionMatrix() {
      var dx = (this.right - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.right + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left = cx - dx;
      var right = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;
      if (this.view !== null && this.view.enabled) {
        var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _superPropGet(OrthographicCamera, "toJSON", this, 3)([meta]);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null) data.object.view = Object.assign({}, this.view);
      return data;
    }
  }]);
}(Camera);
var LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
var MAX_SAMPLES = 20;
var _flatCamera = /*@__PURE__*/new OrthographicCamera();
var _clearColor = /*@__PURE__*/new Color();
var _oldTarget = null;
var _oldActiveCubeFace = 0;
var _oldActiveMipmapLevel = 0;
var _oldXrEnabled = false;

// Golden Ratio
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
var _axisDirections = [/*@__PURE__*/new Vector3(-PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, 1)];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/
var PMREMGenerator = exports.PMREMGenerator = /*#__PURE__*/function () {
  function PMREMGenerator(renderer) {
    _classCallCheck(this, PMREMGenerator);
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }

  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  return _createClass(PMREMGenerator, [{
    key: "fromScene",
    value: function fromScene(scene) {
      var sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
      var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
      _oldTarget = this._renderer.getRenderTarget();
      _oldActiveCubeFace = this._renderer.getActiveCubeFace();
      _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
      _oldXrEnabled = this._renderer.xr.enabled;
      this._renderer.xr.enabled = false;
      this._setSize(256);
      var cubeUVRenderTarget = this._allocateTargets();
      cubeUVRenderTarget.depthBuffer = true;
      this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
      if (sigma > 0) {
        this._blur(cubeUVRenderTarget, 0, 0, sigma);
      }
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }

    /**
     * Generates a PMREM from an equirectangular texture, which can be either LDR
     * or HDR. The ideal input image size is 1k (1024 x 512),
     * as this matches best with the 256 x 256 cubemap output.
     * The smallest supported equirectangular image size is 64 x 32.
     */
  }, {
    key: "fromEquirectangular",
    value: function fromEquirectangular(equirectangular) {
      var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this._fromTexture(equirectangular, renderTarget);
    }

    /**
     * Generates a PMREM from an cubemap texture, which can be either LDR
     * or HDR. The ideal input cube size is 256 x 256,
     * as this matches best with the 256 x 256 cubemap output.
     * The smallest supported cube size is 16 x 16.
     */
  }, {
    key: "fromCubemap",
    value: function fromCubemap(cubemap) {
      var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this._fromTexture(cubemap, renderTarget);
    }

    /**
     * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
  }, {
    key: "compileCubemapShader",
    value: function compileCubemapShader() {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
        this._compileMaterial(this._cubemapMaterial);
      }
    }

    /**
     * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
  }, {
    key: "compileEquirectangularShader",
    value: function compileEquirectangularShader() {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
        this._compileMaterial(this._equirectMaterial);
      }
    }

    /**
     * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
     * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
     * one of them will cause any others to also become unusable.
     */
  }, {
    key: "dispose",
    value: function dispose() {
      this._dispose();
      if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
      if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    }

    // private interface
  }, {
    key: "_setSize",
    value: function _setSize(cubeSize) {
      this._lodMax = Math.floor(Math.log2(cubeSize));
      this._cubeSize = Math.pow(2, this._lodMax);
    }
  }, {
    key: "_dispose",
    value: function _dispose() {
      if (this._blurMaterial !== null) this._blurMaterial.dispose();
      if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
      for (var i = 0; i < this._lodPlanes.length; i++) {
        this._lodPlanes[i].dispose();
      }
    }
  }, {
    key: "_cleanup",
    value: function _cleanup(outputTarget) {
      this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
      this._renderer.xr.enabled = _oldXrEnabled;
      outputTarget.scissorTest = false;
      _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
  }, {
    key: "_fromTexture",
    value: function _fromTexture(texture, renderTarget) {
      if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
        this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
      } else {
        // Equirectangular

        this._setSize(texture.image.width / 4);
      }
      _oldTarget = this._renderer.getRenderTarget();
      _oldActiveCubeFace = this._renderer.getActiveCubeFace();
      _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
      _oldXrEnabled = this._renderer.xr.enabled;
      this._renderer.xr.enabled = false;
      var cubeUVRenderTarget = renderTarget || this._allocateTargets();
      this._textureToCubeUV(texture, cubeUVRenderTarget);
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
  }, {
    key: "_allocateTargets",
    value: function _allocateTargets() {
      var width = 3 * Math.max(this._cubeSize, 16 * 7);
      var height = 4 * this._cubeSize;
      var params = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: false,
        type: HalfFloatType,
        format: RGBAFormat,
        colorSpace: LinearSRGBColorSpace,
        depthBuffer: false
      };
      var cubeUVRenderTarget = _createRenderTarget(width, height, params);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
        if (this._pingPongRenderTarget !== null) {
          this._dispose();
        }
        this._pingPongRenderTarget = _createRenderTarget(width, height, params);
        var _lodMax = this._lodMax;
        var _createPlanes2 = _createPlanes(_lodMax);
        this._sizeLods = _createPlanes2.sizeLods;
        this._lodPlanes = _createPlanes2.lodPlanes;
        this._sigmas = _createPlanes2.sigmas;
        this._blurMaterial = _getBlurShader(_lodMax, width, height);
      }
      return cubeUVRenderTarget;
    }
  }, {
    key: "_compileMaterial",
    value: function _compileMaterial(material) {
      var tmpMesh = new Mesh(this._lodPlanes[0], material);
      this._renderer.compile(tmpMesh, _flatCamera);
    }
  }, {
    key: "_sceneToCubeUV",
    value: function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
      var fov = 90;
      var aspect = 1;
      var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
      var upSign = [1, -1, 1, 1, 1, 1];
      var forwardSign = [1, 1, 1, -1, -1, -1];
      var renderer = this._renderer;
      var originalAutoClear = renderer.autoClear;
      var toneMapping = renderer.toneMapping;
      renderer.getClearColor(_clearColor);
      renderer.toneMapping = NoToneMapping;
      renderer.autoClear = false;
      var backgroundMaterial = new MeshBasicMaterial({
        name: 'PMREM.Background',
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
      var useSolidColor = false;
      var background = scene.background;
      if (background) {
        if (background.isColor) {
          backgroundMaterial.color.copy(background);
          scene.background = null;
          useSolidColor = true;
        }
      } else {
        backgroundMaterial.color.copy(_clearColor);
        useSolidColor = true;
      }
      for (var i = 0; i < 6; i++) {
        var col = i % 3;
        if (col === 0) {
          cubeCamera.up.set(0, upSign[i], 0);
          cubeCamera.lookAt(forwardSign[i], 0, 0);
        } else if (col === 1) {
          cubeCamera.up.set(0, 0, upSign[i]);
          cubeCamera.lookAt(0, forwardSign[i], 0);
        } else {
          cubeCamera.up.set(0, upSign[i], 0);
          cubeCamera.lookAt(0, 0, forwardSign[i]);
        }
        var size = this._cubeSize;
        _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
        renderer.setRenderTarget(cubeUVRenderTarget);
        if (useSolidColor) {
          renderer.render(backgroundBox, cubeCamera);
        }
        renderer.render(scene, cubeCamera);
      }
      backgroundBox.geometry.dispose();
      backgroundBox.material.dispose();
      renderer.toneMapping = toneMapping;
      renderer.autoClear = originalAutoClear;
      scene.background = background;
    }
  }, {
    key: "_textureToCubeUV",
    value: function _textureToCubeUV(texture, cubeUVRenderTarget) {
      var renderer = this._renderer;
      var isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
      if (isCubeTexture) {
        if (this._cubemapMaterial === null) {
          this._cubemapMaterial = _getCubemapMaterial();
        }
        this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
      } else {
        if (this._equirectMaterial === null) {
          this._equirectMaterial = _getEquirectMaterial();
        }
      }
      var material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
      var mesh = new Mesh(this._lodPlanes[0], material);
      var uniforms = material.uniforms;
      uniforms['envMap'].value = texture;
      var size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      renderer.render(mesh, _flatCamera);
    }
  }, {
    key: "_applyPMREM",
    value: function _applyPMREM(cubeUVRenderTarget) {
      var renderer = this._renderer;
      var autoClear = renderer.autoClear;
      renderer.autoClear = false;
      var n = this._lodPlanes.length;
      for (var i = 1; i < n; i++) {
        var sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
        var poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
        this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
      }
      renderer.autoClear = autoClear;
    }

    /**
     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
     * vertically and horizontally, but this breaks down on a cube. Here we apply
     * the blur latitudinally (around the poles), and then longitudinally (towards
     * the poles) to approximate the orthogonally-separable blur. It is least
     * accurate at the poles, but still does a decent job.
     */
  }, {
    key: "_blur",
    value: function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
      var pingPongRenderTarget = this._pingPongRenderTarget;
      this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
      this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    }
  }, {
    key: "_halfBlur",
    value: function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
      var renderer = this._renderer;
      var blurMaterial = this._blurMaterial;
      if (direction !== 'latitudinal' && direction !== 'longitudinal') {
        console.error('blur direction must be either latitudinal or longitudinal!');
      }

      // Number of standard deviations at which to cut off the discrete approximation.
      var STANDARD_DEVIATIONS = 3;
      var blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
      var blurUniforms = blurMaterial.uniforms;
      var pixels = this._sizeLods[lodIn] - 1;
      var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
      var sigmaPixels = sigmaRadians / radiansPerPixel;
      var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
      if (samples > MAX_SAMPLES) {
        console.warn("sigmaRadians, ".concat(sigmaRadians, ", is too large and will clip, as it requested ").concat(samples, " samples when the maximum is set to ").concat(MAX_SAMPLES));
      }
      var weights = [];
      var sum = 0;
      for (var i = 0; i < MAX_SAMPLES; ++i) {
        var _x2 = i / sigmaPixels;
        var weight = Math.exp(-_x2 * _x2 / 2);
        weights.push(weight);
        if (i === 0) {
          sum += weight;
        } else if (i < samples) {
          sum += 2 * weight;
        }
      }
      for (var _i30 = 0; _i30 < weights.length; _i30++) {
        weights[_i30] = weights[_i30] / sum;
      }
      blurUniforms['envMap'].value = targetIn.texture;
      blurUniforms['samples'].value = samples;
      blurUniforms['weights'].value = weights;
      blurUniforms['latitudinal'].value = direction === 'latitudinal';
      if (poleAxis) {
        blurUniforms['poleAxis'].value = poleAxis;
      }
      var _lodMax = this._lodMax;
      blurUniforms['dTheta'].value = radiansPerPixel;
      blurUniforms['mipInt'].value = _lodMax - lodIn;
      var outputSize = this._sizeLods[lodOut];
      var x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
      var y = 4 * (this._cubeSize - outputSize);
      _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
      renderer.setRenderTarget(targetOut);
      renderer.render(blurMesh, _flatCamera);
    }
  }]);
}();
function _createPlanes(lodMax) {
  var lodPlanes = [];
  var sizeLods = [];
  var sigmas = [];
  var lod = lodMax;
  var totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (var i = 0; i < totalLods; i++) {
    var sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    var sigma = 1.0 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    var texelSize = 1.0 / (sizeLod - 2);
    var min = -texelSize;
    var max = 1 + texelSize;
    var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    var cubeFaces = 6;
    var vertices = 6;
    var positionSize = 3;
    var uvSize = 2;
    var faceIndexSize = 1;
    var position = new Float32Array(positionSize * vertices * cubeFaces);
    var uv = new Float32Array(uvSize * vertices * cubeFaces);
    var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (var face = 0; face < cubeFaces; face++) {
      var x = face % 3 * 2 / 3 - 1;
      var y = face > 2 ? 0 : -1;
      var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      var _fill = [face, face, face, face, face, face];
      faceIndex.set(_fill, faceIndexSize * vertices * face);
    }
    var planes = new BufferGeometry();
    planes.setAttribute('position', new BufferAttribute(position, positionSize));
    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return {
    lodPlanes: lodPlanes,
    sizeLods: sizeLods,
    sigmas: sigmas
  };
}
function _createRenderTarget(width, height, params) {
  var cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getBlurShader(lodMax, width, height) {
  var weights = new Float32Array(MAX_SAMPLES);
  var poleAxis = new Vector3(0, 1, 0);
  var shaderMaterial = new ShaderMaterial({
    name: 'SphericalGaussianBlur',
    defines: {
      'n': MAX_SAMPLES,
      'CUBEUV_TEXEL_WIDTH': 1.0 / width,
      'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
      'CUBEUV_MAX_MIP': "".concat(lodMax, ".0")
    },
    uniforms: {
      'envMap': {
        value: null
      },
      'samples': {
        value: 1
      },
      'weights': {
        value: weights
      },
      'latitudinal': {
        value: false
      },
      'dTheta': {
        value: 0
      },
      'mipInt': {
        value: 0
      },
      'poleAxis': {
        value: poleAxis
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: /* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: 'EquirectangularToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: /* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: 'CubemapToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'flipEnvMap': {
        value: -1
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: /* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return /* glsl */"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
}
function WebGLCubeUVMaps(renderer) {
  var cubeUVmaps = new WeakMap();
  var pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      var mapping = texture.mapping;
      var isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      var isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;

      // equirect/cube map to cubeUV conversion

      if (isEquirectMap || isCubeMap) {
        var renderTarget = cubeUVmaps.get(texture);
        var currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;
        if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          renderTarget.texture.pmremVersion = texture.pmremVersion;
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (renderTarget !== undefined) {
            return renderTarget.texture;
          } else {
            var image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
              renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              renderTarget.texture.pmremVersion = texture.pmremVersion;
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener('dispose', onTextureDispose);
              return renderTarget.texture;
            } else {
              // image not yet ready. try the conversion next frame

              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    var count = 0;
    var length = 6;
    for (var i = 0; i < length; i++) {
      if (image[i] !== undefined) count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    var cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== undefined) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get: get,
    dispose: dispose
  };
}
function WebGLExtensions(gl) {
  var extensions = {};
  function getExtension(name) {
    if (extensions[name] !== undefined) {
      return extensions[name];
    }
    var extension;
    switch (name) {
      case 'WEBGL_depth_texture':
        extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
        break;
      case 'EXT_texture_filter_anisotropic':
        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        break;
      case 'WEBGL_compressed_texture_s3tc':
        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        break;
      case 'WEBGL_compressed_texture_pvrtc':
        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function has(name) {
      return getExtension(name) !== null;
    },
    init: function init() {
      getExtension('EXT_color_buffer_float');
      getExtension('WEBGL_clip_cull_distance');
      getExtension('OES_texture_float_linear');
      getExtension('EXT_color_buffer_half_float');
      getExtension('WEBGL_multisampled_render_to_texture');
      getExtension('WEBGL_render_shared_exponent');
    },
    get: function get(name) {
      var extension = getExtension(name);
      if (extension === null) {
        warnOnce('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  var geometries = {};
  var wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    var geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (var name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    for (var _name3 in geometry.morphAttributes) {
      var array = geometry.morphAttributes[_name3];
      for (var i = 0, l = array.length; i < l; i++) {
        attributes.remove(array[i]);
      }
    }
    geometry.removeEventListener('dispose', onGeometryDispose);
    delete geometries[geometry.id];
    var attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }

    //

    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener('dispose', onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    var geometryAttributes = geometry.attributes;

    // Updating index buffer in VAO now. See WebGLBindingStates.

    for (var name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }

    // morph targets

    var morphAttributes = geometry.morphAttributes;
    for (var _name4 in morphAttributes) {
      var array = morphAttributes[_name4];
      for (var i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], gl.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    var indices = [];
    var geometryIndex = geometry.index;
    var geometryPosition = geometry.attributes.position;
    var version = 0;
    if (geometryIndex !== null) {
      var array = geometryIndex.array;
      version = geometryIndex.version;
      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else if (geometryPosition !== undefined) {
      var _array = geometryPosition.array;
      version = geometryPosition.version;
      for (var _i31 = 0, _l5 = _array.length / 3 - 1; _i31 < _l5; _i31 += 3) {
        var _a4 = _i31 + 0;
        var _b4 = _i31 + 1;
        var _c4 = _i31 + 2;
        indices.push(_a4, _b4, _b4, _c4, _c4, _a4);
      }
    } else {
      return;
    }
    var attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;

    // Updating index buffer in VAO now. See WebGLBindingStates

    //

    var previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);

    //

    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    var currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      var geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        // if the attribute is obsolete, create a new one

        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info) {
  var mode;
  function setMode(value) {
    mode = value;
  }
  var type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    var extension = extensions.get('WEBGL_multi_draw');
    extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
    var elementCount = 0;
    for (var i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    var extension = extensions.get('WEBGL_multi_draw');
    if (extension === null) {
      for (var i = 0; i < starts.length; i++) {
        renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);
      }
    } else {
      extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
      var elementCount = 0;
      for (var _i32 = 0; _i32 < drawCount; _i32++) {
        elementCount += counts[_i32];
      }
      for (var _i33 = 0; _i33 < primcount.length; _i33++) {
        info.update(elementCount, mode, primcount[_i33]);
      }
    }
  }

  //

  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLInfo(gl) {
  var memory = {
    geometries: 0,
    textures: 0
  };
  var render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory: memory,
    render: render,
    programs: null,
    autoReset: true,
    reset: reset,
    update: update
  };
}
function WebGLMorphtargets(gl, capabilities, textures) {
  var morphTextures = new WeakMap();
  var morph = new Vector4();
  function update(object, geometry, program) {
    var objectInfluences = object.morphTargetInfluences;

    // the following encodes morph targets into an array of data textures. Each layer represents a single morph target.

    var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
    var entry = morphTextures.get(geometry);
    if (entry === undefined || entry.count !== morphTargetsCount) {
      if (entry !== undefined) entry.texture.dispose();
      var hasMorphPosition = geometry.morphAttributes.position !== undefined;
      var hasMorphNormals = geometry.morphAttributes.normal !== undefined;
      var hasMorphColors = geometry.morphAttributes.color !== undefined;
      var morphTargets = geometry.morphAttributes.position || [];
      var morphNormals = geometry.morphAttributes.normal || [];
      var morphColors = geometry.morphAttributes.color || [];
      var vertexDataCount = 0;
      if (hasMorphPosition === true) vertexDataCount = 1;
      if (hasMorphNormals === true) vertexDataCount = 2;
      if (hasMorphColors === true) vertexDataCount = 3;
      var width = geometry.attributes.position.count * vertexDataCount;
      var height = 1;
      if (width > capabilities.maxTextureSize) {
        height = Math.ceil(width / capabilities.maxTextureSize);
        width = capabilities.maxTextureSize;
      }
      var buffer = new Float32Array(width * height * 4 * morphTargetsCount);
      var texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
      texture.type = FloatType;
      texture.needsUpdate = true;

      // fill buffer

      var vertexDataStride = vertexDataCount * 4;
      for (var i = 0; i < morphTargetsCount; i++) {
        var morphTarget = morphTargets[i];
        var morphNormal = morphNormals[i];
        var morphColor = morphColors[i];
        var offset = width * height * 4 * i;
        for (var j = 0; j < morphTarget.count; j++) {
          var stride = j * vertexDataStride;
          if (hasMorphPosition === true) {
            morph.fromBufferAttribute(morphTarget, j);
            buffer[offset + stride + 0] = morph.x;
            buffer[offset + stride + 1] = morph.y;
            buffer[offset + stride + 2] = morph.z;
            buffer[offset + stride + 3] = 0;
          }
          if (hasMorphNormals === true) {
            morph.fromBufferAttribute(morphNormal, j);
            buffer[offset + stride + 4] = morph.x;
            buffer[offset + stride + 5] = morph.y;
            buffer[offset + stride + 6] = morph.z;
            buffer[offset + stride + 7] = 0;
          }
          if (hasMorphColors === true) {
            morph.fromBufferAttribute(morphColor, j);
            buffer[offset + stride + 8] = morph.x;
            buffer[offset + stride + 9] = morph.y;
            buffer[offset + stride + 10] = morph.z;
            buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
          }
        }
      }
      entry = {
        count: morphTargetsCount,
        texture: texture,
        size: new Vector2(width, height)
      };
      morphTextures.set(geometry, entry);
      function disposeTexture() {
        texture.dispose();
        morphTextures.delete(geometry);
        geometry.removeEventListener('dispose', disposeTexture);
      }
      geometry.addEventListener('dispose', disposeTexture);
    }

    //
    if (object.isInstancedMesh === true && object.morphTexture !== null) {
      program.getUniforms().setValue(gl, 'morphTexture', object.morphTexture, textures);
    } else {
      var morphInfluencesSum = 0;
      for (var _i34 = 0; _i34 < objectInfluences.length; _i34++) {
        morphInfluencesSum += objectInfluences[_i34];
      }
      var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
      program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);
    }
    program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
    program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
  }
  return {
    update: update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  var updateMap = new WeakMap();
  function update(object) {
    var frame = info.render.frame;
    var geometry = object.geometry;
    var buffergeometry = geometries.get(object, geometry);

    // Update once per frame

    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
        object.addEventListener('dispose', onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      var skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    var instancedMesh = event.target;
    instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update: update,
    dispose: dispose
  };
}
var DepthTexture = exports.DepthTexture = /*#__PURE__*/function (_Texture4) {
  function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
    var _this24;
    var format = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : DepthFormat;
    _classCallCheck(this, DepthTexture);
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    }
    if (type === undefined && format === DepthFormat) type = UnsignedIntType;
    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
    _this24 = _callSuper(this, DepthTexture, [null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy]);
    _this24.isDepthTexture = true;
    _this24.image = {
      width: width,
      height: height
    };
    _this24.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    _this24.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    _this24.flipY = false;
    _this24.generateMipmaps = false;
    _this24.compareFunction = null;
    return _this24;
  }
  _inherits(DepthTexture, _Texture4);
  return _createClass(DepthTexture, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(DepthTexture, "copy", this, 3)([source]);
      this.compareFunction = source.compareFunction;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _superPropGet(DepthTexture, "toJSON", this, 3)([meta]);
      if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
      return data;
    }
  }]);
}(Texture);
/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */
var emptyTexture = /*@__PURE__*/new Texture();
var emptyShadowTexture = /*@__PURE__*/new DepthTexture(1, 1);
var emptyArrayTexture = /*@__PURE__*/new DataArrayTexture();
var empty3dTexture = /*@__PURE__*/new Data3DTexture();
var emptyCubeTexture = /*@__PURE__*/new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32 = [];
var arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);

// Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
  var firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  // unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983

  var n = nBlocks * blockSize;
  var r = arrayCacheF32[n];
  if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (var i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (var i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function copyArray(a, b) {
  for (var i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}

// Texture unit allocation

function allocTexUnits(textures, n) {
  var r = arrayCacheI32[n];
  if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (var i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f(gl, v) {
  var cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  var cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== undefined) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  var cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2(gl, v) {
  var cache = this.cache;
  var elements = v.elements;
  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  var cache = this.cache;
  var elements = v.elements;
  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  var cache = this.cache;
  var elements = v.elements;
  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}

// Single integer / boolean

function setValueV1i(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}

// Single integer / boolean vector (from flat array or THREE.VectorN)

function setValueV2i(gl, v) {
  var cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2i(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3i(gl, v) {
  var cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3i(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4i(gl, v) {
  var cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
}

// Single unsigned integer

function setValueV1ui(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}

// Single unsigned integer vector (from flat array or THREE.VectorN)

function setValueV2ui(gl, v) {
  var cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2ui(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3ui(gl, v) {
  var cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3ui(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4ui(gl, v) {
  var cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
  }
}

// Single texture (2D / Cube)

function setValueT1(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  var emptyTexture2D;
  if (this.type === gl.SAMPLER_2D_SHADOW) {
    emptyShadowTexture.compareFunction = LessEqualCompare; // #28670
    emptyTexture2D = emptyShadowTexture;
  } else {
    emptyTexture2D = emptyTexture;
  }
  textures.setTexture2D(v || emptyTexture2D, unit);
}
function setValueT3D1(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit);
}

// Helper to pick the right setter for the singular case

function getSingularSetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1f;
    // FLOAT
    case 0x8b50:
      return setValueV2f;
    // _VEC2
    case 0x8b51:
      return setValueV3f;
    // _VEC3
    case 0x8b52:
      return setValueV4f;
    // _VEC4

    case 0x8b5a:
      return setValueM2;
    // _MAT2
    case 0x8b5b:
      return setValueM3;
    // _MAT3
    case 0x8b5c:
      return setValueM4;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1i;
    // INT, BOOL
    case 0x8b53:
    case 0x8b57:
      return setValueV2i;
    // _VEC2
    case 0x8b54:
    case 0x8b58:
      return setValueV3i;
    // _VEC3
    case 0x8b55:
    case 0x8b59:
      return setValueV4i;
    // _VEC4

    case 0x1405:
      return setValueV1ui;
    // UINT
    case 0x8dc6:
      return setValueV2ui;
    // _VEC2
    case 0x8dc7:
      return setValueV3ui;
    // _VEC3
    case 0x8dc8:
      return setValueV4ui;
    // _VEC4

    case 0x8b5e: // SAMPLER_2D
    case 0x8d66: // SAMPLER_EXTERNAL_OES
    case 0x8dca: // INT_SAMPLER_2D
    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1;
    case 0x8b5f: // SAMPLER_3D
    case 0x8dcb: // INT_SAMPLER_3D
    case 0x8dd3:
      // UNSIGNED_INT_SAMPLER_3D
      return setValueT3D1;
    case 0x8b60: // SAMPLER_CUBE
    case 0x8dcc: // INT_SAMPLER_CUBE
    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6;
    case 0x8dc1: // SAMPLER_2D_ARRAY
    case 0x8dcf: // INT_SAMPLER_2D_ARRAY
    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 0x8dc4:
      // SAMPLER_2D_ARRAY_SHADOW
      return setValueT2DArray1;
  }
}

// Array of scalars

function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray(gl, v) {
  var data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  var data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  var data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array(gl, v) {
  var data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  var data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  var data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}

// Array of integer / boolean

function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}

// Array of unsigned integer

function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}

// Array of textures (2D / 3D / Cube / 2DArray)

function setValueT1Array(gl, v, textures) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (var i = 0; i !== n; ++i) {
    textures.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT3DArray(gl, v, textures) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (var i = 0; i !== n; ++i) {
    textures.setTexture3D(v[i] || empty3dTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (var i = 0; i !== n; ++i) {
    textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (var i = 0; i !== n; ++i) {
    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
  }
}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1fArray;
    // FLOAT
    case 0x8b50:
      return setValueV2fArray;
    // _VEC2
    case 0x8b51:
      return setValueV3fArray;
    // _VEC3
    case 0x8b52:
      return setValueV4fArray;
    // _VEC4

    case 0x8b5a:
      return setValueM2Array;
    // _MAT2
    case 0x8b5b:
      return setValueM3Array;
    // _MAT3
    case 0x8b5c:
      return setValueM4Array;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1iArray;
    // INT, BOOL
    case 0x8b53:
    case 0x8b57:
      return setValueV2iArray;
    // _VEC2
    case 0x8b54:
    case 0x8b58:
      return setValueV3iArray;
    // _VEC3
    case 0x8b55:
    case 0x8b59:
      return setValueV4iArray;
    // _VEC4

    case 0x1405:
      return setValueV1uiArray;
    // UINT
    case 0x8dc6:
      return setValueV2uiArray;
    // _VEC2
    case 0x8dc7:
      return setValueV3uiArray;
    // _VEC3
    case 0x8dc8:
      return setValueV4uiArray;
    // _VEC4

    case 0x8b5e: // SAMPLER_2D
    case 0x8d66: // SAMPLER_EXTERNAL_OES
    case 0x8dca: // INT_SAMPLER_2D
    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1Array;
    case 0x8b5f: // SAMPLER_3D
    case 0x8dcb: // INT_SAMPLER_3D
    case 0x8dd3:
      // UNSIGNED_INT_SAMPLER_3D
      return setValueT3DArray;
    case 0x8b60: // SAMPLER_CUBE
    case 0x8dcc: // INT_SAMPLER_CUBE
    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6Array;
    case 0x8dc1: // SAMPLER_2D_ARRAY
    case 0x8dcf: // INT_SAMPLER_2D_ARRAY
    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 0x8dc4:
      // SAMPLER_2D_ARRAY_SHADOW
      return setValueT2DArrayArray;
  }
}

// --- Uniform Classes ---
var SingleUniform = /*#__PURE__*/_createClass(function SingleUniform(id, activeInfo, addr) {
  _classCallCheck(this, SingleUniform);
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.type = activeInfo.type;
  this.setValue = getSingularSetter(activeInfo.type);

  // this.path = activeInfo.name; // DEBUG
});
var PureArrayUniform = /*#__PURE__*/_createClass(function PureArrayUniform(id, activeInfo, addr) {
  _classCallCheck(this, PureArrayUniform);
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.type = activeInfo.type;
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);

  // this.path = activeInfo.name; // DEBUG
});
var StructuredUniform = /*#__PURE__*/function () {
  function StructuredUniform(id) {
    _classCallCheck(this, StructuredUniform);
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  return _createClass(StructuredUniform, [{
    key: "setValue",
    value: function setValue(gl, value, textures) {
      var seq = this.seq;
      for (var i = 0, n = seq.length; i !== n; ++i) {
        var u = seq[i];
        u.setValue(gl, value[u.id], textures);
      }
    }
  }]);
}(); // --- Top-level ---
// Parser - builds up the property tree from the path strings
var RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  var path = activeInfo.name,
    pathLength = path.length;

  // reset RegExp object, because of the early exit of a previous run
  RePathPart.lastIndex = 0;
  while (true) {
    var match = RePathPart.exec(path),
      matchEnd = RePathPart.lastIndex;
    var id = match[1];
    var idIsIndex = match[2] === ']',
      subscript = match[3];
    if (idIsIndex) id = id | 0; // convert to integer

    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
      // bare name or "pure" bottom-level array "[0]" suffix

      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      // step into inner node / create it in case it doesn't exist

      var map = container.map;
      var next = map[id];
      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}

// Root Container
var WebGLUniforms = /*#__PURE__*/function () {
  function WebGLUniforms(gl, program) {
    _classCallCheck(this, WebGLUniforms);
    this.seq = [];
    this.map = {};
    var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < n; ++i) {
      var info = gl.getActiveUniform(program, i),
        addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  return _createClass(WebGLUniforms, [{
    key: "setValue",
    value: function setValue(gl, name, value, textures) {
      var u = this.map[name];
      if (u !== undefined) u.setValue(gl, value, textures);
    }
  }, {
    key: "setOptional",
    value: function setOptional(gl, object, name) {
      var v = object[name];
      if (v !== undefined) this.setValue(gl, name, v);
    }
  }], [{
    key: "upload",
    value: function upload(gl, seq, values, textures) {
      for (var i = 0, n = seq.length; i !== n; ++i) {
        var u = seq[i],
          v = values[u.id];
        if (v.needsUpdate !== false) {
          // note: always updating when .needsUpdate is undefined
          u.setValue(gl, v.value, textures);
        }
      }
    }
  }, {
    key: "seqWithValue",
    value: function seqWithValue(seq, values) {
      var r = [];
      for (var i = 0, n = seq.length; i !== n; ++i) {
        var u = seq[i];
        if (u.id in values) r.push(u);
      }
      return r;
    }
  }]);
}();
function WebGLShader(gl, type, string) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}

// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
var COMPLETION_STATUS_KHR = 0x91B1;
var programIdCount = 0;
function handleSource(string, errorLine) {
  var lines = string.split('\n');
  var lines2 = [];
  var from = Math.max(errorLine - 6, 0);
  var to = Math.min(errorLine + 6, lines.length);
  for (var i = from; i < to; i++) {
    var line = i + 1;
    lines2.push("".concat(line === errorLine ? '>' : ' ', " ").concat(line, ": ").concat(lines[i]));
  }
  return lines2.join('\n');
}
function getEncodingComponents(colorSpace) {
  var workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
  var encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
  var gamutMapping;
  if (workingPrimaries === encodingPrimaries) {
    gamutMapping = '';
  } else if (workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries) {
    gamutMapping = 'LinearDisplayP3ToLinearSRGB';
  } else if (workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries) {
    gamutMapping = 'LinearSRGBToLinearDisplayP3';
  }
  switch (colorSpace) {
    case LinearSRGBColorSpace:
    case LinearDisplayP3ColorSpace:
      return [gamutMapping, 'LinearTransferOETF'];
    case SRGBColorSpace:
    case DisplayP3ColorSpace:
      return [gamutMapping, 'sRGBTransferOETF'];
    default:
      console.warn('THREE.WebGLProgram: Unsupported color space:', colorSpace);
      return [gamutMapping, 'LinearTransferOETF'];
  }
}
function getShaderErrors(gl, shader, type) {
  var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  var errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === '') return '';
  var errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    // --enable-privileged-webgl-extension
    // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    var errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  var components = getEncodingComponents(colorSpace);
  return "vec4 ".concat(functionName, "( vec4 value ) { return ").concat(components[0], "( ").concat(components[1], "( value ) ); }");
}
function getToneMappingFunction(functionName, toneMapping) {
  var toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear';
      break;
    case ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;
    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;
    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic';
      break;
    case AgXToneMapping:
      toneMappingName = 'AgX';
      break;
    case NeutralToneMapping:
      toneMappingName = 'Neutral';
      break;
    case CustomToneMapping:
      toneMappingName = 'Custom';
      break;
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
      toneMappingName = 'Linear';
  }
  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
var _v0$1 = /*@__PURE__*/new Vector3();
function getLuminanceFunction() {
  ColorManagement.getLuminanceCoefficients(_v0$1);
  var r = _v0$1.x.toFixed(4);
  var g = _v0$1.y.toFixed(4);
  var b = _v0$1.z.toFixed(4);
  return ['float luminance( const in vec3 rgb ) {', "\tconst vec3 weights = vec3( ".concat(r, ", ").concat(g, ", ").concat(b, " );"), '	return dot( weights, rgb );', '}'].join('\n');
}
function generateVertexExtensions(parameters) {
  var chunks = [parameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '', parameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
  var chunks = [];
  for (var name in defines) {
    var value = defines[name];
    if (value === false) continue;
    chunks.push('#define ' + name + ' ' + value);
  }
  return chunks.join('\n');
}
function fetchAttributeLocations(gl, program) {
  var attributes = {};
  var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < n; i++) {
    var info = gl.getActiveAttrib(program, i);
    var name = info.name;
    var locationSize = 1;
    if (info.type === gl.FLOAT_MAT2) locationSize = 2;
    if (info.type === gl.FLOAT_MAT3) locationSize = 3;
    if (info.type === gl.FLOAT_MAT4) locationSize = 4;

    // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize: locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== '';
}
function replaceLightNums(string, parameters) {
  var numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}

// Resolve Includes

var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
var shaderChunkMap = new Map();
function includeReplacer(match, include) {
  var string = ShaderChunk[include];
  if (string === undefined) {
    var newInclude = shaderChunkMap.get(include);
    if (newInclude !== undefined) {
      string = ShaderChunk[newInclude];
      console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error('Can not resolve #include <' + include + '>');
    }
  }
  return resolveIncludes(string);
}

// Unroll Loops

var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  var string = '';
  for (var i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}

//

function generatePrecision(parameters) {
  var precisionstring = "precision ".concat(parameters.precision, " float;\n\tprecision ").concat(parameters.precision, " int;\n\tprecision ").concat(parameters.precision, " sampler2D;\n\tprecision ").concat(parameters.precision, " samplerCube;\n\tprecision ").concat(parameters.precision, " sampler3D;\n\tprecision ").concat(parameters.precision, " sampler2DArray;\n\tprecision ").concat(parameters.precision, " sampler2DShadow;\n\tprecision ").concat(parameters.precision, " samplerCubeShadow;\n\tprecision ").concat(parameters.precision, " sampler2DArrayShadow;\n\tprecision ").concat(parameters.precision, " isampler2D;\n\tprecision ").concat(parameters.precision, " isampler3D;\n\tprecision ").concat(parameters.precision, " isamplerCube;\n\tprecision ").concat(parameters.precision, " isampler2DArray;\n\tprecision ").concat(parameters.precision, " usampler2D;\n\tprecision ").concat(parameters.precision, " usampler3D;\n\tprecision ").concat(parameters.precision, " usamplerCube;\n\tprecision ").concat(parameters.precision, " usampler2DArray;\n\t");
  if (parameters.precision === 'highp') {
    precisionstring += '\n#define HIGH_PRECISION';
  } else if (parameters.precision === 'mediump') {
    precisionstring += '\n#define MEDIUM_PRECISION';
  } else if (parameters.precision === 'lowp') {
    precisionstring += '\n#define LOW_PRECISION';
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;
      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;
      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  var imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  var maxMip = Math.log2(imageHeight) - 2;
  var texelHeight = 1.0 / imageHeight;
  var texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return {
    texelWidth: texelWidth,
    texelHeight: texelHeight,
    maxMip: maxMip
  };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  // TODO Send this event to Three.js DevTools
  // console.log( 'WebGLProgram', cacheKey );

  var gl = renderer.getContext();
  var defines = parameters.defines;
  var vertexShader = parameters.vertexShader;
  var fragmentShader = parameters.fragmentShader;
  var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  var envMapModeDefine = generateEnvMapModeDefine(parameters);
  var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  var envMapCubeUVSize = generateCubeUVSize(parameters);
  var customVertexExtensions = generateVertexExtensions(parameters);
  var customDefines = generateDefines(defines);
  var program = gl.createProgram();
  var prefixVertex, prefixFragment;
  var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
  if (parameters.isRawShaderMaterial) {
    prefixVertex = ['#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines].filter(filterEmptyLine).join('\n');
    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }
    prefixFragment = ['#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines].filter(filterEmptyLine).join('\n');
    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = [generatePrecision(parameters), '#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '', parameters.batching ? '#define USE_BATCHING' : '', parameters.batchingColor ? '#define USE_BATCHING_COLOR' : '', parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '', parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '', parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '', parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.anisotropy ? '#define USE_ANISOTROPY' : '', parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaHash ? '#define USE_ALPHAHASH' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
    //

    parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '', parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '', parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '', parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '', parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '', parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '', parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '', parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '', parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '', parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '', parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '', parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '', parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '', parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '', parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '', parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '', parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '', parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '', parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '', parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '', parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '', parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '', parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',
    //

    parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUv1s ? '#define USE_UV1' : '', parameters.vertexUv2s ? '#define USE_UV2' : '', parameters.vertexUv3s ? '#define USE_UV3' : '', parameters.pointsUvs ? '#define USE_POINTS_UV' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.morphColors ? '#define USE_MORPHCOLORS' : '', parameters.morphTargetsCount > 0 ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '', parameters.morphTargetsCount > 0 ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', '#ifdef USE_INSTANCING_MORPH', '	uniform sampler2D morphTexture;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_UV1', '	attribute vec2 uv1;', '#endif', '#ifdef USE_UV2', '	attribute vec2 uv2;', '#endif', '#ifdef USE_UV3', '	attribute vec2 uv3;', '#endif', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [generatePrecision(parameters), '#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '', envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '', parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.anisotropy ? '#define USE_ANISOTROPY' : '', parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '', parameters.clearcoat ? '#define USE_CLEARCOAT' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.dispersion ? '#define USE_DISPERSION' : '', parameters.iridescence ? '#define USE_IRIDESCENCE' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaTest ? '#define USE_ALPHATEST' : '', parameters.alphaHash ? '#define USE_ALPHAHASH' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUv1s ? '#define USE_UV1' : '', parameters.vertexUv2s ? '#define USE_UV2' : '', parameters.vertexUv3s ? '#define USE_UV3' : '', parameters.pointsUvs ? '#define USE_POINTS_UV' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '', parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
    // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.opaque ? '#define OPAQUE' : '', ShaderChunk['colorspace_pars_fragment'],
    // this code is required here because it is used by the various encoding/decoding function defined below
    getTexelEncodingFunction('linearToOutputTexel', parameters.outputColorSpace), getLuminanceFunction(), parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isRawShaderMaterial !== true) {
    // GLSL 3.0 conversion for built-in materials and ShaderMaterial

    versionString = '#version 300 es\n';
    prefixVertex = [customVertexExtensions, '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }
  var vertexGlsl = versionString + prefixVertex + vertexShader;
  var fragmentGlsl = versionString + prefixFragment + fragmentShader;

  // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );

  var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);

  // Force a particular attribute to index 0.

  if (parameters.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
  }
  gl.linkProgram(program);
  function onFirstUse(self) {
    // check for link errors
    if (renderer.debug.checkShaderErrors) {
      var programLog = gl.getProgramInfoLog(program).trim();
      var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      var runnable = true;
      var haveDiagnostics = true;
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer.debug.onShaderError === 'function') {
          renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
        } else {
          // default error reporting

          var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
          var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
          console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n\n' + 'Material Name: ' + self.name + '\n' + 'Material Type: ' + self.type + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors);
        }
      } else if (programLog !== '') {
        console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
      } else if (vertexLog === '' || fragmentLog === '') {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self.diagnostics = {
          runnable: runnable,
          programLog: programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }

    // Clean up

    // Crashes in iOS9 and iOS10. #18402
    // gl.detachShader( program, glVertexShader );
    // gl.detachShader( program, glFragmentShader );

    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl, program);
    cachedAttributes = fetchAttributeLocations(gl, program);
  }

  // set up caching for uniform locations

  var cachedUniforms;
  this.getUniforms = function () {
    if (cachedUniforms === undefined) {
      // Populates cachedUniforms and cachedAttributes
      onFirstUse(this);
    }
    return cachedUniforms;
  };

  // set up caching for attribute locations

  var cachedAttributes;
  this.getAttributes = function () {
    if (cachedAttributes === undefined) {
      // Populates cachedAttributes and cachedUniforms
      onFirstUse(this);
    }
    return cachedAttributes;
  };

  // indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
  // flag the program as ready immediately. It may cause a stall when it's first used.

  var programReady = parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function () {
    if (programReady === false) {
      programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };

  // free resource

  this.destroy = function () {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = undefined;
  };

  //

  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
var _id$1 = 0;
var WebGLShaderCache = /*#__PURE__*/function () {
  function WebGLShaderCache() {
    _classCallCheck(this, WebGLShaderCache);
    this.shaderCache = new Map();
    this.materialCache = new Map();
  }
  return _createClass(WebGLShaderCache, [{
    key: "update",
    value: function update(material) {
      var vertexShader = material.vertexShader;
      var fragmentShader = material.fragmentShader;
      var vertexShaderStage = this._getShaderStage(vertexShader);
      var fragmentShaderStage = this._getShaderStage(fragmentShader);
      var materialShaders = this._getShaderCacheForMaterial(material);
      if (materialShaders.has(vertexShaderStage) === false) {
        materialShaders.add(vertexShaderStage);
        vertexShaderStage.usedTimes++;
      }
      if (materialShaders.has(fragmentShaderStage) === false) {
        materialShaders.add(fragmentShaderStage);
        fragmentShaderStage.usedTimes++;
      }
      return this;
    }
  }, {
    key: "remove",
    value: function remove(material) {
      var materialShaders = this.materialCache.get(material);
      var _iterator3 = _createForOfIteratorHelper(materialShaders),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var shaderStage = _step3.value;
          shaderStage.usedTimes--;
          if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      this.materialCache.delete(material);
      return this;
    }
  }, {
    key: "getVertexShaderID",
    value: function getVertexShaderID(material) {
      return this._getShaderStage(material.vertexShader).id;
    }
  }, {
    key: "getFragmentShaderID",
    value: function getFragmentShaderID(material) {
      return this._getShaderStage(material.fragmentShader).id;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shaderCache.clear();
      this.materialCache.clear();
    }
  }, {
    key: "_getShaderCacheForMaterial",
    value: function _getShaderCacheForMaterial(material) {
      var cache = this.materialCache;
      var set = cache.get(material);
      if (set === undefined) {
        set = new Set();
        cache.set(material, set);
      }
      return set;
    }
  }, {
    key: "_getShaderStage",
    value: function _getShaderStage(code) {
      var cache = this.shaderCache;
      var stage = cache.get(code);
      if (stage === undefined) {
        stage = new WebGLShaderStage(code);
        cache.set(code, stage);
      }
      return stage;
    }
  }]);
}();
var WebGLShaderStage = /*#__PURE__*/_createClass(function WebGLShaderStage(code) {
  _classCallCheck(this, WebGLShaderStage);
  this.id = _id$1++;
  this.code = code;
  this.usedTimes = 0;
});
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  var _programLayers = new Layers();
  var _customShaders = new WebGLShaderCache();
  var _activeChannels = new Set();
  var programs = [];
  var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  var SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  var precision = capabilities.precision;
  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  function getChannel(value) {
    _activeChannels.add(value);
    if (value === 0) return 'uv';
    return "uv".concat(value);
  }
  function getParameters(material, lights, shadows, scene, object) {
    var fog = scene.fog;
    var geometry = object.geometry;
    var environment = material.isMeshStandardMaterial ? scene.environment : null;
    var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    var envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    var shaderID = shaderIDs[material.type];

    // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }

    //

    var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
    var morphTextureStride = 0;
    if (geometry.morphAttributes.position !== undefined) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== undefined) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== undefined) morphTextureStride = 3;

    //

    var vertexShader, fragmentShader;
    var customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      var shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    var currentRenderTarget = renderer.getRenderTarget();
    var IS_INSTANCEDMESH = object.isInstancedMesh === true;
    var IS_BATCHEDMESH = object.isBatchedMesh === true;
    var HAS_MAP = !!material.map;
    var HAS_MATCAP = !!material.matcap;
    var HAS_ENVMAP = !!envMap;
    var HAS_AOMAP = !!material.aoMap;
    var HAS_LIGHTMAP = !!material.lightMap;
    var HAS_BUMPMAP = !!material.bumpMap;
    var HAS_NORMALMAP = !!material.normalMap;
    var HAS_DISPLACEMENTMAP = !!material.displacementMap;
    var HAS_EMISSIVEMAP = !!material.emissiveMap;
    var HAS_METALNESSMAP = !!material.metalnessMap;
    var HAS_ROUGHNESSMAP = !!material.roughnessMap;
    var HAS_ANISOTROPY = material.anisotropy > 0;
    var HAS_CLEARCOAT = material.clearcoat > 0;
    var HAS_DISPERSION = material.dispersion > 0;
    var HAS_IRIDESCENCE = material.iridescence > 0;
    var HAS_SHEEN = material.sheen > 0;
    var HAS_TRANSMISSION = material.transmission > 0;
    var HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    var HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    var HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    var HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    var HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    var HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    var HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    var HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    var HAS_SPECULARMAP = !!material.specularMap;
    var HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    var HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    var HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    var HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    var HAS_GRADIENTMAP = !!material.gradientMap;
    var HAS_ALPHAMAP = !!material.alphaMap;
    var HAS_ALPHATEST = material.alphaTest > 0;
    var HAS_ALPHAHASH = !!material.alphaHash;
    var HAS_EXTENSIONS = !!material.extensions;
    var toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping = renderer.toneMapping;
      }
    }
    var parameters = {
      shaderID: shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      defines: material.defines,
      customVertexShaderID: customVertexShaderID,
      customFragmentShaderID: customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision: precision,
      batching: IS_BATCHEDMESH,
      batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      alphaToCoverage: !!material.alphaToCoverage,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight: envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      dispersion: HAS_DISPERSION,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //

      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //

      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: !!fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer: logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== undefined,
      morphNormals: geometry.morphAttributes.normal !== undefined,
      morphColors: geometry.morphAttributes.color !== undefined,
      morphTargetsCount: morphTargetsCount,
      morphTextureStride: morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: toneMapping,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has('WEBGL_clip_cull_distance'),
      extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has('WEBGL_multi_draw'),
      rendererExtensionParallelShaderCompile: extensions.has('KHR_parallel_shader_compile'),
      customProgramCacheKey: material.customProgramCacheKey()
    };

    // the usage of getChannel() determines the active texture channels for this shader

    parameters.vertexUv1s = _activeChannels.has(1);
    parameters.vertexUv2s = _activeChannels.has(2);
    parameters.vertexUv3s = _activeChannels.has(3);
    _activeChannels.clear();
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    var array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== undefined) {
      for (var name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.supportsVertexTextures) _programLayers.enable(0);
    if (parameters.instancing) _programLayers.enable(1);
    if (parameters.instancingColor) _programLayers.enable(2);
    if (parameters.instancingMorph) _programLayers.enable(3);
    if (parameters.matcap) _programLayers.enable(4);
    if (parameters.envMap) _programLayers.enable(5);
    if (parameters.normalMapObjectSpace) _programLayers.enable(6);
    if (parameters.normalMapTangentSpace) _programLayers.enable(7);
    if (parameters.clearcoat) _programLayers.enable(8);
    if (parameters.iridescence) _programLayers.enable(9);
    if (parameters.alphaTest) _programLayers.enable(10);
    if (parameters.vertexColors) _programLayers.enable(11);
    if (parameters.vertexAlphas) _programLayers.enable(12);
    if (parameters.vertexUv1s) _programLayers.enable(13);
    if (parameters.vertexUv2s) _programLayers.enable(14);
    if (parameters.vertexUv3s) _programLayers.enable(15);
    if (parameters.vertexTangents) _programLayers.enable(16);
    if (parameters.anisotropy) _programLayers.enable(17);
    if (parameters.alphaHash) _programLayers.enable(18);
    if (parameters.batching) _programLayers.enable(19);
    if (parameters.dispersion) _programLayers.enable(20);
    if (parameters.batchingColor) _programLayers.enable(21);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog) _programLayers.enable(0);
    if (parameters.useFog) _programLayers.enable(1);
    if (parameters.flatShading) _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer) _programLayers.enable(3);
    if (parameters.skinning) _programLayers.enable(4);
    if (parameters.morphTargets) _programLayers.enable(5);
    if (parameters.morphNormals) _programLayers.enable(6);
    if (parameters.morphColors) _programLayers.enable(7);
    if (parameters.premultipliedAlpha) _programLayers.enable(8);
    if (parameters.shadowMapEnabled) _programLayers.enable(9);
    if (parameters.doubleSided) _programLayers.enable(10);
    if (parameters.flipSided) _programLayers.enable(11);
    if (parameters.useDepthPacking) _programLayers.enable(12);
    if (parameters.dithering) _programLayers.enable(13);
    if (parameters.transmission) _programLayers.enable(14);
    if (parameters.sheen) _programLayers.enable(15);
    if (parameters.opaque) _programLayers.enable(16);
    if (parameters.pointsUvs) _programLayers.enable(17);
    if (parameters.decodeVideoTexture) _programLayers.enable(18);
    if (parameters.alphaToCoverage) _programLayers.enable(19);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    var shaderID = shaderIDs[material.type];
    var uniforms;
    if (shaderID) {
      var shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    var program;

    // Check if code has been already compiled
    for (var p = 0, pl = programs.length; p < pl; p++) {
      var preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === undefined) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      var i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();

      // Free WebGL resources
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters: getParameters,
    getProgramCacheKey: getProgramCacheKey,
    getUniforms: getUniforms,
    acquireProgram: acquireProgram,
    releaseProgram: releaseProgram,
    releaseShaderCache: releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: programs,
    dispose: dispose
  };
}
function WebGLProperties() {
  var properties = new WeakMap();
  function get(object) {
    var map = properties.get(object);
    if (map === undefined) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = new WeakMap();
  }
  return {
    get: get,
    remove: remove,
    update: update,
    dispose: dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  var renderItems = [];
  var renderItemsIndex = 0;
  var opaque = [];
  var transmissive = [];
  var transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    var renderItem = renderItems[renderItemsIndex];
    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        groupOrder: groupOrder,
        renderOrder: object.renderOrder,
        z: z,
        group: group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0.0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0.0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    // Clear references from inactive renderItems in the list

    for (var i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      var renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque: opaque,
    transmissive: transmissive,
    transparent: transparent,
    init: init,
    push: push,
    unshift: unshift,
    finish: finish,
    sort: sort
  };
}
function WebGLRenderLists() {
  var lists = new WeakMap();
  function get(scene, renderCallDepth) {
    var listArray = lists.get(scene);
    var list;
    if (listArray === undefined) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = new WeakMap();
  }
  return {
    get: get,
    dispose: dispose
  };
}
function UniformsCache() {
  var lights = {};
  return {
    get: function get(light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }
      var uniforms;
      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case 'SpotLight':
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case 'PointLight':
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case 'HemisphereLight':
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case 'RectAreaLight':
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  var lights = {};
  return {
    get: function get(light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }
      var uniforms;
      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case 'SpotLight':
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case 'PointLight':
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;

        // TODO (abelnation): set RectAreaLight shadow uniforms
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions) {
  var cache = new UniformsCache();
  var shadowCache = ShadowUniformsCache();
  var state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (var i = 0; i < 9; i++) state.probe.push(new Vector3());
  var vector3 = new Vector3();
  var matrix4 = new Matrix4();
  var matrix42 = new Matrix4();
  function setup(lights) {
    var r = 0,
      g = 0,
      b = 0;
    for (var _i35 = 0; _i35 < 9; _i35++) state.probe[_i35].set(0, 0, 0);
    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var numDirectionalShadows = 0;
    var numPointShadows = 0;
    var numSpotShadows = 0;
    var numSpotMaps = 0;
    var numSpotShadowsWithMaps = 0;
    var numLightProbes = 0;

    // ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
    lights.sort(shadowCastingAndTexturingLightsFirst);
    for (var _i36 = 0, l = lights.length; _i36 < l; _i36++) {
      var light = lights[_i36];
      var color = light.color;
      var intensity = light.intensity;
      var distance = light.distance;
      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (var j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        var uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          var shadow = light.shadow;
          var shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        var _uniforms = cache.get(light);
        _uniforms.position.setFromMatrixPosition(light.matrixWorld);
        _uniforms.color.copy(color).multiplyScalar(intensity);
        _uniforms.distance = distance;
        _uniforms.coneCos = Math.cos(light.angle);
        _uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        _uniforms.decay = light.decay;
        state.spot[spotLength] = _uniforms;
        var _shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;

          // make sure the lightMatrix is up to date
          // TODO : do it if required only
          _shadow.updateMatrices(light);
          if (light.castShadow) numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = _shadow.matrix;
        if (light.castShadow) {
          var _shadowUniforms = shadowCache.get(light);
          _shadowUniforms.shadowIntensity = _shadow.intensity;
          _shadowUniforms.shadowBias = _shadow.bias;
          _shadowUniforms.shadowNormalBias = _shadow.normalBias;
          _shadowUniforms.shadowRadius = _shadow.radius;
          _shadowUniforms.shadowMapSize = _shadow.mapSize;
          state.spotShadow[spotLength] = _shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        var _uniforms2 = cache.get(light);
        _uniforms2.color.copy(color).multiplyScalar(intensity);
        _uniforms2.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        _uniforms2.halfHeight.set(0.0, light.height * 0.5, 0.0);
        state.rectArea[rectAreaLength] = _uniforms2;
        rectAreaLength++;
      } else if (light.isPointLight) {
        var _uniforms3 = cache.get(light);
        _uniforms3.color.copy(light.color).multiplyScalar(light.intensity);
        _uniforms3.distance = light.distance;
        _uniforms3.decay = light.decay;
        if (light.castShadow) {
          var _shadow2 = light.shadow;
          var _shadowUniforms2 = shadowCache.get(light);
          _shadowUniforms2.shadowIntensity = _shadow2.intensity;
          _shadowUniforms2.shadowBias = _shadow2.bias;
          _shadowUniforms2.shadowNormalBias = _shadow2.normalBias;
          _shadowUniforms2.shadowRadius = _shadow2.radius;
          _shadowUniforms2.shadowMapSize = _shadow2.mapSize;
          _shadowUniforms2.shadowCameraNear = _shadow2.camera.near;
          _shadowUniforms2.shadowCameraFar = _shadow2.camera.far;
          state.pointShadow[pointLength] = _shadowUniforms2;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = _uniforms3;
        pointLength++;
      } else if (light.isHemisphereLight) {
        var _uniforms4 = cache.get(light);
        _uniforms4.skyColor.copy(light.color).multiplyScalar(intensity);
        _uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = _uniforms4;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (extensions.has('OES_texture_float_linear') === true) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    var hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      hash.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var viewMatrix = camera.matrixWorldInverse;
    for (var _i37 = 0, l = lights.length; _i37 < l; _i37++) {
      var light = lights[_i37];
      if (light.isDirectionalLight) {
        var uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        var _uniforms5 = state.spot[spotLength];
        _uniforms5.position.setFromMatrixPosition(light.matrixWorld);
        _uniforms5.position.applyMatrix4(viewMatrix);
        _uniforms5.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        _uniforms5.direction.sub(vector3);
        _uniforms5.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        var _uniforms6 = state.rectArea[rectAreaLength];
        _uniforms6.position.setFromMatrixPosition(light.matrixWorld);
        _uniforms6.position.applyMatrix4(viewMatrix);

        // extract local rotation of light to derive width/height half vectors
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        _uniforms6.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        _uniforms6.halfHeight.set(0.0, light.height * 0.5, 0.0);
        _uniforms6.halfWidth.applyMatrix4(matrix42);
        _uniforms6.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        var _uniforms7 = state.point[pointLength];
        _uniforms7.position.setFromMatrixPosition(light.matrixWorld);
        _uniforms7.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        var _uniforms8 = state.hemi[hemiLength];
        _uniforms8.direction.setFromMatrixPosition(light.matrixWorld);
        _uniforms8.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup: setup,
    setupView: setupView,
    state: state
  };
}
function WebGLRenderState(extensions) {
  var lights = new WebGLLights(extensions);
  var lightsArray = [];
  var shadowsArray = [];
  function init(camera) {
    state.camera = camera;
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  var state = {
    lightsArray: lightsArray,
    shadowsArray: shadowsArray,
    camera: null,
    lights: lights,
    transmissionRenderTarget: {}
  };
  return {
    init: init,
    state: state,
    setupLights: setupLights,
    setupLightsView: setupLightsView,
    pushLight: pushLight,
    pushShadow: pushShadow
  };
}
function WebGLRenderStates(extensions) {
  var renderStates = new WeakMap();
  function get(scene) {
    var renderCallDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var renderStateArray = renderStates.get(scene);
    var renderState;
    if (renderStateArray === undefined) {
      renderState = new WebGLRenderState(extensions);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = new WeakMap();
  }
  return {
    get: get,
    dispose: dispose
  };
}
var MeshDepthMaterial = exports.MeshDepthMaterial = /*#__PURE__*/function (_Material3) {
  function MeshDepthMaterial(parameters) {
    var _this25;
    _classCallCheck(this, MeshDepthMaterial);
    _this25 = _callSuper(this, MeshDepthMaterial);
    _this25.isMeshDepthMaterial = true;
    _this25.type = 'MeshDepthMaterial';
    _this25.depthPacking = BasicDepthPacking;
    _this25.map = null;
    _this25.alphaMap = null;
    _this25.displacementMap = null;
    _this25.displacementScale = 1;
    _this25.displacementBias = 0;
    _this25.wireframe = false;
    _this25.wireframeLinewidth = 1;
    _this25.setValues(parameters);
    return _this25;
  }
  _inherits(MeshDepthMaterial, _Material3);
  return _createClass(MeshDepthMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshDepthMaterial, "copy", this, 3)([source]);
      this.depthPacking = source.depthPacking;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    }
  }]);
}(Material);
var MeshDistanceMaterial = exports.MeshDistanceMaterial = /*#__PURE__*/function (_Material4) {
  function MeshDistanceMaterial(parameters) {
    var _this26;
    _classCallCheck(this, MeshDistanceMaterial);
    _this26 = _callSuper(this, MeshDistanceMaterial);
    _this26.isMeshDistanceMaterial = true;
    _this26.type = 'MeshDistanceMaterial';
    _this26.map = null;
    _this26.alphaMap = null;
    _this26.displacementMap = null;
    _this26.displacementScale = 1;
    _this26.displacementBias = 0;
    _this26.setValues(parameters);
    return _this26;
  }
  _inherits(MeshDistanceMaterial, _Material4);
  return _createClass(MeshDistanceMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshDistanceMaterial, "copy", this, 3)([source]);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    }
  }]);
}(Material);
var vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(renderer, objects, capabilities) {
  var _frustum = new Frustum();
  var _shadowMapSize = new Vector2(),
    _viewportSize = new Vector2(),
    _viewport = new Vector4(),
    _depthMaterial = new MeshDepthMaterial({
      depthPacking: RGBADepthPacking
    }),
    _distanceMaterial = new MeshDistanceMaterial(),
    _materialCache = {},
    _maxTextureSize = capabilities.maxTextureSize;
  var shadowSide = _defineProperty(_defineProperty(_defineProperty({}, FrontSide, BackSide), BackSide, FrontSide), DoubleSide, DoubleSide);
  var shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new Vector2()
      },
      radius: {
        value: 4.0
      }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  var shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  var fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  var scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  var _previousType = this.type;
  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    var currentRenderTarget = renderer.getRenderTarget();
    var activeCubeFace = renderer.getActiveCubeFace();
    var activeMipmapLevel = renderer.getActiveMipmapLevel();
    var _state = renderer.state;

    // Set GL state for depth map.
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);

    // check for shadow map type changes

    var toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    var fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;

    // render depth map

    for (var i = 0, il = lights.length; i < il; i++) {
      var light = lights[i];
      var shadow = light.shadow;
      if (shadow === undefined) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      var shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        var pars = this.type !== VSMShadowMap ? {
          minFilter: NearestFilter,
          magFilter: NearestFilter
        } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + '.shadowMap';
        shadow.camera.updateProjectionMatrix();
      }
      renderer.setRenderTarget(shadow.map);
      renderer.clear();
      var viewportCount = shadow.getViewportCount();
      for (var vp = 0; vp < viewportCount; vp++) {
        var viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }

      // do blur pass for VSM

      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    var geometry = objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }

    // vertical pass

    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.mapPass);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);

    // horizontal pass

    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.map);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    var result = null;
    var customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== undefined) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        // in this case we need a unique material instance reflecting the
        // appropriate state

        var keyA = result.uuid,
          keyB = material.uuid;
        var materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === undefined) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        var cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === undefined) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
          material.addEventListener('dispose', onMaterialDispose);
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      var materialProperties = renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        var geometry = objects.update(object);
        var material = object.material;
        if (Array.isArray(material)) {
          var groups = geometry.groups;
          for (var k = 0, kl = groups.length; k < kl; k++) {
            var group = groups[k];
            var groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              var depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
              renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
            }
          }
        } else if (material.visible) {
          var _depthMaterial2 = getDepthMaterial(object, material, light, type);
          object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, _depthMaterial2, null);
          renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial2, object, null);
          object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, _depthMaterial2, null);
        }
      }
    }
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
  function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);

    // make sure to remove the unique distance/depth materials used for shadow map rendering

    for (var id in _materialCache) {
      var cache = _materialCache[id];
      var uuid = event.target.uuid;
      if (uuid in cache) {
        var shadowMaterial = cache[uuid];
        shadowMaterial.dispose();
        delete cache[uuid];
      }
    }
  }
}
function WebGLState(gl) {
  var _factorToGL;
  function ColorBuffer() {
    var locked = false;
    var color = new Vector4();
    var currentColorMask = null;
    var currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function setMask(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function setLocked(lock) {
        locked = lock;
      },
      setClear: function setClear(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function reset() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
      }
    };
  }
  function DepthBuffer() {
    var locked = false;
    var currentDepthMask = null;
    var currentDepthFunc = null;
    var currentDepthClear = null;
    return {
      setTest: function setTest(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function setMask(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function setFunc(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function setLocked(lock) {
        locked = lock;
      },
      setClear: function setClear(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function reset() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    var locked = false;
    var currentStencilMask = null;
    var currentStencilFunc = null;
    var currentStencilRef = null;
    var currentStencilFuncMask = null;
    var currentStencilFail = null;
    var currentStencilZFail = null;
    var currentStencilZPass = null;
    var currentStencilClear = null;
    return {
      setTest: function setTest(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function setMask(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function setLocked(lock) {
        locked = lock;
      },
      setClear: function setClear(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function reset() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }

  //

  var colorBuffer = new ColorBuffer();
  var depthBuffer = new DepthBuffer();
  var stencilBuffer = new StencilBuffer();
  var uboBindings = new WeakMap();
  var uboProgramMap = new WeakMap();
  var enabledCapabilities = {};
  var currentBoundFramebuffers = {};
  var currentDrawbuffers = new WeakMap();
  var defaultDrawbuffers = [];
  var currentProgram = null;
  var currentBlendingEnabled = false;
  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;
  var currentBlendColor = new Color(0, 0, 0);
  var currentBlendAlpha = 0;
  var currentPremultipledAlpha = false;
  var currentFlipSided = null;
  var currentCullFace = null;
  var currentLineWidth = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;
  var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  var lineWidthAvailable = false;
  var version = 0;
  var glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf('WebGL') !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1.0;
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2.0;
  }
  var currentTextureSlot = null;
  var currentBoundTextures = {};
  var scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  var viewportParam = gl.getParameter(gl.VIEWPORT);
  var currentScissor = new Vector4().fromArray(scissorParam);
  var currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count, dimensions) {
    var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
    var texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (var i = 0; i < count; i++) {
      if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {
        gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      } else {
        gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }
    return texture;
  }
  var emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
  emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);

  // init

  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);

  //

  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;

      // gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

      if (target === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    var drawBuffers = defaultDrawbuffers;
    var needsUpdate = false;
    if (renderTarget) {
      drawBuffers = currentDrawbuffers.get(framebuffer);
      if (drawBuffers === undefined) {
        drawBuffers = [];
        currentDrawbuffers.set(framebuffer, drawBuffers);
      }
      var textures = renderTarget.textures;
      if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
        for (var i = 0, il = textures.length; i < il; i++) {
          drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
        }
        drawBuffers.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers[0] !== gl.BACK) {
        drawBuffers[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers);
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  var equationToGL = _defineProperty(_defineProperty(_defineProperty({}, AddEquation, gl.FUNC_ADD), SubtractEquation, gl.FUNC_SUBTRACT), ReverseSubtractEquation, gl.FUNC_REVERSE_SUBTRACT);
  equationToGL[MinEquation] = gl.MIN;
  equationToGL[MaxEquation] = gl.MAX;
  var factorToGL = (_factorToGL = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_factorToGL, ZeroFactor, gl.ZERO), OneFactor, gl.ONE), SrcColorFactor, gl.SRC_COLOR), SrcAlphaFactor, gl.SRC_ALPHA), SrcAlphaSaturateFactor, gl.SRC_ALPHA_SATURATE), DstColorFactor, gl.DST_COLOR), DstAlphaFactor, gl.DST_ALPHA), OneMinusSrcColorFactor, gl.ONE_MINUS_SRC_COLOR), OneMinusSrcAlphaFactor, gl.ONE_MINUS_SRC_ALPHA), OneMinusDstColorFactor, gl.ONE_MINUS_DST_COLOR), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_factorToGL, OneMinusDstAlphaFactor, gl.ONE_MINUS_DST_ALPHA), ConstantColorFactor, gl.CONSTANT_COLOR), OneMinusConstantColorFactor, gl.ONE_MINUS_CONSTANT_COLOR), ConstantAlphaFactor, gl.CONSTANT_ALPHA), OneMinusConstantAlphaFactor, gl.ONE_MINUS_CONSTANT_ALPHA));
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }

    // custom blending

    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
      gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    var flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    var stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }

  //

  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }

  // texture

  function activeTexture(webglSlot) {
    if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === undefined) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    var boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    var boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== undefined && boundTexture.type !== undefined) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = undefined;
      boundTexture.texture = undefined;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  //

  function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  }
  function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    var mapping = uboProgramMap.get(program);
    if (mapping === undefined) {
      mapping = new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    var blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === undefined) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    var mapping = uboProgramMap.get(program);
    var blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      // bind shader specific block index to global block point
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }

  //

  function reset() {
    // reset state

    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendColor(0, 0, 0, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    gl.clearDepth(1);
    gl.stencilMask(0xffffffff);
    gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // reset internals

    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable: enable,
    disable: disable,
    bindFramebuffer: bindFramebuffer,
    drawBuffers: drawBuffers,
    useProgram: useProgram,
    setBlending: setBlending,
    setMaterial: setMaterial,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    unbindTexture: unbindTexture,
    compressedTexImage2D: compressedTexImage2D,
    compressedTexImage3D: compressedTexImage3D,
    texImage2D: texImage2D,
    texImage3D: texImage3D,
    updateUBOMapping: updateUBOMapping,
    uniformBlockBinding: uniformBlockBinding,
    texStorage2D: texStorage2D,
    texStorage3D: texStorage3D,
    texSubImage2D: texSubImage2D,
    texSubImage3D: texSubImage3D,
    compressedTexSubImage2D: compressedTexSubImage2D,
    compressedTexSubImage3D: compressedTexSubImage3D,
    scissor: scissor,
    viewport: viewport,
    reset: reset
  };
}
function contain(texture, aspect) {
  var imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
  if (imageAspect > aspect) {
    texture.repeat.x = 1;
    texture.repeat.y = imageAspect / aspect;
    texture.offset.x = 0;
    texture.offset.y = (1 - texture.repeat.y) / 2;
  } else {
    texture.repeat.x = aspect / imageAspect;
    texture.repeat.y = 1;
    texture.offset.x = (1 - texture.repeat.x) / 2;
    texture.offset.y = 0;
  }
  return texture;
}
function cover(texture, aspect) {
  var imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
  if (imageAspect > aspect) {
    texture.repeat.x = aspect / imageAspect;
    texture.repeat.y = 1;
    texture.offset.x = (1 - texture.repeat.x) / 2;
    texture.offset.y = 0;
  } else {
    texture.repeat.x = 1;
    texture.repeat.y = imageAspect / aspect;
    texture.offset.x = 0;
    texture.offset.y = (1 - texture.repeat.y) / 2;
  }
  return texture;
}
function fill(texture) {
  texture.repeat.x = 1;
  texture.repeat.y = 1;
  texture.offset.x = 0;
  texture.offset.y = 0;
  return texture;
}

/**
 * Given the width, height, format, and type of a texture. Determines how many
 * bytes must be used to represent the texture.
 */
function getByteLength(width, height, format, type) {
  var typeByteLength = getTextureTypeByteLength(type);
  switch (format) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case AlphaFormat:
      return width * height;
    case LuminanceFormat:
      return width * height;
    case LuminanceAlphaFormat:
      return width * height * 2;
    case RedFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RedIntegerFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RGFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGIntegerFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGBFormat:
      return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAIntegerFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;

    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;

    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return Math.max(width, 16) * Math.max(height, 8) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return Math.max(width, 8) * Math.max(height, 8) / 2;

    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;

    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case RGBA_ASTC_4x4_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;

    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;

    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
  }
  throw new Error("Unable to determine texture byte length for ".concat(format, " format."));
}
function getTextureTypeByteLength(type) {
  switch (type) {
    case UnsignedByteType:
    case ByteType:
      return {
        byteLength: 1,
        components: 1
      };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return {
        byteLength: 2,
        components: 1
      };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return {
        byteLength: 2,
        components: 4
      };
    case UnsignedIntType:
    case IntType:
    case FloatType:
      return {
        byteLength: 4,
        components: 1
      };
    case UnsignedInt5999Type:
      return {
        byteLength: 4,
        components: 3
      };
  }
  throw new Error("Unknown texture type ".concat(type, "."));
}
var TextureUtils = exports.TextureUtils = {
  contain: contain,
  cover: cover,
  fill: fill,
  getByteLength: getByteLength
};
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  var multisampledRTTExt = extensions.has('WEBGL_multisampled_render_to_texture') ? extensions.get('WEBGL_multisampled_render_to_texture') : null;
  var supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test(navigator.userAgent);
  var _imageDimensions = new Vector2();
  var _videoTextures = new WeakMap();
  var _canvas;
  var _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

  // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

  var useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
    // eslint-disable-next-line compat/compat
    && new OffscreenCanvas(1, 1).getContext('2d') !== null;
  } catch (err) {

    // Ignore any errors
  }
  function createCanvas(width, height) {
    // Use OffscreenCanvas when available. Specially needed in web workers

    return useOffscreenCanvas ?
    // eslint-disable-next-line compat/compat
    new OffscreenCanvas(width, height) : createElementNS('canvas');
  }
  function resizeImage(image, needsNewCanvas, maxSize) {
    var scale = 1;
    var dimensions = getDimensions(image);

    // handle case if texture exceeds max size

    if (dimensions.width > maxSize || dimensions.height > maxSize) {
      scale = maxSize / Math.max(dimensions.width, dimensions.height);
    }

    // only perform resize if necessary

    if (scale < 1) {
      // only perform resize for certain image types

      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap || typeof VideoFrame !== 'undefined' && image instanceof VideoFrame) {
        var width = Math.floor(scale * dimensions.width);
        var height = Math.floor(scale * dimensions.height);
        if (_canvas === undefined) _canvas = createCanvas(width, height);

        // cube textures can't reuse the same canvas

        var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').');
        return canvas;
      } else {
        if ('data' in image) {
          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').');
        }
        return image;
      }
    }
    return image;
  }
  function textureNeedsGenerateMipmaps(texture) {
    return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace) {
    var forceLinearTransfer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
    }
    var internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.R8I;
      if (glType === _gl.SHORT) internalFormat = _gl.R16I;
      if (glType === _gl.INT) internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RG_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
      if (glType === _gl.INT) internalFormat = _gl.RG32I;
    }
    if (glFormat === _gl.RGB) {
      if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
    }
    if (glFormat === _gl.RGBA) {
      var transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get('EXT_color_buffer_float');
    }
    return internalFormat;
  }
  function getInternalDepthFormat(useStencil, depthType) {
    var glInternalFormat;
    if (useStencil) {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH32F_STENCIL8;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
        console.warn('DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.');
      }
    } else {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH_COMPONENT24;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH_COMPONENT16;
      }
    }
    return glInternalFormat;
  }
  function getMipLevels(texture, image) {
    if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {
      // user-defined mipmaps

      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      // texture without mipmaps (only base level)

      return 1;
    }
  }

  //

  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }

  //

  function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === undefined) return;

    // check if it's necessary to remove the WebGLTexture object

    var source = texture.source;
    var webglTextures = _sources.get(source);
    if (webglTextures) {
      var webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;

      // the WebGLTexture object is not used anymore, remove it

      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }

      // remove the weak map entry if no WebGLTexture uses the source anymore

      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    var textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    var source = texture.source;
    var webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (var i = 0; i < 6; i++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
          for (var level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        }
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (var _level = 0; _level < renderTargetProperties.__webglFramebuffer.length; _level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[_level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (var _i38 = 0; _i38 < renderTargetProperties.__webglColorRenderbuffer.length; _i38++) {
          if (renderTargetProperties.__webglColorRenderbuffer[_i38]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[_i38]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    var textures = renderTarget.textures;
    for (var _i39 = 0, il = textures.length; _i39 < il; _i39++) {
      var attachmentProperties = properties.get(textures[_i39]);
      if (attachmentProperties.__webglTexture) {
        _gl.deleteTexture(attachmentProperties.__webglTexture);
        info.memory.textures--;
      }
      properties.remove(textures[_i39]);
    }
    properties.remove(renderTarget);
  }

  //

  var textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    var textureUnit = textureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    var array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }

  //

  function setTexture2D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      var image = texture.image;
      if (image === null) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
      } else if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  var wrappingToGL = _defineProperty(_defineProperty(_defineProperty({}, RepeatWrapping, _gl.REPEAT), ClampToEdgeWrapping, _gl.CLAMP_TO_EDGE), MirroredRepeatWrapping, _gl.MIRRORED_REPEAT);
  var filterToGL = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, NearestFilter, _gl.NEAREST), NearestMipmapNearestFilter, _gl.NEAREST_MIPMAP_NEAREST), NearestMipmapLinearFilter, _gl.NEAREST_MIPMAP_LINEAR), LinearFilter, _gl.LINEAR), LinearMipmapNearestFilter, _gl.LINEAR_MIPMAP_NEAREST), LinearMipmapLinearFilter, _gl.LINEAR_MIPMAP_LINEAR);
  var compareToGL = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, NeverCompare, _gl.NEVER), AlwaysCompare, _gl.ALWAYS), LessCompare, _gl.LESS), LessEqualCompare, _gl.LEQUAL), EqualCompare, _gl.EQUAL), GreaterEqualCompare, _gl.GEQUAL), GreaterCompare, _gl.GREATER), NotEqualCompare, _gl.NOTEQUAL);
  function setTextureParameters(textureType, texture) {
    if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
      console.warn('THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.');
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has('EXT_texture_filter_anisotropic') === true) {
      if (texture.magFilter === NearestFilter) return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
      if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension

      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        var extension = extensions.get('EXT_texture_filter_anisotropic');
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    var forceUpload = false;
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
    }

    // create Source <-> WebGLTextures mapping if necessary

    var source = texture.source;
    var webglTextures = _sources.get(source);
    if (webglTextures === undefined) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }

    // check if there is already a WebGLTexture object for the given texture parameters

    var textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      // if not, create a new instance of WebGLTexture

      if (webglTextures[textureCacheKey] === undefined) {
        // create new entry

        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;

        // when a new instance of WebGLTexture was created, a texture upload is required
        // even if the image contents are identical

        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;

      // every time the texture cache key changes, it's necessary to check if an instance of
      // WebGLTexture can be deleted in order to avoid a memory leak.

      var webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== undefined) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }

      // store references to cache key and WebGLTexture object

      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    var textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
    var forceUpload = initTexture(textureProperties, texture);
    var source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    var sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      var workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      var texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      var unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      var image = resizeImage(texture.image, false, capabilities.maxTextureSize);
      image = verifyColorSpace(texture, image);
      var glFormat = utils.convert(texture.format, texture.colorSpace);
      var glType = utils.convert(texture.type);
      var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
      setTextureParameters(textureType, texture);
      var mipmap;
      var mipmaps = texture.mipmaps;
      var useTexStorage = texture.isVideoTexture !== true;
      var allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
      var dataReady = source.dataReady;
      var levels = getMipLevels(texture, image);
      if (texture.isDepthTexture) {
        glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);

        //

        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels

        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (var _i40 = 0, _il9 = mipmaps.length; _i40 < _il9; _i40++) {
            mipmap = mipmaps[_i40];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    if (texture.layerUpdates.size > 0) {
                      var layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                      var _iterator4 = _createForOfIteratorHelper(texture.layerUpdates),
                        _step4;
                      try {
                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                          var layerIndex = _step4.value;
                          var layerData = mipmap.data.subarray(layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT, (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT);
                          state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, _i40, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData, 0, 0);
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }
                      texture.clearLayerUpdates();
                    } else {
                      state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, _i40, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
                    }
                  }
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, _i40, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, _i40, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, _i40, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (var _i41 = 0, _il10 = mipmaps.length; _i41 < _il10; _i41++) {
            mipmap = mipmaps[_i41];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, _i41, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, _i41, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, _i41, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, _i41, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            if (texture.layerUpdates.size > 0) {
              var _layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);
              var _iterator5 = _createForOfIteratorHelper(texture.layerUpdates),
                _step5;
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  var _layerIndex = _step5.value;
                  var _layerData = image.data.subarray(_layerIndex * _layerByteLength / image.data.BYTES_PER_ELEMENT, (_layerIndex + 1) * _layerByteLength / image.data.BYTES_PER_ELEMENT);
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, _layerIndex, image.width, image.height, 1, glFormat, glType, _layerData);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              texture.clearLayerUpdates();
            } else {
              state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            }
          }
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          }
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            var width = image.width,
              height = image.height;
            for (var _i42 = 0; _i42 < levels; _i42++) {
              state.texImage2D(_gl.TEXTURE_2D, _i42, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        // regular Texture (image, video, canvas)

        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels

        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            var dimensions = getDimensions(mipmaps[0]);
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
          }
          for (var _i43 = 0, _il11 = mipmaps.length; _i43 < _il11; _i43++) {
            mipmap = mipmaps[_i43];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, _i43, 0, 0, glFormat, glType, mipmap);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, _i43, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              var _dimensions = getDimensions(image);
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, _dimensions.width, _dimensions.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    var forceUpload = initTexture(textureProperties, texture);
    var source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    var sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      var workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      var texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      var unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      var isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      var cubeImage = [];
      for (var i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], true, capabilities.maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
        cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
      }
      var image = cubeImage[0],
        glFormat = utils.convert(texture.format, texture.colorSpace),
        glType = utils.convert(texture.type),
        glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      var useTexStorage = texture.isVideoTexture !== true;
      var allocateMemory = sourceProperties.__version === undefined || forceUpload === true;
      var dataReady = source.dataReady;
      var levels = getMipLevels(texture, image);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      var mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (var _i44 = 0; _i44 < 6; _i44++) {
          mipmaps = cubeImage[_i44].mipmaps;
          for (var j = 0; j < mipmaps.length; j++) {
            var mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i44, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i44, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i44, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i44, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          // TODO: Uniformly handle mipmap definitions
          // Normal textures and compressed cube textures define base level + mips with their mipmap array
          // Uncompressed cube textures use their mipmap array only for mips (no base level)

          if (mipmaps.length > 0) levels++;
          var dimensions = getDimensions(cubeImage[0]);
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
        }
        for (var _i45 = 0; _i45 < 6; _i45++) {
          if (isDataTexture) {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i45, 0, 0, 0, cubeImage[_i45].width, cubeImage[_i45].height, glFormat, glType, cubeImage[_i45].data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i45, 0, glInternalFormat, cubeImage[_i45].width, cubeImage[_i45].height, 0, glFormat, glType, cubeImage[_i45].data);
            }
            for (var _j3 = 0; _j3 < mipmaps.length; _j3++) {
              var _mipmap = mipmaps[_j3];
              var mipmapImage = _mipmap.image[_i45].image;
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i45, _j3 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i45, _j3 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i45, 0, 0, 0, glFormat, glType, cubeImage[_i45]);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i45, 0, glInternalFormat, glFormat, glType, cubeImage[_i45]);
            }
            for (var _j4 = 0; _j4 < mipmaps.length; _j4++) {
              var _mipmap2 = mipmaps[_j4];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i45, _j4 + 1, 0, 0, glFormat, glType, _mipmap2.image[_i45]);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i45, _j4 + 1, glInternalFormat, glFormat, glType, _mipmap2.image[_i45]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        // We assume images for cube map have the same size.
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }

  // Render targets

  // Setup storage for target texture and bind it to correct framebuffer
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
    var glFormat = utils.convert(texture.format, texture.colorSpace);
    var glType = utils.convert(texture.type);
    var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    var renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      var width = Math.max(1, renderTarget.width >> level);
      var height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      // see #24753

      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }

  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer) {
      // retrieve the depth attachment types
      var depthTexture = renderTarget.depthTexture;
      var depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
      var glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
      var glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

      // set up the attachment
      var samples = getRenderTargetSamples(renderTarget);
      var isUseMultisampledRTT = useMultisampledRTT(renderTarget);
      if (isUseMultisampledRTT) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (isMultisample) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
    } else {
      var textures = renderTarget.textures;
      for (var i = 0; i < textures.length; i++) {
        var texture = textures[i];
        var glFormat = utils.convert(texture.format, texture.colorSpace);
        var glType = utils.convert(texture.type);
        var _glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        var _samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, _samples, _glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, _samples, _glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }

  // Setup resources for a Depth Texture for a FBO (needs an extension)
  function setupDepthTexture(framebuffer, renderTarget) {
    var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    }

    // upload an empty depth texture with framebuffer size
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    var samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error('Unknown depthTexture format');
    }
  }

  // Setup GL resources for a non-texture depth buffer
  function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (var i = 0; i < 6; i++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }

  // rebind framebuffer with external textures
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    var renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== undefined) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== undefined) {
      setupDepthRenderbuffer(renderTarget);
    }
  }

  // Set up GL resources for the render target
  function setupRenderTarget(renderTarget) {
    var texture = renderTarget.texture;
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);
    var textures = renderTarget.textures;
    var isCube = renderTarget.isWebGLCubeRenderTarget === true;
    var isMultipleRenderTargets = textures.length > 1;
    if (!isMultipleRenderTargets) {
      if (textureProperties.__webglTexture === undefined) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }

    // Setup framebuffer

    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (var i = 0; i < 6; i++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i] = [];
          for (var level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      }
    } else {
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (var _level2 = 0; _level2 < texture.mipmaps.length; _level2++) {
          renderTargetProperties.__webglFramebuffer[_level2] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        for (var _i46 = 0, il = textures.length; _i46 < il; _i46++) {
          var attachmentProperties = properties.get(textures[_i46]);
          if (attachmentProperties.__webglTexture === undefined) {
            attachmentProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
      }
      if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (var _i47 = 0; _i47 < textures.length; _i47++) {
          var _texture = textures[_i47];
          renderTargetProperties.__webglColorRenderbuffer[_i47] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[_i47]);
          var glFormat = utils.convert(_texture.format, _texture.colorSpace);
          var glType = utils.convert(_texture.type);
          var glInternalFormat = getInternalFormat(_texture.internalFormat, glFormat, glType, _texture.colorSpace, renderTarget.isXRRenderTarget === true);
          var samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + _i47, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[_i47]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }

    // Setup color buffer

    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      for (var _i48 = 0; _i48 < 6; _i48++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          for (var _level3 = 0; _level3 < texture.mipmaps.length; _level3++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i48][_level3], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i48, _level3);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i48], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i48, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      for (var _i49 = 0, _il12 = textures.length; _i49 < _il12; _i49++) {
        var attachment = textures[_i49];
        var _attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, _attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + _i49, _gl.TEXTURE_2D, 0);
        if (textureNeedsGenerateMipmaps(attachment)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      var glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture);
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        for (var _level4 = 0; _level4 < texture.mipmaps.length; _level4++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_level4], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, _level4);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }

    // Setup depth and stencil buffers

    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    var textures = renderTarget.textures;
    for (var i = 0, il = textures.length; i < il; i++) {
      var texture = textures[i];
      if (textureNeedsGenerateMipmaps(texture)) {
        var target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        var webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  var invalidationArrayRead = [];
  var invalidationArrayDraw = [];
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.samples > 0) {
      if (useMultisampledRTT(renderTarget) === false) {
        var textures = renderTarget.textures;
        var width = renderTarget.width;
        var height = renderTarget.height;
        var mask = _gl.COLOR_BUFFER_BIT;
        var depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        var renderTargetProperties = properties.get(renderTarget);
        var isMultipleRenderTargets = textures.length > 1;

        // If MRT we need to remove FBO attachments
        if (isMultipleRenderTargets) {
          for (var i = 0; i < textures.length; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        for (var _i50 = 0; _i50 < textures.length; _i50++) {
          if (renderTarget.resolveDepthBuffer) {
            if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;

            // resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)

            if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[_i50]);
            var webglTexture = properties.get(textures[_i50]).__webglTexture;
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
          if (supportsInvalidateFramebuffer === true) {
            invalidationArrayRead.length = 0;
            invalidationArrayDraw.length = 0;
            invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + _i50);
            if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
              invalidationArrayRead.push(depthStyle);
              invalidationArrayDraw.push(depthStyle);
              _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
            }
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);

        // If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
        if (isMultipleRenderTargets) {
          for (var _i51 = 0; _i51 < textures.length; _i51++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + _i51, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[_i51]);
            var _webglTexture = properties.get(textures[_i51]).__webglTexture;
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + _i51, _gl.TEXTURE_2D, _webglTexture, 0);
          }
        }
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
          var _depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [_depthStyle]);
        }
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(capabilities.maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    return renderTarget.samples > 0 && extensions.has('WEBGL_multisampled_render_to_texture') === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    var frame = info.render.frame;

    // Check the last frame we updated the VideoTexture

    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    var colorSpace = texture.colorSpace;
    var format = texture.format;
    var type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      // sRGB

      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
        // in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

        if (format !== RGBAFormat || type !== UnsignedByteType) {
          console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');
        }
      } else {
        console.error('THREE.WebGLTextures: Unsupported texture color space:', colorSpace);
      }
    }
    return image;
  }
  function getDimensions(image) {
    if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) {
      // if intrinsic data are not available, fallback to width/height

      _imageDimensions.width = image.naturalWidth || image.width;
      _imageDimensions.height = image.naturalHeight || image.height;
    } else if (typeof VideoFrame !== 'undefined' && image instanceof VideoFrame) {
      _imageDimensions.width = image.displayWidth;
      _imageDimensions.height = image.displayHeight;
    } else {
      _imageDimensions.width = image.width;
      _imageDimensions.height = image.height;
    }
    return _imageDimensions;
  }

  //

  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions) {
  function convert(p) {
    var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NoColorSpace;
    var extension;
    var transfer = ColorManagement.getTransfer(colorSpace);
    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p === ByteType) return gl.BYTE;
    if (p === ShortType) return gl.SHORT;
    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p === IntType) return gl.INT;
    if (p === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p === FloatType) return gl.FLOAT;
    if (p === HalfFloatType) return gl.HALF_FLOAT;
    if (p === AlphaFormat) return gl.ALPHA;
    if (p === RGBFormat) return gl.RGB;
    if (p === RGBAFormat) return gl.RGBA;
    if (p === LuminanceFormat) return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;

    // WebGL2 formats.

    if (p === RedFormat) return gl.RED;
    if (p === RedIntegerFormat) return gl.RED_INTEGER;
    if (p === RGFormat) return gl.RG;
    if (p === RGIntegerFormat) return gl.RG_INTEGER;
    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

    // S3TC

    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get('WEBGL_compressed_texture_s3tc');
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }

    // PVRTC

    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }

    // ETC

    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc');
      if (extension !== null) {
        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }

    // ASTC

    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get('WEBGL_compressed_texture_astc');
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }

    // BPTC

    if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {
      extension = extensions.get('EXT_texture_compression_bptc');
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }

    // RGTC

    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get('EXT_texture_compression_rgtc');
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }

    //

    if (p === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;

    // if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

    return gl[p] !== undefined ? gl[p] : null;
  }
  return {
    convert: convert
  };
}
var ArrayCamera = exports.ArrayCamera = /*#__PURE__*/function (_PerspectiveCamera) {
  function ArrayCamera() {
    var _this27;
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    _classCallCheck(this, ArrayCamera);
    _this27 = _callSuper(this, ArrayCamera);
    _this27.isArrayCamera = true;
    _this27.cameras = array;
    return _this27;
  }
  _inherits(ArrayCamera, _PerspectiveCamera);
  return _createClass(ArrayCamera);
}(PerspectiveCamera);
var Group = exports.Group = /*#__PURE__*/function (_Object3D4) {
  function Group() {
    var _this28;
    _classCallCheck(this, Group);
    _this28 = _callSuper(this, Group);
    _this28.isGroup = true;
    _this28.type = 'Group';
    return _this28;
  }
  _inherits(Group, _Object3D4);
  return _createClass(Group);
}(Object3D);
var _moveEvent = {
  type: 'move'
};
var WebXRController = /*#__PURE__*/function () {
  function WebXRController() {
    _classCallCheck(this, WebXRController);
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  return _createClass(WebXRController, [{
    key: "getHandSpace",
    value: function getHandSpace() {
      if (this._hand === null) {
        this._hand = new Group();
        this._hand.matrixAutoUpdate = false;
        this._hand.visible = false;
        this._hand.joints = {};
        this._hand.inputState = {
          pinching: false
        };
      }
      return this._hand;
    }
  }, {
    key: "getTargetRaySpace",
    value: function getTargetRaySpace() {
      if (this._targetRay === null) {
        this._targetRay = new Group();
        this._targetRay.matrixAutoUpdate = false;
        this._targetRay.visible = false;
        this._targetRay.hasLinearVelocity = false;
        this._targetRay.linearVelocity = new Vector3();
        this._targetRay.hasAngularVelocity = false;
        this._targetRay.angularVelocity = new Vector3();
      }
      return this._targetRay;
    }
  }, {
    key: "getGripSpace",
    value: function getGripSpace() {
      if (this._grip === null) {
        this._grip = new Group();
        this._grip.matrixAutoUpdate = false;
        this._grip.visible = false;
        this._grip.hasLinearVelocity = false;
        this._grip.linearVelocity = new Vector3();
        this._grip.hasAngularVelocity = false;
        this._grip.angularVelocity = new Vector3();
      }
      return this._grip;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (this._targetRay !== null) {
        this._targetRay.dispatchEvent(event);
      }
      if (this._grip !== null) {
        this._grip.dispatchEvent(event);
      }
      if (this._hand !== null) {
        this._hand.dispatchEvent(event);
      }
      return this;
    }
  }, {
    key: "connect",
    value: function connect(inputSource) {
      if (inputSource && inputSource.hand) {
        var hand = this._hand;
        if (hand) {
          var _iterator6 = _createForOfIteratorHelper(inputSource.hand.values()),
            _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var inputjoint = _step6.value;
              // Initialize hand with joints when connected
              this._getHandJoint(hand, inputjoint);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
      }
      this.dispatchEvent({
        type: 'connected',
        data: inputSource
      });
      return this;
    }
  }, {
    key: "disconnect",
    value: function disconnect(inputSource) {
      this.dispatchEvent({
        type: 'disconnected',
        data: inputSource
      });
      if (this._targetRay !== null) {
        this._targetRay.visible = false;
      }
      if (this._grip !== null) {
        this._grip.visible = false;
      }
      if (this._hand !== null) {
        this._hand.visible = false;
      }
      return this;
    }
  }, {
    key: "update",
    value: function update(inputSource, frame, referenceSpace) {
      var inputPose = null;
      var gripPose = null;
      var handPose = null;
      var targetRay = this._targetRay;
      var grip = this._grip;
      var hand = this._hand;
      if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
        if (hand && inputSource.hand) {
          handPose = true;
          var _iterator7 = _createForOfIteratorHelper(inputSource.hand.values()),
            _step7;
          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var inputjoint = _step7.value;
              // Update the joints groups with the XRJoint poses
              var jointPose = frame.getJointPose(inputjoint, referenceSpace);

              // The transform of this joint will be updated with the joint pose on each frame
              var joint = this._getHandJoint(hand, inputjoint);
              if (jointPose !== null) {
                joint.matrix.fromArray(jointPose.transform.matrix);
                joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                joint.matrixWorldNeedsUpdate = true;
                joint.jointRadius = jointPose.radius;
              }
              joint.visible = jointPose !== null;
            }

            // Custom events

            // Check pinchz
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
          var indexTip = hand.joints['index-finger-tip'];
          var thumbTip = hand.joints['thumb-tip'];
          var distance = indexTip.position.distanceTo(thumbTip.position);
          var distanceToPinch = 0.02;
          var threshold = 0.005;
          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
            hand.inputState.pinching = false;
            this.dispatchEvent({
              type: 'pinchend',
              handedness: inputSource.handedness,
              target: this
            });
          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
            hand.inputState.pinching = true;
            this.dispatchEvent({
              type: 'pinchstart',
              handedness: inputSource.handedness,
              target: this
            });
          }
        } else {
          if (grip !== null && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
            if (gripPose !== null) {
              grip.matrix.fromArray(gripPose.transform.matrix);
              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
              grip.matrixWorldNeedsUpdate = true;
              if (gripPose.linearVelocity) {
                grip.hasLinearVelocity = true;
                grip.linearVelocity.copy(gripPose.linearVelocity);
              } else {
                grip.hasLinearVelocity = false;
              }
              if (gripPose.angularVelocity) {
                grip.hasAngularVelocity = true;
                grip.angularVelocity.copy(gripPose.angularVelocity);
              } else {
                grip.hasAngularVelocity = false;
              }
            }
          }
        }
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

          // Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
          if (inputPose === null && gripPose !== null) {
            inputPose = gripPose;
          }
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
            targetRay.matrixWorldNeedsUpdate = true;
            if (inputPose.linearVelocity) {
              targetRay.hasLinearVelocity = true;
              targetRay.linearVelocity.copy(inputPose.linearVelocity);
            } else {
              targetRay.hasLinearVelocity = false;
            }
            if (inputPose.angularVelocity) {
              targetRay.hasAngularVelocity = true;
              targetRay.angularVelocity.copy(inputPose.angularVelocity);
            } else {
              targetRay.hasAngularVelocity = false;
            }
            this.dispatchEvent(_moveEvent);
          }
        }
      }
      if (targetRay !== null) {
        targetRay.visible = inputPose !== null;
      }
      if (grip !== null) {
        grip.visible = gripPose !== null;
      }
      if (hand !== null) {
        hand.visible = handPose !== null;
      }
      return this;
    }

    // private method
  }, {
    key: "_getHandJoint",
    value: function _getHandJoint(hand, inputjoint) {
      if (hand.joints[inputjoint.jointName] === undefined) {
        var joint = new Group();
        joint.matrixAutoUpdate = false;
        joint.visible = false;
        hand.joints[inputjoint.jointName] = joint;
        hand.add(joint);
      }
      return hand.joints[inputjoint.jointName];
    }
  }]);
}();
var _occlusion_vertex = "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}";
var _occlusion_fragment = "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}";
var WebXRDepthSensing = /*#__PURE__*/function () {
  function WebXRDepthSensing() {
    _classCallCheck(this, WebXRDepthSensing);
    this.texture = null;
    this.mesh = null;
    this.depthNear = 0;
    this.depthFar = 0;
  }
  return _createClass(WebXRDepthSensing, [{
    key: "init",
    value: function init(renderer, depthData, renderState) {
      if (this.texture === null) {
        var texture = new Texture();
        var texProps = renderer.properties.get(texture);
        texProps.__webglTexture = depthData.texture;
        if (depthData.depthNear != renderState.depthNear || depthData.depthFar != renderState.depthFar) {
          this.depthNear = depthData.depthNear;
          this.depthFar = depthData.depthFar;
        }
        this.texture = texture;
      }
    }
  }, {
    key: "getMesh",
    value: function getMesh(cameraXR) {
      if (this.texture !== null) {
        if (this.mesh === null) {
          var viewport = cameraXR.cameras[0].viewport;
          var material = new ShaderMaterial({
            vertexShader: _occlusion_vertex,
            fragmentShader: _occlusion_fragment,
            uniforms: {
              depthColor: {
                value: this.texture
              },
              depthWidth: {
                value: viewport.z
              },
              depthHeight: {
                value: viewport.w
              }
            }
          });
          this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
        }
      }
      return this.mesh;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.texture = null;
      this.mesh = null;
    }
  }, {
    key: "getDepthTexture",
    value: function getDepthTexture() {
      return this.texture;
    }
  }]);
}();
var WebXRManager = /*#__PURE__*/function (_EventDispatcher6) {
  function WebXRManager(renderer, gl) {
    var _this29;
    _classCallCheck(this, WebXRManager);
    _this29 = _callSuper(this, WebXRManager);
    var scope = _this29;
    var session = null;
    var framebufferScaleFactor = 1.0;
    var referenceSpace = null;
    var referenceSpaceType = 'local-floor';
    // Set default foveation to maximum.
    var foveation = 1.0;
    var customReferenceSpace = null;
    var pose = null;
    var glBinding = null;
    var glProjLayer = null;
    var glBaseLayer = null;
    var xrFrame = null;
    var depthSensing = new WebXRDepthSensing();
    var attributes = gl.getContextAttributes();
    var initialRenderTarget = null;
    var newRenderTarget = null;
    var controllers = [];
    var controllerInputSources = [];
    var currentSize = new Vector2();
    var currentPixelRatio = null;

    //

    var cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    var cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    var cameras = [cameraL, cameraR];
    var cameraXR = new ArrayCamera();
    cameraXR.layers.enable(1);
    cameraXR.layers.enable(2);
    var _currentDepthNear = null;
    var _currentDepthFar = null;

    //

    _this29.cameraAutoUpdate = true;
    _this29.enabled = false;
    _this29.isPresenting = false;
    _this29.getController = function (index) {
      var controller = controllers[index];
      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    _this29.getControllerGrip = function (index) {
      var controller = controllers[index];
      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    _this29.getHand = function (index) {
      var controller = controllers[index];
      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };

    //

    function onSessionEvent(event) {
      var controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      var controller = controllers[controllerIndex];
      if (controller !== undefined) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({
          type: event.type,
          data: event.inputSource
        });
      }
    }
    function onSessionEnd() {
      session.removeEventListener('select', onSessionEvent);
      session.removeEventListener('selectstart', onSessionEvent);
      session.removeEventListener('selectend', onSessionEvent);
      session.removeEventListener('squeeze', onSessionEvent);
      session.removeEventListener('squeezestart', onSessionEvent);
      session.removeEventListener('squeezeend', onSessionEvent);
      session.removeEventListener('end', onSessionEnd);
      session.removeEventListener('inputsourceschange', onInputSourcesChange);
      for (var i = 0; i < controllers.length; i++) {
        var inputSource = controllerInputSources[i];
        if (inputSource === null) continue;
        controllerInputSources[i] = null;
        controllers[i].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      depthSensing.reset();

      // restore framebuffer/rendering state

      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;

      //

      animation.stop();
      scope.isPresenting = false;
      renderer.setPixelRatio(currentPixelRatio);
      renderer.setSize(currentSize.width, currentSize.height, false);
      scope.dispatchEvent({
        type: 'sessionend'
      });
    }
    _this29.setFramebufferScaleFactor = function (value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
      }
    };
    _this29.setReferenceSpaceType = function (value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
      }
    };
    _this29.getReferenceSpace = function () {
      return customReferenceSpace || referenceSpace;
    };
    _this29.setReferenceSpace = function (space) {
      customReferenceSpace = space;
    };
    _this29.getBaseLayer = function () {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    _this29.getBinding = function () {
      return glBinding;
    };
    _this29.getFrame = function () {
      return xrFrame;
    };
    _this29.getSession = function () {
      return session;
    };
    _this29.setSession = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(value) {
        var layerInit, depthFormat, depthType, glDepthFormat, projectionlayerInit;
        return _regeneratorRuntime().wrap(function _callee$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              session = value;
              if (!(session !== null)) {
                _context8.next = 27;
                break;
              }
              initialRenderTarget = renderer.getRenderTarget();
              session.addEventListener('select', onSessionEvent);
              session.addEventListener('selectstart', onSessionEvent);
              session.addEventListener('selectend', onSessionEvent);
              session.addEventListener('squeeze', onSessionEvent);
              session.addEventListener('squeezestart', onSessionEvent);
              session.addEventListener('squeezeend', onSessionEvent);
              session.addEventListener('end', onSessionEnd);
              session.addEventListener('inputsourceschange', onInputSourcesChange);
              if (!(attributes.xrCompatible !== true)) {
                _context8.next = 14;
                break;
              }
              _context8.next = 14;
              return gl.makeXRCompatible();
            case 14:
              currentPixelRatio = renderer.getPixelRatio();
              renderer.getSize(currentSize);
              if (session.renderState.layers === undefined) {
                layerInit = {
                  antialias: attributes.antialias,
                  alpha: true,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor: framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({
                  baseLayer: glBaseLayer
                });
                renderer.setPixelRatio(1);
                renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
                newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  colorSpace: renderer.outputColorSpace,
                  stencilBuffer: attributes.stencil
                });
              } else {
                depthFormat = null;
                depthType = null;
                glDepthFormat = null;
                if (attributes.depth) {
                  glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
                  depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                  depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
                }
                projectionlayerInit = {
                  colorFormat: gl.RGBA8,
                  depthFormat: glDepthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                session.updateRenderState({
                  layers: [glProjLayer]
                });
                renderer.setPixelRatio(1);
                renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
                newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
                  stencilBuffer: attributes.stencil,
                  colorSpace: renderer.outputColorSpace,
                  samples: attributes.antialias ? 4 : 0,
                  resolveDepthBuffer: glProjLayer.ignoreDepthValues === false
                });
              }
              newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

              this.setFoveation(foveation);
              customReferenceSpace = null;
              _context8.next = 22;
              return session.requestReferenceSpace(referenceSpaceType);
            case 22:
              referenceSpace = _context8.sent;
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({
                type: 'sessionstart'
              });
            case 27:
            case "end":
              return _context8.stop();
          }
        }, _callee, this);
      }));
      return function (_x3) {
        return _ref.apply(this, arguments);
      };
    }();
    _this29.getEnvironmentBlendMode = function () {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    _this29.getDepthTexture = function () {
      return depthSensing.getDepthTexture();
    };
    function onInputSourcesChange(event) {
      // Notify disconnected

      for (var i = 0; i < event.removed.length; i++) {
        var inputSource = event.removed[i];
        var index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].disconnect(inputSource);
        }
      }

      // Notify connected

      for (var _i52 = 0; _i52 < event.added.length; _i52++) {
        var _inputSource = event.added[_i52];
        var controllerIndex = controllerInputSources.indexOf(_inputSource);
        if (controllerIndex === -1) {
          // Assign input source a controller that currently has no input source

          for (var _i53 = 0; _i53 < controllers.length; _i53++) {
            if (_i53 >= controllerInputSources.length) {
              controllerInputSources.push(_inputSource);
              controllerIndex = _i53;
              break;
            } else if (controllerInputSources[_i53] === null) {
              controllerInputSources[_i53] = _inputSource;
              controllerIndex = _i53;
              break;
            }
          }

          // If all controllers do currently receive input we ignore new ones

          if (controllerIndex === -1) break;
        }
        var controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(_inputSource);
        }
      }
    }

    //

    var cameraLPos = new Vector3();
    var cameraRPos = new Vector3();

    /**
     * Assumes 2 cameras that are parallel and share an X-axis, and that
     * the cameras' projection and world matrices have already been set.
     * And that near and far planes are identical for both cameras.
     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
     */
    function setProjectionFromUnion(camera, cameraL, cameraR) {
      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
      var ipd = cameraLPos.distanceTo(cameraRPos);
      var projL = cameraL.projectionMatrix.elements;
      var projR = cameraR.projectionMatrix.elements;

      // VR systems will have identical far and near planes, and
      // most likely identical top and bottom frustum extents.
      // Use the left camera for these values.
      var near = projL[14] / (projL[10] - 1);
      var far = projL[14] / (projL[10] + 1);
      var topFov = (projL[9] + 1) / projL[5];
      var bottomFov = (projL[9] - 1) / projL[5];
      var leftFov = (projL[8] - 1) / projL[0];
      var rightFov = (projR[8] + 1) / projR[0];
      var left = near * leftFov;
      var right = near * rightFov;

      // Calculate the new camera's position offset from the
      // left camera. xOffset should be roughly half `ipd`.
      var zOffset = ipd / (-leftFov + rightFov);
      var xOffset = zOffset * -leftFov;

      // TODO: Better way to apply this offset?
      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();

      // Find the union of the frustum values of the cameras and scale
      // the values so that the near plane's position does not change in world space,
      // although must now be relative to the new union camera.
      var near2 = near + zOffset;
      var far2 = far + zOffset;
      var left2 = left - xOffset;
      var right2 = right + (ipd - xOffset);
      var top2 = topFov * far / far2 * near2;
      var bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    _this29.updateCamera = function (camera) {
      if (session === null) return;
      if (depthSensing.texture !== null) {
        camera.near = depthSensing.depthNear;
        camera.far = depthSensing.depthFar;
      }
      cameraXR.near = cameraR.near = cameraL.near = camera.near;
      cameraXR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        // Note that the new renderState won't apply until the next frame. See #18320

        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
        cameraL.near = _currentDepthNear;
        cameraL.far = _currentDepthFar;
        cameraR.near = _currentDepthNear;
        cameraR.far = _currentDepthFar;
        cameraL.updateProjectionMatrix();
        cameraR.updateProjectionMatrix();
        camera.updateProjectionMatrix();
      }
      var parent = camera.parent;
      var cameras = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (var i = 0; i < cameras.length; i++) {
        updateCamera(cameras[i], parent);
      }

      // update projection matrix for proper view frustum culling

      if (cameras.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        // assume single camera setup (AR)

        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }

      // update user camera and its children

      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    _this29.getCamera = function () {
      return cameraXR;
    };
    _this29.getFoveation = function () {
      if (glProjLayer === null && glBaseLayer === null) {
        return undefined;
      }
      return foveation;
    };
    _this29.setFoveation = function (value) {
      // 0 = no foveation = full resolution
      // 1 = maximum foveation = the edges render at lower resolution

      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    _this29.hasDepthSensing = function () {
      return depthSensing.texture !== null;
    };
    _this29.getDepthSensingMesh = function () {
      return depthSensing.getMesh(cameraXR);
    };

    // Animation Loop

    var onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        var views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        var cameraXRNeedsUpdate = false;

        // check if it's necessary to rebuild cameraXR's camera list

        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (var i = 0; i < views.length; i++) {
          var view = views[i];
          var viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            var glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;

            // For side-by-side projection, we only produce a single texture for both eyes.
            if (i === 0) {
              renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          var camera = cameras[i];
          if (camera === undefined) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i);
            camera.viewport = new Vector4();
            cameras[i] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }

        //

        var enabledFeatures = session.enabledFeatures;
        if (enabledFeatures && enabledFeatures.includes('depth-sensing')) {
          var depthData = glBinding.getDepthInformation(views[0]);
          if (depthData && depthData.isValid && depthData.texture) {
            depthSensing.init(renderer, depthData, session.renderState);
          }
        }
      }

      //

      for (var _i54 = 0; _i54 < controllers.length; _i54++) {
        var inputSource = controllerInputSources[_i54];
        var controller = controllers[_i54];
        if (inputSource !== null && controller !== undefined) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({
          type: 'planesdetected',
          data: frame
        });
      }
      xrFrame = null;
    }
    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    _this29.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback;
    };
    _this29.dispose = function () {};
    return _this29;
  }
  _inherits(WebXRManager, _EventDispatcher6);
  return _createClass(WebXRManager);
}(EventDispatcher);
var _e1 = /*@__PURE__*/new Euler();
var _m1 = /*@__PURE__*/new Matrix4();
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map, uniform) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false; // #15581
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    var materialProperties = properties.get(material);
    var envMap = materialProperties.envMap;
    var envMapRotation = materialProperties.envMapRotation;
    if (envMap) {
      uniforms.envMap.value = envMap;
      _e1.copy(envMapRotation);

      // accommodate left-handed frame
      _e1.x *= -1;
      _e1.y *= -1;
      _e1.z *= -1;
      if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
        // environment maps which are not cube render targets or PMREMs follow a different convention
        _e1.y *= -1;
        _e1.z *= -1;
      }
      uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    if (material.envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common

      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior; // also part of uniforms common

    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.dispersion > 0) {
      uniforms.dispersion.value = material.dispersion;
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    var light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms: refreshFogUniforms,
    refreshMaterialUniforms: refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
  var buffers = {};
  var updateList = {};
  var allocatedBindingPoints = [];
  var maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS); // binding points are global whereas block indices are per shader program

  function bind(uniformsGroup, program) {
    var webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    var buffer = buffers[uniformsGroup.id];
    if (buffer === undefined) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener('dispose', onUniformsGroupsDispose);
    }

    // ensure to update the binding points/block indices mapping for this program

    var webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);

    // update UBO once per frame

    var frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    // the setup of an UBO is independent of a particular shader program but global

    var bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    var buffer = gl.createBuffer();
    var size = uniformsGroup.__size;
    var usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (var i = 0; i < maxBindingPoints; i++) {
      if (allocatedBindingPoints.indexOf(i) === -1) {
        allocatedBindingPoints.push(i);
        return i;
      }
    }
    console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    var buffer = buffers[uniformsGroup.id];
    var uniforms = uniformsGroup.uniforms;
    var cache = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (var i = 0, il = uniforms.length; i < il; i++) {
      var uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (var j = 0, jl = uniformArray.length; j < jl; j++) {
        var uniform = uniformArray[j];
        if (hasUniformChanged(uniform, i, j, cache) === true) {
          var offset = uniform.__offset;
          var values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          var arrayOffset = 0;
          for (var k = 0; k < values.length; k++) {
            var value = values[k];
            var _info = getUniformSize(value);

            // TODO add integer and struct support
            if (typeof value === 'number' || typeof value === 'boolean') {
              uniform.__data[0] = value;
              gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
            } else if (value.isMatrix3) {
              // manually converting 3x3 to 3x4

              uniform.__data[0] = value.elements[0];
              uniform.__data[1] = value.elements[1];
              uniform.__data[2] = value.elements[2];
              uniform.__data[3] = 0;
              uniform.__data[4] = value.elements[3];
              uniform.__data[5] = value.elements[4];
              uniform.__data[6] = value.elements[5];
              uniform.__data[7] = 0;
              uniform.__data[8] = value.elements[6];
              uniform.__data[9] = value.elements[7];
              uniform.__data[10] = value.elements[8];
              uniform.__data[11] = 0;
            } else {
              value.toArray(uniform.__data, arrayOffset);
              arrayOffset += _info.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
        }
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index, indexArray, cache) {
    var value = uniform.value;
    var indexString = index + '_' + indexArray;
    if (cache[indexString] === undefined) {
      // cache entry does not exist so far

      if (typeof value === 'number' || typeof value === 'boolean') {
        cache[indexString] = value;
      } else {
        cache[indexString] = value.clone();
      }
      return true;
    } else {
      var cachedObject = cache[indexString];

      // compare current value with cached entry

      if (typeof value === 'number' || typeof value === 'boolean') {
        if (cachedObject !== value) {
          cache[indexString] = value;
          return true;
        }
      } else {
        if (cachedObject.equals(value) === false) {
          cachedObject.copy(value);
          return true;
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    // determine total buffer size according to the STD140 layout
    // Hint: STD140 is the only supported layout in WebGL 2

    var uniforms = uniformsGroup.uniforms;
    var offset = 0; // global buffer offset in bytes
    var chunkSize = 16; // size of a chunk in bytes

    for (var i = 0, l = uniforms.length; i < l; i++) {
      var uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (var j = 0, jl = uniformArray.length; j < jl; j++) {
        var uniform = uniformArray[j];
        var values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        for (var k = 0, kl = values.length; k < kl; k++) {
          var value = values[k];
          var _info2 = getUniformSize(value);
          var _chunkOffset = offset % chunkSize; // offset in the current chunk
          var chunkPadding = _chunkOffset % _info2.boundary; // required padding to match boundary
          var chunkStart = _chunkOffset + chunkPadding; // the start position in the current chunk for the data

          offset += chunkPadding;

          // Check for chunk overflow
          if (chunkStart !== 0 && chunkSize - chunkStart < _info2.storage) {
            // Add padding and adjust offset
            offset += chunkSize - chunkStart;
          }

          // the following two properties will be used for partial buffer updates
          uniform.__data = new Float32Array(_info2.storage / Float32Array.BYTES_PER_ELEMENT);
          uniform.__offset = offset;

          // Update the global offset
          offset += _info2.storage;
        }
      }
    }

    // ensure correct final padding

    var chunkOffset = offset % chunkSize;
    if (chunkOffset > 0) offset += chunkSize - chunkOffset;

    //

    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    var info = {
      boundary: 0,
      // bytes
      storage: 0 // bytes
    };

    // determine sizes according to STD140

    if (typeof value === 'number' || typeof value === 'boolean') {
      // float/int/bool

      info.boundary = 4;
      info.storage = 4;
    } else if (value.isVector2) {
      // vec2

      info.boundary = 8;
      info.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      // vec3

      info.boundary = 16;
      info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes
    } else if (value.isVector4) {
      // vec4

      info.boundary = 16;
      info.storage = 16;
    } else if (value.isMatrix3) {
      // mat3 (in STD140 a 3x3 matrix is represented as 3x4)

      info.boundary = 48;
      info.storage = 48;
    } else if (value.isMatrix4) {
      // mat4

      info.boundary = 64;
      info.storage = 64;
    } else if (value.isTexture) {
      console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.');
    } else {
      console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', value);
    }
    return info;
  }
  function onUniformsGroupsDispose(event) {
    var uniformsGroup = event.target;
    uniformsGroup.removeEventListener('dispose', onUniformsGroupsDispose);
    var index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (var id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind: bind,
    update: update,
    dispose: dispose
  };
}
var WebGLRenderer = exports.WebGLRenderer = /*#__PURE__*/function () {
  function WebGLRenderer() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, WebGLRenderer);
    var _parameters$canvas = parameters.canvas,
      canvas = _parameters$canvas === void 0 ? createCanvasElement() : _parameters$canvas,
      _parameters$context = parameters.context,
      context = _parameters$context === void 0 ? null : _parameters$context,
      _parameters$depth = parameters.depth,
      depth = _parameters$depth === void 0 ? true : _parameters$depth,
      _parameters$stencil = parameters.stencil,
      stencil = _parameters$stencil === void 0 ? false : _parameters$stencil,
      _parameters$alpha = parameters.alpha,
      alpha = _parameters$alpha === void 0 ? false : _parameters$alpha,
      _parameters$antialias = parameters.antialias,
      antialias = _parameters$antialias === void 0 ? false : _parameters$antialias,
      _parameters$premultip = parameters.premultipliedAlpha,
      premultipliedAlpha = _parameters$premultip === void 0 ? true : _parameters$premultip,
      _parameters$preserveD = parameters.preserveDrawingBuffer,
      preserveDrawingBuffer = _parameters$preserveD === void 0 ? false : _parameters$preserveD,
      _parameters$powerPref = parameters.powerPreference,
      powerPreference = _parameters$powerPref === void 0 ? 'default' : _parameters$powerPref,
      _parameters$failIfMaj = parameters.failIfMajorPerformanceCaveat,
      failIfMajorPerformanceCaveat = _parameters$failIfMaj === void 0 ? false : _parameters$failIfMaj;
    this.isWebGLRenderer = true;
    var _alpha;
    if (context !== null) {
      if (typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext) {
        throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.');
      }
      _alpha = context.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    var uintClearColor = new Uint32Array(4);
    var intClearColor = new Int32Array(4);
    var currentRenderList = null;
    var currentRenderState = null;

    // render() can be called from within a callback triggered by another render.
    // We track this so that the nested render call gets its list and state isolated from the parent render call.

    var renderListStack = [];
    var renderStateStack = [];

    // public properties

    this.domElement = canvas;

    // Debug configuration container
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    };

    // clearing

    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;

    // scene graph

    this.sortObjects = true;

    // user-defined clipping

    this.clippingPlanes = [];
    this.localClippingEnabled = false;

    // physically based shading

    this._outputColorSpace = SRGBColorSpace;

    // tone mapping

    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1.0;

    // internal properties

    var _this = this;
    var _isContextLost = false;

    // internal state cache

    var _currentActiveCubeFace = 0;
    var _currentActiveMipmapLevel = 0;
    var _currentRenderTarget = null;
    var _currentMaterialId = -1;
    var _currentCamera = null;
    var _currentViewport = new Vector4();
    var _currentScissor = new Vector4();
    var _currentScissorTest = null;
    var _currentClearColor = new Color(0x000000);
    var _currentClearAlpha = 0;

    //

    var _width = canvas.width;
    var _height = canvas.height;
    var _pixelRatio = 1;
    var _opaqueSort = null;
    var _transparentSort = null;
    var _viewport = new Vector4(0, 0, _width, _height);
    var _scissor = new Vector4(0, 0, _width, _height);
    var _scissorTest = false;

    // frustum

    var _frustum = new Frustum();

    // clipping

    var _clippingEnabled = false;
    var _localClippingEnabled = false;

    // camera matrices cache

    var _projScreenMatrix = new Matrix4();
    var _vector3 = new Vector3();
    var _vector4 = new Vector4();
    var _emptyScene = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: true
    };
    var _renderBackground = false;
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }

    // initialize

    var _gl = context;
    function getContext(contextName, contextAttributes) {
      return canvas.getContext(contextName, contextAttributes);
    }
    try {
      var contextAttributes = {
        alpha: true,
        depth: depth,
        stencil: stencil,
        antialias: antialias,
        premultipliedAlpha: premultipliedAlpha,
        preserveDrawingBuffer: preserveDrawingBuffer,
        powerPreference: powerPreference,
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
      };

      // OffscreenCanvas does not have setAttribute, see #22811
      if ('setAttribute' in canvas) canvas.setAttribute('data-engine', "three.js r".concat(REVISION));

      // event listeners must be registered before WebGL context is created, see #12753
      canvas.addEventListener('webglcontextlost', onContextLost, false);
      canvas.addEventListener('webglcontextrestored', onContextRestore, false);
      canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
      if (_gl === null) {
        var contextName = 'webgl2';
        _gl = getContext(contextName, contextAttributes);
        if (_gl === null) {
          if (getContext(contextName)) {
            throw new Error('Error creating WebGL context with your selected attributes.');
          } else {
            throw new Error('Error creating WebGL context.');
          }
        }
      }
    } catch (error) {
      console.error('THREE.WebGLRenderer: ' + error.message);
      throw error;
    }
    var extensions, capabilities, state, info;
    var properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    var programCache, materials, renderLists, renderStates, clipping, shadowMap;
    var background, morphtargets, bufferRenderer, indexedBufferRenderer;
    var utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      extensions.init();
      utils = new WebGLUtils(_gl, extensions);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
      state = new WebGLState(_gl);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl);
      bindingStates = new WebGLBindingStates(_gl, attributes);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();

    // xr

    var xr = new WebXRManager(_this, _gl);
    this.xr = xr;

    // API

    this.getContext = function () {
      return _gl;
    };
    this.getContextAttributes = function () {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function () {
      var extension = extensions.get('WEBGL_lose_context');
      if (extension) extension.loseContext();
    };
    this.forceContextRestore = function () {
      var extension = extensions.get('WEBGL_lose_context');
      if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function () {
      return _pixelRatio;
    };
    this.setPixelRatio = function (value) {
      if (value === undefined) return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function (target) {
      return target.set(_width, _height);
    };
    this.setSize = function (width, height) {
      var updateStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (xr.isPresenting) {
        console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function (target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function (width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function (target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function (target) {
      return target.copy(_viewport);
    };
    this.setViewport = function (x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
    };
    this.getScissor = function (target) {
      return target.copy(_scissor);
    };
    this.setScissor = function (x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
    };
    this.getScissorTest = function () {
      return _scissorTest;
    };
    this.setScissorTest = function (boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function (method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function (method) {
      _transparentSort = method;
    };

    // Clearing

    this.getClearColor = function (target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function () {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function () {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function () {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function () {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var bits = 0;
      if (color) {
        // check if we're trying to clear an integer target
        var isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          var targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
        }

        // use the appropriate clear functions to clear the target if it's a signed
        // or unsigned integer target
        if (isIntegerFormat) {
          var targetType = _currentRenderTarget.texture.type;
          var isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
          var clearColor = background.getClearColor();
          var a = background.getClearAlpha();
          var r = clearColor.r;
          var g = clearColor.g;
          var b = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r;
            uintClearColor[1] = g;
            uintClearColor[2] = b;
            uintClearColor[3] = a;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r;
            intClearColor[1] = g;
            intClearColor[2] = b;
            intClearColor[3] = a;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth) bits |= _gl.DEPTH_BUFFER_BIT;
      if (stencil) {
        bits |= _gl.STENCIL_BUFFER_BIT;
        this.state.buffers.stencil.setMask(0xffffffff);
      }
      _gl.clear(bits);
    };
    this.clearColor = function () {
      this.clear(true, false, false);
    };
    this.clearDepth = function () {
      this.clear(false, true, false);
    };
    this.clearStencil = function () {
      this.clear(false, false, true);
    };

    //

    this.dispose = function () {
      canvas.removeEventListener('webglcontextlost', onContextLost, false);
      canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
      canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener('sessionstart', onXRSessionStart);
      xr.removeEventListener('sessionend', onXRSessionEnd);
      animation.stop();
    };

    // Events

    function onContextLost(event) {
      event.preventDefault();
      console.log('THREE.WebGLRenderer: Context Lost.');
      _isContextLost = true;
    }
    function onContextRestore( /* event */
    ) {
      console.log('THREE.WebGLRenderer: Context Restored.');
      _isContextLost = false;
      var infoAutoReset = info.autoReset;
      var shadowMapEnabled = shadowMap.enabled;
      var shadowMapAutoUpdate = shadowMap.autoUpdate;
      var shadowMapNeedsUpdate = shadowMap.needsUpdate;
      var shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage);
    }
    function onMaterialDispose(event) {
      var material = event.target;
      material.removeEventListener('dispose', onMaterialDispose);
      deallocateMaterial(material);
    }

    // Buffer deallocation

    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      var programs = properties.get(material).programs;
      if (programs !== undefined) {
        programs.forEach(function (program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }

    // Buffer rendering

    this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
      if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

      var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      var program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);

      //

      var index = geometry.index;
      var rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        if (index === undefined) return;
        rangeFactor = 2;
      }

      //

      var drawRange = geometry.drawRange;
      var position = geometry.attributes.position;
      var drawStart = drawRange.start * rangeFactor;
      var drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== undefined && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      var drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity) return;

      //

      bindingStates.setup(object, material, program, geometry, index);
      var attribute;
      var renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }

      //

      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        var lineWidth = material.linewidth;
        if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isBatchedMesh) {
        if (object._multiDrawInstances !== null) {
          renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
        } else {
          if (!extensions.get('WEBGL_multi_draw')) {
            var starts = object._multiDrawStarts;
            var counts = object._multiDrawCounts;
            var _drawCount = object._multiDrawCount;
            var bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
            var uniforms = properties.get(material).currentProgram.getUniforms();
            for (var i = 0; i < _drawCount; i++) {
              uniforms.setValue(_gl, '_gl_DrawID', i);
              renderer.render(starts[i] / bytesPerElement, counts[i]);
            }
          } else {
            renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
          }
        }
      } else if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        var maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
        var instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };

    // Compile

    function prepareMaterial(material, scene, object) {
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = FrontSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = DoubleSide;
      } else {
        getProgram(material, scene, object);
      }
    }
    this.compile = function (scene, camera) {
      var targetScene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (targetScene === null) targetScene = scene;
      currentRenderState = renderStates.get(targetScene);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);

      // gather lights from both the target scene and the new object that will be added to the scene.

      targetScene.traverseVisible(function (object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      if (scene !== targetScene) {
        scene.traverseVisible(function (object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
      }
      currentRenderState.setupLights();

      // Only initialize materials in the new scene, not the targetScene.

      var materials = new Set();
      scene.traverse(function (object) {
        var material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (var i = 0; i < material.length; i++) {
              var material2 = material[i];
              prepareMaterial(material2, targetScene, object);
              materials.add(material2);
            }
          } else {
            prepareMaterial(material, targetScene, object);
            materials.add(material);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
      return materials;
    };

    // compileAsync

    this.compileAsync = function (scene, camera) {
      var targetScene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var materials = this.compile(scene, camera, targetScene);

      // Wait for all the materials in the new object to indicate that they're
      // ready to be used before resolving the promise.

      return new Promise(function (resolve) {
        function checkMaterialsReady() {
          materials.forEach(function (material) {
            var materialProperties = properties.get(material);
            var program = materialProperties.currentProgram;
            if (program.isReady()) {
              // remove any programs that report they're ready to use from the list
              materials.delete(material);
            }
          });

          // once the list of compiling materials is empty, call the callback

          if (materials.size === 0) {
            resolve(scene);
            return;
          }

          // if some materials are still not ready, wait a bit and check again

          setTimeout(checkMaterialsReady, 10);
        }
        if (extensions.get('KHR_parallel_shader_compile') !== null) {
          // If we can check the compilation status of the materials without
          // blocking then do so right away.

          checkMaterialsReady();
        } else {
          // Otherwise start by waiting a bit to give the materials we just
          // initialized a chance to finish.

          setTimeout(checkMaterialsReady, 10);
        }
      });
    };

    // Animation Loop

    var onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== 'undefined') animation.setContext(self);
    this.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener('sessionstart', onXRSessionStart);
    xr.addEventListener('sessionend', onXRSessionEnd);

    // Rendering

    this.render = function (scene, camera) {
      if (camera !== undefined && camera.isCamera !== true) {
        console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
        return;
      }
      if (_isContextLost === true) return;

      // update scene graph

      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();

      // update camera matrices and frustum

      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
        camera = xr.getCamera(); // use XR camera for rendering
      }

      //
      if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      if (xr.enabled === true && xr.isPresenting === true) {
        var depthSensingMesh = _this.xr.getDepthSensingMesh();
        if (depthSensingMesh !== null) {
          projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
        }
      }
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
      if (_renderBackground) {
        background.addToRenderList(currentRenderList, scene);
      }

      //

      this.info.render.frame++;
      if (_clippingEnabled === true) clipping.beginShadows();
      var shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true) clipping.endShadows();

      //

      if (this.info.autoReset === true) this.info.reset();

      // render scene

      var opaqueObjects = currentRenderList.opaque;
      var transmissiveObjects = currentRenderList.transmissive;
      currentRenderState.setupLights();
      if (camera.isArrayCamera) {
        var cameras = camera.cameras;
        if (transmissiveObjects.length > 0) {
          for (var i = 0, l = cameras.length; i < l; i++) {
            var camera2 = cameras[i];
            renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
          }
        }
        if (_renderBackground) background.render(scene);
        for (var _i55 = 0, _l6 = cameras.length; _i55 < _l6; _i55++) {
          var _camera3 = cameras[_i55];
          renderScene(currentRenderList, scene, _camera3, _camera3.viewport);
        }
      } else {
        if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
        if (_renderBackground) background.render(scene);
        renderScene(currentRenderList, scene, camera);
      }

      //

      if (_currentRenderTarget !== null) {
        // resolve multisample renderbuffers to a single-sample texture if necessary

        textures.updateMultisampleRenderTarget(_currentRenderTarget);

        // Generate mipmap if we're using any kind of mipmap filtering

        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }

      //

      if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);

      // _gl.finish();

      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
        if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false) return;
      var visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true) object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            var geometry = objects.update(object);
            var material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            var _geometry2 = objects.update(object);
            var _material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== undefined) {
                if (object.boundingSphere === null) object.computeBoundingSphere();
                _vector4.copy(object.boundingSphere.center);
              } else {
                if (_geometry2.boundingSphere === null) _geometry2.computeBoundingSphere();
                _vector4.copy(_geometry2.boundingSphere.center);
              }
              _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            if (Array.isArray(_material)) {
              var groups = _geometry2.groups;
              for (var i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                var groupMaterial = _material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, _geometry2, groupMaterial, groupOrder, _vector4.z, group);
                }
              }
            } else if (_material.visible) {
              currentRenderList.push(object, _geometry2, _material, groupOrder, _vector4.z, null);
            }
          }
        }
      }
      var children = object.children;
      for (var _i56 = 0, _l7 = children.length; _i56 < _l7; _i56++) {
        projectObject(children[_i56], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList, scene, camera, viewport) {
      var opaqueObjects = currentRenderList.opaque;
      var transmissiveObjects = currentRenderList.transmissive;
      var transparentObjects = currentRenderList.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      if (viewport) state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);

      // Ensure depth buffer writing is enabled so it can be cleared on next render

      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      if (overrideMaterial !== null) {
        return;
      }
      if (currentRenderState.state.transmissionRenderTarget[camera.id] === undefined) {
        currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has('EXT_color_buffer_half_float') || extensions.has('EXT_color_buffer_float') ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: 4,
          stencilBuffer: stencil,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false,
          colorSpace: ColorManagement.workingColorSpace
        });

        // debug

        /*
        const geometry = new PlaneGeometry();
        const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );
        	const mesh = new Mesh( geometry, material );
        scene.add( mesh );
        */
      }
      var transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
      var activeViewport = camera.viewport || _currentViewport;
      transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);

      //

      var currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1) _this.setClearColor(0xffffff, 0.5);
      _this.clear();
      if (_renderBackground) background.render(scene);

      // Turn off the features which can affect the frag color for opaque objects pass.
      // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
      var currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;

      // Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
      // Transmission render pass requires viewport to match the transmissionRenderTarget.
      var currentCameraViewport = camera.viewport;
      if (camera.viewport !== undefined) camera.viewport = undefined;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(transmissionRenderTarget);
      textures.updateRenderTargetMipmap(transmissionRenderTarget);
      if (extensions.has('WEBGL_multisampled_render_to_texture') === false) {
        // see #28131

        var renderTargetNeedsUpdate = false;
        for (var i = 0, l = transmissiveObjects.length; i < l; i++) {
          var renderItem = transmissiveObjects[i];
          var object = renderItem.object;
          var geometry = renderItem.geometry;
          var material = renderItem.material;
          var group = renderItem.group;
          if (material.side === DoubleSide && object.layers.test(camera.layers)) {
            var currentSide = material.side;
            material.side = BackSide;
            material.needsUpdate = true;
            renderObject(object, scene, camera, geometry, material, group);
            material.side = currentSide;
            material.needsUpdate = true;
            renderTargetNeedsUpdate = true;
          }
        }
        if (renderTargetNeedsUpdate === true) {
          textures.updateMultisampleRenderTarget(transmissionRenderTarget);
          textures.updateRenderTargetMipmap(transmissionRenderTarget);
        }
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      if (currentCameraViewport !== undefined) camera.viewport = currentCameraViewport;
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (var i = 0, l = renderList.length; i < l; i++) {
        var renderItem = renderList[i];
        var object = renderItem.object;
        var geometry = renderItem.geometry;
        var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        var group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

      var materialProperties = properties.get(material);
      var lights = currentRenderState.state.lights;
      var shadowsArray = currentRenderState.state.shadowsArray;
      var lightsStateVersion = lights.state.version;
      var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      var programCacheKey = programCache.getProgramCacheKey(parameters);
      var programs = materialProperties.programs;

      // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
      if (programs === undefined) {
        // new material

        material.addEventListener('dispose', onMaterialDispose);
        programs = new Map();
        materialProperties.programs = programs;
      }
      var program = programs.get(programCacheKey);
      if (program !== undefined) {
        // early out if program and light state is identical

        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters);
          return program;
        }
      } else {
        parameters.uniforms = programCache.getUniforms(material);
        material.onBeforeCompile(parameters, _this);
        program = programCache.acquireProgram(parameters, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters.uniforms;
      }
      var uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters);

      // store the light setup it was created for

      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        // wire up the material to this renderer's lighting state

        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        // TODO (abelnation): add area lights shadow info to uniforms
      }
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = null;
      return program;
    }
    function getUniformList(materialProperties) {
      if (materialProperties.uniformsList === null) {
        var progUniforms = materialProperties.currentProgram.getUniforms();
        materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
      }
      return materialProperties.uniformsList;
    }
    function updateCommonMaterialProperties(material, parameters) {
      var materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters.outputColorSpace;
      materialProperties.batching = parameters.batching;
      materialProperties.batchingColor = parameters.batchingColor;
      materialProperties.instancing = parameters.instancing;
      materialProperties.instancingColor = parameters.instancingColor;
      materialProperties.instancingMorph = parameters.instancingMorph;
      materialProperties.skinning = parameters.skinning;
      materialProperties.morphTargets = parameters.morphTargets;
      materialProperties.morphNormals = parameters.morphNormals;
      materialProperties.morphColors = parameters.morphColors;
      materialProperties.morphTargetsCount = parameters.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters.numClippingPlanes;
      materialProperties.numIntersection = parameters.numClipIntersection;
      materialProperties.vertexAlphas = parameters.vertexAlphas;
      materialProperties.vertexTangents = parameters.vertexTangents;
      materialProperties.toneMapping = parameters.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

      textures.resetTextureUnits();
      var fog = scene.fog;
      var environment = material.isMeshStandardMaterial ? scene.environment : null;
      var colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
      var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      var vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      var vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      var morphTargets = !!geometry.morphAttributes.position;
      var morphNormals = !!geometry.morphAttributes.normal;
      var morphColors = !!geometry.morphAttributes.color;
      var toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = _this.toneMapping;
        }
      }
      var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
      var materialProperties = properties.get(material);
      var lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          var useCache = camera === _currentCamera && material.id === _currentMaterialId;

          // we might want to call this function with some ClippingGroup
          // object instead of the material, once it becomes feasible
          // (#8465, #8379)
          clipping.setState(material, camera, useCache);
        }
      }

      //

      var needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batching === false) {
          needsProgramChange = true;
        } else if (!object.isBatchedMesh && materialProperties.batching === true) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }

      //

      var program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      var refreshProgram = false;
      var refreshMaterial = false;
      var refreshLights = false;
      var p_uniforms = program.getUniforms(),
        m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        // common camera uniforms

        p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
        var uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
        }

        // consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067

        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;

          // lighting uniforms depend on the camera so enforce an update
          // now, in case this material supports lights - or later, when
          // the next material that does gets activated:

          refreshMaterial = true; // set to true on material change
          refreshLights = true; // remains set until update done
        }
      }

      // skinning and morph target uniforms must be set even if material didn't change
      // auto-setting of texture unit for bone and morph texture must go before other textures
      // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, 'bindMatrix');
        p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
        var skeleton = object.skeleton;
        if (skeleton) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
        }
      }
      if (object.isBatchedMesh) {
        p_uniforms.setOptional(_gl, object, 'batchingTexture');
        p_uniforms.setValue(_gl, 'batchingTexture', object._matricesTexture, textures);
        p_uniforms.setOptional(_gl, object, 'batchingIdTexture');
        p_uniforms.setValue(_gl, 'batchingIdTexture', object._indirectTexture, textures);
        p_uniforms.setOptional(_gl, object, 'batchingColorTexture');
        if (object._colorsTexture !== null) {
          p_uniforms.setValue(_gl, 'batchingColorTexture', object._colorsTexture, textures);
        }
      }
      var morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
      }

      // https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
        m_uniforms.envMapIntensity.value = scene.environmentIntensity;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          // the current material requires lighting info

          // note: all lighting uniforms are always set correctly
          // they simply reference the renderer's state for their
          // values
          //
          // use the current material's .needsUpdate flags to set
          // the GL state when required

          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }

        // refresh uniforms common to several materials

        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, 'center', object.center);
      }

      // common matrices

      p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
      p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
      p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

      // UBOs

      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        var groups = material.uniformsGroups;
        for (var i = 0, l = groups.length; i < l; i++) {
          var group = groups[i];
          uniformsGroups.update(group, program);
          uniformsGroups.bind(group, program);
        }
      }
      return program;
    }

    // If uniforms are marked as clean, they don't need to be loaded to the GPU.

    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function () {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function () {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function () {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function (renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      var renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        // The multisample_render_to_texture extension doesn't work properly if there
        // are midframe flushes and an external depth buffer. Disable use of the extension.
        if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {
          console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    };
    this.setRenderTargetFramebuffer = function (renderTarget, defaultFramebuffer) {
      var renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
    };
    this.setRenderTarget = function (renderTarget) {
      var activeCubeFace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var activeMipmapLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      var useDefaultFramebuffer = true;
      var framebuffer = null;
      var isCube = false;
      var isRenderTarget3D = false;
      if (renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
          // We need to make sure to rebind the framebuffer.
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === undefined) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          // Color and depth texture must be rebound in order for the swapchain to update.
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
        var texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      var framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        var textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        var _textureProperties = properties.get(renderTarget.texture);
        var layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1; // reset current material to ensure correct uniform bindings
    };
    this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
        return;
      }
      var framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          var texture = renderTarget.texture;
          var textureFormat = texture.format;
          var textureType = texture.type;
          if (!capabilities.textureFormatReadable(textureFormat)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
            return;
          }
          if (!capabilities.textureTypeReadable(textureType)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
            return;
          }

          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          // restore framebuffer of current render target if necessary

          var _framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, _framebuffer);
        }
      }
    };
    this.readRenderTargetPixelsAsync = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
        var framebuffer, texture, textureFormat, textureType, glBuffer, sync, _framebuffer2;
        return _regeneratorRuntime().wrap(function _callee2$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (renderTarget && renderTarget.isWebGLRenderTarget) {
                _context9.next = 2;
                break;
              }
              throw new Error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            case 2:
              framebuffer = properties.get(renderTarget).__webglFramebuffer;
              if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
                framebuffer = framebuffer[activeCubeFaceIndex];
              }
              if (!framebuffer) {
                _context9.next = 29;
                break;
              }
              state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
              _context9.prev = 6;
              texture = renderTarget.texture;
              textureFormat = texture.format;
              textureType = texture.type;
              if (capabilities.textureFormatReadable(textureFormat)) {
                _context9.next = 12;
                break;
              }
              throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.');
            case 12:
              if (capabilities.textureTypeReadable(textureType)) {
                _context9.next = 14;
                break;
              }
              throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.');
            case 14:
              if (!(x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height)) {
                _context9.next = 25;
                break;
              }
              glBuffer = _gl.createBuffer();
              _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
              _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
              _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
              _gl.flush();

              // check if the commands have finished every 8 ms
              sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
              _context9.next = 23;
              return probeAsync(_gl, sync, 4);
            case 23:
              try {
                _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
                _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
              } finally {
                _gl.deleteBuffer(glBuffer);
                _gl.deleteSync(sync);
              }
              return _context9.abrupt("return", buffer);
            case 25:
              _context9.prev = 25;
              // restore framebuffer of current render target if necessary
              _framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
              state.bindFramebuffer(_gl.FRAMEBUFFER, _framebuffer2);
              return _context9.finish(25);
            case 29:
            case "end":
              return _context9.stop();
          }
        }, _callee2, null, [[6,, 25, 29]]);
      }));
      return function (_x4, _x5, _x6, _x7, _x8, _x9, _x10) {
        return _ref2.apply(this, arguments);
      };
    }();
    this.copyFramebufferToTexture = function (texture) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // support previous signature with position first
      if (texture.isTexture !== true) {
        // @deprecated, r165
        warnOnce('WebGLRenderer: copyFramebufferToTexture function signature has changed.');
        position = arguments[0] || null;
        texture = arguments[1];
      }
      var levelScale = Math.pow(2, -level);
      var width = Math.floor(texture.image.width * levelScale);
      var height = Math.floor(texture.image.height * levelScale);
      var x = position !== null ? position.x : 0;
      var y = position !== null ? position.y : 0;
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function (srcTexture, dstTexture) {
      var srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      // support previous signature with dstPosition first
      if (srcTexture.isTexture !== true) {
        // @deprecated, r165
        warnOnce('WebGLRenderer: copyTextureToTexture function signature has changed.');
        dstPosition = arguments[0] || null;
        srcTexture = arguments[1];
        dstTexture = arguments[2];
        level = arguments[3] || 0;
        srcRegion = null;
      }
      var width, height, minX, minY;
      var dstX, dstY;
      if (srcRegion !== null) {
        width = srcRegion.max.x - srcRegion.min.x;
        height = srcRegion.max.y - srcRegion.min.y;
        minX = srcRegion.min.x;
        minY = srcRegion.min.y;
      } else {
        width = srcTexture.image.width;
        height = srcTexture.image.height;
        minX = 0;
        minY = 0;
      }
      if (dstPosition !== null) {
        dstX = dstPosition.x;
        dstY = dstPosition.y;
      } else {
        dstX = 0;
        dstY = 0;
      }
      var glFormat = utils.convert(dstTexture.format);
      var glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);

      // As another texture upload may have changed pixelStorei
      // parameters, make sure they are correct for the dstTexture
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      var currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      var currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      var currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      var currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      var currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);
        } else {
          _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);

      // Generate mipmaps only when copying level 0
      if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function (srcTexture, dstTexture) {
      var srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      // support previous signature with source box first
      if (srcTexture.isTexture !== true) {
        // @deprecated, r165
        warnOnce('WebGLRenderer: copyTextureToTexture3D function signature has changed.');
        srcRegion = arguments[0] || null;
        dstPosition = arguments[1] || null;
        srcTexture = arguments[2];
        dstTexture = arguments[3];
        level = arguments[4] || 0;
      }
      var width, height, depth, minX, minY, minZ;
      var dstX, dstY, dstZ;
      var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
      if (srcRegion !== null) {
        width = srcRegion.max.x - srcRegion.min.x;
        height = srcRegion.max.y - srcRegion.min.y;
        depth = srcRegion.max.z - srcRegion.min.z;
        minX = srcRegion.min.x;
        minY = srcRegion.min.y;
        minZ = srcRegion.min.z;
      } else {
        width = image.width;
        height = image.height;
        depth = image.depth;
        minX = 0;
        minY = 0;
        minZ = 0;
      }
      if (dstPosition !== null) {
        dstX = dstPosition.x;
        dstY = dstPosition.y;
        dstZ = dstPosition.z;
      } else {
        dstX = 0;
        dstY = 0;
        dstZ = 0;
      }
      var glFormat = utils.convert(dstTexture.format);
      var glType = utils.convert(dstTexture.type);
      var glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
        return;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      var currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      var currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      var currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      var currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      var currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data);
      } else {
        if (dstTexture.isCompressedArrayTexture) {
          _gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);

      // Generate mipmaps only when copying level 0
      if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initRenderTarget = function (target) {
      if (properties.get(target).__webglFramebuffer === undefined) {
        textures.setupRenderTarget(target);
      }
    };
    this.initTexture = function (texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function () {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
      }));
    }
  }
  return _createClass(WebGLRenderer, [{
    key: "coordinateSystem",
    get: function get() {
      return WebGLCoordinateSystem;
    }
  }, {
    key: "outputColorSpace",
    get: function get() {
      return this._outputColorSpace;
    },
    set: function set(colorSpace) {
      this._outputColorSpace = colorSpace;
      var gl = this.getContext();
      gl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? 'display-p3' : 'srgb';
      gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? 'display-p3' : 'srgb';
    }
  }]);
}();
var FogExp2 = exports.FogExp2 = /*#__PURE__*/function () {
  function FogExp2(color) {
    var density = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00025;
    _classCallCheck(this, FogExp2);
    this.isFogExp2 = true;
    this.name = '';
    this.color = new Color(color);
    this.density = density;
  }
  return _createClass(FogExp2, [{
    key: "clone",
    value: function clone() {
      return new FogExp2(this.color, this.density);
    }
  }, {
    key: "toJSON",
    value: function toJSON( /* meta */
    ) {
      return {
        type: 'FogExp2',
        name: this.name,
        color: this.color.getHex(),
        density: this.density
      };
    }
  }]);
}();
var Fog = exports.Fog = /*#__PURE__*/function () {
  function Fog(color) {
    var near = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var far = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
    _classCallCheck(this, Fog);
    this.isFog = true;
    this.name = '';
    this.color = new Color(color);
    this.near = near;
    this.far = far;
  }
  return _createClass(Fog, [{
    key: "clone",
    value: function clone() {
      return new Fog(this.color, this.near, this.far);
    }
  }, {
    key: "toJSON",
    value: function toJSON( /* meta */
    ) {
      return {
        type: 'Fog',
        name: this.name,
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  }]);
}();
var Scene = exports.Scene = /*#__PURE__*/function (_Object3D5) {
  function Scene() {
    var _this30;
    _classCallCheck(this, Scene);
    _this30 = _callSuper(this, Scene);
    _this30.isScene = true;
    _this30.type = 'Scene';
    _this30.background = null;
    _this30.environment = null;
    _this30.fog = null;
    _this30.backgroundBlurriness = 0;
    _this30.backgroundIntensity = 1;
    _this30.backgroundRotation = new Euler();
    _this30.environmentIntensity = 1;
    _this30.environmentRotation = new Euler();
    _this30.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: _this30
      }));
    }
    return _this30;
  }
  _inherits(Scene, _Object3D5);
  return _createClass(Scene, [{
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(Scene, "copy", this, 3)([source, recursive]);
      if (source.background !== null) this.background = source.background.clone();
      if (source.environment !== null) this.environment = source.environment.clone();
      if (source.fog !== null) this.fog = source.fog.clone();
      this.backgroundBlurriness = source.backgroundBlurriness;
      this.backgroundIntensity = source.backgroundIntensity;
      this.backgroundRotation.copy(source.backgroundRotation);
      this.environmentIntensity = source.environmentIntensity;
      this.environmentRotation.copy(source.environmentRotation);
      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _superPropGet(Scene, "toJSON", this, 3)([meta]);
      if (this.fog !== null) data.object.fog = this.fog.toJSON();
      if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
      if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
      data.object.backgroundRotation = this.backgroundRotation.toArray();
      if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
      data.object.environmentRotation = this.environmentRotation.toArray();
      return data;
    }
  }]);
}(Object3D);
var InterleavedBuffer = exports.InterleavedBuffer = /*#__PURE__*/function () {
  function InterleavedBuffer(array, stride) {
    _classCallCheck(this, InterleavedBuffer);
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this._updateRange = {
      offset: 0,
      count: -1
    };
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID();
  }
  return _createClass(InterleavedBuffer, [{
    key: "onUploadCallback",
    value: function onUploadCallback() {}
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "updateRange",
    get: function get() {
      warnOnce('THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'); // @deprecated, r159
      return this._updateRange;
    }
  }, {
    key: "setUsage",
    value: function setUsage(value) {
      this.usage = value;
      return this;
    }
  }, {
    key: "addUpdateRange",
    value: function addUpdateRange(start, count) {
      this.updateRanges.push({
        start: start,
        count: count
      });
    }
  }, {
    key: "clearUpdateRanges",
    value: function clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.usage = source.usage;
      return this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;
      for (var i = 0, l = this.stride; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    }
  }, {
    key: "set",
    value: function set(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.array.set(value, offset);
      return this;
    }
  }, {
    key: "clone",
    value: function clone(data) {
      if (data.arrayBuffers === undefined) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === undefined) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
      }
      var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
      var ib = new this.constructor(array, this.stride);
      ib.setUsage(this.usage);
      return ib;
    }
  }, {
    key: "onUpload",
    value: function onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(data) {
      if (data.arrayBuffers === undefined) {
        data.arrayBuffers = {};
      }

      // generate UUID for array buffer if necessary

      if (this.array.buffer._uuid === undefined) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
        data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
      }

      //

      return {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  }]);
}();
var _vector$6 = /*@__PURE__*/new Vector3();
var InterleavedBufferAttribute = exports.InterleavedBufferAttribute = /*#__PURE__*/function () {
  function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset) {
    var normalized = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    _classCallCheck(this, InterleavedBufferAttribute);
    this.isInterleavedBufferAttribute = true;
    this.name = '';
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  return _createClass(InterleavedBufferAttribute, [{
    key: "count",
    get: function get() {
      return this.data.count;
    }
  }, {
    key: "array",
    get: function get() {
      return this.data.array;
    }
  }, {
    key: "needsUpdate",
    set: function set(value) {
      this.data.needsUpdate = value;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      for (var i = 0, l = this.data.count; i < l; i++) {
        _vector$6.fromBufferAttribute(this, i);
        _vector$6.applyMatrix4(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$6.fromBufferAttribute(this, i);
        _vector$6.applyNormalMatrix(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$6.fromBufferAttribute(this, i);
        _vector$6.transformDirection(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index, component) {
      var value = this.array[index * this.data.stride + this.offset + component];
      if (this.normalized) value = denormalize(value, this.array);
      return value;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, component, value) {
      if (this.normalized) value = normalize(value, this.array);
      this.data.array[index * this.data.stride + this.offset + component] = value;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(index, x) {
      if (this.normalized) x = normalize(x, this.array);
      this.data.array[index * this.data.stride + this.offset] = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(index, y) {
      if (this.normalized) y = normalize(y, this.array);
      this.data.array[index * this.data.stride + this.offset + 1] = y;
      return this;
    }
  }, {
    key: "setZ",
    value: function setZ(index, z) {
      if (this.normalized) z = normalize(z, this.array);
      this.data.array[index * this.data.stride + this.offset + 2] = z;
      return this;
    }
  }, {
    key: "setW",
    value: function setW(index, w) {
      if (this.normalized) w = normalize(w, this.array);
      this.data.array[index * this.data.stride + this.offset + 3] = w;
      return this;
    }
  }, {
    key: "getX",
    value: function getX(index) {
      var x = this.data.array[index * this.data.stride + this.offset];
      if (this.normalized) x = denormalize(x, this.array);
      return x;
    }
  }, {
    key: "getY",
    value: function getY(index) {
      var y = this.data.array[index * this.data.stride + this.offset + 1];
      if (this.normalized) y = denormalize(y, this.array);
      return y;
    }
  }, {
    key: "getZ",
    value: function getZ(index) {
      var z = this.data.array[index * this.data.stride + this.offset + 2];
      if (this.normalized) z = denormalize(z, this.array);
      return z;
    }
  }, {
    key: "getW",
    value: function getW(index) {
      var w = this.data.array[index * this.data.stride + this.offset + 3];
      if (this.normalized) w = denormalize(w, this.array);
      return w;
    }
  }, {
    key: "setXY",
    value: function setXY(index, x, y) {
      index = index * this.data.stride + this.offset;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
      }
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      return this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(index, x, y, z) {
      index = index * this.data.stride + this.offset;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
      }
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      return this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(index, x, y, z, w) {
      index = index * this.data.stride + this.offset;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
        w = normalize(w, this.array);
      }
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      this.data.array[index + 3] = w;
      return this;
    }
  }, {
    key: "clone",
    value: function clone(data) {
      if (data === undefined) {
        console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.');
        var array = [];
        for (var i = 0; i < this.count; i++) {
          var index = i * this.data.stride + this.offset;
          for (var j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }
        return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
      } else {
        if (data.interleavedBuffers === undefined) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === undefined) {
          data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
        }
        return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(data) {
      if (data === undefined) {
        console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.');
        var array = [];
        for (var i = 0; i < this.count; i++) {
          var index = i * this.data.stride + this.offset;
          for (var j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }

        // de-interleave data and save it as an ordinary buffer attribute for now

        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: array,
          normalized: this.normalized
        };
      } else {
        // save as true interleaved attribute

        if (data.interleavedBuffers === undefined) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === undefined) {
          data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
        }
        return {
          isInterleavedBufferAttribute: true,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }
    }
  }]);
}();
var SpriteMaterial = exports.SpriteMaterial = /*#__PURE__*/function (_Material5) {
  function SpriteMaterial(parameters) {
    var _this31;
    _classCallCheck(this, SpriteMaterial);
    _this31 = _callSuper(this, SpriteMaterial);
    _this31.isSpriteMaterial = true;
    _this31.type = 'SpriteMaterial';
    _this31.color = new Color(0xffffff);
    _this31.map = null;
    _this31.alphaMap = null;
    _this31.rotation = 0;
    _this31.sizeAttenuation = true;
    _this31.transparent = true;
    _this31.fog = true;
    _this31.setValues(parameters);
    return _this31;
  }
  _inherits(SpriteMaterial, _Material5);
  return _createClass(SpriteMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(SpriteMaterial, "copy", this, 3)([source]);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.rotation = source.rotation;
      this.sizeAttenuation = source.sizeAttenuation;
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material);
var _geometry;
var _intersectPoint = /*@__PURE__*/new Vector3();
var _worldScale = /*@__PURE__*/new Vector3();
var _mvPosition = /*@__PURE__*/new Vector3();
var _alignedPosition = /*@__PURE__*/new Vector2();
var _rotatedPosition = /*@__PURE__*/new Vector2();
var _viewWorldMatrix = /*@__PURE__*/new Matrix4();
var _vA = /*@__PURE__*/new Vector3();
var _vB = /*@__PURE__*/new Vector3();
var _vC = /*@__PURE__*/new Vector3();
var _uvA = /*@__PURE__*/new Vector2();
var _uvB = /*@__PURE__*/new Vector2();
var _uvC = /*@__PURE__*/new Vector2();
var Sprite = exports.Sprite = /*#__PURE__*/function (_Object3D6) {
  function Sprite() {
    var _this32;
    var material = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new SpriteMaterial();
    _classCallCheck(this, Sprite);
    _this32 = _callSuper(this, Sprite);
    _this32.isSprite = true;
    _this32.type = 'Sprite';
    if (_geometry === undefined) {
      _geometry = new BufferGeometry();
      var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
      var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    _this32.geometry = _geometry;
    _this32.material = material;
    _this32.center = new Vector2(0.5, 0.5);
    return _this32;
  }
  _inherits(Sprite, _Object3D6);
  return _createClass(Sprite, [{
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      if (raycaster.camera === null) {
        console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
      }
      _worldScale.setFromMatrixScale(this.matrixWorld);
      _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
      this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
      _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
      if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
        _worldScale.multiplyScalar(-_mvPosition.z);
      }
      var rotation = this.material.rotation;
      var sin, cos;
      if (rotation !== 0) {
        cos = Math.cos(rotation);
        sin = Math.sin(rotation);
      }
      var center = this.center;
      transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvA.set(0, 0);
      _uvB.set(1, 0);
      _uvC.set(1, 1);

      // check first triangle
      var intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
      if (intersect === null) {
        // check second triangle
        transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvB.set(0, 1);
        intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
        if (intersect === null) {
          return;
        }
      }
      var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far) return;
      intersects.push({
        distance: distance,
        point: _intersectPoint.clone(),
        uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
        face: null,
        object: this
      });
    }
  }, {
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(Sprite, "copy", this, 3)([source, recursive]);
      if (source.center !== undefined) this.center.copy(source.center);
      this.material = source.material;
      return this;
    }
  }]);
}(Object3D);
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  // compute position in camera space
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);

  // to check if rotation is not zero
  if (sin !== undefined) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;

  // transform to world space
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
var _v1$2 = /*@__PURE__*/new Vector3();
var _v2$1 = /*@__PURE__*/new Vector3();
var LOD = exports.LOD = /*#__PURE__*/function (_Object3D7) {
  function LOD() {
    var _this33;
    _classCallCheck(this, LOD);
    _this33 = _callSuper(this, LOD);
    _this33._currentLevel = 0;
    _this33.type = 'LOD';
    Object.defineProperties(_this33, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    _this33.autoUpdate = true;
    return _this33;
  }
  _inherits(LOD, _Object3D7);
  return _createClass(LOD, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(LOD, "copy", this, 3)([source, false]);
      var levels = source.levels;
      for (var i = 0, l = levels.length; i < l; i++) {
        var level = levels[i];
        this.addLevel(level.object.clone(), level.distance, level.hysteresis);
      }
      this.autoUpdate = source.autoUpdate;
      return this;
    }
  }, {
    key: "addLevel",
    value: function addLevel(object) {
      var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var hysteresis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      distance = Math.abs(distance);
      var levels = this.levels;
      var l;
      for (l = 0; l < levels.length; l++) {
        if (distance < levels[l].distance) {
          break;
        }
      }
      levels.splice(l, 0, {
        distance: distance,
        hysteresis: hysteresis,
        object: object
      });
      this.add(object);
      return this;
    }
  }, {
    key: "getCurrentLevel",
    value: function getCurrentLevel() {
      return this._currentLevel;
    }
  }, {
    key: "getObjectForDistance",
    value: function getObjectForDistance(distance) {
      var levels = this.levels;
      if (levels.length > 0) {
        var i, l;
        for (i = 1, l = levels.length; i < l; i++) {
          var levelDistance = levels[i].distance;
          if (levels[i].object.visible) {
            levelDistance -= levelDistance * levels[i].hysteresis;
          }
          if (distance < levelDistance) {
            break;
          }
        }
        return levels[i - 1].object;
      }
      return null;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var levels = this.levels;
      if (levels.length > 0) {
        _v1$2.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(_v1$2);
        this.getObjectForDistance(distance).raycast(raycaster, intersects);
      }
    }
  }, {
    key: "update",
    value: function update(camera) {
      var levels = this.levels;
      if (levels.length > 1) {
        _v1$2.setFromMatrixPosition(camera.matrixWorld);
        _v2$1.setFromMatrixPosition(this.matrixWorld);
        var distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
        levels[0].object.visible = true;
        var i, l;
        for (i = 1, l = levels.length; i < l; i++) {
          var levelDistance = levels[i].distance;
          if (levels[i].object.visible) {
            levelDistance -= levelDistance * levels[i].hysteresis;
          }
          if (distance >= levelDistance) {
            levels[i - 1].object.visible = false;
            levels[i].object.visible = true;
          } else {
            break;
          }
        }
        this._currentLevel = i - 1;
        for (; i < l; i++) {
          levels[i].object.visible = false;
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _superPropGet(LOD, "toJSON", this, 3)([meta]);
      if (this.autoUpdate === false) data.object.autoUpdate = false;
      data.object.levels = [];
      var levels = this.levels;
      for (var i = 0, l = levels.length; i < l; i++) {
        var level = levels[i];
        data.object.levels.push({
          object: level.object.uuid,
          distance: level.distance,
          hysteresis: level.hysteresis
        });
      }
      return data;
    }
  }]);
}(Object3D);
var _basePosition = /*@__PURE__*/new Vector3();
var _skinIndex = /*@__PURE__*/new Vector4();
var _skinWeight = /*@__PURE__*/new Vector4();
var _vector3 = /*@__PURE__*/new Vector3();
var _matrix4 = /*@__PURE__*/new Matrix4();
var _vertex = /*@__PURE__*/new Vector3();
var _sphere$4 = /*@__PURE__*/new Sphere();
var _inverseMatrix$2 = /*@__PURE__*/new Matrix4();
var _ray$2 = /*@__PURE__*/new Ray();
var SkinnedMesh = exports.SkinnedMesh = /*#__PURE__*/function (_Mesh) {
  function SkinnedMesh(geometry, material) {
    var _this34;
    _classCallCheck(this, SkinnedMesh);
    _this34 = _callSuper(this, SkinnedMesh, [geometry, material]);
    _this34.isSkinnedMesh = true;
    _this34.type = 'SkinnedMesh';
    _this34.bindMode = AttachedBindMode;
    _this34.bindMatrix = new Matrix4();
    _this34.bindMatrixInverse = new Matrix4();
    _this34.boundingBox = null;
    _this34.boundingSphere = null;
    return _this34;
  }
  _inherits(SkinnedMesh, _Mesh);
  return _createClass(SkinnedMesh, [{
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      var geometry = this.geometry;
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      this.boundingBox.makeEmpty();
      var positionAttribute = geometry.getAttribute('position');
      for (var i = 0; i < positionAttribute.count; i++) {
        this.getVertexPosition(i, _vertex);
        this.boundingBox.expandByPoint(_vertex);
      }
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      var geometry = this.geometry;
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      this.boundingSphere.makeEmpty();
      var positionAttribute = geometry.getAttribute('position');
      for (var i = 0; i < positionAttribute.count; i++) {
        this.getVertexPosition(i, _vertex);
        this.boundingSphere.expandByPoint(_vertex);
      }
    }
  }, {
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(SkinnedMesh, "copy", this, 3)([source, recursive]);
      this.bindMode = source.bindMode;
      this.bindMatrix.copy(source.bindMatrix);
      this.bindMatrixInverse.copy(source.bindMatrixInverse);
      this.skeleton = source.skeleton;
      if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
      if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
      return this;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === undefined) return;

      // test with bounding sphere in world space

      if (this.boundingSphere === null) this.computeBoundingSphere();
      _sphere$4.copy(this.boundingSphere);
      _sphere$4.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;

      // convert ray to local space of skinned mesh

      _inverseMatrix$2.copy(matrixWorld).invert();
      _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

      // test with bounding box in local space

      if (this.boundingBox !== null) {
        if (_ray$2.intersectsBox(this.boundingBox) === false) return;
      }

      // test for intersections with geometry

      this._computeIntersections(raycaster, intersects, _ray$2);
    }
  }, {
    key: "getVertexPosition",
    value: function getVertexPosition(index, target) {
      _superPropGet(SkinnedMesh, "getVertexPosition", this, 3)([index, target]);
      this.applyBoneTransform(index, target);
      return target;
    }
  }, {
    key: "bind",
    value: function bind(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === undefined) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.copy(bindMatrix).invert();
    }
  }, {
    key: "pose",
    value: function pose() {
      this.skeleton.pose();
    }
  }, {
    key: "normalizeSkinWeights",
    value: function normalizeSkinWeights() {
      var vector = new Vector4();
      var skinWeight = this.geometry.attributes.skinWeight;
      for (var i = 0, l = skinWeight.count; i < l; i++) {
        vector.fromBufferAttribute(skinWeight, i);
        var scale = 1.0 / vector.manhattanLength();
        if (scale !== Infinity) {
          vector.multiplyScalar(scale);
        } else {
          vector.set(1, 0, 0, 0); // do something reasonable
        }
        skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
      }
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      _superPropGet(SkinnedMesh, "updateMatrixWorld", this, 3)([force]);
      if (this.bindMode === AttachedBindMode) {
        this.bindMatrixInverse.copy(this.matrixWorld).invert();
      } else if (this.bindMode === DetachedBindMode) {
        this.bindMatrixInverse.copy(this.bindMatrix).invert();
      } else {
        console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
      }
    }
  }, {
    key: "applyBoneTransform",
    value: function applyBoneTransform(index, vector) {
      var skeleton = this.skeleton;
      var geometry = this.geometry;
      _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
      _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
      _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
      vector.set(0, 0, 0);
      for (var i = 0; i < 4; i++) {
        var weight = _skinWeight.getComponent(i);
        if (weight !== 0) {
          var boneIndex = _skinIndex.getComponent(i);
          _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
          vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
        }
      }
      return vector.applyMatrix4(this.bindMatrixInverse);
    }
  }]);
}(Mesh);
var Bone = exports.Bone = /*#__PURE__*/function (_Object3D8) {
  function Bone() {
    var _this35;
    _classCallCheck(this, Bone);
    _this35 = _callSuper(this, Bone);
    _this35.isBone = true;
    _this35.type = 'Bone';
    return _this35;
  }
  _inherits(Bone, _Object3D8);
  return _createClass(Bone);
}(Object3D);
var DataTexture = exports.DataTexture = /*#__PURE__*/function (_Texture5) {
  function DataTexture() {
    var _this36;
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var format = arguments.length > 3 ? arguments[3] : undefined;
    var type = arguments.length > 4 ? arguments[4] : undefined;
    var mapping = arguments.length > 5 ? arguments[5] : undefined;
    var wrapS = arguments.length > 6 ? arguments[6] : undefined;
    var wrapT = arguments.length > 7 ? arguments[7] : undefined;
    var magFilter = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : NearestFilter;
    var minFilter = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : NearestFilter;
    var anisotropy = arguments.length > 10 ? arguments[10] : undefined;
    var colorSpace = arguments.length > 11 ? arguments[11] : undefined;
    _classCallCheck(this, DataTexture);
    _this36 = _callSuper(this, DataTexture, [null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace]);
    _this36.isDataTexture = true;
    _this36.image = {
      data: data,
      width: width,
      height: height
    };
    _this36.generateMipmaps = false;
    _this36.flipY = false;
    _this36.unpackAlignment = 1;
    return _this36;
  }
  _inherits(DataTexture, _Texture5);
  return _createClass(DataTexture);
}(Texture);
var _offsetMatrix = /*@__PURE__*/new Matrix4();
var _identityMatrix$1 = /*@__PURE__*/new Matrix4();
var Skeleton = exports.Skeleton = /*#__PURE__*/function () {
  function Skeleton() {
    var bones = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var boneInverses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    _classCallCheck(this, Skeleton);
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.init();
  }
  return _createClass(Skeleton, [{
    key: "init",
    value: function init() {
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      this.boneMatrices = new Float32Array(bones.length * 16);

      // calculate inverse bone matrices if necessary

      if (boneInverses.length === 0) {
        this.calculateInverses();
      } else {
        // handle special case

        if (bones.length !== boneInverses.length) {
          console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
          this.boneInverses = [];
          for (var i = 0, il = this.bones.length; i < il; i++) {
            this.boneInverses.push(new Matrix4());
          }
        }
      }
    }
  }, {
    key: "calculateInverses",
    value: function calculateInverses() {
      this.boneInverses.length = 0;
      for (var i = 0, il = this.bones.length; i < il; i++) {
        var inverse = new Matrix4();
        if (this.bones[i]) {
          inverse.copy(this.bones[i].matrixWorld).invert();
        }
        this.boneInverses.push(inverse);
      }
    }
  }, {
    key: "pose",
    value: function pose() {
      // recover the bind-time world matrices

      for (var i = 0, il = this.bones.length; i < il; i++) {
        var bone = this.bones[i];
        if (bone) {
          bone.matrixWorld.copy(this.boneInverses[i]).invert();
        }
      }

      // compute the local matrices, positions, rotations and scales

      for (var _i57 = 0, _il13 = this.bones.length; _i57 < _il13; _i57++) {
        var _bone = this.bones[_i57];
        if (_bone) {
          if (_bone.parent && _bone.parent.isBone) {
            _bone.matrix.copy(_bone.parent.matrixWorld).invert();
            _bone.matrix.multiply(_bone.matrixWorld);
          } else {
            _bone.matrix.copy(_bone.matrixWorld);
          }
          _bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      var boneMatrices = this.boneMatrices;
      var boneTexture = this.boneTexture;

      // flatten bone matrices to array

      for (var i = 0, il = bones.length; i < il; i++) {
        // compute the offset between the current and the original transform

        var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix$1;
        _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
        _offsetMatrix.toArray(boneMatrices, i * 16);
      }
      if (boneTexture !== null) {
        boneTexture.needsUpdate = true;
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Skeleton(this.bones, this.boneInverses);
    }
  }, {
    key: "computeBoneTexture",
    value: function computeBoneTexture() {
      // layout (1 matrix = 4 pixels)
      //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
      //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
      //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
      //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
      //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

      var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
      size = Math.ceil(size / 4) * 4;
      size = Math.max(size, 4);
      var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
      boneMatrices.set(this.boneMatrices); // copy current values

      var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
      boneTexture.needsUpdate = true;
      this.boneMatrices = boneMatrices;
      this.boneTexture = boneTexture;
      return this;
    }
  }, {
    key: "getBoneByName",
    value: function getBoneByName(name) {
      for (var i = 0, il = this.bones.length; i < il; i++) {
        var bone = this.bones[i];
        if (bone.name === name) {
          return bone;
        }
      }
      return undefined;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.boneTexture !== null) {
        this.boneTexture.dispose();
        this.boneTexture = null;
      }
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json, bones) {
      this.uuid = json.uuid;
      for (var i = 0, l = json.bones.length; i < l; i++) {
        var uuid = json.bones[i];
        var bone = bones[uuid];
        if (bone === undefined) {
          console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
          bone = new Bone();
        }
        this.bones.push(bone);
        this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
      }
      this.init();
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        metadata: {
          version: 4.6,
          type: 'Skeleton',
          generator: 'Skeleton.toJSON'
        },
        bones: [],
        boneInverses: []
      };
      data.uuid = this.uuid;
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      for (var i = 0, l = bones.length; i < l; i++) {
        var bone = bones[i];
        data.bones.push(bone.uuid);
        var boneInverse = boneInverses[i];
        data.boneInverses.push(boneInverse.toArray());
      }
      return data;
    }
  }]);
}();
var InstancedBufferAttribute = exports.InstancedBufferAttribute = /*#__PURE__*/function (_BufferAttribute10) {
  function InstancedBufferAttribute(array, itemSize, normalized) {
    var _this37;
    var meshPerAttribute = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, InstancedBufferAttribute);
    _this37 = _callSuper(this, InstancedBufferAttribute, [array, itemSize, normalized]);
    _this37.isInstancedBufferAttribute = true;
    _this37.meshPerAttribute = meshPerAttribute;
    return _this37;
  }
  _inherits(InstancedBufferAttribute, _BufferAttribute10);
  return _createClass(InstancedBufferAttribute, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(InstancedBufferAttribute, "copy", this, 3)([source]);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(InstancedBufferAttribute, "toJSON", this, 3)([]);
      data.meshPerAttribute = this.meshPerAttribute;
      data.isInstancedBufferAttribute = true;
      return data;
    }
  }]);
}(BufferAttribute);
var _instanceLocalMatrix = /*@__PURE__*/new Matrix4();
var _instanceWorldMatrix = /*@__PURE__*/new Matrix4();
var _instanceIntersects = [];
var _box3 = /*@__PURE__*/new Box3();
var _identity = /*@__PURE__*/new Matrix4();
var _mesh$1 = /*@__PURE__*/new Mesh();
var _sphere$3 = /*@__PURE__*/new Sphere();
var InstancedMesh = exports.InstancedMesh = /*#__PURE__*/function (_Mesh2) {
  function InstancedMesh(geometry, material, count) {
    var _this38;
    _classCallCheck(this, InstancedMesh);
    _this38 = _callSuper(this, InstancedMesh, [geometry, material]);
    _this38.isInstancedMesh = true;
    _this38.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    _this38.instanceColor = null;
    _this38.morphTexture = null;
    _this38.count = count;
    _this38.boundingBox = null;
    _this38.boundingSphere = null;
    for (var i = 0; i < count; i++) {
      _this38.setMatrixAt(i, _identity);
    }
    return _this38;
  }
  _inherits(InstancedMesh, _Mesh2);
  return _createClass(InstancedMesh, [{
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      var geometry = this.geometry;
      var count = this.count;
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      this.boundingBox.makeEmpty();
      for (var i = 0; i < count; i++) {
        this.getMatrixAt(i, _instanceLocalMatrix);
        _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
        this.boundingBox.union(_box3);
      }
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      var geometry = this.geometry;
      var count = this.count;
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      if (geometry.boundingSphere === null) {
        geometry.computeBoundingSphere();
      }
      this.boundingSphere.makeEmpty();
      for (var i = 0; i < count; i++) {
        this.getMatrixAt(i, _instanceLocalMatrix);
        _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
        this.boundingSphere.union(_sphere$3);
      }
    }
  }, {
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(InstancedMesh, "copy", this, 3)([source, recursive]);
      this.instanceMatrix.copy(source.instanceMatrix);
      if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
      if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
      this.count = source.count;
      if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
      if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
      return this;
    }
  }, {
    key: "getColorAt",
    value: function getColorAt(index, color) {
      color.fromArray(this.instanceColor.array, index * 3);
    }
  }, {
    key: "getMatrixAt",
    value: function getMatrixAt(index, matrix) {
      matrix.fromArray(this.instanceMatrix.array, index * 16);
    }
  }, {
    key: "getMorphAt",
    value: function getMorphAt(index, object) {
      var objectInfluences = object.morphTargetInfluences;
      var array = this.morphTexture.source.data.data;
      var len = objectInfluences.length + 1; // All influences + the baseInfluenceSum

      var dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning

      for (var i = 0; i < objectInfluences.length; i++) {
        objectInfluences[i] = array[dataIndex + i];
      }
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var matrixWorld = this.matrixWorld;
      var raycastTimes = this.count;
      _mesh$1.geometry = this.geometry;
      _mesh$1.material = this.material;
      if (_mesh$1.material === undefined) return;

      // test with bounding sphere first

      if (this.boundingSphere === null) this.computeBoundingSphere();
      _sphere$3.copy(this.boundingSphere);
      _sphere$3.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;

      // now test each instance

      for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
        // calculate the world matrix for each instance

        this.getMatrixAt(instanceId, _instanceLocalMatrix);
        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);

        // the mesh represents this single instance

        _mesh$1.matrixWorld = _instanceWorldMatrix;
        _mesh$1.raycast(raycaster, _instanceIntersects);

        // process the result of raycast

        for (var i = 0, l = _instanceIntersects.length; i < l; i++) {
          var _intersect = _instanceIntersects[i];
          _intersect.instanceId = instanceId;
          _intersect.object = this;
          intersects.push(_intersect);
        }
        _instanceIntersects.length = 0;
      }
    }
  }, {
    key: "setColorAt",
    value: function setColorAt(index, color) {
      if (this.instanceColor === null) {
        this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);
      }
      color.toArray(this.instanceColor.array, index * 3);
    }
  }, {
    key: "setMatrixAt",
    value: function setMatrixAt(index, matrix) {
      matrix.toArray(this.instanceMatrix.array, index * 16);
    }
  }, {
    key: "setMorphAt",
    value: function setMorphAt(index, object) {
      var objectInfluences = object.morphTargetInfluences;
      var len = objectInfluences.length + 1; // morphBaseInfluence + all influences

      if (this.morphTexture === null) {
        this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);
      }
      var array = this.morphTexture.source.data.data;
      var morphInfluencesSum = 0;
      for (var i = 0; i < objectInfluences.length; i++) {
        morphInfluencesSum += objectInfluences[i];
      }
      var morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      var dataIndex = len * index;
      array[dataIndex] = morphBaseInfluence;
      array.set(objectInfluences, dataIndex + 1);
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {}
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
      if (this.morphTexture !== null) {
        this.morphTexture.dispose();
        this.morphTexture = null;
      }
      return this;
    }
  }]);
}(Mesh);
function sortOpaque(a, b) {
  return a.z - b.z;
}
function sortTransparent(a, b) {
  return b.z - a.z;
}
var MultiDrawRenderList = /*#__PURE__*/function () {
  function MultiDrawRenderList() {
    _classCallCheck(this, MultiDrawRenderList);
    this.index = 0;
    this.pool = [];
    this.list = [];
  }
  return _createClass(MultiDrawRenderList, [{
    key: "push",
    value: function push(drawRange, z, index) {
      var pool = this.pool;
      var list = this.list;
      if (this.index >= pool.length) {
        pool.push({
          start: -1,
          count: -1,
          z: -1,
          index: -1
        });
      }
      var item = pool[this.index];
      list.push(item);
      this.index++;
      item.start = drawRange.start;
      item.count = drawRange.count;
      item.z = z;
      item.index = index;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.list.length = 0;
      this.index = 0;
    }
  }]);
}();
var _matrix$1 = /*@__PURE__*/new Matrix4();
var _invMatrixWorld = /*@__PURE__*/new Matrix4();
var _identityMatrix = /*@__PURE__*/new Matrix4();
var _whiteColor = /*@__PURE__*/new Color(1, 1, 1);
var _projScreenMatrix$2 = /*@__PURE__*/new Matrix4();
var _frustum = /*@__PURE__*/new Frustum();
var _box$1 = /*@__PURE__*/new Box3();
var _sphere$2 = /*@__PURE__*/new Sphere();
var _vector$5 = /*@__PURE__*/new Vector3();
var _forward = /*@__PURE__*/new Vector3();
var _temp = /*@__PURE__*/new Vector3();
var _renderList = /*@__PURE__*/new MultiDrawRenderList();
var _mesh = /*@__PURE__*/new Mesh();
var _batchIntersects = [];

// @TODO: SkinnedMesh support?
// @TODO: geometry.groups support?
// @TODO: geometry.drawRange support?
// @TODO: geometry.morphAttributes support?
// @TODO: Support uniform parameter per geometry
// @TODO: Add an "optimize" function to pack geometry and remove data gaps

// copies data from attribute "src" into "target" starting at "targetOffset"
function copyAttributeData(src, target) {
  var targetOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var itemSize = target.itemSize;
  if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {
    // use the component getters and setters if the array data cannot
    // be copied directly
    var vertexCount = src.count;
    for (var i = 0; i < vertexCount; i++) {
      for (var c = 0; c < itemSize; c++) {
        target.setComponent(i + targetOffset, c, src.getComponent(i, c));
      }
    }
  } else {
    // faster copy approach using typed array set function
    target.array.set(src.array, targetOffset * itemSize);
  }
  target.needsUpdate = true;
}
var BatchedMesh = exports.BatchedMesh = /*#__PURE__*/function (_Mesh3) {
  function BatchedMesh(maxInstanceCount, maxVertexCount) {
    var _this39;
    var maxIndexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : maxVertexCount * 2;
    var material = arguments.length > 3 ? arguments[3] : undefined;
    _classCallCheck(this, BatchedMesh);
    _this39 = _callSuper(this, BatchedMesh, [new BufferGeometry(), material]);
    _this39.isBatchedMesh = true;
    _this39.perObjectFrustumCulled = true;
    _this39.sortObjects = true;
    _this39.boundingBox = null;
    _this39.boundingSphere = null;
    _this39.customSort = null;

    // stores visible, active, and geometry id per object
    _this39._drawInfo = [];

    // geometry information
    _this39._drawRanges = [];
    _this39._reservedRanges = [];
    _this39._bounds = [];
    _this39._maxInstanceCount = maxInstanceCount;
    _this39._maxVertexCount = maxVertexCount;
    _this39._maxIndexCount = maxIndexCount;
    _this39._geometryInitialized = false;
    _this39._geometryCount = 0;
    _this39._multiDrawCounts = new Int32Array(maxInstanceCount);
    _this39._multiDrawStarts = new Int32Array(maxInstanceCount);
    _this39._multiDrawCount = 0;
    _this39._multiDrawInstances = null;
    _this39._visibilityChanged = true;

    // Local matrix per geometry by using data texture
    _this39._matricesTexture = null;
    _this39._indirectTexture = null;
    _this39._colorsTexture = null;
    _this39._initMatricesTexture();
    _this39._initIndirectTexture();
    return _this39;
  }
  _inherits(BatchedMesh, _Mesh3);
  return _createClass(BatchedMesh, [{
    key: "maxInstanceCount",
    get: function get() {
      return this._maxInstanceCount;
    }
  }, {
    key: "_initMatricesTexture",
    value: function _initMatricesTexture() {
      // layout (1 matrix = 4 pixels)
      //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
      //  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)
      //       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)
      //       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)
      //       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)

      var size = Math.sqrt(this._maxInstanceCount * 4); // 4 pixels needed for 1 matrix
      size = Math.ceil(size / 4) * 4;
      size = Math.max(size, 4);
      var matricesArray = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
      var matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);
      this._matricesTexture = matricesTexture;
    }
  }, {
    key: "_initIndirectTexture",
    value: function _initIndirectTexture() {
      var size = Math.sqrt(this._maxInstanceCount);
      size = Math.ceil(size);
      var indirectArray = new Uint32Array(size * size);
      var indirectTexture = new DataTexture(indirectArray, size, size, RedIntegerFormat, UnsignedIntType);
      this._indirectTexture = indirectTexture;
    }
  }, {
    key: "_initColorsTexture",
    value: function _initColorsTexture() {
      var size = Math.sqrt(this._maxIndexCount);
      size = Math.ceil(size);

      // 4 floats per RGBA pixel initialized to white
      var colorsArray = new Float32Array(size * size * 4).fill(1);
      var colorsTexture = new DataTexture(colorsArray, size, size, RGBAFormat, FloatType);
      colorsTexture.colorSpace = ColorManagement.workingColorSpace;
      this._colorsTexture = colorsTexture;
    }
  }, {
    key: "_initializeGeometry",
    value: function _initializeGeometry(reference) {
      var geometry = this.geometry;
      var maxVertexCount = this._maxVertexCount;
      var maxIndexCount = this._maxIndexCount;
      if (this._geometryInitialized === false) {
        for (var attributeName in reference.attributes) {
          var srcAttribute = reference.getAttribute(attributeName);
          var array = srcAttribute.array,
            itemSize = srcAttribute.itemSize,
            normalized = srcAttribute.normalized;
          var dstArray = new array.constructor(maxVertexCount * itemSize);
          var dstAttribute = new BufferAttribute(dstArray, itemSize, normalized);
          geometry.setAttribute(attributeName, dstAttribute);
        }
        if (reference.getIndex() !== null) {
          // Reserve last u16 index for primitive restart.
          var indexArray = maxVertexCount > 65535 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);
          geometry.setIndex(new BufferAttribute(indexArray, 1));
        }
        this._geometryInitialized = true;
      }
    }

    // Make sure the geometry is compatible with the existing combined geometry attributes
  }, {
    key: "_validateGeometry",
    value: function _validateGeometry(geometry) {
      // check to ensure the geometries are using consistent attributes and indices
      var batchGeometry = this.geometry;
      if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
        throw new Error('BatchedMesh: All geometries must consistently have "index".');
      }
      for (var attributeName in batchGeometry.attributes) {
        if (!geometry.hasAttribute(attributeName)) {
          throw new Error("BatchedMesh: Added geometry missing \"".concat(attributeName, "\". All geometries must have consistent attributes."));
        }
        var srcAttribute = geometry.getAttribute(attributeName);
        var dstAttribute = batchGeometry.getAttribute(attributeName);
        if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
          throw new Error('BatchedMesh: All attributes must have a consistent itemSize and normalized value.');
        }
      }
    }
  }, {
    key: "setCustomSort",
    value: function setCustomSort(func) {
      this.customSort = func;
      return this;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      var geometryCount = this._geometryCount;
      var boundingBox = this.boundingBox;
      var drawInfo = this._drawInfo;
      boundingBox.makeEmpty();
      for (var i = 0; i < geometryCount; i++) {
        if (drawInfo[i].active === false) continue;
        var geometryId = drawInfo[i].geometryIndex;
        this.getMatrixAt(i, _matrix$1);
        this.getBoundingBoxAt(geometryId, _box$1).applyMatrix4(_matrix$1);
        boundingBox.union(_box$1);
      }
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      var boundingSphere = this.boundingSphere;
      var drawInfo = this._drawInfo;
      boundingSphere.makeEmpty();
      for (var i = 0, l = drawInfo.length; i < l; i++) {
        if (drawInfo[i].active === false) continue;
        var geometryId = drawInfo[i].geometryIndex;
        this.getMatrixAt(i, _matrix$1);
        this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
        boundingSphere.union(_sphere$2);
      }
    }
  }, {
    key: "addInstance",
    value: function addInstance(geometryId) {
      // ensure we're not over geometry
      if (this._drawInfo.length >= this._maxInstanceCount) {
        throw new Error('BatchedMesh: Maximum item count reached.');
      }
      this._drawInfo.push({
        visible: true,
        active: true,
        geometryIndex: geometryId
      });

      // initialize the matrix
      var drawId = this._drawInfo.length - 1;
      var matricesTexture = this._matricesTexture;
      var matricesArray = matricesTexture.image.data;
      _identityMatrix.toArray(matricesArray, drawId * 16);
      matricesTexture.needsUpdate = true;
      var colorsTexture = this._colorsTexture;
      if (colorsTexture) {
        _whiteColor.toArray(colorsTexture.image.data, drawId * 4);
        colorsTexture.needsUpdate = true;
      }
      return drawId;
    }
  }, {
    key: "addGeometry",
    value: function addGeometry(geometry) {
      var vertexCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      var indexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      this._initializeGeometry(geometry);
      this._validateGeometry(geometry);

      // ensure we're not over geometry
      if (this._drawInfo.length >= this._maxInstanceCount) {
        throw new Error('BatchedMesh: Maximum item count reached.');
      }

      // get the necessary range fo the geometry
      var reservedRange = {
        vertexStart: -1,
        vertexCount: -1,
        indexStart: -1,
        indexCount: -1
      };
      var lastRange = null;
      var reservedRanges = this._reservedRanges;
      var drawRanges = this._drawRanges;
      var bounds = this._bounds;
      if (this._geometryCount !== 0) {
        lastRange = reservedRanges[reservedRanges.length - 1];
      }
      if (vertexCount === -1) {
        reservedRange.vertexCount = geometry.getAttribute('position').count;
      } else {
        reservedRange.vertexCount = vertexCount;
      }
      if (lastRange === null) {
        reservedRange.vertexStart = 0;
      } else {
        reservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount;
      }
      var index = geometry.getIndex();
      var hasIndex = index !== null;
      if (hasIndex) {
        if (indexCount === -1) {
          reservedRange.indexCount = index.count;
        } else {
          reservedRange.indexCount = indexCount;
        }
        if (lastRange === null) {
          reservedRange.indexStart = 0;
        } else {
          reservedRange.indexStart = lastRange.indexStart + lastRange.indexCount;
        }
      }
      if (reservedRange.indexStart !== -1 && reservedRange.indexStart + reservedRange.indexCount > this._maxIndexCount || reservedRange.vertexStart + reservedRange.vertexCount > this._maxVertexCount) {
        throw new Error('BatchedMesh: Reserved space request exceeds the maximum buffer size.');
      }

      // update id
      var geometryId = this._geometryCount;
      this._geometryCount++;

      // add the reserved range and draw range objects
      reservedRanges.push(reservedRange);
      drawRanges.push({
        start: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart,
        count: -1
      });
      bounds.push({
        boxInitialized: false,
        box: new Box3(),
        sphereInitialized: false,
        sphere: new Sphere()
      });

      // update the geometry
      this.setGeometryAt(geometryId, geometry);
      return geometryId;
    }
  }, {
    key: "setGeometryAt",
    value: function setGeometryAt(geometryId, geometry) {
      if (geometryId >= this._geometryCount) {
        throw new Error('BatchedMesh: Maximum geometry count reached.');
      }
      this._validateGeometry(geometry);
      var batchGeometry = this.geometry;
      var hasIndex = batchGeometry.getIndex() !== null;
      var dstIndex = batchGeometry.getIndex();
      var srcIndex = geometry.getIndex();
      var reservedRange = this._reservedRanges[geometryId];
      if (hasIndex && srcIndex.count > reservedRange.indexCount || geometry.attributes.position.count > reservedRange.vertexCount) {
        throw new Error('BatchedMesh: Reserved space not large enough for provided geometry.');
      }

      // copy geometry over
      var vertexStart = reservedRange.vertexStart;
      var vertexCount = reservedRange.vertexCount;
      for (var attributeName in batchGeometry.attributes) {
        // copy attribute data
        var srcAttribute = geometry.getAttribute(attributeName);
        var dstAttribute = batchGeometry.getAttribute(attributeName);
        copyAttributeData(srcAttribute, dstAttribute, vertexStart);

        // fill the rest in with zeroes
        var itemSize = srcAttribute.itemSize;
        for (var i = srcAttribute.count, l = vertexCount; i < l; i++) {
          var index = vertexStart + i;
          for (var c = 0; c < itemSize; c++) {
            dstAttribute.setComponent(index, c, 0);
          }
        }
        dstAttribute.needsUpdate = true;
        dstAttribute.addUpdateRange(vertexStart * itemSize, vertexCount * itemSize);
      }

      // copy index
      if (hasIndex) {
        var indexStart = reservedRange.indexStart;

        // copy index data over
        for (var _i58 = 0; _i58 < srcIndex.count; _i58++) {
          dstIndex.setX(indexStart + _i58, vertexStart + srcIndex.getX(_i58));
        }

        // fill the rest in with zeroes
        for (var _i59 = srcIndex.count, _l8 = reservedRange.indexCount; _i59 < _l8; _i59++) {
          dstIndex.setX(indexStart + _i59, vertexStart);
        }
        dstIndex.needsUpdate = true;
        dstIndex.addUpdateRange(indexStart, reservedRange.indexCount);
      }

      // store the bounding boxes
      var bound = this._bounds[geometryId];
      if (geometry.boundingBox !== null) {
        bound.box.copy(geometry.boundingBox);
        bound.boxInitialized = true;
      } else {
        bound.boxInitialized = false;
      }
      if (geometry.boundingSphere !== null) {
        bound.sphere.copy(geometry.boundingSphere);
        bound.sphereInitialized = true;
      } else {
        bound.sphereInitialized = false;
      }

      // set drawRange count
      var drawRange = this._drawRanges[geometryId];
      var posAttr = geometry.getAttribute('position');
      drawRange.count = hasIndex ? srcIndex.count : posAttr.count;
      this._visibilityChanged = true;
      return geometryId;
    }

    /*
    deleteGeometry( geometryId ) {
    		// TODO: delete geometry and associated instances
    	}
    */

    /*
    deleteInstance( instanceId ) {
    		// Note: User needs to call optimize() afterward to pack the data.
    		const drawInfo = this._drawInfo;
    	if ( instanceId >= drawInfo.length || drawInfo[ instanceId ].active === false ) {
    			return this;
    		}
    		drawInfo[ instanceId ].active = false;
    	this._visibilityChanged = true;
    		return this;
    	}
    */

    // get bounding box and compute it if it doesn't exist
  }, {
    key: "getBoundingBoxAt",
    value: function getBoundingBoxAt(geometryId, target) {
      if (geometryId >= this._geometryCount) {
        return null;
      }

      // compute bounding box
      var bound = this._bounds[geometryId];
      var box = bound.box;
      var geometry = this.geometry;
      if (bound.boxInitialized === false) {
        box.makeEmpty();
        var index = geometry.index;
        var position = geometry.attributes.position;
        var drawRange = this._drawRanges[geometryId];
        for (var i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i++) {
          var iv = i;
          if (index) {
            iv = index.getX(iv);
          }
          box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));
        }
        bound.boxInitialized = true;
      }
      target.copy(box);
      return target;
    }

    // get bounding sphere and compute it if it doesn't exist
  }, {
    key: "getBoundingSphereAt",
    value: function getBoundingSphereAt(geometryId, target) {
      if (geometryId >= this._geometryCount) {
        return null;
      }

      // compute bounding sphere
      var bound = this._bounds[geometryId];
      var sphere = bound.sphere;
      var geometry = this.geometry;
      if (bound.sphereInitialized === false) {
        sphere.makeEmpty();
        this.getBoundingBoxAt(geometryId, _box$1);
        _box$1.getCenter(sphere.center);
        var index = geometry.index;
        var position = geometry.attributes.position;
        var drawRange = this._drawRanges[geometryId];
        var maxRadiusSq = 0;
        for (var i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i++) {
          var iv = i;
          if (index) {
            iv = index.getX(iv);
          }
          _vector$5.fromBufferAttribute(position, iv);
          maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5));
        }
        sphere.radius = Math.sqrt(maxRadiusSq);
        bound.sphereInitialized = true;
      }
      target.copy(sphere);
      return target;
    }
  }, {
    key: "setMatrixAt",
    value: function setMatrixAt(instanceId, matrix) {
      // @TODO: Map geometryId to index of the arrays because
      //        optimize() can make geometryId mismatch the index

      var drawInfo = this._drawInfo;
      var matricesTexture = this._matricesTexture;
      var matricesArray = this._matricesTexture.image.data;
      if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
        return this;
      }
      matrix.toArray(matricesArray, instanceId * 16);
      matricesTexture.needsUpdate = true;
      return this;
    }
  }, {
    key: "getMatrixAt",
    value: function getMatrixAt(instanceId, matrix) {
      var drawInfo = this._drawInfo;
      var matricesArray = this._matricesTexture.image.data;
      if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
        return null;
      }
      return matrix.fromArray(matricesArray, instanceId * 16);
    }
  }, {
    key: "setColorAt",
    value: function setColorAt(instanceId, color) {
      if (this._colorsTexture === null) {
        this._initColorsTexture();
      }

      // @TODO: Map id to index of the arrays because
      //        optimize() can make id mismatch the index

      var colorsTexture = this._colorsTexture;
      var colorsArray = this._colorsTexture.image.data;
      var drawInfo = this._drawInfo;
      if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
        return this;
      }
      color.toArray(colorsArray, instanceId * 4);
      colorsTexture.needsUpdate = true;
      return this;
    }
  }, {
    key: "getColorAt",
    value: function getColorAt(instanceId, color) {
      var colorsArray = this._colorsTexture.image.data;
      var drawInfo = this._drawInfo;
      if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
        return null;
      }
      return color.fromArray(colorsArray, instanceId * 4);
    }
  }, {
    key: "setVisibleAt",
    value: function setVisibleAt(instanceId, value) {
      // if the geometry is out of range, not active, or visibility state
      // does not change then return early
      var drawInfo = this._drawInfo;
      if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false || drawInfo[instanceId].visible === value) {
        return this;
      }
      drawInfo[instanceId].visible = value;
      this._visibilityChanged = true;
      return this;
    }
  }, {
    key: "getVisibleAt",
    value: function getVisibleAt(instanceId) {
      // return early if the geometry is out of range or not active
      var drawInfo = this._drawInfo;
      if (instanceId >= drawInfo.length || drawInfo[instanceId].active === false) {
        return false;
      }
      return drawInfo[instanceId].visible;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var drawInfo = this._drawInfo;
      var drawRanges = this._drawRanges;
      var matrixWorld = this.matrixWorld;
      var batchGeometry = this.geometry;

      // iterate over each geometry
      _mesh.material = this.material;
      _mesh.geometry.index = batchGeometry.index;
      _mesh.geometry.attributes = batchGeometry.attributes;
      if (_mesh.geometry.boundingBox === null) {
        _mesh.geometry.boundingBox = new Box3();
      }
      if (_mesh.geometry.boundingSphere === null) {
        _mesh.geometry.boundingSphere = new Sphere();
      }
      for (var i = 0, l = drawInfo.length; i < l; i++) {
        if (!drawInfo[i].visible || !drawInfo[i].active) {
          continue;
        }
        var geometryId = drawInfo[i].geometryIndex;
        var drawRange = drawRanges[geometryId];
        _mesh.geometry.setDrawRange(drawRange.start, drawRange.count);

        // ge the intersects
        this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);
        this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);
        this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);
        _mesh.raycast(raycaster, _batchIntersects);

        // add batch id to the intersects
        for (var j = 0, _l9 = _batchIntersects.length; j < _l9; j++) {
          var _intersect2 = _batchIntersects[j];
          _intersect2.object = this;
          _intersect2.batchId = i;
          intersects.push(_intersect2);
        }
        _batchIntersects.length = 0;
      }
      _mesh.material = null;
      _mesh.geometry.index = null;
      _mesh.geometry.attributes = {};
      _mesh.geometry.setDrawRange(0, Infinity);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(BatchedMesh, "copy", this, 3)([source]);
      this.geometry = source.geometry.clone();
      this.perObjectFrustumCulled = source.perObjectFrustumCulled;
      this.sortObjects = source.sortObjects;
      this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
      this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;
      this._drawRanges = source._drawRanges.map(function (range) {
        return _objectSpread({}, range);
      });
      this._reservedRanges = source._reservedRanges.map(function (range) {
        return _objectSpread({}, range);
      });
      this._drawInfo = source._drawInfo.map(function (inf) {
        return _objectSpread({}, inf);
      });
      this._bounds = source._bounds.map(function (bound) {
        return {
          boxInitialized: bound.boxInitialized,
          box: bound.box.clone(),
          sphereInitialized: bound.sphereInitialized,
          sphere: bound.sphere.clone()
        };
      });
      this._maxInstanceCount = source._maxInstanceCount;
      this._maxVertexCount = source._maxVertexCount;
      this._maxIndexCount = source._maxIndexCount;
      this._geometryInitialized = source._geometryInitialized;
      this._geometryCount = source._geometryCount;
      this._multiDrawCounts = source._multiDrawCounts.slice();
      this._multiDrawStarts = source._multiDrawStarts.slice();
      this._matricesTexture = source._matricesTexture.clone();
      this._matricesTexture.image.data = this._matricesTexture.image.data.slice();
      if (this._colorsTexture !== null) {
        this._colorsTexture = source._colorsTexture.clone();
        this._colorsTexture.image.data = this._colorsTexture.image.data.slice();
      }
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      // Assuming the geometry is not shared with other meshes
      this.geometry.dispose();
      this._matricesTexture.dispose();
      this._matricesTexture = null;
      this._indirectTexture.dispose();
      this._indirectTexture = null;
      if (this._colorsTexture !== null) {
        this._colorsTexture.dispose();
        this._colorsTexture = null;
      }
      return this;
    }
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender(renderer, scene, camera, geometry, material /*, _group*/) {
      // if visibility has not changed and frustum culling and object sorting is not required
      // then skip iterating over all items
      if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) {
        return;
      }

      // the indexed version of the multi draw function requires specifying the start
      // offset in bytes.
      var index = geometry.getIndex();
      var bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;
      var drawInfo = this._drawInfo;
      var multiDrawStarts = this._multiDrawStarts;
      var multiDrawCounts = this._multiDrawCounts;
      var drawRanges = this._drawRanges;
      var perObjectFrustumCulled = this.perObjectFrustumCulled;
      var indirectTexture = this._indirectTexture;
      var indirectArray = indirectTexture.image.data;

      // prepare the frustum in the local frame
      if (perObjectFrustumCulled) {
        _projScreenMatrix$2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse).multiply(this.matrixWorld);
        _frustum.setFromProjectionMatrix(_projScreenMatrix$2, renderer.coordinateSystem);
      }
      var count = 0;
      if (this.sortObjects) {
        // get the camera position in the local frame
        _invMatrixWorld.copy(this.matrixWorld).invert();
        _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_invMatrixWorld);
        _forward.set(0, 0, -1).transformDirection(camera.matrixWorld).transformDirection(_invMatrixWorld);
        for (var i = 0, l = drawInfo.length; i < l; i++) {
          if (drawInfo[i].visible && drawInfo[i].active) {
            var geometryId = drawInfo[i].geometryIndex;

            // get the bounds in world space
            this.getMatrixAt(i, _matrix$1);
            this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);

            // determine whether the batched geometry is within the frustum
            var culled = false;
            if (perObjectFrustumCulled) {
              culled = !_frustum.intersectsSphere(_sphere$2);
            }
            if (!culled) {
              // get the distance from camera used for sorting
              var z = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);
              _renderList.push(drawRanges[geometryId], z, i);
            }
          }
        }

        // Sort the draw ranges and prep for rendering
        var list = _renderList.list;
        var customSort = this.customSort;
        if (customSort === null) {
          list.sort(material.transparent ? sortTransparent : sortOpaque);
        } else {
          customSort.call(this, list, camera);
        }
        for (var _i60 = 0, _l10 = list.length; _i60 < _l10; _i60++) {
          var item = list[_i60];
          multiDrawStarts[count] = item.start * bytesPerElement;
          multiDrawCounts[count] = item.count;
          indirectArray[count] = item.index;
          count++;
        }
        _renderList.reset();
      } else {
        for (var _i61 = 0, _l11 = drawInfo.length; _i61 < _l11; _i61++) {
          if (drawInfo[_i61].visible && drawInfo[_i61].active) {
            var _geometryId = drawInfo[_i61].geometryIndex;

            // determine whether the batched geometry is within the frustum
            var _culled = false;
            if (perObjectFrustumCulled) {
              // get the bounds in world space
              this.getMatrixAt(_i61, _matrix$1);
              this.getBoundingSphereAt(_geometryId, _sphere$2).applyMatrix4(_matrix$1);
              _culled = !_frustum.intersectsSphere(_sphere$2);
            }
            if (!_culled) {
              var range = drawRanges[_geometryId];
              multiDrawStarts[count] = range.start * bytesPerElement;
              multiDrawCounts[count] = range.count;
              indirectArray[count] = _i61;
              count++;
            }
          }
        }
      }
      indirectTexture.needsUpdate = true;
      this._multiDrawCount = count;
      this._visibilityChanged = false;
    }
  }, {
    key: "onBeforeShadow",
    value: function onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial /* , group */) {
      this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);
    }
  }]);
}(Mesh);
var LineBasicMaterial = exports.LineBasicMaterial = /*#__PURE__*/function (_Material6) {
  function LineBasicMaterial(parameters) {
    var _this40;
    _classCallCheck(this, LineBasicMaterial);
    _this40 = _callSuper(this, LineBasicMaterial);
    _this40.isLineBasicMaterial = true;
    _this40.type = 'LineBasicMaterial';
    _this40.color = new Color(0xffffff);
    _this40.map = null;
    _this40.linewidth = 1;
    _this40.linecap = 'round';
    _this40.linejoin = 'round';
    _this40.fog = true;
    _this40.setValues(parameters);
    return _this40;
  }
  _inherits(LineBasicMaterial, _Material6);
  return _createClass(LineBasicMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(LineBasicMaterial, "copy", this, 3)([source]);
      this.color.copy(source.color);
      this.map = source.map;
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material);
var _vStart = /*@__PURE__*/new Vector3();
var _vEnd = /*@__PURE__*/new Vector3();
var _inverseMatrix$1 = /*@__PURE__*/new Matrix4();
var _ray$1 = /*@__PURE__*/new Ray();
var _sphere$1 = /*@__PURE__*/new Sphere();
var _intersectPointOnRay = /*@__PURE__*/new Vector3();
var _intersectPointOnSegment = /*@__PURE__*/new Vector3();
var Line = exports.Line = /*#__PURE__*/function (_Object3D9) {
  function Line() {
    var _this41;
    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineBasicMaterial();
    _classCallCheck(this, Line);
    _this41 = _callSuper(this, Line);
    _this41.isLine = true;
    _this41.type = 'Line';
    _this41.geometry = geometry;
    _this41.material = material;
    _this41.updateMorphTargets();
    return _this41;
  }
  _inherits(Line, _Object3D9);
  return _createClass(Line, [{
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(Line, "copy", this, 3)([source, recursive]);
      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
      this.geometry = source.geometry;
      return this;
    }
  }, {
    key: "computeLineDistances",
    value: function computeLineDistances() {
      var geometry = this.geometry;

      // we assume non-indexed geometry

      if (geometry.index === null) {
        var positionAttribute = geometry.attributes.position;
        var lineDistances = [0];
        for (var i = 1, l = positionAttribute.count; i < l; i++) {
          _vStart.fromBufferAttribute(positionAttribute, i - 1);
          _vEnd.fromBufferAttribute(positionAttribute, i);
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _vStart.distanceTo(_vEnd);
        }
        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
      return this;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold = raycaster.params.Line.threshold;
      var drawRange = geometry.drawRange;

      // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$1.copy(geometry.boundingSphere);
      _sphere$1.applyMatrix4(matrixWorld);
      _sphere$1.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;

      //

      _inverseMatrix$1.copy(matrixWorld).invert();
      _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;
      var step = this.isLineSegments ? 2 : 1;
      var index = geometry.index;
      var attributes = geometry.attributes;
      var positionAttribute = attributes.position;
      if (index !== null) {
        var start = Math.max(0, drawRange.start);
        var end = Math.min(index.count, drawRange.start + drawRange.count);
        for (var i = start, l = end - 1; i < l; i += step) {
          var a = index.getX(i);
          var b = index.getX(i + 1);
          var _intersect3 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
          if (_intersect3) {
            intersects.push(_intersect3);
          }
        }
        if (this.isLineLoop) {
          var _a5 = index.getX(end - 1);
          var _b5 = index.getX(start);
          var _intersect4 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, _a5, _b5);
          if (_intersect4) {
            intersects.push(_intersect4);
          }
        }
      } else {
        var _start6 = Math.max(0, drawRange.start);
        var _end5 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (var _i62 = _start6, _l12 = _end5 - 1; _i62 < _l12; _i62 += step) {
          var _intersect5 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, _i62, _i62 + 1);
          if (_intersect5) {
            intersects.push(_intersect5);
          }
        }
        if (this.isLineLoop) {
          var _intersect6 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, _end5 - 1, _start6);
          if (_intersect6) {
            intersects.push(_intersect6);
          }
        }
      }
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var geometry = this.geometry;
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
            var name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    }
  }]);
}(Object3D);
function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
  var positionAttribute = object.geometry.attributes.position;
  _vStart.fromBufferAttribute(positionAttribute, a);
  _vEnd.fromBufferAttribute(positionAttribute, b);
  var distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
  if (distSq > thresholdSq) return;
  _intersectPointOnRay.applyMatrix4(object.matrixWorld); // Move back to world space for distance calculation

  var distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
  if (distance < raycaster.near || distance > raycaster.far) return;
  return {
    distance: distance,
    // What do we want? intersection point on the ray or on the segment??
    // point: raycaster.ray.at( distance ),
    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
    index: a,
    face: null,
    faceIndex: null,
    object: object
  };
}
var _start = /*@__PURE__*/new Vector3();
var _end = /*@__PURE__*/new Vector3();
var LineSegments = exports.LineSegments = /*#__PURE__*/function (_Line) {
  function LineSegments(geometry, material) {
    var _this42;
    _classCallCheck(this, LineSegments);
    _this42 = _callSuper(this, LineSegments, [geometry, material]);
    _this42.isLineSegments = true;
    _this42.type = 'LineSegments';
    return _this42;
  }
  _inherits(LineSegments, _Line);
  return _createClass(LineSegments, [{
    key: "computeLineDistances",
    value: function computeLineDistances() {
      var geometry = this.geometry;

      // we assume non-indexed geometry

      if (geometry.index === null) {
        var positionAttribute = geometry.attributes.position;
        var lineDistances = [];
        for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start.fromBufferAttribute(positionAttribute, i);
          _end.fromBufferAttribute(positionAttribute, i + 1);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
        }
        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
      return this;
    }
  }]);
}(Line);
var LineLoop = exports.LineLoop = /*#__PURE__*/function (_Line2) {
  function LineLoop(geometry, material) {
    var _this43;
    _classCallCheck(this, LineLoop);
    _this43 = _callSuper(this, LineLoop, [geometry, material]);
    _this43.isLineLoop = true;
    _this43.type = 'LineLoop';
    return _this43;
  }
  _inherits(LineLoop, _Line2);
  return _createClass(LineLoop);
}(Line);
var PointsMaterial = exports.PointsMaterial = /*#__PURE__*/function (_Material7) {
  function PointsMaterial(parameters) {
    var _this44;
    _classCallCheck(this, PointsMaterial);
    _this44 = _callSuper(this, PointsMaterial);
    _this44.isPointsMaterial = true;
    _this44.type = 'PointsMaterial';
    _this44.color = new Color(0xffffff);
    _this44.map = null;
    _this44.alphaMap = null;
    _this44.size = 1;
    _this44.sizeAttenuation = true;
    _this44.fog = true;
    _this44.setValues(parameters);
    return _this44;
  }
  _inherits(PointsMaterial, _Material7);
  return _createClass(PointsMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(PointsMaterial, "copy", this, 3)([source]);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material);
var _inverseMatrix = /*@__PURE__*/new Matrix4();
var _ray = /*@__PURE__*/new Ray();
var _sphere = /*@__PURE__*/new Sphere();
var _position$2 = /*@__PURE__*/new Vector3();
var Points = exports.Points = /*#__PURE__*/function (_Object3D10) {
  function Points() {
    var _this45;
    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PointsMaterial();
    _classCallCheck(this, Points);
    _this45 = _callSuper(this, Points);
    _this45.isPoints = true;
    _this45.type = 'Points';
    _this45.geometry = geometry;
    _this45.material = material;
    _this45.updateMorphTargets();
    return _this45;
  }
  _inherits(Points, _Object3D10);
  return _createClass(Points, [{
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(Points, "copy", this, 3)([source, recursive]);
      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
      this.geometry = source.geometry;
      return this;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold = raycaster.params.Points.threshold;
      var drawRange = geometry.drawRange;

      // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere.copy(geometry.boundingSphere);
      _sphere.applyMatrix4(matrixWorld);
      _sphere.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere) === false) return;

      //

      _inverseMatrix.copy(matrixWorld).invert();
      _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;
      var index = geometry.index;
      var attributes = geometry.attributes;
      var positionAttribute = attributes.position;
      if (index !== null) {
        var start = Math.max(0, drawRange.start);
        var end = Math.min(index.count, drawRange.start + drawRange.count);
        for (var i = start, il = end; i < il; i++) {
          var a = index.getX(i);
          _position$2.fromBufferAttribute(positionAttribute, a);
          testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      } else {
        var _start7 = Math.max(0, drawRange.start);
        var _end6 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (var _i63 = _start7, l = _end6; _i63 < l; _i63++) {
          _position$2.fromBufferAttribute(positionAttribute, _i63);
          testPoint(_position$2, _i63, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var geometry = this.geometry;
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
            var name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    }
  }]);
}(Object3D);
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  var rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    var intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index,
      face: null,
      object: object
    });
  }
}
var VideoTexture = exports.VideoTexture = /*#__PURE__*/function (_Texture6) {
  function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    var _this46;
    _classCallCheck(this, VideoTexture);
    _this46 = _callSuper(this, VideoTexture, [video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy]);
    _this46.isVideoTexture = true;
    _this46.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
    _this46.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    _this46.generateMipmaps = false;
    var scope = _this46;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ('requestVideoFrameCallback' in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
    return _this46;
  }
  _inherits(VideoTexture, _Texture6);
  return _createClass(VideoTexture, [{
    key: "clone",
    value: function clone() {
      return new this.constructor(this.image).copy(this);
    }
  }, {
    key: "update",
    value: function update() {
      var video = this.image;
      var hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
      if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
        this.needsUpdate = true;
      }
    }
  }]);
}(Texture);
var FramebufferTexture = exports.FramebufferTexture = /*#__PURE__*/function (_Texture7) {
  function FramebufferTexture(width, height) {
    var _this47;
    _classCallCheck(this, FramebufferTexture);
    _this47 = _callSuper(this, FramebufferTexture, [{
      width: width,
      height: height
    }]);
    _this47.isFramebufferTexture = true;
    _this47.magFilter = NearestFilter;
    _this47.minFilter = NearestFilter;
    _this47.generateMipmaps = false;
    _this47.needsUpdate = true;
    return _this47;
  }
  _inherits(FramebufferTexture, _Texture7);
  return _createClass(FramebufferTexture);
}(Texture);
var CompressedTexture = exports.CompressedTexture = /*#__PURE__*/function (_Texture8) {
  function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {
    var _this48;
    _classCallCheck(this, CompressedTexture);
    _this48 = _callSuper(this, CompressedTexture, [null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace]);
    _this48.isCompressedTexture = true;
    _this48.image = {
      width: width,
      height: height
    };
    _this48.mipmaps = mipmaps;

    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )

    _this48.flipY = false;

    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files

    _this48.generateMipmaps = false;
    return _this48;
  }
  _inherits(CompressedTexture, _Texture8);
  return _createClass(CompressedTexture);
}(Texture);
var CompressedArrayTexture = exports.CompressedArrayTexture = /*#__PURE__*/function (_CompressedTexture) {
  function CompressedArrayTexture(mipmaps, width, height, depth, format, type) {
    var _this49;
    _classCallCheck(this, CompressedArrayTexture);
    _this49 = _callSuper(this, CompressedArrayTexture, [mipmaps, width, height, format, type]);
    _this49.isCompressedArrayTexture = true;
    _this49.image.depth = depth;
    _this49.wrapR = ClampToEdgeWrapping;
    _this49.layerUpdates = new Set();
    return _this49;
  }
  _inherits(CompressedArrayTexture, _CompressedTexture);
  return _createClass(CompressedArrayTexture, [{
    key: "addLayerUpdate",
    value: function addLayerUpdate(layerIndex) {
      this.layerUpdates.add(layerIndex);
    }
  }, {
    key: "clearLayerUpdates",
    value: function clearLayerUpdates() {
      this.layerUpdates.clear();
    }
  }]);
}(CompressedTexture);
var CompressedCubeTexture = exports.CompressedCubeTexture = /*#__PURE__*/function (_CompressedTexture2) {
  function CompressedCubeTexture(images, format, type) {
    var _this50;
    _classCallCheck(this, CompressedCubeTexture);
    _this50 = _callSuper(this, CompressedCubeTexture, [undefined, images[0].width, images[0].height, format, type, CubeReflectionMapping]);
    _this50.isCompressedCubeTexture = true;
    _this50.isCubeTexture = true;
    _this50.image = images;
    return _this50;
  }
  _inherits(CompressedCubeTexture, _CompressedTexture2);
  return _createClass(CompressedCubeTexture);
}(CompressedTexture);
var CanvasTexture = exports.CanvasTexture = /*#__PURE__*/function (_Texture9) {
  function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    var _this51;
    _classCallCheck(this, CanvasTexture);
    _this51 = _callSuper(this, CanvasTexture, [canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy]);
    _this51.isCanvasTexture = true;
    _this51.needsUpdate = true;
    return _this51;
  }
  _inherits(CanvasTexture, _Texture9);
  return _createClass(CanvasTexture);
}(Texture);
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/
var Curve = exports.Curve = /*#__PURE__*/function () {
  function Curve() {
    _classCallCheck(this, Curve);
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
  }

  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  return _createClass(Curve, [{
    key: "getPoint",
    value: function getPoint( /* t, optionalTarget */
    ) {
      console.warn('THREE.Curve: .getPoint() not implemented.');
      return null;
    }

    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
  }, {
    key: "getPointAt",
    value: function getPointAt(u, optionalTarget) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t, optionalTarget);
    }

    // Get sequence of points using getPoint( t )
  }, {
    key: "getPoints",
    value: function getPoints() {
      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
      var points = [];
      for (var d = 0; d <= divisions; d++) {
        points.push(this.getPoint(d / divisions));
      }
      return points;
    }

    // Get sequence of points using getPointAt( u )
  }, {
    key: "getSpacedPoints",
    value: function getSpacedPoints() {
      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
      var points = [];
      for (var d = 0; d <= divisions; d++) {
        points.push(this.getPointAt(d / divisions));
      }
      return points;
    }

    // Get total curve arc length
  }, {
    key: "getLength",
    value: function getLength() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    }

    // Get list of cumulative segment lengths
  }, {
    key: "getLengths",
    value: function getLengths() {
      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.arcLengthDivisions;
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      var cache = [];
      var current,
        last = this.getPoint(0);
      var sum = 0;
      cache.push(0);
      for (var p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    }
  }, {
    key: "updateArcLengths",
    value: function updateArcLengths() {
      this.needsUpdate = true;
      this.getLengths();
    }

    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  }, {
    key: "getUtoTmapping",
    value: function getUtoTmapping(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0;
      var il = arcLengths.length;
      var targetArcLength; // The targeted u distance value to get

      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }

      // binary search for the index with largest value smaller than target u distance

      var low = 0,
        high = il - 1,
        comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;

          // DONE
        }
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        return i / (il - 1);
      }

      // we could get finer grain at lengths, or use simple interpolation between two points

      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;

      // determine where we are between the 'before' and 'after' points

      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

      // add that fractional amount to t

      var t = (i + segmentFraction) / (il - 1);
      return t;
    }

    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
  }, {
    key: "getTangent",
    value: function getTangent(t, optionalTarget) {
      var delta = 0.0001;
      var t1 = t - delta;
      var t2 = t + delta;

      // Capping in case of danger

      if (t1 < 0) t1 = 0;
      if (t2 > 1) t2 = 1;
      var pt1 = this.getPoint(t1);
      var pt2 = this.getPoint(t2);
      var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
      tangent.copy(pt2).sub(pt1).normalize();
      return tangent;
    }
  }, {
    key: "getTangentAt",
    value: function getTangentAt(u, optionalTarget) {
      var t = this.getUtoTmapping(u);
      return this.getTangent(t, optionalTarget);
    }
  }, {
    key: "computeFrenetFrames",
    value: function computeFrenetFrames(segments, closed) {
      // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

      var normal = new Vector3();
      var tangents = [];
      var normals = [];
      var binormals = [];
      var vec = new Vector3();
      var mat = new Matrix4();

      // compute the tangent vectors for each segment on the curve

      for (var i = 0; i <= segments; i++) {
        var u = i / segments;
        tangents[i] = this.getTangentAt(u, new Vector3());
      }

      // select an initial normal vector perpendicular to the first tangent vector,
      // and in the direction of the minimum tangent xyz component

      normals[0] = new Vector3();
      binormals[0] = new Vector3();
      var min = Number.MAX_VALUE;
      var tx = Math.abs(tangents[0].x);
      var ty = Math.abs(tangents[0].y);
      var tz = Math.abs(tangents[0].z);
      if (tx <= min) {
        min = tx;
        normal.set(1, 0, 0);
      }
      if (ty <= min) {
        min = ty;
        normal.set(0, 1, 0);
      }
      if (tz <= min) {
        normal.set(0, 0, 1);
      }
      vec.crossVectors(tangents[0], normal).normalize();
      normals[0].crossVectors(tangents[0], vec);
      binormals[0].crossVectors(tangents[0], normals[0]);

      // compute the slowly-varying normal and binormal vectors for each segment on the curve

      for (var _i64 = 1; _i64 <= segments; _i64++) {
        normals[_i64] = normals[_i64 - 1].clone();
        binormals[_i64] = binormals[_i64 - 1].clone();
        vec.crossVectors(tangents[_i64 - 1], tangents[_i64]);
        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          var theta = Math.acos(clamp(tangents[_i64 - 1].dot(tangents[_i64]), -1, 1)); // clamp for floating pt errors

          normals[_i64].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[_i64].crossVectors(tangents[_i64], normals[_i64]);
      }

      // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

      if (closed === true) {
        var _theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
        _theta /= segments;
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
          _theta = -_theta;
        }
        for (var _i65 = 1; _i65 <= segments; _i65++) {
          // twist a little...
          normals[_i65].applyMatrix4(mat.makeRotationAxis(tangents[_i65], _theta * _i65));
          binormals[_i65].crossVectors(tangents[_i65], normals[_i65]);
        }
      }
      return {
        tangents: tangents,
        normals: normals,
        binormals: binormals
      };
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.arcLengthDivisions = source.arcLengthDivisions;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        metadata: {
          version: 4.6,
          type: 'Curve',
          generator: 'Curve.toJSON'
        }
      };
      data.arcLengthDivisions = this.arcLengthDivisions;
      data.type = this.type;
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      this.arcLengthDivisions = json.arcLengthDivisions;
      return this;
    }
  }]);
}();
var EllipseCurve = exports.EllipseCurve = /*#__PURE__*/function (_Curve) {
  function EllipseCurve() {
    var _this52;
    var aX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var aY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var xRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var yRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var aStartAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var aEndAngle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;
    var aClockwise = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var aRotation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    _classCallCheck(this, EllipseCurve);
    _this52 = _callSuper(this, EllipseCurve);
    _this52.isEllipseCurve = true;
    _this52.type = 'EllipseCurve';
    _this52.aX = aX;
    _this52.aY = aY;
    _this52.xRadius = xRadius;
    _this52.yRadius = yRadius;
    _this52.aStartAngle = aStartAngle;
    _this52.aEndAngle = aEndAngle;
    _this52.aClockwise = aClockwise;
    _this52.aRotation = aRotation;
    return _this52;
  }
  _inherits(EllipseCurve, _Curve);
  return _createClass(EllipseCurve, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
      var point = optionalTarget;
      var twoPi = Math.PI * 2;
      var deltaAngle = this.aEndAngle - this.aStartAngle;
      var samePoints = Math.abs(deltaAngle) < Number.EPSILON;

      // ensures that deltaAngle is 0 .. 2 PI
      while (deltaAngle < 0) deltaAngle += twoPi;
      while (deltaAngle > twoPi) deltaAngle -= twoPi;
      if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
          deltaAngle = 0;
        } else {
          deltaAngle = twoPi;
        }
      }
      if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) {
          deltaAngle = -twoPi;
        } else {
          deltaAngle = deltaAngle - twoPi;
        }
      }
      var angle = this.aStartAngle + t * deltaAngle;
      var x = this.aX + this.xRadius * Math.cos(angle);
      var y = this.aY + this.yRadius * Math.sin(angle);
      if (this.aRotation !== 0) {
        var cos = Math.cos(this.aRotation);
        var sin = Math.sin(this.aRotation);
        var tx = x - this.aX;
        var ty = y - this.aY;

        // Rotate the point about the center of the ellipse.
        x = tx * cos - ty * sin + this.aX;
        y = tx * sin + ty * cos + this.aY;
      }
      return point.set(x, y);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(EllipseCurve, "copy", this, 3)([source]);
      this.aX = source.aX;
      this.aY = source.aY;
      this.xRadius = source.xRadius;
      this.yRadius = source.yRadius;
      this.aStartAngle = source.aStartAngle;
      this.aEndAngle = source.aEndAngle;
      this.aClockwise = source.aClockwise;
      this.aRotation = source.aRotation;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(EllipseCurve, "toJSON", this, 3)([]);
      data.aX = this.aX;
      data.aY = this.aY;
      data.xRadius = this.xRadius;
      data.yRadius = this.yRadius;
      data.aStartAngle = this.aStartAngle;
      data.aEndAngle = this.aEndAngle;
      data.aClockwise = this.aClockwise;
      data.aRotation = this.aRotation;
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(EllipseCurve, "fromJSON", this, 3)([json]);
      this.aX = json.aX;
      this.aY = json.aY;
      this.xRadius = json.xRadius;
      this.yRadius = json.yRadius;
      this.aStartAngle = json.aStartAngle;
      this.aEndAngle = json.aEndAngle;
      this.aClockwise = json.aClockwise;
      this.aRotation = json.aRotation;
      return this;
    }
  }]);
}(Curve);
var ArcCurve = exports.ArcCurve = /*#__PURE__*/function (_EllipseCurve) {
  function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    var _this53;
    _classCallCheck(this, ArcCurve);
    _this53 = _callSuper(this, ArcCurve, [aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise]);
    _this53.isArcCurve = true;
    _this53.type = 'ArcCurve';
    return _this53;
  }
  _inherits(ArcCurve, _EllipseCurve);
  return _createClass(ArcCurve);
}(EllipseCurve);
/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */
/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/
function CubicPoly() {
  var c0 = 0,
    c1 = 0,
    c2 = 0,
    c3 = 0;

  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

      // rescale tangents for parametrization in [0,1]
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function calc(t) {
      var t2 = t * t;
      var t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}

//

var tmp = /*@__PURE__*/new Vector3();
var px = /*@__PURE__*/new CubicPoly();
var py = /*@__PURE__*/new CubicPoly();
var pz = /*@__PURE__*/new CubicPoly();
var CatmullRomCurve3 = exports.CatmullRomCurve3 = /*#__PURE__*/function (_Curve2) {
  function CatmullRomCurve3() {
    var _this54;
    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var curveType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'centripetal';
    var tension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
    _classCallCheck(this, CatmullRomCurve3);
    _this54 = _callSuper(this, CatmullRomCurve3);
    _this54.isCatmullRomCurve3 = true;
    _this54.type = 'CatmullRomCurve3';
    _this54.points = points;
    _this54.closed = closed;
    _this54.curveType = curveType;
    _this54.tension = tension;
    return _this54;
  }
  _inherits(CatmullRomCurve3, _Curve2);
  return _createClass(CatmullRomCurve3, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      var point = optionalTarget;
      var points = this.points;
      var l = points.length;
      var p = (l - (this.closed ? 0 : 1)) * t;
      var intPoint = Math.floor(p);
      var weight = p - intPoint;
      if (this.closed) {
        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
      } else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
      }
      var p0, p3; // 4 points (p1 & p2 defined below)

      if (this.closed || intPoint > 0) {
        p0 = points[(intPoint - 1) % l];
      } else {
        // extrapolate first point
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
      }
      var p1 = points[intPoint % l];
      var p2 = points[(intPoint + 1) % l];
      if (this.closed || intPoint + 2 < l) {
        p3 = points[(intPoint + 2) % l];
      } else {
        // extrapolate last point
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
      }
      if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
        // init Centripetal / Chordal Catmull-Rom
        var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
        var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        var dt2 = Math.pow(p2.distanceToSquared(p3), pow);

        // safety check for repeated points
        if (dt1 < 1e-4) dt1 = 1.0;
        if (dt0 < 1e-4) dt0 = dt1;
        if (dt2 < 1e-4) dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
      } else if (this.curveType === 'catmullrom') {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
      }
      point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(CatmullRomCurve3, "copy", this, 3)([source]);
      this.points = [];
      for (var i = 0, l = source.points.length; i < l; i++) {
        var point = source.points[i];
        this.points.push(point.clone());
      }
      this.closed = source.closed;
      this.curveType = source.curveType;
      this.tension = source.tension;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(CatmullRomCurve3, "toJSON", this, 3)([]);
      data.points = [];
      for (var i = 0, l = this.points.length; i < l; i++) {
        var point = this.points[i];
        data.points.push(point.toArray());
      }
      data.closed = this.closed;
      data.curveType = this.curveType;
      data.tension = this.tension;
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(CatmullRomCurve3, "fromJSON", this, 3)([json]);
      this.points = [];
      for (var i = 0, l = json.points.length; i < l; i++) {
        var point = json.points[i];
        this.points.push(new Vector3().fromArray(point));
      }
      this.closed = json.closed;
      this.curveType = json.curveType;
      this.tension = json.tension;
      return this;
    }
  }]);
}(Curve);
/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */
function CatmullRom(t, p0, p1, p2, p3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}

//

function QuadraticBezierP0(t, p) {
  var k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}

//

function CubicBezierP0(t, p) {
  var k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  var k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
var CubicBezierCurve = exports.CubicBezierCurve = /*#__PURE__*/function (_Curve3) {
  function CubicBezierCurve() {
    var _this55;
    var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
    var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
    var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();
    var v3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Vector2();
    _classCallCheck(this, CubicBezierCurve);
    _this55 = _callSuper(this, CubicBezierCurve);
    _this55.isCubicBezierCurve = true;
    _this55.type = 'CubicBezierCurve';
    _this55.v0 = v0;
    _this55.v1 = v1;
    _this55.v2 = v2;
    _this55.v3 = v3;
    return _this55;
  }
  _inherits(CubicBezierCurve, _Curve3);
  return _createClass(CubicBezierCurve, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
      var point = optionalTarget;
      var v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2,
        v3 = this.v3;
      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(CubicBezierCurve, "copy", this, 3)([source]);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(CubicBezierCurve, "toJSON", this, 3)([]);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(CubicBezierCurve, "fromJSON", this, 3)([json]);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  }]);
}(Curve);
var CubicBezierCurve3 = exports.CubicBezierCurve3 = /*#__PURE__*/function (_Curve4) {
  function CubicBezierCurve3() {
    var _this56;
    var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
    var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
    var v3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Vector3();
    _classCallCheck(this, CubicBezierCurve3);
    _this56 = _callSuper(this, CubicBezierCurve3);
    _this56.isCubicBezierCurve3 = true;
    _this56.type = 'CubicBezierCurve3';
    _this56.v0 = v0;
    _this56.v1 = v1;
    _this56.v2 = v2;
    _this56.v3 = v3;
    return _this56;
  }
  _inherits(CubicBezierCurve3, _Curve4);
  return _createClass(CubicBezierCurve3, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      var point = optionalTarget;
      var v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2,
        v3 = this.v3;
      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(CubicBezierCurve3, "copy", this, 3)([source]);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(CubicBezierCurve3, "toJSON", this, 3)([]);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(CubicBezierCurve3, "fromJSON", this, 3)([json]);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  }]);
}(Curve);
var LineCurve = exports.LineCurve = /*#__PURE__*/function (_Curve5) {
  function LineCurve() {
    var _this57;
    var v1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
    var v2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
    _classCallCheck(this, LineCurve);
    _this57 = _callSuper(this, LineCurve);
    _this57.isLineCurve = true;
    _this57.type = 'LineCurve';
    _this57.v1 = v1;
    _this57.v2 = v2;
    return _this57;
  }
  _inherits(LineCurve, _Curve5);
  return _createClass(LineCurve, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
      var point = optionalTarget;
      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }
      return point;
    }

    // Line curve is linear, so we can overwrite default getPointAt
  }, {
    key: "getPointAt",
    value: function getPointAt(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    }
  }, {
    key: "getTangent",
    value: function getTangent(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
      return optionalTarget.subVectors(this.v2, this.v1).normalize();
    }
  }, {
    key: "getTangentAt",
    value: function getTangentAt(u, optionalTarget) {
      return this.getTangent(u, optionalTarget);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(LineCurve, "copy", this, 3)([source]);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(LineCurve, "toJSON", this, 3)([]);
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(LineCurve, "fromJSON", this, 3)([json]);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  }]);
}(Curve);
var LineCurve3 = exports.LineCurve3 = /*#__PURE__*/function (_Curve6) {
  function LineCurve3() {
    var _this58;
    var v1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var v2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
    _classCallCheck(this, LineCurve3);
    _this58 = _callSuper(this, LineCurve3);
    _this58.isLineCurve3 = true;
    _this58.type = 'LineCurve3';
    _this58.v1 = v1;
    _this58.v2 = v2;
    return _this58;
  }
  _inherits(LineCurve3, _Curve6);
  return _createClass(LineCurve3, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      var point = optionalTarget;
      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }
      return point;
    }

    // Line curve is linear, so we can overwrite default getPointAt
  }, {
    key: "getPointAt",
    value: function getPointAt(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    }
  }, {
    key: "getTangent",
    value: function getTangent(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      return optionalTarget.subVectors(this.v2, this.v1).normalize();
    }
  }, {
    key: "getTangentAt",
    value: function getTangentAt(u, optionalTarget) {
      return this.getTangent(u, optionalTarget);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(LineCurve3, "copy", this, 3)([source]);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(LineCurve3, "toJSON", this, 3)([]);
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(LineCurve3, "fromJSON", this, 3)([json]);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  }]);
}(Curve);
var QuadraticBezierCurve = exports.QuadraticBezierCurve = /*#__PURE__*/function (_Curve7) {
  function QuadraticBezierCurve() {
    var _this59;
    var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
    var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
    var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();
    _classCallCheck(this, QuadraticBezierCurve);
    _this59 = _callSuper(this, QuadraticBezierCurve);
    _this59.isQuadraticBezierCurve = true;
    _this59.type = 'QuadraticBezierCurve';
    _this59.v0 = v0;
    _this59.v1 = v1;
    _this59.v2 = v2;
    return _this59;
  }
  _inherits(QuadraticBezierCurve, _Curve7);
  return _createClass(QuadraticBezierCurve, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
      var point = optionalTarget;
      var v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2;
      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(QuadraticBezierCurve, "copy", this, 3)([source]);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(QuadraticBezierCurve, "toJSON", this, 3)([]);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(QuadraticBezierCurve, "fromJSON", this, 3)([json]);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  }]);
}(Curve);
var QuadraticBezierCurve3 = exports.QuadraticBezierCurve3 = /*#__PURE__*/function (_Curve8) {
  function QuadraticBezierCurve3() {
    var _this60;
    var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
    var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
    _classCallCheck(this, QuadraticBezierCurve3);
    _this60 = _callSuper(this, QuadraticBezierCurve3);
    _this60.isQuadraticBezierCurve3 = true;
    _this60.type = 'QuadraticBezierCurve3';
    _this60.v0 = v0;
    _this60.v1 = v1;
    _this60.v2 = v2;
    return _this60;
  }
  _inherits(QuadraticBezierCurve3, _Curve8);
  return _createClass(QuadraticBezierCurve3, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      var point = optionalTarget;
      var v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2;
      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(QuadraticBezierCurve3, "copy", this, 3)([source]);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(QuadraticBezierCurve3, "toJSON", this, 3)([]);
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(QuadraticBezierCurve3, "fromJSON", this, 3)([json]);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  }]);
}(Curve);
var SplineCurve = exports.SplineCurve = /*#__PURE__*/function (_Curve9) {
  function SplineCurve() {
    var _this61;
    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    _classCallCheck(this, SplineCurve);
    _this61 = _callSuper(this, SplineCurve);
    _this61.isSplineCurve = true;
    _this61.type = 'SplineCurve';
    _this61.points = points;
    return _this61;
  }
  _inherits(SplineCurve, _Curve9);
  return _createClass(SplineCurve, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
      var point = optionalTarget;
      var points = this.points;
      var p = (points.length - 1) * t;
      var intPoint = Math.floor(p);
      var weight = p - intPoint;
      var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      var p1 = points[intPoint];
      var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(SplineCurve, "copy", this, 3)([source]);
      this.points = [];
      for (var i = 0, l = source.points.length; i < l; i++) {
        var point = source.points[i];
        this.points.push(point.clone());
      }
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(SplineCurve, "toJSON", this, 3)([]);
      data.points = [];
      for (var i = 0, l = this.points.length; i < l; i++) {
        var point = this.points[i];
        data.points.push(point.toArray());
      }
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(SplineCurve, "fromJSON", this, 3)([json]);
      this.points = [];
      for (var i = 0, l = json.points.length; i < l; i++) {
        var point = json.points[i];
        this.points.push(new Vector2().fromArray(point));
      }
      return this;
    }
  }]);
}(Curve);
var Curves = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArcCurve: ArcCurve,
  CatmullRomCurve3: CatmullRomCurve3,
  CubicBezierCurve: CubicBezierCurve,
  CubicBezierCurve3: CubicBezierCurve3,
  EllipseCurve: EllipseCurve,
  LineCurve: LineCurve,
  LineCurve3: LineCurve3,
  QuadraticBezierCurve: QuadraticBezierCurve,
  QuadraticBezierCurve3: QuadraticBezierCurve3,
  SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/
var CurvePath = exports.CurvePath = /*#__PURE__*/function (_Curve10) {
  function CurvePath() {
    var _this62;
    _classCallCheck(this, CurvePath);
    _this62 = _callSuper(this, CurvePath);
    _this62.type = 'CurvePath';
    _this62.curves = [];
    _this62.autoClose = false; // Automatically closes the path
    return _this62;
  }
  _inherits(CurvePath, _Curve10);
  return _createClass(CurvePath, [{
    key: "add",
    value: function add(curve) {
      this.curves.push(curve);
    }
  }, {
    key: "closePath",
    value: function closePath() {
      // Add a line curve if start and end of lines are not connected
      var startPoint = this.curves[0].getPoint(0);
      var endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        var lineType = startPoint.isVector2 === true ? 'LineCurve' : 'LineCurve3';
        this.curves.push(new Curves[lineType](endPoint, startPoint));
      }
      return this;
    }

    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:

    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
  }, {
    key: "getPoint",
    value: function getPoint(t, optionalTarget) {
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0;

      // To think about boundaries points.

      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          var diff = curveLengths[i] - d;
          var curve = this.curves[i];
          var segmentLength = curve.getLength();
          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getPointAt(u, optionalTarget);
        }
        i++;
      }
      return null;

      // loop where sum != 0, sum > d , sum+1 <d
    }

    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
  }, {
    key: "getLength",
    value: function getLength() {
      var lens = this.getCurveLengths();
      return lens[lens.length - 1];
    }

    // cacheLengths must be recalculated.
  }, {
    key: "updateArcLengths",
    value: function updateArcLengths() {
      this.needsUpdate = true;
      this.cacheLengths = null;
      this.getCurveLengths();
    }

    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
  }, {
    key: "getCurveLengths",
    value: function getCurveLengths() {
      // We use cache values if curves and cache array are same length

      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }

      // Get length of sub-curve
      // Push sums into cached array

      var lengths = [];
      var sums = 0;
      for (var i = 0, l = this.curves.length; i < l; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    }
  }, {
    key: "getSpacedPoints",
    value: function getSpacedPoints() {
      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 40;
      var points = [];
      for (var i = 0; i <= divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      if (this.autoClose) {
        points.push(points[0]);
      }
      return points;
    }
  }, {
    key: "getPoints",
    value: function getPoints() {
      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;
      var points = [];
      var last;
      for (var i = 0, curves = this.curves; i < curves.length; i++) {
        var curve = curves[i];
        var resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
        var pts = curve.getPoints(resolution);
        for (var j = 0; j < pts.length; j++) {
          var point = pts[j];
          if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

          points.push(point);
          last = point;
        }
      }
      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
        points.push(points[0]);
      }
      return points;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(CurvePath, "copy", this, 3)([source]);
      this.curves = [];
      for (var i = 0, l = source.curves.length; i < l; i++) {
        var curve = source.curves[i];
        this.curves.push(curve.clone());
      }
      this.autoClose = source.autoClose;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(CurvePath, "toJSON", this, 3)([]);
      data.autoClose = this.autoClose;
      data.curves = [];
      for (var i = 0, l = this.curves.length; i < l; i++) {
        var curve = this.curves[i];
        data.curves.push(curve.toJSON());
      }
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(CurvePath, "fromJSON", this, 3)([json]);
      this.autoClose = json.autoClose;
      this.curves = [];
      for (var i = 0, l = json.curves.length; i < l; i++) {
        var curve = json.curves[i];
        this.curves.push(new Curves[curve.type]().fromJSON(curve));
      }
      return this;
    }
  }]);
}(Curve);
var Path = exports.Path = /*#__PURE__*/function (_CurvePath) {
  function Path(points) {
    var _this63;
    _classCallCheck(this, Path);
    _this63 = _callSuper(this, Path);
    _this63.type = 'Path';
    _this63.currentPoint = new Vector2();
    if (points) {
      _this63.setFromPoints(points);
    }
    return _this63;
  }
  _inherits(Path, _CurvePath);
  return _createClass(Path, [{
    key: "setFromPoints",
    value: function setFromPoints(points) {
      this.moveTo(points[0].x, points[0].y);
      for (var i = 1, l = points.length; i < l; i++) {
        this.lineTo(points[i].x, points[i].y);
      }
      return this;
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y) {
      this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

      return this;
    }
  }, {
    key: "lineTo",
    value: function lineTo(x, y) {
      var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
      this.curves.push(curve);
      this.currentPoint.set(x, y);
      return this;
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
      var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
  }, {
    key: "splineThru",
    value: function splineThru(pts /*Array of Vector*/) {
      var npts = [this.currentPoint.clone()].concat(pts);
      var curve = new SplineCurve(npts);
      this.curves.push(curve);
      this.currentPoint.copy(pts[pts.length - 1]);
      return this;
    }
  }, {
    key: "arc",
    value: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    }
  }, {
    key: "absarc",
    value: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    }
  }, {
    key: "ellipse",
    value: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      return this;
    }
  }, {
    key: "absellipse",
    value: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      if (this.curves.length > 0) {
        // if a previous curve is present, attempt to join
        var firstPoint = curve.getPoint(0);
        if (!firstPoint.equals(this.currentPoint)) {
          this.lineTo(firstPoint.x, firstPoint.y);
        }
      }
      this.curves.push(curve);
      var lastPoint = curve.getPoint(1);
      this.currentPoint.copy(lastPoint);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(Path, "copy", this, 3)([source]);
      this.currentPoint.copy(source.currentPoint);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(Path, "toJSON", this, 3)([]);
      data.currentPoint = this.currentPoint.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(Path, "fromJSON", this, 3)([json]);
      this.currentPoint.fromArray(json.currentPoint);
      return this;
    }
  }]);
}(CurvePath);
var LatheGeometry = exports.LatheGeometry = /*#__PURE__*/function (_BufferGeometry3) {
  function LatheGeometry() {
    var _this64;
    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)];
    var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
    var phiStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var phiLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;
    _classCallCheck(this, LatheGeometry);
    _this64 = _callSuper(this, LatheGeometry);
    _this64.type = 'LatheGeometry';
    _this64.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = Math.floor(segments);

    // clamp phiLength so it's in range of [ 0, 2PI ]

    phiLength = clamp(phiLength, 0, Math.PI * 2);

    // buffers

    var indices = [];
    var vertices = [];
    var uvs = [];
    var initNormals = [];
    var normals = [];

    // helper variables

    var inverseSegments = 1.0 / segments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var normal = new Vector3();
    var curNormal = new Vector3();
    var prevNormal = new Vector3();
    var dx = 0;
    var dy = 0;

    // pre-compute normals for initial "meridian"

    for (var j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          // special handling for 1st vertex on path

          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1.0;
          normal.y = -dx;
          normal.z = dy * 0.0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;
        case points.length - 1:
          // special handling for last Vertex on path

          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;
        default:
          // default handling for all vertices in between

          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1.0;
          normal.y = -dx;
          normal.z = dy * 0.0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    }

    // generate vertices, uvs and normals

    for (var i = 0; i <= segments; i++) {
      var phi = phiStart + i * inverseSegments * phiLength;
      var sin = Math.sin(phi);
      var cos = Math.cos(phi);
      for (var _j5 = 0; _j5 <= points.length - 1; _j5++) {
        // vertex

        vertex.x = points[_j5].x * sin;
        vertex.y = points[_j5].y;
        vertex.z = points[_j5].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z);

        // uv

        uv.x = i / segments;
        uv.y = _j5 / (points.length - 1);
        uvs.push(uv.x, uv.y);

        // normal

        var x = initNormals[3 * _j5 + 0] * sin;
        var y = initNormals[3 * _j5 + 1];
        var z = initNormals[3 * _j5 + 0] * cos;
        normals.push(x, y, z);
      }
    }

    // indices

    for (var _i66 = 0; _i66 < segments; _i66++) {
      for (var _j6 = 0; _j6 < points.length - 1; _j6++) {
        var base = _j6 + _i66 * points.length;
        var a = base;
        var b = base + points.length;
        var c = base + points.length + 1;
        var d = base + 1;

        // faces

        indices.push(a, b, d);
        indices.push(c, d, b);
      }
    }

    // build geometry

    _this64.setIndex(indices);
    _this64.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this64.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    _this64.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    return _this64;
  }
  _inherits(LatheGeometry, _BufferGeometry3);
  return _createClass(LatheGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(LatheGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
    }
  }]);
}(BufferGeometry);
var CapsuleGeometry = exports.CapsuleGeometry = /*#__PURE__*/function (_LatheGeometry) {
  function CapsuleGeometry() {
    var _this65;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var capSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
    var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
    _classCallCheck(this, CapsuleGeometry);
    var path = new Path();
    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
    _this65 = _callSuper(this, CapsuleGeometry, [path.getPoints(capSegments), radialSegments]);
    _this65.type = 'CapsuleGeometry';
    _this65.parameters = {
      radius: radius,
      length: length,
      capSegments: capSegments,
      radialSegments: radialSegments
    };
    return _this65;
  }
  _inherits(CapsuleGeometry, _LatheGeometry);
  return _createClass(CapsuleGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
    }
  }]);
}(LatheGeometry);
var CircleGeometry = exports.CircleGeometry = /*#__PURE__*/function (_BufferGeometry4) {
  function CircleGeometry() {
    var _this66;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
    var thetaStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var thetaLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;
    _classCallCheck(this, CircleGeometry);
    _this66 = _callSuper(this, CircleGeometry);
    _this66.type = 'CircleGeometry';
    _this66.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    segments = Math.max(3, segments);

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var vertex = new Vector3();
    var uv = new Vector2();

    // center point

    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (var s = 0, i = 3; s <= segments; s++, i += 3) {
      var segment = thetaStart + s / segments * thetaLength;

      // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);

      // normal

      normals.push(0, 0, 1);

      // uvs

      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }

    // indices

    for (var _i67 = 1; _i67 <= segments; _i67++) {
      indices.push(_i67, _i67 + 1, 0);
    }

    // build geometry

    _this66.setIndex(indices);
    _this66.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this66.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this66.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    return _this66;
  }
  _inherits(CircleGeometry, _BufferGeometry4);
  return _createClass(CircleGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(CircleGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
    }
  }]);
}(BufferGeometry);
var CylinderGeometry = exports.CylinderGeometry = /*#__PURE__*/function (_BufferGeometry5) {
  function CylinderGeometry() {
    var _this67;
    var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;
    var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var openEnded = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var thetaStart = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var thetaLength = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI * 2;
    _classCallCheck(this, CylinderGeometry);
    _this67 = _callSuper(this, CylinderGeometry);
    _this67.type = 'CylinderGeometry';
    _this67.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    var scope = _this67;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var index = 0;
    var indexArray = [];
    var halfHeight = height / 2;
    var groupStart = 0;

    // generate geometry

    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }

    // build geometry

    _this67.setIndex(indices);
    _this67.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this67.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this67.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      var normal = new Vector3();
      var vertex = new Vector3();
      var groupCount = 0;

      // this will be used to calculate the normal
      var slope = (radiusBottom - radiusTop) / height;

      // generate vertices, normals and uvs

      for (var y = 0; y <= heightSegments; y++) {
        var indexRow = [];
        var v = y / heightSegments;

        // calculate the radius of the current row

        var radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (var x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var theta = u * thetaLength + thetaStart;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta);

          // vertex

          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);

          // normal

          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);

          // uv

          uvs.push(u, 1 - v);

          // save index of vertex in respective row

          indexRow.push(index++);
        }

        // now save vertices of the row in our index array

        indexArray.push(indexRow);
      }

      // generate indices

      for (var _x11 = 0; _x11 < radialSegments; _x11++) {
        for (var _y2 = 0; _y2 < heightSegments; _y2++) {
          // we use the index array to access the correct indices

          var a = indexArray[_y2][_x11];
          var b = indexArray[_y2 + 1][_x11];
          var c = indexArray[_y2 + 1][_x11 + 1];
          var d = indexArray[_y2][_x11 + 1];

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);

          // update group counter

          groupCount += 6;
        }
      }

      // add a group to the geometry. this will ensure multi material support

      scope.addGroup(groupStart, groupCount, 0);

      // calculate new start value for groups

      groupStart += groupCount;
    }
    function generateCap(top) {
      // save the index of the first center vertex
      var centerIndexStart = index;
      var uv = new Vector2();
      var vertex = new Vector3();
      var groupCount = 0;
      var radius = top === true ? radiusTop : radiusBottom;
      var sign = top === true ? 1 : -1;

      // first we generate the center vertex data of the cap.
      // because the geometry needs one set of uvs per face,
      // we must generate a center vertex per face/segment

      for (var x = 1; x <= radialSegments; x++) {
        // vertex

        vertices.push(0, halfHeight * sign, 0);

        // normal

        normals.push(0, sign, 0);

        // uv

        uvs.push(0.5, 0.5);

        // increase index

        index++;
      }

      // save the index of the last center vertex
      var centerIndexEnd = index;

      // now we generate the surrounding vertices, normals and uvs

      for (var _x12 = 0; _x12 <= radialSegments; _x12++) {
        var u = _x12 / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);

        // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal

        normals.push(0, sign, 0);

        // uv

        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y);

        // increase index

        index++;
      }

      // generate indices

      for (var _x13 = 0; _x13 < radialSegments; _x13++) {
        var c = centerIndexStart + _x13;
        var i = centerIndexEnd + _x13;
        if (top === true) {
          // face top

          indices.push(i, i + 1, c);
        } else {
          // face bottom

          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }

      // add a group to the geometry. this will ensure multi material support

      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

      // calculate new start value for groups

      groupStart += groupCount;
    }
    return _this67;
  }
  _inherits(CylinderGeometry, _BufferGeometry5);
  return _createClass(CylinderGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(CylinderGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
  }]);
}(BufferGeometry);
var ConeGeometry = exports.ConeGeometry = /*#__PURE__*/function (_CylinderGeometry) {
  function ConeGeometry() {
    var _this68;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var radialSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
    var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var openEnded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI * 2;
    _classCallCheck(this, ConeGeometry);
    _this68 = _callSuper(this, ConeGeometry, [0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength]);
    _this68.type = 'ConeGeometry';
    _this68.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    return _this68;
  }
  _inherits(ConeGeometry, _CylinderGeometry);
  return _createClass(ConeGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
  }]);
}(CylinderGeometry);
var PolyhedronGeometry = exports.PolyhedronGeometry = /*#__PURE__*/function (_BufferGeometry6) {
  function PolyhedronGeometry() {
    var _this69;
    var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    _classCallCheck(this, PolyhedronGeometry);
    _this69 = _callSuper(this, PolyhedronGeometry);
    _this69.type = 'PolyhedronGeometry';
    _this69.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    };

    // default buffer data

    var vertexBuffer = [];
    var uvBuffer = [];

    // the subdivision creates the vertex buffer data

    subdivide(detail);

    // all vertices should lie on a conceptual sphere with a given radius

    applyRadius(radius);

    // finally, create the uv data

    generateUVs();

    // build non-indexed geometry

    _this69.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
    _this69.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
    _this69.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      _this69.computeVertexNormals(); // flat normals
    } else {
      _this69.normalizeNormals(); // smooth normals
    }

    // helper functions

    function subdivide(detail) {
      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3();

      // iterate over all faces and apply a subdivision with the given detail value

      for (var i = 0; i < indices.length; i += 3) {
        // get the vertices of the face

        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);

        // perform subdivision

        subdivideFace(a, b, c, detail);
      }
    }
    function subdivideFace(a, b, c, detail) {
      var cols = detail + 1;

      // we use this multidimensional array as a data structure for creating the subdivision

      var v = [];

      // construct all of the vertices for this subdivision

      for (var i = 0; i <= cols; i++) {
        v[i] = [];
        var aj = a.clone().lerp(c, i / cols);
        var bj = b.clone().lerp(c, i / cols);
        var rows = cols - i;
        for (var j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }

      // construct all of the faces

      for (var _i68 = 0; _i68 < cols; _i68++) {
        for (var _j7 = 0; _j7 < 2 * (cols - _i68) - 1; _j7++) {
          var k = Math.floor(_j7 / 2);
          if (_j7 % 2 === 0) {
            pushVertex(v[_i68][k + 1]);
            pushVertex(v[_i68 + 1][k]);
            pushVertex(v[_i68][k]);
          } else {
            pushVertex(v[_i68][k + 1]);
            pushVertex(v[_i68 + 1][k + 1]);
            pushVertex(v[_i68 + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius) {
      var vertex = new Vector3();

      // iterate over the entire buffer and apply the radius to each vertex

      for (var i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }
    function generateUVs() {
      var vertex = new Vector3();
      for (var i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        var u = azimuth(vertex) / 2 / Math.PI + 0.5;
        var v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      // handle case when face straddles the seam, see #3269

      for (var i = 0; i < uvBuffer.length; i += 6) {
        // uv data of a single face

        var x0 = uvBuffer[i + 0];
        var x1 = uvBuffer[i + 2];
        var x2 = uvBuffer[i + 4];
        var max = Math.max(x0, x1, x2);
        var min = Math.min(x0, x1, x2);

        // 0.9 is somewhat arbitrary

        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index, vertex) {
      var stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }
    function correctUVs() {
      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3();
      var centroid = new Vector3();
      var uvA = new Vector2();
      var uvB = new Vector2();
      var uvC = new Vector2();
      for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        var azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth) {
      if (azimuth < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
      }
    }

    // Angle around the Y axis, counter-clockwise when looking from above.

    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }

    // Angle above the XZ plane.

    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
    return _this69;
  }
  _inherits(PolyhedronGeometry, _BufferGeometry6);
  return _createClass(PolyhedronGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(PolyhedronGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
    }
  }]);
}(BufferGeometry);
var DodecahedronGeometry = exports.DodecahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
  function DodecahedronGeometry() {
    var _this70;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, DodecahedronGeometry);
    var t = (1 + Math.sqrt(5)) / 2;
    var r = 1 / t;
    var vertices = [
    // (1, 1, 1)
    -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,
    // (0, 1/, )
    0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t,
    // (1/, , 0)
    -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0,
    // (, 0, 1/)
    -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
    var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    _this70 = _callSuper(this, DodecahedronGeometry, [vertices, indices, radius, detail]);
    _this70.type = 'DodecahedronGeometry';
    _this70.parameters = {
      radius: radius,
      detail: detail
    };
    return _this70;
  }
  _inherits(DodecahedronGeometry, _PolyhedronGeometry);
  return _createClass(DodecahedronGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new DodecahedronGeometry(data.radius, data.detail);
    }
  }]);
}(PolyhedronGeometry);
var _v0 = /*@__PURE__*/new Vector3();
var _v1$1 = /*@__PURE__*/new Vector3();
var _normal = /*@__PURE__*/new Vector3();
var _triangle = /*@__PURE__*/new Triangle();
var EdgesGeometry = exports.EdgesGeometry = /*#__PURE__*/function (_BufferGeometry7) {
  function EdgesGeometry() {
    var _this71;
    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var thresholdAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    _classCallCheck(this, EdgesGeometry);
    _this71 = _callSuper(this, EdgesGeometry);
    _this71.type = 'EdgesGeometry';
    _this71.parameters = {
      geometry: geometry,
      thresholdAngle: thresholdAngle
    };
    if (geometry !== null) {
      var precisionPoints = 4;
      var precision = Math.pow(10, precisionPoints);
      var thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
      var indexAttr = geometry.getIndex();
      var positionAttr = geometry.getAttribute('position');
      var indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      var indexArr = [0, 0, 0];
      var vertKeys = ['a', 'b', 'c'];
      var hashes = new Array(3);
      var edgeData = {};
      var vertices = [];
      for (var i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }
        var a = _triangle.a,
          b = _triangle.b,
          c = _triangle.c;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);

        // create hashes for the edge from the vertices
        hashes[0] = "".concat(Math.round(a.x * precision), ",").concat(Math.round(a.y * precision), ",").concat(Math.round(a.z * precision));
        hashes[1] = "".concat(Math.round(b.x * precision), ",").concat(Math.round(b.y * precision), ",").concat(Math.round(b.z * precision));
        hashes[2] = "".concat(Math.round(c.x * precision), ",").concat(Math.round(c.y * precision), ",").concat(Math.round(c.z * precision));

        // skip degenerate triangles
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }

        // iterate over every edge
        for (var j = 0; j < 3; j++) {
          // get the first and next vertex making up the edge
          var jNext = (j + 1) % 3;
          var vecHash0 = hashes[j];
          var vecHash1 = hashes[jNext];
          var v0 = _triangle[vertKeys[j]];
          var v1 = _triangle[vertKeys[jNext]];
          var hash = "".concat(vecHash0, "_").concat(vecHash1);
          var reverseHash = "".concat(vecHash1, "_").concat(vecHash0);
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            // if we found a sibling edge add it into the vertex array if
            // it meets the angle threshold and delete the edge from the map.
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            // if we've already got an edge here then skip adding a new one
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }

      // iterate over all remaining, unmatched edges and add them to the vertex array
      for (var key in edgeData) {
        if (edgeData[key]) {
          var _edgeData$key = edgeData[key],
            index0 = _edgeData$key.index0,
            index1 = _edgeData$key.index1;
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      _this71.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
    return _this71;
  }
  _inherits(EdgesGeometry, _BufferGeometry7);
  return _createClass(EdgesGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(EdgesGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }]);
}(BufferGeometry);
var Shape = exports.Shape = /*#__PURE__*/function (_Path) {
  function Shape(points) {
    var _this72;
    _classCallCheck(this, Shape);
    _this72 = _callSuper(this, Shape, [points]);
    _this72.uuid = generateUUID();
    _this72.type = 'Shape';
    _this72.holes = [];
    return _this72;
  }
  _inherits(Shape, _Path);
  return _createClass(Shape, [{
    key: "getPointsHoles",
    value: function getPointsHoles(divisions) {
      var holesPts = [];
      for (var i = 0, l = this.holes.length; i < l; i++) {
        holesPts[i] = this.holes[i].getPoints(divisions);
      }
      return holesPts;
    }

    // get points of shape and holes (keypoints based on segments parameter)
  }, {
    key: "extractPoints",
    value: function extractPoints(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(Shape, "copy", this, 3)([source]);
      this.holes = [];
      for (var i = 0, l = source.holes.length; i < l; i++) {
        var hole = source.holes[i];
        this.holes.push(hole.clone());
      }
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(Shape, "toJSON", this, 3)([]);
      data.uuid = this.uuid;
      data.holes = [];
      for (var i = 0, l = this.holes.length; i < l; i++) {
        var hole = this.holes[i];
        data.holes.push(hole.toJSON());
      }
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _superPropGet(Shape, "fromJSON", this, 3)([json]);
      this.uuid = json.uuid;
      this.holes = [];
      for (var i = 0, l = json.holes.length; i < l; i++) {
        var hole = json.holes[i];
        this.holes.push(new Path().fromJSON(hole));
      }
      return this;
    }
  }]);
}(Path);
/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */
var Earcut = {
  triangulate: function triangulate(data, holeIndices) {
    var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var outerNode = linkedList(data, 0, outerLen, dim, true);
    var triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }

      // minX, minY and invSize are later used to transform coords into integers for z-order calculation
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p = start,
    again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;

  // interlink polygon nodes in z-order
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop = ear,
    prev,
    next;

  // iterate through ears, slicing them one by one
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);

      // skipping the next vertex leads to less sliver triangles
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;

    // if we looped through the whole remaining polygon and can't find any more ears
    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

        // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

        // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
  var a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  // now make sure we don't have other points inside the potential ear
  var ax = a.x,
    bx = b.x,
    cx = c.x,
    ay = a.y,
    by = b.y,
    cy = c.y;

  // triangle bbox; min & max are calculated like this for speed
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
    y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
    x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
    y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p = c.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  var ax = a.x,
    bx = b.x,
    cx = c.x,
    ay = a.y,
    by = b.y,
    cy = c.y;

  // triangle bbox; min & max are calculated like this for speed
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
    y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
    x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
    y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;

  // z-order range for the current triangle bbox;
  var minZ = zOrder(x0, y0, minX, minY, invSize),
    maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p = ear.prevZ,
    n = ear.nextZ;

  // look for points inside the triangle in both directions
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  // look for remaining points in decreasing z-order
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }

  // look for remaining points in increasing z-order
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
  var p = start;
  do {
    var a = p.prev,
      b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);

      // remove two nodes involved
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  var a = start;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        var c = splitPolygon(a, b);

        // filter colinear points around the cuts
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);

        // run earcut on each half
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [];
  var i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);

  // process holes from left to right
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);

  // filter collinear points around the cuts
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
  var p = outerNode,
    qx = -Infinity,
    m;
  var hx = hole.x,
    hy = hole.y;

  // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;

  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  var stop = m,
    mx = m.x,
    my = m.y;
  var tanMin = Infinity,
    tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
  var p = start;
  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
  var i,
    p,
    q,
    e,
    tail,
    numMerges,
    pSize,
    qSize,
    inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
  var p = start,
    leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (
  // dones't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (
  // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) ||
  // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
  var o1 = sign(area(p1, q1, p2));
  var o2 = sign(area(p1, q1, q2));
  var o3 = sign(area(p2, q2, p1));
  var o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
  var p = a,
    inside = false;
  var px = (a.x + b.x) / 2,
    py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y),
    b2 = new Node(b.i, b.x, b.y),
    an = a.next,
    bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i;

  // vertex coordinates
  this.x = x;
  this.y = y;

  // previous and next vertex nodes in a polygon ring
  this.prev = null;
  this.next = null;

  // z-order curve value
  this.z = 0;

  // previous and next nodes in z-order
  this.prevZ = null;
  this.nextZ = null;

  // indicates whether this is a steiner point
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
var ShapeUtils = exports.ShapeUtils = /*#__PURE__*/function () {
  function ShapeUtils() {
    _classCallCheck(this, ShapeUtils);
  }
  return _createClass(ShapeUtils, null, [{
    key: "area",
    value:
    // calculate area of the contour polygon

    function area(contour) {
      var n = contour.length;
      var a = 0.0;
      for (var p = n - 1, q = 0; q < n; p = q++) {
        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
      }
      return a * 0.5;
    }
  }, {
    key: "isClockWise",
    value: function isClockWise(pts) {
      return ShapeUtils.area(pts) < 0;
    }
  }, {
    key: "triangulateShape",
    value: function triangulateShape(contour, holes) {
      var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
      var holeIndices = []; // array of hole indices
      var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

      removeDupEndPts(contour);
      addContour(vertices, contour);

      //

      var holeIndex = contour.length;
      holes.forEach(removeDupEndPts);
      for (var i = 0; i < holes.length; i++) {
        holeIndices.push(holeIndex);
        holeIndex += holes[i].length;
        addContour(vertices, holes[i]);
      }

      //

      var triangles = Earcut.triangulate(vertices, holeIndices);

      //

      for (var _i69 = 0; _i69 < triangles.length; _i69 += 3) {
        faces.push(triangles.slice(_i69, _i69 + 3));
      }
      return faces;
    }
  }]);
}();
function removeDupEndPts(points) {
  var l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (var i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */
var ExtrudeGeometry = exports.ExtrudeGeometry = /*#__PURE__*/function (_BufferGeometry8) {
  function ExtrudeGeometry() {
    var _this73;
    var shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, ExtrudeGeometry);
    _this73 = _callSuper(this, ExtrudeGeometry);
    _this73.type = 'ExtrudeGeometry';
    _this73.parameters = {
      shapes: shapes,
      options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    var scope = _this73;
    var verticesArray = [];
    var uvArray = [];
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      addShape(shape);
    }

    // build geometry

    _this73.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
    _this73.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
    _this73.computeVertexNormals();

    // functions

    function addShape(shape) {
      var placeholder = [];

      // options

      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var steps = options.steps !== undefined ? options.steps : 1;
      var depth = options.depth !== undefined ? options.depth : 1;
      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
      var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      var extrudePath = options.extrudePath;
      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

      //

      var extrudePts,
        extrudeByPath = false;
      var splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion

        // SETUP TNB variables

        // TODO1 - have a .isClosed in spline?

        splineTube = extrudePath.computeFrenetFrames(steps, false);

        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }

      // Safeguards if bevels are not enabled

      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }

      // Variables initialization

      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for (var h = 0, hl = holes.length; h < hl; h++) {
          var ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      var faces = ShapeUtils.triangulateShape(vertices, holes);

      /* Vertices */

      var contour = vertices; // vertices has all points but contour has only points of circumference

      for (var _h = 0, _hl = holes.length; _h < _hl; _h++) {
        var _ahole = holes[_h];
        vertices = vertices.concat(_ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
        return pt.clone().addScaledVector(vec, size);
      }
      var vlen = vertices.length,
        flen = faces.length;

      // Find directions for point movement

      function getBevelVec(inPt, inPrev, inNext) {
        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.

        var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        var v_prev_x = inPt.x - inPrev.x,
          v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
          v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;

        // check for collinear edges
        var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          // not collinear

          // length of vectors for normalizing

          var v_prev_len = Math.sqrt(v_prev_lensq);
          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

          // shift adjacent points by unit vectors to the left

          var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          var ptNextShift_x = inNext.x - v_next_y / v_next_len;
          var ptNextShift_y = inNext.y + v_next_x / v_next_len;

          // scaling factor for v_prev to intersection point

          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);

          // vector from inPt to intersection point

          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;

          // Don't normalize!, otherwise sharp corners become ugly
          //  but prevent crazy spikes
          var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          // handle special case of collinear edges

          var direction_eq = false; // assumes: opposite

          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            // console.log("Warning: lines are a straight sequence");
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            // console.log("Warning: lines are a straight spike");
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      var contourMovements = [];
      for (var _i70 = 0, il = contour.length, j = il - 1, k = _i70 + 1; _i70 < il; _i70++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0;

        //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[_i70] = getBevelVec(contour[_i70], contour[j], contour[k]);
      }
      var holesMovements = [];
      var oneHoleMovements,
        verticesMovements = contourMovements.concat();
      for (var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++) {
        var _ahole2 = holes[_h2];
        oneHoleMovements = [];
        for (var _i71 = 0, _il14 = _ahole2.length, _j8 = _il14 - 1, _k = _i71 + 1; _i71 < _il14; _i71++, _j8++, _k++) {
          if (_j8 === _il14) _j8 = 0;
          if (_k === _il14) _k = 0;

          //  (j)---(i)---(k)
          oneHoleMovements[_i71] = getBevelVec(_ahole2[_i71], _ahole2[_j8], _ahole2[_k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }

      // Loop bevelSegments, 1 for the front, 1 for the back

      for (var b = 0; b < bevelSegments; b++) {
        //for ( b = bevelSegments; b > 0; b -- ) {

        var t = b / bevelSegments;
        var z = bevelThickness * Math.cos(t * Math.PI / 2);
        var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

        // contract shape

        for (var _i72 = 0, _il15 = contour.length; _i72 < _il15; _i72++) {
          var vert = scalePt2(contour[_i72], contourMovements[_i72], _bs);
          v(vert.x, vert.y, -z);
        }

        // expand holes

        for (var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++) {
          var _ahole3 = holes[_h3];
          oneHoleMovements = holesMovements[_h3];
          for (var _i73 = 0, _il16 = _ahole3.length; _i73 < _il16; _i73++) {
            var _vert = scalePt2(_ahole3[_i73], oneHoleMovements[_i73], _bs);
            v(_vert.x, _vert.y, -z);
          }
        }
      }
      var bs = bevelSize + bevelOffset;

      // Back facing vertices

      for (var _i74 = 0; _i74 < vlen; _i74++) {
        var _vert2 = bevelEnabled ? scalePt2(vertices[_i74], verticesMovements[_i74], bs) : vertices[_i74];
        if (!extrudeByPath) {
          v(_vert2.x, _vert2.y, 0);
        } else {
          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

          normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }

      // Add stepped vertices...
      // Including front facing vertices

      for (var s = 1; s <= steps; s++) {
        for (var _i75 = 0; _i75 < vlen; _i75++) {
          var _vert3 = bevelEnabled ? scalePt2(vertices[_i75], verticesMovements[_i75], bs) : vertices[_i75];
          if (!extrudeByPath) {
            v(_vert3.x, _vert3.y, depth / steps * s);
          } else {
            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

            normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }

      // Add bevel segments planes

      //for ( b = 1; b <= bevelSegments; b ++ ) {
      for (var _b6 = bevelSegments - 1; _b6 >= 0; _b6--) {
        var _t = _b6 / bevelSegments;
        var _z2 = bevelThickness * Math.cos(_t * Math.PI / 2);
        var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset;

        // contract shape

        for (var _i76 = 0, _il17 = contour.length; _i76 < _il17; _i76++) {
          var _vert4 = scalePt2(contour[_i76], contourMovements[_i76], _bs2);
          v(_vert4.x, _vert4.y, depth + _z2);
        }

        // expand holes

        for (var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++) {
          var _ahole4 = holes[_h4];
          oneHoleMovements = holesMovements[_h4];
          for (var _i77 = 0, _il18 = _ahole4.length; _i77 < _il18; _i77++) {
            var _vert5 = scalePt2(_ahole4[_i77], oneHoleMovements[_i77], _bs2);
            if (!extrudeByPath) {
              v(_vert5.x, _vert5.y, depth + _z2);
            } else {
              v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z2);
            }
          }
        }
      }

      /* Faces */

      // Top and bottom faces

      buildLidFaces();

      // Sides faces

      buildSideFaces();

      /////  Internal functions

      function buildLidFaces() {
        var start = verticesArray.length / 3;
        if (bevelEnabled) {
          var layer = 0; // steps + 1
          var offset = vlen * layer;

          // Bottom faces

          for (var _i78 = 0; _i78 < flen; _i78++) {
            var face = faces[_i78];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;

          // Top faces

          for (var _i79 = 0; _i79 < flen; _i79++) {
            var _face = faces[_i79];
            f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);
          }
        } else {
          // Bottom faces

          for (var _i80 = 0; _i80 < flen; _i80++) {
            var _face2 = faces[_i80];
            f3(_face2[2], _face2[1], _face2[0]);
          }

          // Top faces

          for (var _i81 = 0; _i81 < flen; _i81++) {
            var _face3 = faces[_i81];
            f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }

      // Create faces for the z-sides of the shape

      function buildSideFaces() {
        var start = verticesArray.length / 3;
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++) {
          var _ahole5 = holes[_h5];
          sidewalls(_ahole5, layeroffset);

          //, true
          layeroffset += _ahole5.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour, layeroffset) {
        var i = contour.length;
        while (--i >= 0) {
          var _j9 = i;
          var _k2 = i - 1;
          if (_k2 < 0) _k2 = contour.length - 1;

          //console.log('b', i,j, i-1, k,vertices.length);

          for (var _s4 = 0, sl = steps + bevelSegments * 2; _s4 < sl; _s4++) {
            var slen1 = vlen * _s4;
            var slen2 = vlen * (_s4 + 1);
            var a = layeroffset + _j9 + slen1,
              _b7 = layeroffset + _k2 + slen1,
              c = layeroffset + _k2 + slen2,
              d = layeroffset + _j9 + slen2;
            f4(a, _b7, c, d);
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }
      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
    return _this73;
  }
  _inherits(ExtrudeGeometry, _BufferGeometry8);
  return _createClass(ExtrudeGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(ExtrudeGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(ExtrudeGeometry, "toJSON", this, 3)([]);
      var shapes = this.parameters.shapes;
      var options = this.parameters.options;
      return toJSON$1(shapes, options, data);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data, shapes) {
      var geometryShapes = [];
      for (var j = 0, jl = data.shapes.length; j < jl; j++) {
        var shape = shapes[data.shapes[j]];
        geometryShapes.push(shape);
      }
      var extrudePath = data.options.extrudePath;
      if (extrudePath !== undefined) {
        data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
      }
      return new ExtrudeGeometry(geometryShapes, data.options);
    }
  }]);
}(BufferGeometry);
var WorldUVGenerator = {
  generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
  },
  generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var a_z = vertices[indexA * 3 + 2];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var b_z = vertices[indexB * 3 + 2];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    var c_z = vertices[indexC * 3 + 2];
    var d_x = vertices[indexD * 3];
    var d_y = vertices[indexD * 3 + 1];
    var d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
    } else {
      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  data.options = Object.assign({}, options);
  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
var IcosahedronGeometry = exports.IcosahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry2) {
  function IcosahedronGeometry() {
    var _this74;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, IcosahedronGeometry);
    var t = (1 + Math.sqrt(5)) / 2;
    var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
    var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    _this74 = _callSuper(this, IcosahedronGeometry, [vertices, indices, radius, detail]);
    _this74.type = 'IcosahedronGeometry';
    _this74.parameters = {
      radius: radius,
      detail: detail
    };
    return _this74;
  }
  _inherits(IcosahedronGeometry, _PolyhedronGeometry2);
  return _createClass(IcosahedronGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new IcosahedronGeometry(data.radius, data.detail);
    }
  }]);
}(PolyhedronGeometry);
var OctahedronGeometry = exports.OctahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry3) {
  function OctahedronGeometry() {
    var _this75;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, OctahedronGeometry);
    var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    _this75 = _callSuper(this, OctahedronGeometry, [vertices, indices, radius, detail]);
    _this75.type = 'OctahedronGeometry';
    _this75.parameters = {
      radius: radius,
      detail: detail
    };
    return _this75;
  }
  _inherits(OctahedronGeometry, _PolyhedronGeometry3);
  return _createClass(OctahedronGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new OctahedronGeometry(data.radius, data.detail);
    }
  }]);
}(PolyhedronGeometry);
var RingGeometry = exports.RingGeometry = /*#__PURE__*/function (_BufferGeometry9) {
  function RingGeometry() {
    var _this76;
    var innerRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
    var outerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var thetaSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
    var phiSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var thetaStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var thetaLength = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;
    _classCallCheck(this, RingGeometry);
    _this76 = _callSuper(this, RingGeometry);
    _this76.type = 'RingGeometry';
    _this76.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // some helper variables

    var radius = innerRadius;
    var radiusStep = (outerRadius - innerRadius) / phiSegments;
    var vertex = new Vector3();
    var uv = new Vector2();

    // generate vertices, normals and uvs

    for (var j = 0; j <= phiSegments; j++) {
      for (var i = 0; i <= thetaSegments; i++) {
        // values are generate from the inside of the ring to the outside

        var segment = thetaStart + i / thetaSegments * thetaLength;

        // vertex

        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal

        normals.push(0, 0, 1);

        // uv

        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }

      // increase the radius for next row of vertices

      radius += radiusStep;
    }

    // indices

    for (var _j10 = 0; _j10 < phiSegments; _j10++) {
      var thetaSegmentLevel = _j10 * (thetaSegments + 1);
      for (var _i82 = 0; _i82 < thetaSegments; _i82++) {
        var _segment = _i82 + thetaSegmentLevel;
        var a = _segment;
        var b = _segment + thetaSegments + 1;
        var c = _segment + thetaSegments + 2;
        var d = _segment + 1;

        // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    // build geometry

    _this76.setIndex(indices);
    _this76.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this76.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this76.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    return _this76;
  }
  _inherits(RingGeometry, _BufferGeometry9);
  return _createClass(RingGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(RingGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
    }
  }]);
}(BufferGeometry);
var ShapeGeometry = exports.ShapeGeometry = /*#__PURE__*/function (_BufferGeometry10) {
  function ShapeGeometry() {
    var _this77;
    var shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
    var curveSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
    _classCallCheck(this, ShapeGeometry);
    _this77 = _callSuper(this, ShapeGeometry);
    _this77.type = 'ShapeGeometry';
    _this77.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    };

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var groupStart = 0;
    var groupCount = 0;

    // allow single and array values for "shapes" parameter

    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (var i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        _this77.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

        groupStart += groupCount;
        groupCount = 0;
      }
    }

    // build geometry

    _this77.setIndex(indices);
    _this77.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this77.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this77.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    // helper functions

    function addShape(shape) {
      var indexOffset = vertices.length / 3;
      var points = shape.extractPoints(curveSegments);
      var shapeVertices = points.shape;
      var shapeHoles = points.holes;

      // check direction of vertices

      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (var _i83 = 0, l = shapeHoles.length; _i83 < l; _i83++) {
        var shapeHole = shapeHoles[_i83];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[_i83] = shapeHole.reverse();
        }
      }
      var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

      // join vertices of inner and outer paths to a single array

      for (var _i84 = 0, _l13 = shapeHoles.length; _i84 < _l13; _i84++) {
        var _shapeHole = shapeHoles[_i84];
        shapeVertices = shapeVertices.concat(_shapeHole);
      }

      // vertices, normals, uvs

      for (var _i85 = 0, _l14 = shapeVertices.length; _i85 < _l14; _i85++) {
        var _vertex2 = shapeVertices[_i85];
        vertices.push(_vertex2.x, _vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(_vertex2.x, _vertex2.y); // world uvs
      }

      // indices

      for (var _i86 = 0, _l15 = faces.length; _i86 < _l15; _i86++) {
        var face = faces[_i86];
        var a = face[0] + indexOffset;
        var b = face[1] + indexOffset;
        var c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
    return _this77;
  }
  _inherits(ShapeGeometry, _BufferGeometry10);
  return _createClass(ShapeGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(ShapeGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(ShapeGeometry, "toJSON", this, 3)([]);
      var shapes = this.parameters.shapes;
      return _toJSON(shapes, data);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data, shapes) {
      var geometryShapes = [];
      for (var j = 0, jl = data.shapes.length; j < jl; j++) {
        var shape = shapes[data.shapes[j]];
        geometryShapes.push(shape);
      }
      return new ShapeGeometry(geometryShapes, data.curveSegments);
    }
  }]);
}(BufferGeometry);
function _toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
var SphereGeometry = exports.SphereGeometry = /*#__PURE__*/function (_BufferGeometry11) {
  function SphereGeometry() {
    var _this78;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
    var heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;
    var phiStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var phiLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;
    var thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI;
    _classCallCheck(this, SphereGeometry);
    _this78 = _callSuper(this, SphereGeometry);
    _this78.type = 'SphereGeometry';
    _this78.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    var index = 0;
    var grid = [];
    var vertex = new Vector3();
    var normal = new Vector3();

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // generate vertices, normals and uvs

    for (var iy = 0; iy <= heightSegments; iy++) {
      var verticesRow = [];
      var v = iy / heightSegments;

      // special case for the poles

      var uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (var ix = 0; ix <= widthSegments; ix++) {
        var u = ix / widthSegments;

        // vertex

        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal

        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);

        // uv

        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }

    // indices

    for (var _iy3 = 0; _iy3 < heightSegments; _iy3++) {
      for (var _ix3 = 0; _ix3 < widthSegments; _ix3++) {
        var a = grid[_iy3][_ix3 + 1];
        var b = grid[_iy3][_ix3];
        var c = grid[_iy3 + 1][_ix3];
        var d = grid[_iy3 + 1][_ix3 + 1];
        if (_iy3 !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (_iy3 !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    }

    // build geometry

    _this78.setIndex(indices);
    _this78.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this78.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this78.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    return _this78;
  }
  _inherits(SphereGeometry, _BufferGeometry11);
  return _createClass(SphereGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(SphereGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
    }
  }]);
}(BufferGeometry);
var TetrahedronGeometry = exports.TetrahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry4) {
  function TetrahedronGeometry() {
    var _this79;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, TetrahedronGeometry);
    var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    _this79 = _callSuper(this, TetrahedronGeometry, [vertices, indices, radius, detail]);
    _this79.type = 'TetrahedronGeometry';
    _this79.parameters = {
      radius: radius,
      detail: detail
    };
    return _this79;
  }
  _inherits(TetrahedronGeometry, _PolyhedronGeometry4);
  return _createClass(TetrahedronGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new TetrahedronGeometry(data.radius, data.detail);
    }
  }]);
}(PolyhedronGeometry);
var TorusGeometry = exports.TorusGeometry = /*#__PURE__*/function (_BufferGeometry12) {
  function TorusGeometry() {
    var _this80;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;
    var radialSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12;
    var tubularSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 48;
    var arc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;
    _classCallCheck(this, TorusGeometry);
    _this80 = _callSuper(this, TorusGeometry);
    _this80.type = 'TorusGeometry';
    _this80.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var center = new Vector3();
    var vertex = new Vector3();
    var normal = new Vector3();

    // generate vertices, normals and uvs

    for (var j = 0; j <= radialSegments; j++) {
      for (var i = 0; i <= tubularSegments; i++) {
        var u = i / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2;

        // vertex

        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal

        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);

        // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }

    // generate indices

    for (var _j11 = 1; _j11 <= radialSegments; _j11++) {
      for (var _i87 = 1; _i87 <= tubularSegments; _i87++) {
        // indices

        var a = (tubularSegments + 1) * _j11 + _i87 - 1;
        var b = (tubularSegments + 1) * (_j11 - 1) + _i87 - 1;
        var c = (tubularSegments + 1) * (_j11 - 1) + _i87;
        var d = (tubularSegments + 1) * _j11 + _i87;

        // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    // build geometry

    _this80.setIndex(indices);
    _this80.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this80.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this80.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    return _this80;
  }
  _inherits(TorusGeometry, _BufferGeometry12);
  return _createClass(TorusGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(TorusGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
    }
  }]);
}(BufferGeometry);
var TorusKnotGeometry = exports.TorusKnotGeometry = /*#__PURE__*/function (_BufferGeometry13) {
  function TorusKnotGeometry() {
    var _this81;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;
    var tubularSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 64;
    var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
    var p = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;
    var q = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;
    _classCallCheck(this, TorusKnotGeometry);
    _this81 = _callSuper(this, TorusKnotGeometry);
    _this81.type = 'TorusKnotGeometry';
    _this81.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);

    // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    // helper variables

    var vertex = new Vector3();
    var normal = new Vector3();
    var P1 = new Vector3();
    var P2 = new Vector3();
    var B = new Vector3();
    var T = new Vector3();
    var N = new Vector3();

    // generate vertices, normals and uvs

    for (var i = 0; i <= tubularSegments; ++i) {
      // the radian "u" is used to calculate the position on the torus curve of the current tubular segment

      var u = i / tubularSegments * p * Math.PI * 2;

      // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
      // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

      // calculate orthonormal basis

      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);

      // normalize B, N. T can be ignored, we don't use it

      B.normalize();
      N.normalize();
      for (var j = 0; j <= radialSegments; ++j) {
        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

        var v = j / radialSegments * Math.PI * 2;
        var cx = -tube * Math.cos(v);
        var cy = tube * Math.sin(v);

        // now calculate the final vertex position.
        // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);

        // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }

    // generate indices

    for (var _j12 = 1; _j12 <= tubularSegments; _j12++) {
      for (var _i88 = 1; _i88 <= radialSegments; _i88++) {
        // indices

        var a = (radialSegments + 1) * (_j12 - 1) + (_i88 - 1);
        var b = (radialSegments + 1) * _j12 + (_i88 - 1);
        var c = (radialSegments + 1) * _j12 + _i88;
        var d = (radialSegments + 1) * (_j12 - 1) + _i88;

        // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    // build geometry

    _this81.setIndex(indices);
    _this81.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this81.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this81.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    // this function calculates the current position on the torus curve

    function calculatePositionOnCurve(u, p, q, radius, position) {
      var cu = Math.cos(u);
      var su = Math.sin(u);
      var quOverP = q / p * u;
      var cs = Math.cos(quOverP);
      position.x = radius * (2 + cs) * 0.5 * cu;
      position.y = radius * (2 + cs) * su * 0.5;
      position.z = radius * Math.sin(quOverP) * 0.5;
    }
    return _this81;
  }
  _inherits(TorusKnotGeometry, _BufferGeometry13);
  return _createClass(TorusKnotGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(TorusKnotGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
    }
  }]);
}(BufferGeometry);
var TubeGeometry = exports.TubeGeometry = /*#__PURE__*/function (_BufferGeometry14) {
  function TubeGeometry() {
    var _this82;
    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0));
    var tubularSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;
    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
    var closed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    _classCallCheck(this, TubeGeometry);
    _this82 = _callSuper(this, TubeGeometry);
    _this82.type = 'TubeGeometry';
    _this82.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    var frames = path.computeFrenetFrames(tubularSegments, closed);

    // expose internals

    _this82.tangents = frames.tangents;
    _this82.normals = frames.normals;
    _this82.binormals = frames.binormals;

    // helper variables

    var vertex = new Vector3();
    var normal = new Vector3();
    var uv = new Vector2();
    var P = new Vector3();

    // buffer

    var vertices = [];
    var normals = [];
    var uvs = [];
    var indices = [];

    // create buffer data

    generateBufferData();

    // build geometry

    _this82.setIndex(indices);
    _this82.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this82.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this82.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    // functions

    function generateBufferData() {
      for (var i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }

      // if the geometry is not closed, generate the last row of vertices and normals
      // at the regular position on the given path
      //
      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

      generateSegment(closed === false ? tubularSegments : 0);

      // uvs are generated in a separate function.
      // this makes it easy compute correct values for closed geometries

      generateUVs();

      // finally create faces

      generateIndices();
    }
    function generateSegment(i) {
      // we use getPointAt to sample evenly distributed points from the given path

      P = path.getPointAt(i / tubularSegments, P);

      // retrieve corresponding normal and binormal

      var N = frames.normals[i];
      var B = frames.binormals[i];

      // generate normals and vertices for the current segment

      for (var j = 0; j <= radialSegments; j++) {
        var v = j / radialSegments * Math.PI * 2;
        var sin = Math.sin(v);
        var cos = -Math.cos(v);

        // normal

        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);

        // vertex

        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }
    function generateIndices() {
      for (var j = 1; j <= tubularSegments; j++) {
        for (var i = 1; i <= radialSegments; i++) {
          var a = (radialSegments + 1) * (j - 1) + (i - 1);
          var b = (radialSegments + 1) * j + (i - 1);
          var c = (radialSegments + 1) * j + i;
          var d = (radialSegments + 1) * (j - 1) + i;

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }
    function generateUVs() {
      for (var i = 0; i <= tubularSegments; i++) {
        for (var j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
    return _this82;
  }
  _inherits(TubeGeometry, _BufferGeometry14);
  return _createClass(TubeGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(TubeGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(TubeGeometry, "toJSON", this, 3)([]);
      data.path = this.parameters.path.toJSON();
      return data;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      // This only works for built-in curves (e.g. CatmullRomCurve3).
      // User defined curves or instances of CurvePath will not be deserialized.
      return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
    }
  }]);
}(BufferGeometry);
var WireframeGeometry = exports.WireframeGeometry = /*#__PURE__*/function (_BufferGeometry15) {
  function WireframeGeometry() {
    var _this83;
    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    _classCallCheck(this, WireframeGeometry);
    _this83 = _callSuper(this, WireframeGeometry);
    _this83.type = 'WireframeGeometry';
    _this83.parameters = {
      geometry: geometry
    };
    if (geometry !== null) {
      // buffer

      var vertices = [];
      var edges = new Set();

      // helper variables

      var start = new Vector3();
      var end = new Vector3();
      if (geometry.index !== null) {
        // indexed BufferGeometry

        var position = geometry.attributes.position;
        var indices = geometry.index;
        var groups = geometry.groups;
        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.count,
            materialIndex: 0
          }];
        }

        // create a data structure that contains all edges without duplicates

        for (var o = 0, ol = groups.length; o < ol; ++o) {
          var group = groups[o];
          var groupStart = group.start;
          var groupCount = group.count;
          for (var i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
            for (var j = 0; j < 3; j++) {
              var index1 = indices.getX(i + j);
              var index2 = indices.getX(i + (j + 1) % 3);
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);
              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        // non-indexed BufferGeometry

        var _position2 = geometry.attributes.position;
        for (var _i89 = 0, _l16 = _position2.count / 3; _i89 < _l16; _i89++) {
          for (var _j13 = 0; _j13 < 3; _j13++) {
            // three edges per triangle, an edge is represented as (index1, index2)
            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

            var _index = 3 * _i89 + _j13;
            var _index2 = 3 * _i89 + (_j13 + 1) % 3;
            start.fromBufferAttribute(_position2, _index);
            end.fromBufferAttribute(_position2, _index2);
            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }

      // build geometry

      _this83.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
    return _this83;
  }
  _inherits(WireframeGeometry, _BufferGeometry15);
  return _createClass(WireframeGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(WireframeGeometry, "copy", this, 3)([source]);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }]);
}(BufferGeometry);
function isUniqueEdge(start, end, edges) {
  var hash1 = "".concat(start.x, ",").concat(start.y, ",").concat(start.z, "-").concat(end.x, ",").concat(end.y, ",").concat(end.z);
  var hash2 = "".concat(end.x, ",").concat(end.y, ",").concat(end.z, "-").concat(start.x, ",").concat(start.y, ",").concat(start.z); // coincident edge

  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
var Geometries = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BoxGeometry: BoxGeometry,
  CapsuleGeometry: CapsuleGeometry,
  CircleGeometry: CircleGeometry,
  ConeGeometry: ConeGeometry,
  CylinderGeometry: CylinderGeometry,
  DodecahedronGeometry: DodecahedronGeometry,
  EdgesGeometry: EdgesGeometry,
  ExtrudeGeometry: ExtrudeGeometry,
  IcosahedronGeometry: IcosahedronGeometry,
  LatheGeometry: LatheGeometry,
  OctahedronGeometry: OctahedronGeometry,
  PlaneGeometry: PlaneGeometry,
  PolyhedronGeometry: PolyhedronGeometry,
  RingGeometry: RingGeometry,
  ShapeGeometry: ShapeGeometry,
  SphereGeometry: SphereGeometry,
  TetrahedronGeometry: TetrahedronGeometry,
  TorusGeometry: TorusGeometry,
  TorusKnotGeometry: TorusKnotGeometry,
  TubeGeometry: TubeGeometry,
  WireframeGeometry: WireframeGeometry
});
var ShadowMaterial = exports.ShadowMaterial = /*#__PURE__*/function (_Material8) {
  function ShadowMaterial(parameters) {
    var _this84;
    _classCallCheck(this, ShadowMaterial);
    _this84 = _callSuper(this, ShadowMaterial);
    _this84.isShadowMaterial = true;
    _this84.type = 'ShadowMaterial';
    _this84.color = new Color(0x000000);
    _this84.transparent = true;
    _this84.fog = true;
    _this84.setValues(parameters);
    return _this84;
  }
  _inherits(ShadowMaterial, _Material8);
  return _createClass(ShadowMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(ShadowMaterial, "copy", this, 3)([source]);
      this.color.copy(source.color);
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material);
var RawShaderMaterial = exports.RawShaderMaterial = /*#__PURE__*/function (_ShaderMaterial) {
  function RawShaderMaterial(parameters) {
    var _this85;
    _classCallCheck(this, RawShaderMaterial);
    _this85 = _callSuper(this, RawShaderMaterial, [parameters]);
    _this85.isRawShaderMaterial = true;
    _this85.type = 'RawShaderMaterial';
    return _this85;
  }
  _inherits(RawShaderMaterial, _ShaderMaterial);
  return _createClass(RawShaderMaterial);
}(ShaderMaterial);
var MeshStandardMaterial = exports.MeshStandardMaterial = /*#__PURE__*/function (_Material9) {
  function MeshStandardMaterial(parameters) {
    var _this86;
    _classCallCheck(this, MeshStandardMaterial);
    _this86 = _callSuper(this, MeshStandardMaterial);
    _this86.isMeshStandardMaterial = true;
    _this86.defines = {
      'STANDARD': ''
    };
    _this86.type = 'MeshStandardMaterial';
    _this86.color = new Color(0xffffff); // diffuse
    _this86.roughness = 1.0;
    _this86.metalness = 0.0;
    _this86.map = null;
    _this86.lightMap = null;
    _this86.lightMapIntensity = 1.0;
    _this86.aoMap = null;
    _this86.aoMapIntensity = 1.0;
    _this86.emissive = new Color(0x000000);
    _this86.emissiveIntensity = 1.0;
    _this86.emissiveMap = null;
    _this86.bumpMap = null;
    _this86.bumpScale = 1;
    _this86.normalMap = null;
    _this86.normalMapType = TangentSpaceNormalMap;
    _this86.normalScale = new Vector2(1, 1);
    _this86.displacementMap = null;
    _this86.displacementScale = 1;
    _this86.displacementBias = 0;
    _this86.roughnessMap = null;
    _this86.metalnessMap = null;
    _this86.alphaMap = null;
    _this86.envMap = null;
    _this86.envMapRotation = new Euler();
    _this86.envMapIntensity = 1.0;
    _this86.wireframe = false;
    _this86.wireframeLinewidth = 1;
    _this86.wireframeLinecap = 'round';
    _this86.wireframeLinejoin = 'round';
    _this86.flatShading = false;
    _this86.fog = true;
    _this86.setValues(parameters);
    return _this86;
  }
  _inherits(MeshStandardMaterial, _Material9);
  return _createClass(MeshStandardMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshStandardMaterial, "copy", this, 3)([source]);
      this.defines = {
        'STANDARD': ''
      };
      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.roughnessMap = source.roughnessMap;
      this.metalnessMap = source.metalnessMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapRotation.copy(source.envMapRotation);
      this.envMapIntensity = source.envMapIntensity;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material);
var MeshPhysicalMaterial = exports.MeshPhysicalMaterial = /*#__PURE__*/function (_MeshStandardMaterial) {
  function MeshPhysicalMaterial(parameters) {
    var _this87;
    _classCallCheck(this, MeshPhysicalMaterial);
    _this87 = _callSuper(this, MeshPhysicalMaterial);
    _this87.isMeshPhysicalMaterial = true;
    _this87.defines = {
      'STANDARD': '',
      'PHYSICAL': ''
    };
    _this87.type = 'MeshPhysicalMaterial';
    _this87.anisotropyRotation = 0;
    _this87.anisotropyMap = null;
    _this87.clearcoatMap = null;
    _this87.clearcoatRoughness = 0.0;
    _this87.clearcoatRoughnessMap = null;
    _this87.clearcoatNormalScale = new Vector2(1, 1);
    _this87.clearcoatNormalMap = null;
    _this87.ior = 1.5;
    Object.defineProperty(_this87, 'reflectivity', {
      get: function get() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function set(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    _this87.iridescenceMap = null;
    _this87.iridescenceIOR = 1.3;
    _this87.iridescenceThicknessRange = [100, 400];
    _this87.iridescenceThicknessMap = null;
    _this87.sheenColor = new Color(0x000000);
    _this87.sheenColorMap = null;
    _this87.sheenRoughness = 1.0;
    _this87.sheenRoughnessMap = null;
    _this87.transmissionMap = null;
    _this87.thickness = 0;
    _this87.thicknessMap = null;
    _this87.attenuationDistance = Infinity;
    _this87.attenuationColor = new Color(1, 1, 1);
    _this87.specularIntensity = 1.0;
    _this87.specularIntensityMap = null;
    _this87.specularColor = new Color(1, 1, 1);
    _this87.specularColorMap = null;
    _this87._anisotropy = 0;
    _this87._clearcoat = 0;
    _this87._dispersion = 0;
    _this87._iridescence = 0;
    _this87._sheen = 0.0;
    _this87._transmission = 0;
    _this87.setValues(parameters);
    return _this87;
  }
  _inherits(MeshPhysicalMaterial, _MeshStandardMaterial);
  return _createClass(MeshPhysicalMaterial, [{
    key: "anisotropy",
    get: function get() {
      return this._anisotropy;
    },
    set: function set(value) {
      if (this._anisotropy > 0 !== value > 0) {
        this.version++;
      }
      this._anisotropy = value;
    }
  }, {
    key: "clearcoat",
    get: function get() {
      return this._clearcoat;
    },
    set: function set(value) {
      if (this._clearcoat > 0 !== value > 0) {
        this.version++;
      }
      this._clearcoat = value;
    }
  }, {
    key: "iridescence",
    get: function get() {
      return this._iridescence;
    },
    set: function set(value) {
      if (this._iridescence > 0 !== value > 0) {
        this.version++;
      }
      this._iridescence = value;
    }
  }, {
    key: "dispersion",
    get: function get() {
      return this._dispersion;
    },
    set: function set(value) {
      if (this._dispersion > 0 !== value > 0) {
        this.version++;
      }
      this._dispersion = value;
    }
  }, {
    key: "sheen",
    get: function get() {
      return this._sheen;
    },
    set: function set(value) {
      if (this._sheen > 0 !== value > 0) {
        this.version++;
      }
      this._sheen = value;
    }
  }, {
    key: "transmission",
    get: function get() {
      return this._transmission;
    },
    set: function set(value) {
      if (this._transmission > 0 !== value > 0) {
        this.version++;
      }
      this._transmission = value;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshPhysicalMaterial, "copy", this, 3)([source]);
      this.defines = {
        'STANDARD': '',
        'PHYSICAL': ''
      };
      this.anisotropy = source.anisotropy;
      this.anisotropyRotation = source.anisotropyRotation;
      this.anisotropyMap = source.anisotropyMap;
      this.clearcoat = source.clearcoat;
      this.clearcoatMap = source.clearcoatMap;
      this.clearcoatRoughness = source.clearcoatRoughness;
      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
      this.dispersion = source.dispersion;
      this.ior = source.ior;
      this.iridescence = source.iridescence;
      this.iridescenceMap = source.iridescenceMap;
      this.iridescenceIOR = source.iridescenceIOR;
      this.iridescenceThicknessRange = _toConsumableArray(source.iridescenceThicknessRange);
      this.iridescenceThicknessMap = source.iridescenceThicknessMap;
      this.sheen = source.sheen;
      this.sheenColor.copy(source.sheenColor);
      this.sheenColorMap = source.sheenColorMap;
      this.sheenRoughness = source.sheenRoughness;
      this.sheenRoughnessMap = source.sheenRoughnessMap;
      this.transmission = source.transmission;
      this.transmissionMap = source.transmissionMap;
      this.thickness = source.thickness;
      this.thicknessMap = source.thicknessMap;
      this.attenuationDistance = source.attenuationDistance;
      this.attenuationColor.copy(source.attenuationColor);
      this.specularIntensity = source.specularIntensity;
      this.specularIntensityMap = source.specularIntensityMap;
      this.specularColor.copy(source.specularColor);
      this.specularColorMap = source.specularColorMap;
      return this;
    }
  }]);
}(MeshStandardMaterial);
var MeshPhongMaterial = exports.MeshPhongMaterial = /*#__PURE__*/function (_Material10) {
  function MeshPhongMaterial(parameters) {
    var _this88;
    _classCallCheck(this, MeshPhongMaterial);
    _this88 = _callSuper(this, MeshPhongMaterial);
    _this88.isMeshPhongMaterial = true;
    _this88.type = 'MeshPhongMaterial';
    _this88.color = new Color(0xffffff); // diffuse
    _this88.specular = new Color(0x111111);
    _this88.shininess = 30;
    _this88.map = null;
    _this88.lightMap = null;
    _this88.lightMapIntensity = 1.0;
    _this88.aoMap = null;
    _this88.aoMapIntensity = 1.0;
    _this88.emissive = new Color(0x000000);
    _this88.emissiveIntensity = 1.0;
    _this88.emissiveMap = null;
    _this88.bumpMap = null;
    _this88.bumpScale = 1;
    _this88.normalMap = null;
    _this88.normalMapType = TangentSpaceNormalMap;
    _this88.normalScale = new Vector2(1, 1);
    _this88.displacementMap = null;
    _this88.displacementScale = 1;
    _this88.displacementBias = 0;
    _this88.specularMap = null;
    _this88.alphaMap = null;
    _this88.envMap = null;
    _this88.envMapRotation = new Euler();
    _this88.combine = MultiplyOperation;
    _this88.reflectivity = 1;
    _this88.refractionRatio = 0.98;
    _this88.wireframe = false;
    _this88.wireframeLinewidth = 1;
    _this88.wireframeLinecap = 'round';
    _this88.wireframeLinejoin = 'round';
    _this88.flatShading = false;
    _this88.fog = true;
    _this88.setValues(parameters);
    return _this88;
  }
  _inherits(MeshPhongMaterial, _Material10);
  return _createClass(MeshPhongMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshPhongMaterial, "copy", this, 3)([source]);
      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapRotation.copy(source.envMapRotation);
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material);
var MeshToonMaterial = exports.MeshToonMaterial = /*#__PURE__*/function (_Material11) {
  function MeshToonMaterial(parameters) {
    var _this89;
    _classCallCheck(this, MeshToonMaterial);
    _this89 = _callSuper(this, MeshToonMaterial);
    _this89.isMeshToonMaterial = true;
    _this89.defines = {
      'TOON': ''
    };
    _this89.type = 'MeshToonMaterial';
    _this89.color = new Color(0xffffff);
    _this89.map = null;
    _this89.gradientMap = null;
    _this89.lightMap = null;
    _this89.lightMapIntensity = 1.0;
    _this89.aoMap = null;
    _this89.aoMapIntensity = 1.0;
    _this89.emissive = new Color(0x000000);
    _this89.emissiveIntensity = 1.0;
    _this89.emissiveMap = null;
    _this89.bumpMap = null;
    _this89.bumpScale = 1;
    _this89.normalMap = null;
    _this89.normalMapType = TangentSpaceNormalMap;
    _this89.normalScale = new Vector2(1, 1);
    _this89.displacementMap = null;
    _this89.displacementScale = 1;
    _this89.displacementBias = 0;
    _this89.alphaMap = null;
    _this89.wireframe = false;
    _this89.wireframeLinewidth = 1;
    _this89.wireframeLinecap = 'round';
    _this89.wireframeLinejoin = 'round';
    _this89.fog = true;
    _this89.setValues(parameters);
    return _this89;
  }
  _inherits(MeshToonMaterial, _Material11);
  return _createClass(MeshToonMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshToonMaterial, "copy", this, 3)([source]);
      this.color.copy(source.color);
      this.map = source.map;
      this.gradientMap = source.gradientMap;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material);
var MeshNormalMaterial = exports.MeshNormalMaterial = /*#__PURE__*/function (_Material12) {
  function MeshNormalMaterial(parameters) {
    var _this90;
    _classCallCheck(this, MeshNormalMaterial);
    _this90 = _callSuper(this, MeshNormalMaterial);
    _this90.isMeshNormalMaterial = true;
    _this90.type = 'MeshNormalMaterial';
    _this90.bumpMap = null;
    _this90.bumpScale = 1;
    _this90.normalMap = null;
    _this90.normalMapType = TangentSpaceNormalMap;
    _this90.normalScale = new Vector2(1, 1);
    _this90.displacementMap = null;
    _this90.displacementScale = 1;
    _this90.displacementBias = 0;
    _this90.wireframe = false;
    _this90.wireframeLinewidth = 1;
    _this90.flatShading = false;
    _this90.setValues(parameters);
    return _this90;
  }
  _inherits(MeshNormalMaterial, _Material12);
  return _createClass(MeshNormalMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshNormalMaterial, "copy", this, 3)([source]);
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.flatShading = source.flatShading;
      return this;
    }
  }]);
}(Material);
var MeshLambertMaterial = exports.MeshLambertMaterial = /*#__PURE__*/function (_Material13) {
  function MeshLambertMaterial(parameters) {
    var _this91;
    _classCallCheck(this, MeshLambertMaterial);
    _this91 = _callSuper(this, MeshLambertMaterial);
    _this91.isMeshLambertMaterial = true;
    _this91.type = 'MeshLambertMaterial';
    _this91.color = new Color(0xffffff); // diffuse

    _this91.map = null;
    _this91.lightMap = null;
    _this91.lightMapIntensity = 1.0;
    _this91.aoMap = null;
    _this91.aoMapIntensity = 1.0;
    _this91.emissive = new Color(0x000000);
    _this91.emissiveIntensity = 1.0;
    _this91.emissiveMap = null;
    _this91.bumpMap = null;
    _this91.bumpScale = 1;
    _this91.normalMap = null;
    _this91.normalMapType = TangentSpaceNormalMap;
    _this91.normalScale = new Vector2(1, 1);
    _this91.displacementMap = null;
    _this91.displacementScale = 1;
    _this91.displacementBias = 0;
    _this91.specularMap = null;
    _this91.alphaMap = null;
    _this91.envMap = null;
    _this91.envMapRotation = new Euler();
    _this91.combine = MultiplyOperation;
    _this91.reflectivity = 1;
    _this91.refractionRatio = 0.98;
    _this91.wireframe = false;
    _this91.wireframeLinewidth = 1;
    _this91.wireframeLinecap = 'round';
    _this91.wireframeLinejoin = 'round';
    _this91.flatShading = false;
    _this91.fog = true;
    _this91.setValues(parameters);
    return _this91;
  }
  _inherits(MeshLambertMaterial, _Material13);
  return _createClass(MeshLambertMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshLambertMaterial, "copy", this, 3)([source]);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapRotation.copy(source.envMapRotation);
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material);
var MeshMatcapMaterial = exports.MeshMatcapMaterial = /*#__PURE__*/function (_Material14) {
  function MeshMatcapMaterial(parameters) {
    var _this92;
    _classCallCheck(this, MeshMatcapMaterial);
    _this92 = _callSuper(this, MeshMatcapMaterial);
    _this92.isMeshMatcapMaterial = true;
    _this92.defines = {
      'MATCAP': ''
    };
    _this92.type = 'MeshMatcapMaterial';
    _this92.color = new Color(0xffffff); // diffuse

    _this92.matcap = null;
    _this92.map = null;
    _this92.bumpMap = null;
    _this92.bumpScale = 1;
    _this92.normalMap = null;
    _this92.normalMapType = TangentSpaceNormalMap;
    _this92.normalScale = new Vector2(1, 1);
    _this92.displacementMap = null;
    _this92.displacementScale = 1;
    _this92.displacementBias = 0;
    _this92.alphaMap = null;
    _this92.flatShading = false;
    _this92.fog = true;
    _this92.setValues(parameters);
    return _this92;
  }
  _inherits(MeshMatcapMaterial, _Material14);
  return _createClass(MeshMatcapMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(MeshMatcapMaterial, "copy", this, 3)([source]);
      this.defines = {
        'MATCAP': ''
      };
      this.color.copy(source.color);
      this.matcap = source.matcap;
      this.map = source.map;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.flatShading = source.flatShading;
      this.fog = source.fog;
      return this;
    }
  }]);
}(Material);
var LineDashedMaterial = exports.LineDashedMaterial = /*#__PURE__*/function (_LineBasicMaterial) {
  function LineDashedMaterial(parameters) {
    var _this93;
    _classCallCheck(this, LineDashedMaterial);
    _this93 = _callSuper(this, LineDashedMaterial);
    _this93.isLineDashedMaterial = true;
    _this93.type = 'LineDashedMaterial';
    _this93.scale = 1;
    _this93.dashSize = 3;
    _this93.gapSize = 1;
    _this93.setValues(parameters);
    return _this93;
  }
  _inherits(LineDashedMaterial, _LineBasicMaterial);
  return _createClass(LineDashedMaterial, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(LineDashedMaterial, "copy", this, 3)([source]);
      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      return this;
    }
  }]);
}(LineBasicMaterial); // converts an array to a specific type
function convertArray(array, type, forceClone) {
  if (!array ||
  // let 'undefined' and 'null' pass
  !forceClone && array.constructor === type) return array;
  if (typeof type.BYTES_PER_ELEMENT === 'number') {
    return new type(array); // create typed array
  }
  return Array.prototype.slice.call(array); // create Array
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}

// returns an array by which times and values can be sorted
function getKeyframeOrder(times) {
  function compareTime(i, j) {
    return times[i] - times[j];
  }
  var n = times.length;
  var result = new Array(n);
  for (var i = 0; i !== n; ++i) result[i] = i;
  result.sort(compareTime);
  return result;
}

// uses the array previously returned by 'getKeyframeOrder' to sort data
function sortedArray(values, stride, order) {
  var nValues = values.length;
  var result = new values.constructor(nValues);
  for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
    var srcOffset = order[i] * stride;
    for (var j = 0; j !== stride; ++j) {
      result[dstOffset++] = values[srcOffset + j];
    }
  }
  return result;
}

// function for parsing AOS keyframe formats
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
  var i = 1,
    key = jsonKeys[0];
  while (key !== undefined && key[valuePropertyName] === undefined) {
    key = jsonKeys[i++];
  }
  if (key === undefined) return; // no data

  var value = key[valuePropertyName];
  if (value === undefined) return; // no data

  if (Array.isArray(value)) {
    do {
      value = key[valuePropertyName];
      if (value !== undefined) {
        times.push(key.time);
        values.push.apply(values, value); // push all elements
      }
      key = jsonKeys[i++];
    } while (key !== undefined);
  } else if (value.toArray !== undefined) {
    // ...assume THREE.Math-ish

    do {
      value = key[valuePropertyName];
      if (value !== undefined) {
        times.push(key.time);
        value.toArray(values, values.length);
      }
      key = jsonKeys[i++];
    } while (key !== undefined);
  } else {
    // otherwise push as-is

    do {
      value = key[valuePropertyName];
      if (value !== undefined) {
        times.push(key.time);
        values.push(value);
      }
      key = jsonKeys[i++];
    } while (key !== undefined);
  }
}
function subclip(sourceClip, name, startFrame, endFrame) {
  var fps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 30;
  var clip = sourceClip.clone();
  clip.name = name;
  var tracks = [];
  for (var i = 0; i < clip.tracks.length; ++i) {
    var track = clip.tracks[i];
    var valueSize = track.getValueSize();
    var times = [];
    var values = [];
    for (var j = 0; j < track.times.length; ++j) {
      var frame = track.times[j] * fps;
      if (frame < startFrame || frame >= endFrame) continue;
      times.push(track.times[j]);
      for (var k = 0; k < valueSize; ++k) {
        values.push(track.values[j * valueSize + k]);
      }
    }
    if (times.length === 0) continue;
    track.times = convertArray(times, track.times.constructor);
    track.values = convertArray(values, track.values.constructor);
    tracks.push(track);
  }
  clip.tracks = tracks;

  // find minimum .times value across all tracks in the trimmed clip

  var minStartTime = Infinity;
  for (var _i90 = 0; _i90 < clip.tracks.length; ++_i90) {
    if (minStartTime > clip.tracks[_i90].times[0]) {
      minStartTime = clip.tracks[_i90].times[0];
    }
  }

  // shift all tracks such that clip begins at t=0

  for (var _i91 = 0; _i91 < clip.tracks.length; ++_i91) {
    clip.tracks[_i91].shift(-1 * minStartTime);
  }
  clip.resetDuration();
  return clip;
}
function makeClipAdditive(targetClip) {
  var referenceFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var referenceClip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : targetClip;
  var fps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;
  if (fps <= 0) fps = 30;
  var numTracks = referenceClip.tracks.length;
  var referenceTime = referenceFrame / fps;

  // Make each track's values relative to the values at the reference frame
  var _loop = function _loop() {
      var referenceTrack = referenceClip.tracks[i];
      var referenceTrackType = referenceTrack.ValueTypeName;

      // Skip this track if it's non-numeric
      if (referenceTrackType === 'bool' || referenceTrackType === 'string') return 0; // continue

      // Find the track in the target clip whose name and type matches the reference track
      var targetTrack = targetClip.tracks.find(function (track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === undefined) return 0; // continue
      var referenceOffset = 0;
      var referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      var targetOffset = 0;
      var targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      var lastIndex = referenceTrack.times.length - 1;
      var referenceValue;

      // Find the value to subtract out of the track
      if (referenceTime <= referenceTrack.times[0]) {
        // Reference frame is earlier than the first keyframe, so just use the first keyframe
        var startIndex = referenceOffset;
        var endIndex = referenceValueSize - referenceOffset;
        referenceValue = referenceTrack.values.slice(startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        // Reference frame is after the last keyframe, so just use the last keyframe
        var _startIndex = lastIndex * referenceValueSize + referenceOffset;
        var _endIndex = _startIndex + referenceValueSize - referenceOffset;
        referenceValue = referenceTrack.values.slice(_startIndex, _endIndex);
      } else {
        // Interpolate to the reference value
        var interpolant = referenceTrack.createInterpolant();
        var _startIndex2 = referenceOffset;
        var _endIndex2 = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = interpolant.resultBuffer.slice(_startIndex2, _endIndex2);
      }

      // Conjugate the quaternion
      if (referenceTrackType === 'quaternion') {
        var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }

      // Subtract the reference value from all of the track values

      var numTimes = targetTrack.times.length;
      for (var j = 0; j < numTimes; ++j) {
        var valueStart = j * targetValueSize + targetOffset;
        if (referenceTrackType === 'quaternion') {
          // Multiply the conjugate for quaternion track types
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          var valueEnd = targetValueSize - targetOffset * 2;

          // Subtract each value for all other numeric track types
          for (var k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    },
    _ret;
  for (var i = 0; i < numTracks; ++i) {
    _ret = _loop();
    if (_ret === 0) continue;
  }
  targetClip.blendMode = AdditiveAnimationBlendMode;
  return targetClip;
}
var AnimationUtils = exports.AnimationUtils = {
  convertArray: convertArray,
  isTypedArray: isTypedArray,
  getKeyframeOrder: getKeyframeOrder,
  sortedArray: sortedArray,
  flattenJSON: flattenJSON,
  subclip: subclip,
  makeClipAdditive: makeClipAdditive
};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */
var Interpolant = exports.Interpolant = /*#__PURE__*/function () {
  function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    _classCallCheck(this, Interpolant);
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  return _createClass(Interpolant, [{
    key: "evaluate",
    value: function evaluate(t) {
      var pp = this.parameterPositions;
      var i1 = this._cachedIndex,
        t1 = pp[i1],
        t0 = pp[i1 - 1];
      validate_interval: {
        seek: {
          var right;
          linear_scan: {
            //- See http://jsperf.com/comparison-to-undefined/3
            //- slower code:
            //-
            //- 				if ( t >= t1 || t1 === undefined ) {
            forward_scan: if (!(t < t1)) {
              for (var giveUpAt = i1 + 2;;) {
                if (t1 === undefined) {
                  if (t < t0) break forward_scan;

                  // after end

                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.copySampleValue_(i1 - 1);
                }
                if (i1 === giveUpAt) break; // this loop

                t0 = t1;
                t1 = pp[++i1];
                if (t < t1) {
                  // we have arrived at the sought interval
                  break seek;
                }
              }

              // prepare binary search on the right side of the index
              right = pp.length;
              break linear_scan;
            }

            //- slower code:
            //-					if ( t < t0 || t0 === undefined ) {
            if (!(t >= t0)) {
              // looping?

              var t1global = pp[1];
              if (t < t1global) {
                i1 = 2; // + 1, using the scan for the details
                t0 = t1global;
              }

              // linear reverse scan

              for (var _giveUpAt = i1 - 2;;) {
                if (t0 === undefined) {
                  // before start

                  this._cachedIndex = 0;
                  return this.copySampleValue_(0);
                }
                if (i1 === _giveUpAt) break; // this loop

                t1 = t0;
                t0 = pp[--i1 - 1];
                if (t >= t0) {
                  // we have arrived at the sought interval
                  break seek;
                }
              }

              // prepare binary search on the left side of the index
              right = i1;
              i1 = 0;
              break linear_scan;
            }

            // the interval is valid

            break validate_interval;
          } // linear scan

          // binary search

          while (i1 < right) {
            var mid = i1 + right >>> 1;
            if (t < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }
          t1 = pp[i1];
          t0 = pp[i1 - 1];

          // check boundary cases, again

          if (t0 === undefined) {
            this._cachedIndex = 0;
            return this.copySampleValue_(0);
          }
          if (t1 === undefined) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.copySampleValue_(i1 - 1);
          }
        } // seek

        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      } // validate_interval

      return this.interpolate_(i1, t0, t, t1);
    }
  }, {
    key: "getSettings_",
    value: function getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
  }, {
    key: "copySampleValue_",
    value: function copySampleValue_(index) {
      // copies a sample value to the result buffer

      var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        offset = index * stride;
      for (var i = 0; i !== stride; ++i) {
        result[i] = values[offset + i];
      }
      return result;
    }

    // Template methods for derived classes:
  }, {
    key: "interpolate_",
    value: function interpolate_( /* i1, t0, t, t1 */
    ) {
      throw new Error('call to abstract method');
      // implementations shall return this.resultBuffer
    }
  }, {
    key: "intervalChanged_",
    value: function intervalChanged_( /* i1, t0, t1 */
    ) {

      // empty
    }
  }]);
}();
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */
var CubicInterpolant = exports.CubicInterpolant = /*#__PURE__*/function (_Interpolant) {
  function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    var _this94;
    _classCallCheck(this, CubicInterpolant);
    _this94 = _callSuper(this, CubicInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
    _this94._weightPrev = -0;
    _this94._offsetPrev = -0;
    _this94._weightNext = -0;
    _this94._offsetNext = -0;
    _this94.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    return _this94;
  }
  _inherits(CubicInterpolant, _Interpolant);
  return _createClass(CubicInterpolant, [{
    key: "intervalChanged_",
    value: function intervalChanged_(i1, t0, t1) {
      var pp = this.parameterPositions;
      var iPrev = i1 - 2,
        iNext = i1 + 1,
        tPrev = pp[iPrev],
        tNext = pp[iNext];
      if (tPrev === undefined) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            // f'(t0) = 0
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;
          case WrapAroundEnding:
            // use the other end of the curve
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;
          default:
            // ZeroCurvatureEnding

            // f''(t0) = 0 a.k.a. Natural Spline
            iPrev = i1;
            tPrev = t1;
        }
      }
      if (tNext === undefined) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            // f'(tN) = 0
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;
          case WrapAroundEnding:
            // use the other end of the curve
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;
          default:
            // ZeroCurvatureEnding

            // f''(tN) = 0, a.k.a. Natural Spline
            iNext = i1 - 1;
            tNext = t0;
        }
      }
      var halfDt = (t1 - t0) * 0.5,
        stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    }
  }, {
    key: "interpolate_",
    value: function interpolate_(i1, t0, t, t1) {
      var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        o1 = i1 * stride,
        o0 = o1 - stride,
        oP = this._offsetPrev,
        oN = this._offsetNext,
        wP = this._weightPrev,
        wN = this._weightNext,
        p = (t - t0) / (t1 - t0),
        pp = p * p,
        ppp = pp * p;

      // evaluate polynomials

      var sP = -wP * ppp + 2 * wP * pp - wP * p;
      var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
      var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
      var sN = wN * ppp - wN * pp;

      // combine data linearly

      for (var i = 0; i !== stride; ++i) {
        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
      }
      return result;
    }
  }]);
}(Interpolant);
var LinearInterpolant = exports.LinearInterpolant = /*#__PURE__*/function (_Interpolant2) {
  function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    _classCallCheck(this, LinearInterpolant);
    return _callSuper(this, LinearInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
  }
  _inherits(LinearInterpolant, _Interpolant2);
  return _createClass(LinearInterpolant, [{
    key: "interpolate_",
    value: function interpolate_(i1, t0, t, t1) {
      var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        offset1 = i1 * stride,
        offset0 = offset1 - stride,
        weight1 = (t - t0) / (t1 - t0),
        weight0 = 1 - weight1;
      for (var i = 0; i !== stride; ++i) {
        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
      }
      return result;
    }
  }]);
}(Interpolant);
/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */
var DiscreteInterpolant = exports.DiscreteInterpolant = /*#__PURE__*/function (_Interpolant3) {
  function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    _classCallCheck(this, DiscreteInterpolant);
    return _callSuper(this, DiscreteInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
  }
  _inherits(DiscreteInterpolant, _Interpolant3);
  return _createClass(DiscreteInterpolant, [{
    key: "interpolate_",
    value: function interpolate_(i1 /*, t0, t, t1 */) {
      return this.copySampleValue_(i1 - 1);
    }
  }]);
}(Interpolant);
var KeyframeTrack = exports.KeyframeTrack = /*#__PURE__*/function () {
  function KeyframeTrack(name, times, values, interpolation) {
    _classCallCheck(this, KeyframeTrack);
    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }

  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  return _createClass(KeyframeTrack, [{
    key: "InterpolantFactoryMethodDiscrete",
    value: function InterpolantFactoryMethodDiscrete(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  }, {
    key: "InterpolantFactoryMethodLinear",
    value: function InterpolantFactoryMethodLinear(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  }, {
    key: "InterpolantFactoryMethodSmooth",
    value: function InterpolantFactoryMethodSmooth(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  }, {
    key: "setInterpolation",
    value: function setInterpolation(interpolation) {
      var factoryMethod;
      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (factoryMethod === undefined) {
        var message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
        if (this.createInterpolant === undefined) {
          // fall back to default, unless the default itself is messed up
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message); // fatal, in this case
          }
        }
        console.warn('THREE.KeyframeTrack:', message);
        return this;
      }
      this.createInterpolant = factoryMethod;
      return this;
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    }
  }, {
    key: "getValueSize",
    value: function getValueSize() {
      return this.values.length / this.times.length;
    }

    // move all keyframes either forwards or backwards in time
  }, {
    key: "shift",
    value: function shift(timeOffset) {
      if (timeOffset !== 0.0) {
        var times = this.times;
        for (var i = 0, n = times.length; i !== n; ++i) {
          times[i] += timeOffset;
        }
      }
      return this;
    }

    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  }, {
    key: "scale",
    value: function scale(timeScale) {
      if (timeScale !== 1.0) {
        var times = this.times;
        for (var i = 0, n = times.length; i !== n; ++i) {
          times[i] *= timeScale;
        }
      }
      return this;
    }

    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  }, {
    key: "trim",
    value: function trim(startTime, endTime) {
      var times = this.times,
        nKeys = times.length;
      var from = 0,
        to = nKeys - 1;
      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }
      while (to !== -1 && times[to] > endTime) {
        --to;
      }
      ++to; // inclusive -> exclusive bound

      if (from !== 0 || to !== nKeys) {
        // empty tracks are forbidden, so keep at least one keyframe
        if (from >= to) {
          to = Math.max(to, 1);
          from = to - 1;
        }
        var stride = this.getValueSize();
        this.times = times.slice(from, to);
        this.values = this.values.slice(from * stride, to * stride);
      }
      return this;
    }

    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  }, {
    key: "validate",
    value: function validate() {
      var valid = true;
      var valueSize = this.getValueSize();
      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
        valid = false;
      }
      var times = this.times,
        values = this.values,
        nKeys = times.length;
      if (nKeys === 0) {
        console.error('THREE.KeyframeTrack: Track is empty.', this);
        valid = false;
      }
      var prevTime = null;
      for (var i = 0; i !== nKeys; i++) {
        var currTime = times[i];
        if (typeof currTime === 'number' && isNaN(currTime)) {
          console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
          valid = false;
          break;
        }
        if (prevTime !== null && prevTime > currTime) {
          console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
          valid = false;
          break;
        }
        prevTime = currTime;
      }
      if (values !== undefined) {
        if (isTypedArray(values)) {
          for (var _i92 = 0, n = values.length; _i92 !== n; ++_i92) {
            var value = values[_i92];
            if (isNaN(value)) {
              console.error('THREE.KeyframeTrack: Value is not a valid number.', this, _i92, value);
              valid = false;
              break;
            }
          }
        }
      }
      return valid;
    }

    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  }, {
    key: "optimize",
    value: function optimize() {
      // times or values may be shared with other tracks, so overwriting is unsafe
      var times = this.times.slice(),
        values = this.values.slice(),
        stride = this.getValueSize(),
        smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
        lastIndex = times.length - 1;
      var writeIndex = 1;
      for (var i = 1; i < lastIndex; ++i) {
        var keep = false;
        var time = times[i];
        var timeNext = times[i + 1];

        // remove adjacent keyframes scheduled at the same time

        if (time !== timeNext && (i !== 1 || time !== times[0])) {
          if (!smoothInterpolation) {
            // remove unnecessary keyframes same as their neighbors

            var offset = i * stride,
              offsetP = offset - stride,
              offsetN = offset + stride;
            for (var j = 0; j !== stride; ++j) {
              var value = values[offset + j];
              if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }

        // in-place compaction

        if (keep) {
          if (i !== writeIndex) {
            times[writeIndex] = times[i];
            var readOffset = i * stride,
              writeOffset = writeIndex * stride;
            for (var _j14 = 0; _j14 !== stride; ++_j14) {
              values[writeOffset + _j14] = values[readOffset + _j14];
            }
          }
          ++writeIndex;
        }
      }

      // flush last keyframe (compaction looks ahead)

      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];
        for (var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j15 = 0; _j15 !== stride; ++_j15) {
          values[_writeOffset + _j15] = values[_readOffset + _j15];
        }
        ++writeIndex;
      }
      if (writeIndex !== times.length) {
        this.times = times.slice(0, writeIndex);
        this.values = values.slice(0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var times = this.times.slice();
      var values = this.values.slice();
      var TypedKeyframeTrack = this.constructor;
      var track = new TypedKeyframeTrack(this.name, times, values);

      // Interpolant argument to constructor is not saved, so copy the factory method directly.
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  }], [{
    key: "toJSON",
    value: function toJSON(track) {
      var trackType = track.constructor;
      var json;

      // derived classes can define a static toJSON method
      if (trackType.toJSON !== this.toJSON) {
        json = trackType.toJSON(track);
      } else {
        // by default, we assume the data can be serialized as-is
        json = {
          'name': track.name,
          'times': convertArray(track.times, Array),
          'values': convertArray(track.values, Array)
        };
        var interpolation = track.getInterpolation();
        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }
      json.type = track.ValueTypeName; // mandatory

      return json;
    }
  }]);
}();
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
var BooleanKeyframeTrack = exports.BooleanKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  function BooleanKeyframeTrack(name, times, values) {
    _classCallCheck(this, BooleanKeyframeTrack);
    return _callSuper(this, BooleanKeyframeTrack, [name, times, values]);
  }
  _inherits(BooleanKeyframeTrack, _KeyframeTrack);
  return _createClass(BooleanKeyframeTrack);
}(KeyframeTrack);
BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
var ColorKeyframeTrack = exports.ColorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack2) {
  function ColorKeyframeTrack() {
    _classCallCheck(this, ColorKeyframeTrack);
    return _callSuper(this, ColorKeyframeTrack, arguments);
  }
  _inherits(ColorKeyframeTrack, _KeyframeTrack2);
  return _createClass(ColorKeyframeTrack);
}(KeyframeTrack);
ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
var NumberKeyframeTrack = exports.NumberKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack3) {
  function NumberKeyframeTrack() {
    _classCallCheck(this, NumberKeyframeTrack);
    return _callSuper(this, NumberKeyframeTrack, arguments);
  }
  _inherits(NumberKeyframeTrack, _KeyframeTrack3);
  return _createClass(NumberKeyframeTrack);
}(KeyframeTrack);
NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */
var QuaternionLinearInterpolant = exports.QuaternionLinearInterpolant = /*#__PURE__*/function (_Interpolant4) {
  function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    _classCallCheck(this, QuaternionLinearInterpolant);
    return _callSuper(this, QuaternionLinearInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
  }
  _inherits(QuaternionLinearInterpolant, _Interpolant4);
  return _createClass(QuaternionLinearInterpolant, [{
    key: "interpolate_",
    value: function interpolate_(i1, t0, t, t1) {
      var result = this.resultBuffer,
        values = this.sampleValues,
        stride = this.valueSize,
        alpha = (t - t0) / (t1 - t0);
      var offset = i1 * stride;
      for (var end = offset + stride; offset !== end; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }
      return result;
    }
  }]);
}(Interpolant);
/**
 * A Track of quaternion keyframe values.
 */
var QuaternionKeyframeTrack = exports.QuaternionKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack4) {
  function QuaternionKeyframeTrack() {
    _classCallCheck(this, QuaternionKeyframeTrack);
    return _callSuper(this, QuaternionKeyframeTrack, arguments);
  }
  _inherits(QuaternionKeyframeTrack, _KeyframeTrack4);
  return _createClass(QuaternionKeyframeTrack, [{
    key: "InterpolantFactoryMethodLinear",
    value: function InterpolantFactoryMethodLinear(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  }]);
}(KeyframeTrack);
QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
// DefaultInterpolation is inherited;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
var StringKeyframeTrack = exports.StringKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack5) {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  function StringKeyframeTrack(name, times, values) {
    _classCallCheck(this, StringKeyframeTrack);
    return _callSuper(this, StringKeyframeTrack, [name, times, values]);
  }
  _inherits(StringKeyframeTrack, _KeyframeTrack5);
  return _createClass(StringKeyframeTrack);
}(KeyframeTrack);
StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
var VectorKeyframeTrack = exports.VectorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack6) {
  function VectorKeyframeTrack() {
    _classCallCheck(this, VectorKeyframeTrack);
    return _callSuper(this, VectorKeyframeTrack, arguments);
  }
  _inherits(VectorKeyframeTrack, _KeyframeTrack6);
  return _createClass(VectorKeyframeTrack);
}(KeyframeTrack);
VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
var AnimationClip = exports.AnimationClip = /*#__PURE__*/function () {
  function AnimationClip() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var tracks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var blendMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NormalAnimationBlendMode;
    _classCallCheck(this, AnimationClip);
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();

    // this means it should figure out its duration by scanning the tracks
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  return _createClass(AnimationClip, [{
    key: "resetDuration",
    value: function resetDuration() {
      var tracks = this.tracks;
      var duration = 0;
      for (var i = 0, n = tracks.length; i !== n; ++i) {
        var track = this.tracks[i];
        duration = Math.max(duration, track.times[track.times.length - 1]);
      }
      this.duration = duration;
      return this;
    }
  }, {
    key: "trim",
    value: function trim() {
      for (var i = 0; i < this.tracks.length; i++) {
        this.tracks[i].trim(0, this.duration);
      }
      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var valid = true;
      for (var i = 0; i < this.tracks.length; i++) {
        valid = valid && this.tracks[i].validate();
      }
      return valid;
    }
  }, {
    key: "optimize",
    value: function optimize() {
      for (var i = 0; i < this.tracks.length; i++) {
        this.tracks[i].optimize();
      }
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var tracks = [];
      for (var i = 0; i < this.tracks.length; i++) {
        tracks.push(this.tracks[i].clone());
      }
      return new this.constructor(this.name, this.duration, tracks, this.blendMode);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.constructor.toJSON(this);
    }
  }], [{
    key: "parse",
    value: function parse(json) {
      var tracks = [],
        jsonTracks = json.tracks,
        frameTime = 1.0 / (json.fps || 1.0);
      for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
        tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
      }
      var clip = new this(json.name, json.duration, tracks, json.blendMode);
      clip.uuid = json.uuid;
      return clip;
    }
  }, {
    key: "toJSON",
    value: function toJSON(clip) {
      var tracks = [],
        clipTracks = clip.tracks;
      var json = {
        'name': clip.name,
        'duration': clip.duration,
        'tracks': tracks,
        'uuid': clip.uuid,
        'blendMode': clip.blendMode
      };
      for (var i = 0, n = clipTracks.length; i !== n; ++i) {
        tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
      }
      return json;
    }
  }, {
    key: "CreateFromMorphTargetSequence",
    value: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
      var numMorphTargets = morphTargetSequence.length;
      var tracks = [];
      for (var i = 0; i < numMorphTargets; i++) {
        var times = [];
        var values = [];
        times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
        values.push(0, 1, 0);
        var order = getKeyframeOrder(times);
        times = sortedArray(times, 1, order);
        values = sortedArray(values, 1, order);

        // if there is a key at the first frame, duplicate it as the
        // last frame as well for perfect loop.
        if (!noLoop && times[0] === 0) {
          times.push(numMorphTargets);
          values.push(values[0]);
        }
        tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
      }
      return new this(name, -1, tracks);
    }
  }, {
    key: "findByName",
    value: function findByName(objectOrClipArray, name) {
      var clipArray = objectOrClipArray;
      if (!Array.isArray(objectOrClipArray)) {
        var o = objectOrClipArray;
        clipArray = o.geometry && o.geometry.animations || o.animations;
      }
      for (var i = 0; i < clipArray.length; i++) {
        if (clipArray[i].name === name) {
          return clipArray[i];
        }
      }
      return null;
    }
  }, {
    key: "CreateClipsFromMorphTargetSequences",
    value: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
      var animationToMorphTargets = {};

      // tested with https://regex101.com/ on trick sequences
      // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
      var pattern = /^([\w-]*?)([\d]+)$/;

      // sort morph target names into animation groups based
      // patterns like Walk_001, Walk_002, Run_001, Run_002
      for (var i = 0, il = morphTargets.length; i < il; i++) {
        var morphTarget = morphTargets[i];
        var parts = morphTarget.name.match(pattern);
        if (parts && parts.length > 1) {
          var name = parts[1];
          var animationMorphTargets = animationToMorphTargets[name];
          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }
          animationMorphTargets.push(morphTarget);
        }
      }
      var clips = [];
      for (var _name5 in animationToMorphTargets) {
        clips.push(this.CreateFromMorphTargetSequence(_name5, animationToMorphTargets[_name5], fps, noLoop));
      }
      return clips;
    }

    // parse the animation.hierarchy format
  }, {
    key: "parseAnimation",
    value: function parseAnimation(animation, bones) {
      if (!animation) {
        console.error('THREE.AnimationClip: No animation in JSONLoader data.');
        return null;
      }
      var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {
        // only return track if there are actually keys.
        if (animationKeys.length !== 0) {
          var times = [];
          var values = [];
          flattenJSON(animationKeys, times, values, propertyName);

          // empty keys are filtered out, so check again
          if (times.length !== 0) {
            destTracks.push(new trackType(trackName, times, values));
          }
        }
      };
      var tracks = [];
      var clipName = animation.name || 'default';
      var fps = animation.fps || 30;
      var blendMode = animation.blendMode;

      // automatic length determination in AnimationClip.
      var duration = animation.length || -1;
      var hierarchyTracks = animation.hierarchy || [];
      for (var h = 0; h < hierarchyTracks.length; h++) {
        var animationKeys = hierarchyTracks[h].keys;

        // skip empty tracks
        if (!animationKeys || animationKeys.length === 0) continue;

        // process morph targets
        if (animationKeys[0].morphTargets) {
          // figure out all morph targets used in this track
          var morphTargetNames = {};
          var k = void 0;
          for (k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
              for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
              }
            }
          }

          // create a track for each morph target with all zero
          // morphTargetInfluences except for the keys in which
          // the morphTarget is named.
          for (var morphTargetName in morphTargetNames) {
            var times = [];
            var values = [];
            for (var _m = 0; _m !== animationKeys[k].morphTargets.length; ++_m) {
              var animationKey = animationKeys[k];
              times.push(animationKey.time);
              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }
            tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
          }
          duration = morphTargetNames.length * fps;
        } else {
          // ...assume skeletal animation

          var boneName = '.bones[' + bones[h].name + ']';
          addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
          addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
          addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
        }
      }
      if (tracks.length === 0) {
        return null;
      }
      var clip = new this(clipName, duration, tracks, blendMode);
      return clip;
    }
  }]);
}();
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return NumberKeyframeTrack;
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return VectorKeyframeTrack;
    case 'color':
      return ColorKeyframeTrack;
    case 'quaternion':
      return QuaternionKeyframeTrack;
    case 'bool':
    case 'boolean':
      return BooleanKeyframeTrack;
    case 'string':
      return StringKeyframeTrack;
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === undefined) {
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  }
  var trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === undefined) {
    var times = [],
      values = [];
    flattenJSON(json.keys, times, values, 'value');
    json.times = times;
    json.values = values;
  }

  // derived classes can define a static parse method
  if (trackType.parse !== undefined) {
    return trackType.parse(json);
  } else {
    // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
var Cache = exports.Cache = {
  enabled: false,
  files: {},
  add: function add(key, file) {
    if (this.enabled === false) return;

    // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function get(key) {
    if (this.enabled === false) return;

    // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function remove(key) {
    delete this.files[key];
  },
  clear: function clear() {
    this.files = {};
  }
};
var LoadingManager = exports.LoadingManager = /*#__PURE__*/_createClass(function LoadingManager(onLoad, onProgress, onError) {
  _classCallCheck(this, LoadingManager);
  var scope = this;
  var isLoading = false;
  var itemsLoaded = 0;
  var itemsTotal = 0;
  var urlModifier = undefined;
  var handlers = [];

  // Refer to #5689 for the reason why we don't set .onStart
  // in the constructor

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function (url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function (url) {
    itemsLoaded++;
    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };
  this.resolveURL = function (url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function (transform) {
    urlModifier = transform;
    return this;
  };
  this.addHandler = function (regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function (regex) {
    var index = handlers.indexOf(regex);
    if (index !== -1) {
      handlers.splice(index, 2);
    }
    return this;
  };
  this.getHandler = function (file) {
    for (var i = 0, l = handlers.length; i < l; i += 2) {
      var regex = handlers[i];
      var loader = handlers[i + 1];
      if (regex.global) regex.lastIndex = 0; // see #17920

      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
});
var DefaultLoadingManager = exports.DefaultLoadingManager = /*@__PURE__*/new LoadingManager();
var Loader = exports.Loader = /*#__PURE__*/function () {
  function Loader(manager) {
    _classCallCheck(this, Loader);
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = 'anonymous';
    this.withCredentials = false;
    this.path = '';
    this.resourcePath = '';
    this.requestHeader = {};
  }
  return _createClass(Loader, [{
    key: "load",
    value: function load( /* url, onLoad, onProgress, onError */) {}
  }, {
    key: "loadAsync",
    value: function loadAsync(url, onProgress) {
      var scope = this;
      return new Promise(function (resolve, reject) {
        scope.load(url, resolve, onProgress, reject);
      });
    }
  }, {
    key: "parse",
    value: function parse( /* data */) {}
  }, {
    key: "setCrossOrigin",
    value: function setCrossOrigin(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    }
  }, {
    key: "setWithCredentials",
    value: function setWithCredentials(value) {
      this.withCredentials = value;
      return this;
    }
  }, {
    key: "setPath",
    value: function setPath(path) {
      this.path = path;
      return this;
    }
  }, {
    key: "setResourcePath",
    value: function setResourcePath(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    }
  }, {
    key: "setRequestHeader",
    value: function setRequestHeader(requestHeader) {
      this.requestHeader = requestHeader;
      return this;
    }
  }]);
}();
Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';
var loading = {};
var HttpError = /*#__PURE__*/function (_Error) {
  function HttpError(message, response) {
    var _this95;
    _classCallCheck(this, HttpError);
    _this95 = _callSuper(this, HttpError, [message]);
    _this95.response = response;
    return _this95;
  }
  _inherits(HttpError, _Error);
  return _createClass(HttpError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var FileLoader = exports.FileLoader = /*#__PURE__*/function (_Loader) {
  function FileLoader(manager) {
    _classCallCheck(this, FileLoader);
    return _callSuper(this, FileLoader, [manager]);
  }
  _inherits(FileLoader, _Loader);
  return _createClass(FileLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var _this96 = this;
      if (url === undefined) url = '';
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var cached = Cache.get(url);
      if (cached !== undefined) {
        this.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          _this96.manager.itemEnd(url);
        }, 0);
        return cached;
      }

      // Check if request is duplicate

      if (loading[url] !== undefined) {
        loading[url].push({
          onLoad: onLoad,
          onProgress: onProgress,
          onError: onError
        });
        return;
      }

      // Initialise array for duplicate requests
      loading[url] = [];
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });

      // create request
      var req = new Request(url, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin'
        // An abort controller could be added within a future PR
      });

      // record states ( avoid data race )
      var mimeType = this.mimeType;
      var responseType = this.responseType;

      // start the fetch
      fetch(req).then(function (response) {
        if (response.status === 200 || response.status === 0) {
          // Some browsers return HTTP Status 0 when using non-http protocol
          // e.g. 'file://' or 'data://'. Handle as success.

          if (response.status === 0) {
            console.warn('THREE.FileLoader: HTTP Status 0 received.');
          }

          // Workaround: Checking if response.body === undefined for Alipay browser #23548

          if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {
            return response;
          }
          var callbacks = loading[url];
          var reader = response.body.getReader();

          // Nginx needs X-File-Size check
          // https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
          var contentLength = response.headers.get('X-File-Size') || response.headers.get('Content-Length');
          var total = contentLength ? parseInt(contentLength) : 0;
          var lengthComputable = total !== 0;
          var loaded = 0;

          // periodically read data into the new stream tracking while download progress
          var stream = new ReadableStream({
            start: function start(controller) {
              readData();
              function readData() {
                reader.read().then(function (_ref3) {
                  var done = _ref3.done,
                    value = _ref3.value;
                  if (done) {
                    controller.close();
                  } else {
                    loaded += value.byteLength;
                    var event = new ProgressEvent('progress', {
                      lengthComputable: lengthComputable,
                      loaded: loaded,
                      total: total
                    });
                    for (var i = 0, il = callbacks.length; i < il; i++) {
                      var callback = callbacks[i];
                      if (callback.onProgress) callback.onProgress(event);
                    }
                    controller.enqueue(value);
                    readData();
                  }
                }, function (e) {
                  controller.error(e);
                });
              }
            }
          });
          return new Response(stream);
        } else {
          throw new HttpError("fetch for \"".concat(response.url, "\" responded with ").concat(response.status, ": ").concat(response.statusText), response);
        }
      }).then(function (response) {
        switch (responseType) {
          case 'arraybuffer':
            return response.arrayBuffer();
          case 'blob':
            return response.blob();
          case 'document':
            return response.text().then(function (text) {
              var parser = new DOMParser();
              return parser.parseFromString(text, mimeType);
            });
          case 'json':
            return response.json();
          default:
            if (mimeType === undefined) {
              return response.text();
            } else {
              // sniff encoding
              var re = /charset="?([^;"\s]*)"?/i;
              var exec = re.exec(mimeType);
              var label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
              var decoder = new TextDecoder(label);
              return response.arrayBuffer().then(function (ab) {
                return decoder.decode(ab);
              });
            }
        }
      }).then(function (data) {
        // Add to cache only on HTTP success, so that we do not cache
        // error response bodies as proper responses to requests.
        Cache.add(url, data);
        var callbacks = loading[url];
        delete loading[url];
        for (var i = 0, il = callbacks.length; i < il; i++) {
          var callback = callbacks[i];
          if (callback.onLoad) callback.onLoad(data);
        }
      }).catch(function (err) {
        // Abort errors and other errors are handled the same

        var callbacks = loading[url];
        if (callbacks === undefined) {
          // When onLoad was called and url was deleted in `loading`
          _this96.manager.itemError(url);
          throw err;
        }
        delete loading[url];
        for (var i = 0, il = callbacks.length; i < il; i++) {
          var callback = callbacks[i];
          if (callback.onError) callback.onError(err);
        }
        _this96.manager.itemError(url);
      }).finally(function () {
        _this96.manager.itemEnd(url);
      });
      this.manager.itemStart(url);
    }
  }, {
    key: "setResponseType",
    value: function setResponseType(value) {
      this.responseType = value;
      return this;
    }
  }, {
    key: "setMimeType",
    value: function setMimeType(value) {
      this.mimeType = value;
      return this;
    }
  }]);
}(Loader);
var AnimationLoader = exports.AnimationLoader = /*#__PURE__*/function (_Loader2) {
  function AnimationLoader(manager) {
    _classCallCheck(this, AnimationLoader);
    return _callSuper(this, AnimationLoader, [manager]);
  }
  _inherits(AnimationLoader, _Loader2);
  return _createClass(AnimationLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }, {
    key: "parse",
    value: function parse(json) {
      var animations = [];
      for (var i = 0; i < json.length; i++) {
        var clip = AnimationClip.parse(json[i]);
        animations.push(clip);
      }
      return animations;
    }
  }]);
}(Loader);
/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */
var CompressedTextureLoader = exports.CompressedTextureLoader = /*#__PURE__*/function (_Loader3) {
  function CompressedTextureLoader(manager) {
    _classCallCheck(this, CompressedTextureLoader);
    return _callSuper(this, CompressedTextureLoader, [manager]);
  }
  _inherits(CompressedTextureLoader, _Loader3);
  return _createClass(CompressedTextureLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var images = [];
      var texture = new CompressedTexture();
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType('arraybuffer');
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      var loaded = 0;
      function loadTexture(i) {
        loader.load(url[i], function (buffer) {
          var texDatas = scope.parse(buffer, true);
          images[i] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };
          loaded += 1;
          if (loaded === 6) {
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.image = images;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }
        }, onProgress, onError);
      }
      if (Array.isArray(url)) {
        for (var i = 0, il = url.length; i < il; ++i) {
          loadTexture(i);
        }
      } else {
        // compressed cubemap texture stored in a single DDS file

        loader.load(url, function (buffer) {
          var texDatas = scope.parse(buffer, true);
          if (texDatas.isCubemap) {
            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
            for (var f = 0; f < faces; f++) {
              images[f] = {
                mipmaps: []
              };
              for (var _i93 = 0; _i93 < texDatas.mipmapCount; _i93++) {
                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i93]);
                images[f].format = texDatas.format;
                images[f].width = texDatas.width;
                images[f].height = texDatas.height;
              }
            }
            texture.image = images;
          } else {
            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;
          }
          if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }, onProgress, onError);
      }
      return texture;
    }
  }]);
}(Loader);
var ImageLoader = exports.ImageLoader = /*#__PURE__*/function (_Loader4) {
  function ImageLoader(manager) {
    _classCallCheck(this, ImageLoader);
    return _callSuper(this, ImageLoader, [manager]);
  }
  _inherits(ImageLoader, _Loader4);
  return _createClass(ImageLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);
      if (cached !== undefined) {
        scope.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      var image = createElementNS('img');
      function onImageLoad() {
        removeEventListeners();
        Cache.add(url, this);
        if (onLoad) onLoad(this);
        scope.manager.itemEnd(url);
      }
      function onImageError(event) {
        removeEventListeners();
        if (onError) onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }
      function removeEventListeners() {
        image.removeEventListener('load', onImageLoad, false);
        image.removeEventListener('error', onImageError, false);
      }
      image.addEventListener('load', onImageLoad, false);
      image.addEventListener('error', onImageError, false);
      if (url.slice(0, 5) !== 'data:') {
        if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
      }
      scope.manager.itemStart(url);
      image.src = url;
      return image;
    }
  }]);
}(Loader);
var CubeTextureLoader = exports.CubeTextureLoader = /*#__PURE__*/function (_Loader5) {
  function CubeTextureLoader(manager) {
    _classCallCheck(this, CubeTextureLoader);
    return _callSuper(this, CubeTextureLoader, [manager]);
  }
  _inherits(CubeTextureLoader, _Loader5);
  return _createClass(CubeTextureLoader, [{
    key: "load",
    value: function load(urls, onLoad, onProgress, onError) {
      var texture = new CubeTexture();
      texture.colorSpace = SRGBColorSpace;
      var loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      var loaded = 0;
      function loadTexture(i) {
        loader.load(urls[i], function (image) {
          texture.images[i] = image;
          loaded++;
          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }
        }, undefined, onError);
      }
      for (var i = 0; i < urls.length; ++i) {
        loadTexture(i);
      }
      return texture;
    }
  }]);
}(Loader);
/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */
var DataTextureLoader = exports.DataTextureLoader = /*#__PURE__*/function (_Loader6) {
  function DataTextureLoader(manager) {
    _classCallCheck(this, DataTextureLoader);
    return _callSuper(this, DataTextureLoader, [manager]);
  }
  _inherits(DataTextureLoader, _Loader6);
  return _createClass(DataTextureLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var texture = new DataTexture();
      var loader = new FileLoader(this.manager);
      loader.setResponseType('arraybuffer');
      loader.setRequestHeader(this.requestHeader);
      loader.setPath(this.path);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function (buffer) {
        var texData;
        try {
          texData = scope.parse(buffer);
        } catch (error) {
          if (onError !== undefined) {
            onError(error);
          } else {
            console.error(error);
            return;
          }
        }
        if (texData.image !== undefined) {
          texture.image = texData.image;
        } else if (texData.data !== undefined) {
          texture.image.width = texData.width;
          texture.image.height = texData.height;
          texture.image.data = texData.data;
        }
        texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
        texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
        texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
        texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
        texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
        if (texData.colorSpace !== undefined) {
          texture.colorSpace = texData.colorSpace;
        }
        if (texData.flipY !== undefined) {
          texture.flipY = texData.flipY;
        }
        if (texData.format !== undefined) {
          texture.format = texData.format;
        }
        if (texData.type !== undefined) {
          texture.type = texData.type;
        }
        if (texData.mipmaps !== undefined) {
          texture.mipmaps = texData.mipmaps;
          texture.minFilter = LinearMipmapLinearFilter; // presumably...
        }
        if (texData.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        if (texData.generateMipmaps !== undefined) {
          texture.generateMipmaps = texData.generateMipmaps;
        }
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture, texData);
      }, onProgress, onError);
      return texture;
    }
  }]);
}(Loader);
var TextureLoader = exports.TextureLoader = /*#__PURE__*/function (_Loader7) {
  function TextureLoader(manager) {
    _classCallCheck(this, TextureLoader);
    return _callSuper(this, TextureLoader, [manager]);
  }
  _inherits(TextureLoader, _Loader7);
  return _createClass(TextureLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var texture = new Texture();
      var loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function (image) {
        texture.image = image;
        texture.needsUpdate = true;
        if (onLoad !== undefined) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  }]);
}(Loader);
var Light = exports.Light = /*#__PURE__*/function (_Object3D11) {
  function Light(color) {
    var _this97;
    var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    _classCallCheck(this, Light);
    _this97 = _callSuper(this, Light);
    _this97.isLight = true;
    _this97.type = 'Light';
    _this97.color = new Color(color);
    _this97.intensity = intensity;
    return _this97;
  }
  _inherits(Light, _Object3D11);
  return _createClass(Light, [{
    key: "dispose",
    value: function dispose() {

      // Empty here in base class; some subclasses override.
    }
  }, {
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(Light, "copy", this, 3)([source, recursive]);
      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _superPropGet(Light, "toJSON", this, 3)([meta]);
      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== undefined) data.object.distance = this.distance;
      if (this.angle !== undefined) data.object.angle = this.angle;
      if (this.decay !== undefined) data.object.decay = this.decay;
      if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
      if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
      if (this.target !== undefined) data.object.target = this.target.uuid;
      return data;
    }
  }]);
}(Object3D);
var HemisphereLight = exports.HemisphereLight = /*#__PURE__*/function (_Light) {
  function HemisphereLight(skyColor, groundColor, intensity) {
    var _this98;
    _classCallCheck(this, HemisphereLight);
    _this98 = _callSuper(this, HemisphereLight, [skyColor, intensity]);
    _this98.isHemisphereLight = true;
    _this98.type = 'HemisphereLight';
    _this98.position.copy(Object3D.DEFAULT_UP);
    _this98.updateMatrix();
    _this98.groundColor = new Color(groundColor);
    return _this98;
  }
  _inherits(HemisphereLight, _Light);
  return _createClass(HemisphereLight, [{
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(HemisphereLight, "copy", this, 3)([source, recursive]);
      this.groundColor.copy(source.groundColor);
      return this;
    }
  }]);
}(Light);
var _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();
var _lightPositionWorld$1 = /*@__PURE__*/new Vector3();
var _lookTarget$1 = /*@__PURE__*/new Vector3();
var LightShadow = /*#__PURE__*/function () {
  function LightShadow(camera) {
    _classCallCheck(this, LightShadow);
    this.camera = camera;
    this.intensity = 1;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [new Vector4(0, 0, 1, 1)];
  }
  return _createClass(LightShadow, [{
    key: "getViewportCount",
    value: function getViewportCount() {
      return this._viewportCount;
    }
  }, {
    key: "getFrustum",
    value: function getFrustum() {
      return this._frustum;
    }
  }, {
    key: "updateMatrices",
    value: function updateMatrices(light) {
      var shadowCamera = this.camera;
      var shadowMatrix = this.matrix;
      _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld$1);
      _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
      shadowCamera.lookAt(_lookTarget$1);
      shadowCamera.updateMatrixWorld();
      _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
      shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
      shadowMatrix.multiply(_projScreenMatrix$1);
    }
  }, {
    key: "getViewport",
    value: function getViewport(viewportIndex) {
      return this._viewports[viewportIndex];
    }
  }, {
    key: "getFrameExtents",
    value: function getFrameExtents() {
      return this._frameExtents;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.map) {
        this.map.dispose();
      }
      if (this.mapPass) {
        this.mapPass.dispose();
      }
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.camera = source.camera.clone();
      this.intensity = source.intensity;
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var object = {};
      if (this.intensity !== 1) object.intensity = this.intensity;
      if (this.bias !== 0) object.bias = this.bias;
      if (this.normalBias !== 0) object.normalBias = this.normalBias;
      if (this.radius !== 1) object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  }]);
}();
var SpotLightShadow = /*#__PURE__*/function (_LightShadow) {
  function SpotLightShadow() {
    var _this99;
    _classCallCheck(this, SpotLightShadow);
    _this99 = _callSuper(this, SpotLightShadow, [new PerspectiveCamera(50, 1, 0.5, 500)]);
    _this99.isSpotLightShadow = true;
    _this99.focus = 1;
    return _this99;
  }
  _inherits(SpotLightShadow, _LightShadow);
  return _createClass(SpotLightShadow, [{
    key: "updateMatrices",
    value: function updateMatrices(light) {
      var camera = this.camera;
      var fov = RAD2DEG * 2 * light.angle * this.focus;
      var aspect = this.mapSize.width / this.mapSize.height;
      var far = light.distance || camera.far;
      if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
        camera.fov = fov;
        camera.aspect = aspect;
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      _superPropGet(SpotLightShadow, "updateMatrices", this, 3)([light]);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(SpotLightShadow, "copy", this, 3)([source]);
      this.focus = source.focus;
      return this;
    }
  }]);
}(LightShadow);
var SpotLight = exports.SpotLight = /*#__PURE__*/function (_Light2) {
  function SpotLight(color, intensity) {
    var _this100;
    var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var angle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI / 3;
    var penumbra = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var decay = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;
    _classCallCheck(this, SpotLight);
    _this100 = _callSuper(this, SpotLight, [color, intensity]);
    _this100.isSpotLight = true;
    _this100.type = 'SpotLight';
    _this100.position.copy(Object3D.DEFAULT_UP);
    _this100.updateMatrix();
    _this100.target = new Object3D();
    _this100.distance = distance;
    _this100.angle = angle;
    _this100.penumbra = penumbra;
    _this100.decay = decay;
    _this100.map = null;
    _this100.shadow = new SpotLightShadow();
    return _this100;
  }
  _inherits(SpotLight, _Light2);
  return _createClass(SpotLight, [{
    key: "power",
    get: function get() {
      // compute the light's luminous power (in lumens) from its intensity (in candela)
      // by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
      return this.intensity * Math.PI;
    },
    set: function set(power) {
      // set the light's intensity (in candela) from the desired luminous power (in lumens)
      this.intensity = power / Math.PI;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(SpotLight, "copy", this, 3)([source, recursive]);
      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  }]);
}(Light);
var _projScreenMatrix = /*@__PURE__*/new Matrix4();
var _lightPositionWorld = /*@__PURE__*/new Vector3();
var _lookTarget = /*@__PURE__*/new Vector3();
var PointLightShadow = /*#__PURE__*/function (_LightShadow2) {
  function PointLightShadow() {
    var _this101;
    _classCallCheck(this, PointLightShadow);
    _this101 = _callSuper(this, PointLightShadow, [new PerspectiveCamera(90, 1, 0.5, 500)]);
    _this101.isPointLightShadow = true;
    _this101._frameExtents = new Vector2(4, 2);
    _this101._viewportCount = 6;
    _this101._viewports = [
    // These viewports map a cube-map onto a 2D texture with the
    // following orientation:
    //
    //  xzXZ
    //   y Y
    //
    // X - Positive x direction
    // x - Negative x direction
    // Y - Positive y direction
    // y - Negative y direction
    // Z - Positive z direction
    // z - Negative z direction

    // positive X
    new Vector4(2, 1, 1, 1),
    // negative X
    new Vector4(0, 1, 1, 1),
    // positive Z
    new Vector4(3, 1, 1, 1),
    // negative Z
    new Vector4(1, 1, 1, 1),
    // positive Y
    new Vector4(3, 0, 1, 1),
    // negative Y
    new Vector4(1, 0, 1, 1)];
    _this101._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
    _this101._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
    return _this101;
  }
  _inherits(PointLightShadow, _LightShadow2);
  return _createClass(PointLightShadow, [{
    key: "updateMatrices",
    value: function updateMatrices(light) {
      var viewportIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var camera = this.camera;
      var shadowMatrix = this.matrix;
      var far = light.distance || camera.far;
      if (far !== camera.far) {
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      camera.position.copy(_lightPositionWorld);
      _lookTarget.copy(camera.position);
      _lookTarget.add(this._cubeDirections[viewportIndex]);
      camera.up.copy(this._cubeUps[viewportIndex]);
      camera.lookAt(_lookTarget);
      camera.updateMatrixWorld();
      shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    }
  }]);
}(LightShadow);
var PointLight = exports.PointLight = /*#__PURE__*/function (_Light3) {
  function PointLight(color, intensity) {
    var _this102;
    var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var decay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;
    _classCallCheck(this, PointLight);
    _this102 = _callSuper(this, PointLight, [color, intensity]);
    _this102.isPointLight = true;
    _this102.type = 'PointLight';
    _this102.distance = distance;
    _this102.decay = decay;
    _this102.shadow = new PointLightShadow();
    return _this102;
  }
  _inherits(PointLight, _Light3);
  return _createClass(PointLight, [{
    key: "power",
    get: function get() {
      // compute the light's luminous power (in lumens) from its intensity (in candela)
      // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
      return this.intensity * 4 * Math.PI;
    },
    set: function set(power) {
      // set the light's intensity (in candela) from the desired luminous power (in lumens)
      this.intensity = power / (4 * Math.PI);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(PointLight, "copy", this, 3)([source, recursive]);
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  }]);
}(Light);
var DirectionalLightShadow = /*#__PURE__*/function (_LightShadow3) {
  function DirectionalLightShadow() {
    var _this103;
    _classCallCheck(this, DirectionalLightShadow);
    _this103 = _callSuper(this, DirectionalLightShadow, [new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)]);
    _this103.isDirectionalLightShadow = true;
    return _this103;
  }
  _inherits(DirectionalLightShadow, _LightShadow3);
  return _createClass(DirectionalLightShadow);
}(LightShadow);
var DirectionalLight = exports.DirectionalLight = /*#__PURE__*/function (_Light4) {
  function DirectionalLight(color, intensity) {
    var _this104;
    _classCallCheck(this, DirectionalLight);
    _this104 = _callSuper(this, DirectionalLight, [color, intensity]);
    _this104.isDirectionalLight = true;
    _this104.type = 'DirectionalLight';
    _this104.position.copy(Object3D.DEFAULT_UP);
    _this104.updateMatrix();
    _this104.target = new Object3D();
    _this104.shadow = new DirectionalLightShadow();
    return _this104;
  }
  _inherits(DirectionalLight, _Light4);
  return _createClass(DirectionalLight, [{
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(DirectionalLight, "copy", this, 3)([source]);
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  }]);
}(Light);
var AmbientLight = exports.AmbientLight = /*#__PURE__*/function (_Light5) {
  function AmbientLight(color, intensity) {
    var _this105;
    _classCallCheck(this, AmbientLight);
    _this105 = _callSuper(this, AmbientLight, [color, intensity]);
    _this105.isAmbientLight = true;
    _this105.type = 'AmbientLight';
    return _this105;
  }
  _inherits(AmbientLight, _Light5);
  return _createClass(AmbientLight);
}(Light);
var RectAreaLight = exports.RectAreaLight = /*#__PURE__*/function (_Light6) {
  function RectAreaLight(color, intensity) {
    var _this106;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
    _classCallCheck(this, RectAreaLight);
    _this106 = _callSuper(this, RectAreaLight, [color, intensity]);
    _this106.isRectAreaLight = true;
    _this106.type = 'RectAreaLight';
    _this106.width = width;
    _this106.height = height;
    return _this106;
  }
  _inherits(RectAreaLight, _Light6);
  return _createClass(RectAreaLight, [{
    key: "power",
    get: function get() {
      // compute the light's luminous power (in lumens) from its intensity (in nits)
      return this.intensity * this.width * this.height * Math.PI;
    },
    set: function set(power) {
      // set the light's intensity (in nits) from the desired luminous power (in lumens)
      this.intensity = power / (this.width * this.height * Math.PI);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(RectAreaLight, "copy", this, 3)([source]);
      this.width = source.width;
      this.height = source.height;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _superPropGet(RectAreaLight, "toJSON", this, 3)([meta]);
      data.object.width = this.width;
      data.object.height = this.height;
      return data;
    }
  }]);
}(Light);
/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */
// 3-band SH defined by 9 coefficients
var SphericalHarmonics3 = exports.SphericalHarmonics3 = /*#__PURE__*/function () {
  function SphericalHarmonics3() {
    _classCallCheck(this, SphericalHarmonics3);
    this.isSphericalHarmonics3 = true;
    this.coefficients = [];
    for (var i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }
  return _createClass(SphericalHarmonics3, [{
    key: "set",
    value: function set(coefficients) {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].copy(coefficients[i]);
      }
      return this;
    }
  }, {
    key: "zero",
    value: function zero() {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].set(0, 0, 0);
      }
      return this;
    }

    // get the radiance in the direction of the normal
    // target is a Vector3
  }, {
    key: "getAt",
    value: function getAt(normal, target) {
      // normal is assumed to be unit length

      var x = normal.x,
        y = normal.y,
        z = normal.z;
      var coeff = this.coefficients;

      // band 0
      target.copy(coeff[0]).multiplyScalar(0.282095);

      // band 1
      target.addScaledVector(coeff[1], 0.488603 * y);
      target.addScaledVector(coeff[2], 0.488603 * z);
      target.addScaledVector(coeff[3], 0.488603 * x);

      // band 2
      target.addScaledVector(coeff[4], 1.092548 * (x * y));
      target.addScaledVector(coeff[5], 1.092548 * (y * z));
      target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
      target.addScaledVector(coeff[7], 1.092548 * (x * z));
      target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
      return target;
    }

    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
    // target is a Vector3
    // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  }, {
    key: "getIrradianceAt",
    value: function getIrradianceAt(normal, target) {
      // normal is assumed to be unit length

      var x = normal.x,
        y = normal.y,
        z = normal.z;
      var coeff = this.coefficients;

      // band 0
      target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095

      // band 1
      target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 *  / 3 ) * 0.488603
      target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
      target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);

      // band 2
      target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // (  / 4 ) * 1.092548
      target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
      target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3
      target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
      target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274

      return target;
    }
  }, {
    key: "add",
    value: function add(sh) {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].add(sh.coefficients[i]);
      }
      return this;
    }
  }, {
    key: "addScaledSH",
    value: function addScaledSH(sh, s) {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].addScaledVector(sh.coefficients[i], s);
      }
      return this;
    }
  }, {
    key: "scale",
    value: function scale(s) {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].multiplyScalar(s);
      }
      return this;
    }
  }, {
    key: "lerp",
    value: function lerp(sh, alpha) {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].lerp(sh.coefficients[i], alpha);
      }
      return this;
    }
  }, {
    key: "equals",
    value: function equals(sh) {
      for (var i = 0; i < 9; i++) {
        if (!this.coefficients[i].equals(sh.coefficients[i])) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "copy",
    value: function copy(sh) {
      return this.set(sh.coefficients);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var coefficients = this.coefficients;
      for (var i = 0; i < 9; i++) {
        coefficients[i].fromArray(array, offset + i * 3);
      }
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var coefficients = this.coefficients;
      for (var i = 0; i < 9; i++) {
        coefficients[i].toArray(array, offset + i * 3);
      }
      return array;
    }

    // evaluate the basis functions
    // shBasis is an Array[ 9 ]
  }], [{
    key: "getBasisAt",
    value: function getBasisAt(normal, shBasis) {
      // normal is assumed to be unit length

      var x = normal.x,
        y = normal.y,
        z = normal.z;

      // band 0
      shBasis[0] = 0.282095;

      // band 1
      shBasis[1] = 0.488603 * y;
      shBasis[2] = 0.488603 * z;
      shBasis[3] = 0.488603 * x;

      // band 2
      shBasis[4] = 1.092548 * x * y;
      shBasis[5] = 1.092548 * y * z;
      shBasis[6] = 0.315392 * (3 * z * z - 1);
      shBasis[7] = 1.092548 * x * z;
      shBasis[8] = 0.546274 * (x * x - y * y);
    }
  }]);
}();
var LightProbe = exports.LightProbe = /*#__PURE__*/function (_Light7) {
  function LightProbe() {
    var _this107;
    var sh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new SphericalHarmonics3();
    var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    _classCallCheck(this, LightProbe);
    _this107 = _callSuper(this, LightProbe, [undefined, intensity]);
    _this107.isLightProbe = true;
    _this107.sh = sh;
    return _this107;
  }
  _inherits(LightProbe, _Light7);
  return _createClass(LightProbe, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(LightProbe, "copy", this, 3)([source]);
      this.sh.copy(source.sh);
      return this;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
      this.sh.fromArray(json.sh);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _superPropGet(LightProbe, "toJSON", this, 3)([meta]);
      data.object.sh = this.sh.toArray();
      return data;
    }
  }]);
}(Light);
var MaterialLoader = exports.MaterialLoader = /*#__PURE__*/function (_Loader8) {
  function MaterialLoader(manager) {
    var _this108;
    _classCallCheck(this, MaterialLoader);
    _this108 = _callSuper(this, MaterialLoader, [manager]);
    _this108.textures = {};
    return _this108;
  }
  _inherits(MaterialLoader, _Loader8);
  return _createClass(MaterialLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }, {
    key: "parse",
    value: function parse(json) {
      var textures = this.textures;
      function getTexture(name) {
        if (textures[name] === undefined) {
          console.warn('THREE.MaterialLoader: Undefined texture', name);
        }
        return textures[name];
      }
      var material = MaterialLoader.createMaterialFromType(json.type);
      if (json.uuid !== undefined) material.uuid = json.uuid;
      if (json.name !== undefined) material.name = json.name;
      if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
      if (json.roughness !== undefined) material.roughness = json.roughness;
      if (json.metalness !== undefined) material.metalness = json.metalness;
      if (json.sheen !== undefined) material.sheen = json.sheen;
      if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);
      if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
      if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
      if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
      if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
      if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
      if (json.shininess !== undefined) material.shininess = json.shininess;
      if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
      if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
      if (json.dispersion !== undefined) material.dispersion = json.dispersion;
      if (json.iridescence !== undefined) material.iridescence = json.iridescence;
      if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;
      if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
      if (json.transmission !== undefined) material.transmission = json.transmission;
      if (json.thickness !== undefined) material.thickness = json.thickness;
      if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
      if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
      if (json.anisotropy !== undefined) material.anisotropy = json.anisotropy;
      if (json.anisotropyRotation !== undefined) material.anisotropyRotation = json.anisotropyRotation;
      if (json.fog !== undefined) material.fog = json.fog;
      if (json.flatShading !== undefined) material.flatShading = json.flatShading;
      if (json.blending !== undefined) material.blending = json.blending;
      if (json.combine !== undefined) material.combine = json.combine;
      if (json.side !== undefined) material.side = json.side;
      if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
      if (json.opacity !== undefined) material.opacity = json.opacity;
      if (json.transparent !== undefined) material.transparent = json.transparent;
      if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
      if (json.alphaHash !== undefined) material.alphaHash = json.alphaHash;
      if (json.depthFunc !== undefined) material.depthFunc = json.depthFunc;
      if (json.depthTest !== undefined) material.depthTest = json.depthTest;
      if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
      if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
      if (json.blendSrc !== undefined) material.blendSrc = json.blendSrc;
      if (json.blendDst !== undefined) material.blendDst = json.blendDst;
      if (json.blendEquation !== undefined) material.blendEquation = json.blendEquation;
      if (json.blendSrcAlpha !== undefined) material.blendSrcAlpha = json.blendSrcAlpha;
      if (json.blendDstAlpha !== undefined) material.blendDstAlpha = json.blendDstAlpha;
      if (json.blendEquationAlpha !== undefined) material.blendEquationAlpha = json.blendEquationAlpha;
      if (json.blendColor !== undefined && material.blendColor !== undefined) material.blendColor.setHex(json.blendColor);
      if (json.blendAlpha !== undefined) material.blendAlpha = json.blendAlpha;
      if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
      if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
      if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
      if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
      if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
      if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
      if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
      if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
      if (json.wireframe !== undefined) material.wireframe = json.wireframe;
      if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
      if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
      if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
      if (json.rotation !== undefined) material.rotation = json.rotation;
      if (json.linewidth !== undefined) material.linewidth = json.linewidth;
      if (json.dashSize !== undefined) material.dashSize = json.dashSize;
      if (json.gapSize !== undefined) material.gapSize = json.gapSize;
      if (json.scale !== undefined) material.scale = json.scale;
      if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
      if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
      if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
      if (json.dithering !== undefined) material.dithering = json.dithering;
      if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
      if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
      if (json.forceSinglePass !== undefined) material.forceSinglePass = json.forceSinglePass;
      if (json.visible !== undefined) material.visible = json.visible;
      if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
      if (json.userData !== undefined) material.userData = json.userData;
      if (json.vertexColors !== undefined) {
        if (typeof json.vertexColors === 'number') {
          material.vertexColors = json.vertexColors > 0 ? true : false;
        } else {
          material.vertexColors = json.vertexColors;
        }
      }

      // Shader Material

      if (json.uniforms !== undefined) {
        for (var name in json.uniforms) {
          var uniform = json.uniforms[name];
          material.uniforms[name] = {};
          switch (uniform.type) {
            case 't':
              material.uniforms[name].value = getTexture(uniform.value);
              break;
            case 'c':
              material.uniforms[name].value = new Color().setHex(uniform.value);
              break;
            case 'v2':
              material.uniforms[name].value = new Vector2().fromArray(uniform.value);
              break;
            case 'v3':
              material.uniforms[name].value = new Vector3().fromArray(uniform.value);
              break;
            case 'v4':
              material.uniforms[name].value = new Vector4().fromArray(uniform.value);
              break;
            case 'm3':
              material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
              break;
            case 'm4':
              material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
              break;
            default:
              material.uniforms[name].value = uniform.value;
          }
        }
      }
      if (json.defines !== undefined) material.defines = json.defines;
      if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
      if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
      if (json.glslVersion !== undefined) material.glslVersion = json.glslVersion;
      if (json.extensions !== undefined) {
        for (var key in json.extensions) {
          material.extensions[key] = json.extensions[key];
        }
      }
      if (json.lights !== undefined) material.lights = json.lights;
      if (json.clipping !== undefined) material.clipping = json.clipping;

      // for PointsMaterial

      if (json.size !== undefined) material.size = json.size;
      if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

      // maps

      if (json.map !== undefined) material.map = getTexture(json.map);
      if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
      if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
      if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
      if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
      if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
      if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
      if (json.normalScale !== undefined) {
        var normalScale = json.normalScale;
        if (Array.isArray(normalScale) === false) {
          // Blender exporter used to export a scalar. See #7459

          normalScale = [normalScale, normalScale];
        }
        material.normalScale = new Vector2().fromArray(normalScale);
      }
      if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
      if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
      if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
      if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
      if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
      if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
      if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
      if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
      if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
      if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
      if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
      if (json.envMapRotation !== undefined) material.envMapRotation.fromArray(json.envMapRotation);
      if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
      if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
      if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
      if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
      if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
      if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
      if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
      if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
      if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
      if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
      if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
      if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
      if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);
      if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
      if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
      if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
      if (json.anisotropyMap !== undefined) material.anisotropyMap = getTexture(json.anisotropyMap);
      if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
      if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
      return material;
    }
  }, {
    key: "setTextures",
    value: function setTextures(value) {
      this.textures = value;
      return this;
    }
  }], [{
    key: "createMaterialFromType",
    value: function createMaterialFromType(type) {
      var materialLib = {
        ShadowMaterial: ShadowMaterial,
        SpriteMaterial: SpriteMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShaderMaterial: ShaderMaterial,
        PointsMaterial: PointsMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshToonMaterial: MeshToonMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshDistanceMaterial: MeshDistanceMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        MeshMatcapMaterial: MeshMatcapMaterial,
        LineDashedMaterial: LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial,
        Material: Material
      };
      return new materialLib[type]();
    }
  }]);
}(Loader);
var LoaderUtils = exports.LoaderUtils = /*#__PURE__*/function () {
  function LoaderUtils() {
    _classCallCheck(this, LoaderUtils);
  }
  return _createClass(LoaderUtils, null, [{
    key: "decodeText",
    value: function decodeText(array) {
      // @deprecated, r165

      console.warn('THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.');
      if (typeof TextDecoder !== 'undefined') {
        return new TextDecoder().decode(array);
      }

      // Avoid the String.fromCharCode.apply(null, array) shortcut, which
      // throws a "maximum call stack size exceeded" error for large arrays.

      var s = '';
      for (var i = 0, il = array.length; i < il; i++) {
        // Implicitly assumes little-endian.
        s += String.fromCharCode(array[i]);
      }
      try {
        // merges multi-byte utf-8 characters.

        return decodeURIComponent(escape(s));
      } catch (e) {
        // see #16358

        return s;
      }
    }
  }, {
    key: "extractUrlBase",
    value: function extractUrlBase(url) {
      var index = url.lastIndexOf('/');
      if (index === -1) return './';
      return url.slice(0, index + 1);
    }
  }, {
    key: "resolveURL",
    value: function resolveURL(url, path) {
      // Invalid URL
      if (typeof url !== 'string' || url === '') return '';

      // Host Relative URL
      if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
        path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
      }

      // Absolute URL http://,https://,//
      if (/^(https?:)?\/\//i.test(url)) return url;

      // Data URI
      if (/^data:.*,.*$/i.test(url)) return url;

      // Blob URL
      if (/^blob:.*$/i.test(url)) return url;

      // Relative URL
      return path + url;
    }
  }]);
}();
var InstancedBufferGeometry = exports.InstancedBufferGeometry = /*#__PURE__*/function (_BufferGeometry16) {
  function InstancedBufferGeometry() {
    var _this109;
    _classCallCheck(this, InstancedBufferGeometry);
    _this109 = _callSuper(this, InstancedBufferGeometry);
    _this109.isInstancedBufferGeometry = true;
    _this109.type = 'InstancedBufferGeometry';
    _this109.instanceCount = Infinity;
    return _this109;
  }
  _inherits(InstancedBufferGeometry, _BufferGeometry16);
  return _createClass(InstancedBufferGeometry, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(InstancedBufferGeometry, "copy", this, 3)([source]);
      this.instanceCount = source.instanceCount;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _superPropGet(InstancedBufferGeometry, "toJSON", this, 3)([]);
      data.instanceCount = this.instanceCount;
      data.isInstancedBufferGeometry = true;
      return data;
    }
  }]);
}(BufferGeometry);
var BufferGeometryLoader = exports.BufferGeometryLoader = /*#__PURE__*/function (_Loader9) {
  function BufferGeometryLoader(manager) {
    _classCallCheck(this, BufferGeometryLoader);
    return _callSuper(this, BufferGeometryLoader, [manager]);
  }
  _inherits(BufferGeometryLoader, _Loader9);
  return _createClass(BufferGeometryLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }, {
    key: "parse",
    value: function parse(json) {
      var interleavedBufferMap = {};
      var arrayBufferMap = {};
      function getInterleavedBuffer(json, uuid) {
        if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
        var interleavedBuffers = json.interleavedBuffers;
        var interleavedBuffer = interleavedBuffers[uuid];
        var buffer = getArrayBuffer(json, interleavedBuffer.buffer);
        var array = getTypedArray(interleavedBuffer.type, buffer);
        var ib = new InterleavedBuffer(array, interleavedBuffer.stride);
        ib.uuid = interleavedBuffer.uuid;
        interleavedBufferMap[uuid] = ib;
        return ib;
      }
      function getArrayBuffer(json, uuid) {
        if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
        var arrayBuffers = json.arrayBuffers;
        var arrayBuffer = arrayBuffers[uuid];
        var ab = new Uint32Array(arrayBuffer).buffer;
        arrayBufferMap[uuid] = ab;
        return ab;
      }
      var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
      var index = json.data.index;
      if (index !== undefined) {
        var typedArray = getTypedArray(index.type, index.array);
        geometry.setIndex(new BufferAttribute(typedArray, 1));
      }
      var attributes = json.data.attributes;
      for (var key in attributes) {
        var attribute = attributes[key];
        var bufferAttribute = void 0;
        if (attribute.isInterleavedBufferAttribute) {
          var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
          bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
        } else {
          var _typedArray = getTypedArray(attribute.type, attribute.array);
          var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
          bufferAttribute = new bufferAttributeConstr(_typedArray, attribute.itemSize, attribute.normalized);
        }
        if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
        if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
        geometry.setAttribute(key, bufferAttribute);
      }
      var morphAttributes = json.data.morphAttributes;
      if (morphAttributes) {
        for (var _key3 in morphAttributes) {
          var attributeArray = morphAttributes[_key3];
          var array = [];
          for (var i = 0, il = attributeArray.length; i < il; i++) {
            var _attribute3 = attributeArray[i];
            var _bufferAttribute = void 0;
            if (_attribute3.isInterleavedBufferAttribute) {
              var _interleavedBuffer = getInterleavedBuffer(json.data, _attribute3.data);
              _bufferAttribute = new InterleavedBufferAttribute(_interleavedBuffer, _attribute3.itemSize, _attribute3.offset, _attribute3.normalized);
            } else {
              var _typedArray2 = getTypedArray(_attribute3.type, _attribute3.array);
              _bufferAttribute = new BufferAttribute(_typedArray2, _attribute3.itemSize, _attribute3.normalized);
            }
            if (_attribute3.name !== undefined) _bufferAttribute.name = _attribute3.name;
            array.push(_bufferAttribute);
          }
          geometry.morphAttributes[_key3] = array;
        }
      }
      var morphTargetsRelative = json.data.morphTargetsRelative;
      if (morphTargetsRelative) {
        geometry.morphTargetsRelative = true;
      }
      var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
      if (groups !== undefined) {
        for (var _i94 = 0, n = groups.length; _i94 !== n; ++_i94) {
          var group = groups[_i94];
          geometry.addGroup(group.start, group.count, group.materialIndex);
        }
      }
      var boundingSphere = json.data.boundingSphere;
      if (boundingSphere !== undefined) {
        var center = new Vector3();
        if (boundingSphere.center !== undefined) {
          center.fromArray(boundingSphere.center);
        }
        geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
      }
      if (json.name) geometry.name = json.name;
      if (json.userData) geometry.userData = json.userData;
      return geometry;
    }
  }]);
}(Loader);
var ObjectLoader = exports.ObjectLoader = /*#__PURE__*/function (_Loader10) {
  function ObjectLoader(manager) {
    _classCallCheck(this, ObjectLoader);
    return _callSuper(this, ObjectLoader, [manager]);
  }
  _inherits(ObjectLoader, _Loader10);
  return _createClass(ObjectLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
      this.resourcePath = this.resourcePath || path;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (text) {
        var json = null;
        try {
          json = JSON.parse(text);
        } catch (error) {
          if (onError !== undefined) onError(error);
          console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
          return;
        }
        var metadata = json.metadata;
        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
          if (onError !== undefined) onError(new Error('THREE.ObjectLoader: Can\'t load ' + url));
          console.error('THREE.ObjectLoader: Can\'t load ' + url);
          return;
        }
        scope.parse(json, onLoad);
      }, onProgress, onError);
    }
  }, {
    key: "loadAsync",
    value: function () {
      var _loadAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(url, onProgress) {
        var scope, path, loader, text, json, metadata;
        return _regeneratorRuntime().wrap(function _callee3$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              scope = this;
              path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
              this.resourcePath = this.resourcePath || path;
              loader = new FileLoader(this.manager);
              loader.setPath(this.path);
              loader.setRequestHeader(this.requestHeader);
              loader.setWithCredentials(this.withCredentials);
              _context10.next = 9;
              return loader.loadAsync(url, onProgress);
            case 9:
              text = _context10.sent;
              json = JSON.parse(text);
              metadata = json.metadata;
              if (!(metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry')) {
                _context10.next = 14;
                break;
              }
              throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
            case 14:
              _context10.next = 16;
              return scope.parseAsync(json);
            case 16:
              return _context10.abrupt("return", _context10.sent);
            case 17:
            case "end":
              return _context10.stop();
          }
        }, _callee3, this);
      }));
      function loadAsync(_x14, _x15) {
        return _loadAsync.apply(this, arguments);
      }
      return loadAsync;
    }()
  }, {
    key: "parse",
    value: function parse(json, onLoad) {
      var animations = this.parseAnimations(json.animations);
      var shapes = this.parseShapes(json.shapes);
      var geometries = this.parseGeometries(json.geometries, shapes);
      var images = this.parseImages(json.images, function () {
        if (onLoad !== undefined) onLoad(object);
      });
      var textures = this.parseTextures(json.textures, images);
      var materials = this.parseMaterials(json.materials, textures);
      var object = this.parseObject(json.object, geometries, materials, textures, animations);
      var skeletons = this.parseSkeletons(json.skeletons, object);
      this.bindSkeletons(object, skeletons);
      this.bindLightTargets(object);

      //

      if (onLoad !== undefined) {
        var hasImages = false;
        for (var uuid in images) {
          if (images[uuid].data instanceof HTMLImageElement) {
            hasImages = true;
            break;
          }
        }
        if (hasImages === false) onLoad(object);
      }
      return object;
    }
  }, {
    key: "parseAsync",
    value: function () {
      var _parseAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(json) {
        var animations, shapes, geometries, images, textures, materials, object, skeletons;
        return _regeneratorRuntime().wrap(function _callee4$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              animations = this.parseAnimations(json.animations);
              shapes = this.parseShapes(json.shapes);
              geometries = this.parseGeometries(json.geometries, shapes);
              _context11.next = 5;
              return this.parseImagesAsync(json.images);
            case 5:
              images = _context11.sent;
              textures = this.parseTextures(json.textures, images);
              materials = this.parseMaterials(json.materials, textures);
              object = this.parseObject(json.object, geometries, materials, textures, animations);
              skeletons = this.parseSkeletons(json.skeletons, object);
              this.bindSkeletons(object, skeletons);
              this.bindLightTargets(object);
              return _context11.abrupt("return", object);
            case 13:
            case "end":
              return _context11.stop();
          }
        }, _callee4, this);
      }));
      function parseAsync(_x16) {
        return _parseAsync.apply(this, arguments);
      }
      return parseAsync;
    }()
  }, {
    key: "parseShapes",
    value: function parseShapes(json) {
      var shapes = {};
      if (json !== undefined) {
        for (var i = 0, l = json.length; i < l; i++) {
          var shape = new Shape().fromJSON(json[i]);
          shapes[shape.uuid] = shape;
        }
      }
      return shapes;
    }
  }, {
    key: "parseSkeletons",
    value: function parseSkeletons(json, object) {
      var skeletons = {};
      var bones = {};

      // generate bone lookup table

      object.traverse(function (child) {
        if (child.isBone) bones[child.uuid] = child;
      });

      // create skeletons

      if (json !== undefined) {
        for (var i = 0, l = json.length; i < l; i++) {
          var skeleton = new Skeleton().fromJSON(json[i], bones);
          skeletons[skeleton.uuid] = skeleton;
        }
      }
      return skeletons;
    }
  }, {
    key: "parseGeometries",
    value: function parseGeometries(json, shapes) {
      var geometries = {};
      if (json !== undefined) {
        var bufferGeometryLoader = new BufferGeometryLoader();
        for (var i = 0, l = json.length; i < l; i++) {
          var geometry = void 0;
          var data = json[i];
          switch (data.type) {
            case 'BufferGeometry':
            case 'InstancedBufferGeometry':
              geometry = bufferGeometryLoader.parse(data);
              break;
            default:
              if (data.type in Geometries) {
                geometry = Geometries[data.type].fromJSON(data, shapes);
              } else {
                console.warn("THREE.ObjectLoader: Unsupported geometry type \"".concat(data.type, "\""));
              }
          }
          geometry.uuid = data.uuid;
          if (data.name !== undefined) geometry.name = data.name;
          if (data.userData !== undefined) geometry.userData = data.userData;
          geometries[data.uuid] = geometry;
        }
      }
      return geometries;
    }
  }, {
    key: "parseMaterials",
    value: function parseMaterials(json, textures) {
      var cache = {}; // MultiMaterial
      var materials = {};
      if (json !== undefined) {
        var loader = new MaterialLoader();
        loader.setTextures(textures);
        for (var i = 0, l = json.length; i < l; i++) {
          var data = json[i];
          if (cache[data.uuid] === undefined) {
            cache[data.uuid] = loader.parse(data);
          }
          materials[data.uuid] = cache[data.uuid];
        }
      }
      return materials;
    }
  }, {
    key: "parseAnimations",
    value: function parseAnimations(json) {
      var animations = {};
      if (json !== undefined) {
        for (var i = 0; i < json.length; i++) {
          var data = json[i];
          var clip = AnimationClip.parse(data);
          animations[clip.uuid] = clip;
        }
      }
      return animations;
    }
  }, {
    key: "parseImages",
    value: function parseImages(json, onLoad) {
      var scope = this;
      var images = {};
      var loader;
      function loadImage(url) {
        scope.manager.itemStart(url);
        return loader.load(url, function () {
          scope.manager.itemEnd(url);
        }, undefined, function () {
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
      }
      function deserializeImage(image) {
        if (typeof image === 'string') {
          var url = image;
          var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
          return loadImage(path);
        } else {
          if (image.data) {
            return {
              data: getTypedArray(image.type, image.data),
              width: image.width,
              height: image.height
            };
          } else {
            return null;
          }
        }
      }
      if (json !== undefined && json.length > 0) {
        var manager = new LoadingManager(onLoad);
        loader = new ImageLoader(manager);
        loader.setCrossOrigin(this.crossOrigin);
        for (var i = 0, il = json.length; i < il; i++) {
          var image = json[i];
          var url = image.url;
          if (Array.isArray(url)) {
            // load array of images e.g CubeTexture

            var imageArray = [];
            for (var j = 0, jl = url.length; j < jl; j++) {
              var currentUrl = url[j];
              var deserializedImage = deserializeImage(currentUrl);
              if (deserializedImage !== null) {
                if (deserializedImage instanceof HTMLImageElement) {
                  imageArray.push(deserializedImage);
                } else {
                  // special case: handle array of data textures for cube textures

                  imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                }
              }
            }
            images[image.uuid] = new Source(imageArray);
          } else {
            // load single image

            var _deserializedImage = deserializeImage(image.url);
            images[image.uuid] = new Source(_deserializedImage);
          }
        }
      }
      return images;
    }
  }, {
    key: "parseImagesAsync",
    value: function () {
      var _parseImagesAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(json) {
        var scope, images, loader, deserializeImage, _deserializeImage, i, il, image, url, imageArray, j, jl, currentUrl, deserializedImage, _deserializedImage2;
        return _regeneratorRuntime().wrap(function _callee6$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _deserializeImage = function _deserializeImage3() {
                _deserializeImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(image) {
                  var _url, path;
                  return _regeneratorRuntime().wrap(function _callee5$(_context12) {
                    while (1) switch (_context12.prev = _context12.next) {
                      case 0:
                        if (!(typeof image === 'string')) {
                          _context12.next = 8;
                          break;
                        }
                        _url = image;
                        path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(_url) ? _url : scope.resourcePath + _url;
                        _context12.next = 5;
                        return loader.loadAsync(path);
                      case 5:
                        return _context12.abrupt("return", _context12.sent);
                      case 8:
                        if (!image.data) {
                          _context12.next = 12;
                          break;
                        }
                        return _context12.abrupt("return", {
                          data: getTypedArray(image.type, image.data),
                          width: image.width,
                          height: image.height
                        });
                      case 12:
                        return _context12.abrupt("return", null);
                      case 13:
                      case "end":
                        return _context12.stop();
                    }
                  }, _callee5);
                }));
                return _deserializeImage.apply(this, arguments);
              };
              deserializeImage = function _deserializeImage2(_x18) {
                return _deserializeImage.apply(this, arguments);
              };
              scope = this;
              images = {};
              if (!(json !== undefined && json.length > 0)) {
                _context13.next = 33;
                break;
              }
              loader = new ImageLoader(this.manager);
              loader.setCrossOrigin(this.crossOrigin);
              i = 0, il = json.length;
            case 8:
              if (!(i < il)) {
                _context13.next = 33;
                break;
              }
              image = json[i];
              url = image.url;
              if (!Array.isArray(url)) {
                _context13.next = 26;
                break;
              }
              // load array of images e.g CubeTexture
              imageArray = [];
              j = 0, jl = url.length;
            case 14:
              if (!(j < jl)) {
                _context13.next = 23;
                break;
              }
              currentUrl = url[j];
              _context13.next = 18;
              return deserializeImage(currentUrl);
            case 18:
              deserializedImage = _context13.sent;
              if (deserializedImage !== null) {
                if (deserializedImage instanceof HTMLImageElement) {
                  imageArray.push(deserializedImage);
                } else {
                  // special case: handle array of data textures for cube textures

                  imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                }
              }
            case 20:
              j++;
              _context13.next = 14;
              break;
            case 23:
              images[image.uuid] = new Source(imageArray);
              _context13.next = 30;
              break;
            case 26:
              _context13.next = 28;
              return deserializeImage(image.url);
            case 28:
              _deserializedImage2 = _context13.sent;
              images[image.uuid] = new Source(_deserializedImage2);
            case 30:
              i++;
              _context13.next = 8;
              break;
            case 33:
              return _context13.abrupt("return", images);
            case 34:
            case "end":
              return _context13.stop();
          }
        }, _callee6, this);
      }));
      function parseImagesAsync(_x17) {
        return _parseImagesAsync.apply(this, arguments);
      }
      return parseImagesAsync;
    }()
  }, {
    key: "parseTextures",
    value: function parseTextures(json, images) {
      function parseConstant(value, type) {
        if (typeof value === 'number') return value;
        console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
        return type[value];
      }
      var textures = {};
      if (json !== undefined) {
        for (var i = 0, l = json.length; i < l; i++) {
          var data = json[i];
          if (data.image === undefined) {
            console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
          }
          if (images[data.image] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined image', data.image);
          }
          var source = images[data.image];
          var image = source.data;
          var texture = void 0;
          if (Array.isArray(image)) {
            texture = new CubeTexture();
            if (image.length === 6) texture.needsUpdate = true;
          } else {
            if (image && image.data) {
              texture = new DataTexture();
            } else {
              texture = new Texture();
            }
            if (image) texture.needsUpdate = true; // textures can have undefined image data
          }
          texture.source = source;
          texture.uuid = data.uuid;
          if (data.name !== undefined) texture.name = data.name;
          if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
          if (data.channel !== undefined) texture.channel = data.channel;
          if (data.offset !== undefined) texture.offset.fromArray(data.offset);
          if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
          if (data.center !== undefined) texture.center.fromArray(data.center);
          if (data.rotation !== undefined) texture.rotation = data.rotation;
          if (data.wrap !== undefined) {
            texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
            texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
          }
          if (data.format !== undefined) texture.format = data.format;
          if (data.internalFormat !== undefined) texture.internalFormat = data.internalFormat;
          if (data.type !== undefined) texture.type = data.type;
          if (data.colorSpace !== undefined) texture.colorSpace = data.colorSpace;
          if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
          if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
          if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
          if (data.flipY !== undefined) texture.flipY = data.flipY;
          if (data.generateMipmaps !== undefined) texture.generateMipmaps = data.generateMipmaps;
          if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
          if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
          if (data.compareFunction !== undefined) texture.compareFunction = data.compareFunction;
          if (data.userData !== undefined) texture.userData = data.userData;
          textures[data.uuid] = texture;
        }
      }
      return textures;
    }
  }, {
    key: "parseObject",
    value: function parseObject(data, geometries, materials, textures, animations) {
      var object;
      function getGeometry(name) {
        if (geometries[name] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined geometry', name);
        }
        return geometries[name];
      }
      function getMaterial(name) {
        if (name === undefined) return undefined;
        if (Array.isArray(name)) {
          var array = [];
          for (var i = 0, l = name.length; i < l; i++) {
            var uuid = name[i];
            if (materials[uuid] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined material', uuid);
            }
            array.push(materials[uuid]);
          }
          return array;
        }
        if (materials[name] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined material', name);
        }
        return materials[name];
      }
      function getTexture(uuid) {
        if (textures[uuid] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined texture', uuid);
        }
        return textures[uuid];
      }
      var geometry, material;
      switch (data.type) {
        case 'Scene':
          object = new Scene();
          if (data.background !== undefined) {
            if (Number.isInteger(data.background)) {
              object.background = new Color(data.background);
            } else {
              object.background = getTexture(data.background);
            }
          }
          if (data.environment !== undefined) {
            object.environment = getTexture(data.environment);
          }
          if (data.fog !== undefined) {
            if (data.fog.type === 'Fog') {
              object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
            } else if (data.fog.type === 'FogExp2') {
              object.fog = new FogExp2(data.fog.color, data.fog.density);
            }
            if (data.fog.name !== '') {
              object.fog.name = data.fog.name;
            }
          }
          if (data.backgroundBlurriness !== undefined) object.backgroundBlurriness = data.backgroundBlurriness;
          if (data.backgroundIntensity !== undefined) object.backgroundIntensity = data.backgroundIntensity;
          if (data.backgroundRotation !== undefined) object.backgroundRotation.fromArray(data.backgroundRotation);
          if (data.environmentIntensity !== undefined) object.environmentIntensity = data.environmentIntensity;
          if (data.environmentRotation !== undefined) object.environmentRotation.fromArray(data.environmentRotation);
          break;
        case 'PerspectiveCamera':
          object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
          if (data.focus !== undefined) object.focus = data.focus;
          if (data.zoom !== undefined) object.zoom = data.zoom;
          if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
          if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
          if (data.view !== undefined) object.view = Object.assign({}, data.view);
          break;
        case 'OrthographicCamera':
          object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
          if (data.zoom !== undefined) object.zoom = data.zoom;
          if (data.view !== undefined) object.view = Object.assign({}, data.view);
          break;
        case 'AmbientLight':
          object = new AmbientLight(data.color, data.intensity);
          break;
        case 'DirectionalLight':
          object = new DirectionalLight(data.color, data.intensity);
          object.target = data.target || '';
          break;
        case 'PointLight':
          object = new PointLight(data.color, data.intensity, data.distance, data.decay);
          break;
        case 'RectAreaLight':
          object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
          break;
        case 'SpotLight':
          object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
          object.target = data.target || '';
          break;
        case 'HemisphereLight':
          object = new HemisphereLight(data.color, data.groundColor, data.intensity);
          break;
        case 'LightProbe':
          object = new LightProbe().fromJSON(data);
          break;
        case 'SkinnedMesh':
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          object = new SkinnedMesh(geometry, material);
          if (data.bindMode !== undefined) object.bindMode = data.bindMode;
          if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
          if (data.skeleton !== undefined) object.skeleton = data.skeleton;
          break;
        case 'Mesh':
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          object = new Mesh(geometry, material);
          break;
        case 'InstancedMesh':
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          var count = data.count;
          var instanceMatrix = data.instanceMatrix;
          var instanceColor = data.instanceColor;
          object = new InstancedMesh(geometry, material, count);
          object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
          if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
          break;
        case 'BatchedMesh':
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          object = new BatchedMesh(data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material);
          object.geometry = geometry;
          object.perObjectFrustumCulled = data.perObjectFrustumCulled;
          object.sortObjects = data.sortObjects;
          object._drawRanges = data.drawRanges;
          object._reservedRanges = data.reservedRanges;
          object._visibility = data.visibility;
          object._active = data.active;
          object._bounds = data.bounds.map(function (bound) {
            var box = new Box3();
            box.min.fromArray(bound.boxMin);
            box.max.fromArray(bound.boxMax);
            var sphere = new Sphere();
            sphere.radius = bound.sphereRadius;
            sphere.center.fromArray(bound.sphereCenter);
            return {
              boxInitialized: bound.boxInitialized,
              box: box,
              sphereInitialized: bound.sphereInitialized,
              sphere: sphere
            };
          });
          object._maxInstanceCount = data.maxInstanceCount;
          object._maxVertexCount = data.maxVertexCount;
          object._maxIndexCount = data.maxIndexCount;
          object._geometryInitialized = data.geometryInitialized;
          object._geometryCount = data.geometryCount;
          object._matricesTexture = getTexture(data.matricesTexture.uuid);
          if (data.colorsTexture !== undefined) object._colorsTexture = getTexture(data.colorsTexture.uuid);
          break;
        case 'LOD':
          object = new LOD();
          break;
        case 'Line':
          object = new Line(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case 'LineLoop':
          object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case 'LineSegments':
          object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case 'PointCloud':
        case 'Points':
          object = new Points(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case 'Sprite':
          object = new Sprite(getMaterial(data.material));
          break;
        case 'Group':
          object = new Group();
          break;
        case 'Bone':
          object = new Bone();
          break;
        default:
          object = new Object3D();
      }
      object.uuid = data.uuid;
      if (data.name !== undefined) object.name = data.name;
      if (data.matrix !== undefined) {
        object.matrix.fromArray(data.matrix);
        if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
        if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        if (data.position !== undefined) object.position.fromArray(data.position);
        if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
        if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
        if (data.scale !== undefined) object.scale.fromArray(data.scale);
      }
      if (data.up !== undefined) object.up.fromArray(data.up);
      if (data.castShadow !== undefined) object.castShadow = data.castShadow;
      if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
      if (data.shadow) {
        if (data.shadow.intensity !== undefined) object.shadow.intensity = data.shadow.intensity;
        if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
        if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
        if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
        if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
        if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
      }
      if (data.visible !== undefined) object.visible = data.visible;
      if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
      if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
      if (data.userData !== undefined) object.userData = data.userData;
      if (data.layers !== undefined) object.layers.mask = data.layers;
      if (data.children !== undefined) {
        var children = data.children;
        for (var i = 0; i < children.length; i++) {
          object.add(this.parseObject(children[i], geometries, materials, textures, animations));
        }
      }
      if (data.animations !== undefined) {
        var objectAnimations = data.animations;
        for (var _i95 = 0; _i95 < objectAnimations.length; _i95++) {
          var uuid = objectAnimations[_i95];
          object.animations.push(animations[uuid]);
        }
      }
      if (data.type === 'LOD') {
        if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
        var levels = data.levels;
        for (var l = 0; l < levels.length; l++) {
          var level = levels[l];
          var child = object.getObjectByProperty('uuid', level.object);
          if (child !== undefined) {
            object.addLevel(child, level.distance, level.hysteresis);
          }
        }
      }
      return object;
    }
  }, {
    key: "bindSkeletons",
    value: function bindSkeletons(object, skeletons) {
      if (Object.keys(skeletons).length === 0) return;
      object.traverse(function (child) {
        if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
          var skeleton = skeletons[child.skeleton];
          if (skeleton === undefined) {
            console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
          } else {
            child.bind(skeleton, child.bindMatrix);
          }
        }
      });
    }
  }, {
    key: "bindLightTargets",
    value: function bindLightTargets(object) {
      object.traverse(function (child) {
        if (child.isDirectionalLight || child.isSpotLight) {
          var uuid = child.target;
          var target = object.getObjectByProperty('uuid', uuid);
          if (target !== undefined) {
            child.target = target;
          } else {
            child.target = new Object3D();
          }
        }
      });
    }
  }]);
}(Loader);
var TEXTURE_MAPPING = {
  UVMapping: UVMapping,
  CubeReflectionMapping: CubeReflectionMapping,
  CubeRefractionMapping: CubeRefractionMapping,
  EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  CubeUVReflectionMapping: CubeUVReflectionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping: RepeatWrapping,
  ClampToEdgeWrapping: ClampToEdgeWrapping,
  MirroredRepeatWrapping: MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter: NearestFilter,
  NearestMipmapNearestFilter: NearestMipmapNearestFilter,
  NearestMipmapLinearFilter: NearestMipmapLinearFilter,
  LinearFilter: LinearFilter,
  LinearMipmapNearestFilter: LinearMipmapNearestFilter,
  LinearMipmapLinearFilter: LinearMipmapLinearFilter
};
var ImageBitmapLoader = exports.ImageBitmapLoader = /*#__PURE__*/function (_Loader11) {
  function ImageBitmapLoader(manager) {
    var _this110;
    _classCallCheck(this, ImageBitmapLoader);
    _this110 = _callSuper(this, ImageBitmapLoader, [manager]);
    _this110.isImageBitmapLoader = true;
    if (typeof createImageBitmap === 'undefined') {
      console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
    }
    if (typeof fetch === 'undefined') {
      console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
    }
    _this110.options = {
      premultiplyAlpha: 'none'
    };
    return _this110;
  }
  _inherits(ImageBitmapLoader, _Loader11);
  return _createClass(ImageBitmapLoader, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      return this;
    }
  }, {
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      if (url === undefined) url = '';
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);
      if (cached !== undefined) {
        scope.manager.itemStart(url);

        // If cached is a promise, wait for it to resolve
        if (cached.then) {
          cached.then(function (imageBitmap) {
            if (onLoad) onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          }).catch(function (e) {
            if (onError) onError(e);
          });
          return;
        }

        // If cached is not a promise (i.e., it's already an imageBitmap)
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      var fetchOptions = {};
      fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
      fetchOptions.headers = this.requestHeader;
      var promise = fetch(url, fetchOptions).then(function (res) {
        return res.blob();
      }).then(function (blob) {
        return createImageBitmap(blob, Object.assign(scope.options, {
          colorSpaceConversion: 'none'
        }));
      }).then(function (imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad) onLoad(imageBitmap);
        scope.manager.itemEnd(url);
        return imageBitmap;
      }).catch(function (e) {
        if (onError) onError(e);
        Cache.remove(url);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
      Cache.add(url, promise);
      scope.manager.itemStart(url);
    }
  }]);
}(Loader);
var _context;
var AudioContext = exports.AudioContext = /*#__PURE__*/function () {
  function AudioContext() {
    _classCallCheck(this, AudioContext);
  }
  return _createClass(AudioContext, null, [{
    key: "getContext",
    value: function getContext() {
      if (_context === undefined) {
        _context = new (window.AudioContext || window.webkitAudioContext)();
      }
      return _context;
    }
  }, {
    key: "setContext",
    value: function setContext(value) {
      _context = value;
    }
  }]);
}();
var AudioLoader = exports.AudioLoader = /*#__PURE__*/function (_Loader12) {
  function AudioLoader(manager) {
    _classCallCheck(this, AudioLoader);
    return _callSuper(this, AudioLoader, [manager]);
  }
  _inherits(AudioLoader, _Loader12);
  return _createClass(AudioLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(this.manager);
      loader.setResponseType('arraybuffer');
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (buffer) {
        try {
          // Create a copy of the buffer. The `decodeAudioData` method
          // detaches the buffer when complete, preventing reuse.
          var bufferCopy = buffer.slice(0);
          var context = AudioContext.getContext();
          context.decodeAudioData(bufferCopy, function (audioBuffer) {
            onLoad(audioBuffer);
          }).catch(handleError);
        } catch (e) {
          handleError(e);
        }
      }, onProgress, onError);
      function handleError(e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }
  }]);
}(Loader);
var _eyeRight = /*@__PURE__*/new Matrix4();
var _eyeLeft = /*@__PURE__*/new Matrix4();
var _projectionMatrix = /*@__PURE__*/new Matrix4();
var StereoCamera = exports.StereoCamera = /*#__PURE__*/function () {
  function StereoCamera() {
    _classCallCheck(this, StereoCamera);
    this.type = 'StereoCamera';
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  return _createClass(StereoCamera, [{
    key: "update",
    value: function update(camera) {
      var cache = this._cache;
      var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
      if (needsUpdate) {
        cache.focus = camera.focus;
        cache.fov = camera.fov;
        cache.aspect = camera.aspect * this.aspect;
        cache.near = camera.near;
        cache.far = camera.far;
        cache.zoom = camera.zoom;
        cache.eyeSep = this.eyeSep;

        // Off-axis stereoscopic effect based on
        // http://paulbourke.net/stereographics/stereorender/

        _projectionMatrix.copy(camera.projectionMatrix);
        var eyeSepHalf = cache.eyeSep / 2;
        var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
        var ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
        var xmin, xmax;

        // translate xOffset

        _eyeLeft.elements[12] = -eyeSepHalf;
        _eyeRight.elements[12] = eyeSepHalf;

        // for left eye

        xmin = -ymax * cache.aspect + eyeSepOnProjection;
        xmax = ymax * cache.aspect + eyeSepOnProjection;
        _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
        _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraL.projectionMatrix.copy(_projectionMatrix);

        // for right eye

        xmin = -ymax * cache.aspect - eyeSepOnProjection;
        xmax = ymax * cache.aspect - eyeSepOnProjection;
        _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
        _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraR.projectionMatrix.copy(_projectionMatrix);
      }
      this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
      this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
    }
  }]);
}();
var Clock = exports.Clock = /*#__PURE__*/function () {
  function Clock() {
    var autoStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    _classCallCheck(this, Clock);
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  return _createClass(Clock, [{
    key: "start",
    value: function start() {
      this.startTime = now();
      this.oldTime = this.startTime;
      this.elapsedTime = 0;
      this.running = true;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.getElapsedTime();
      this.running = false;
      this.autoStart = false;
    }
  }, {
    key: "getElapsedTime",
    value: function getElapsedTime() {
      this.getDelta();
      return this.elapsedTime;
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      var diff = 0;
      if (this.autoStart && !this.running) {
        this.start();
        return 0;
      }
      if (this.running) {
        var newTime = now();
        diff = (newTime - this.oldTime) / 1000;
        this.oldTime = newTime;
        this.elapsedTime += diff;
      }
      return diff;
    }
  }]);
}();
function now() {
  return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
}
var _position$1 = /*@__PURE__*/new Vector3();
var _quaternion$1 = /*@__PURE__*/new Quaternion();
var _scale$1 = /*@__PURE__*/new Vector3();
var _orientation$1 = /*@__PURE__*/new Vector3();
var AudioListener = exports.AudioListener = /*#__PURE__*/function (_Object3D12) {
  function AudioListener() {
    var _this111;
    _classCallCheck(this, AudioListener);
    _this111 = _callSuper(this, AudioListener);
    _this111.type = 'AudioListener';
    _this111.context = AudioContext.getContext();
    _this111.gain = _this111.context.createGain();
    _this111.gain.connect(_this111.context.destination);
    _this111.filter = null;
    _this111.timeDelta = 0;

    // private

    _this111._clock = new Clock();
    return _this111;
  }
  _inherits(AudioListener, _Object3D12);
  return _createClass(AudioListener, [{
    key: "getInput",
    value: function getInput() {
      return this.gain;
    }
  }, {
    key: "removeFilter",
    value: function removeFilter() {
      if (this.filter !== null) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
        this.gain.connect(this.context.destination);
        this.filter = null;
      }
      return this;
    }
  }, {
    key: "getFilter",
    value: function getFilter() {
      return this.filter;
    }
  }, {
    key: "setFilter",
    value: function setFilter(value) {
      if (this.filter !== null) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
      } else {
        this.gain.disconnect(this.context.destination);
      }
      this.filter = value;
      this.gain.connect(this.filter);
      this.filter.connect(this.context.destination);
      return this;
    }
  }, {
    key: "getMasterVolume",
    value: function getMasterVolume() {
      return this.gain.gain.value;
    }
  }, {
    key: "setMasterVolume",
    value: function setMasterVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      _superPropGet(AudioListener, "updateMatrixWorld", this, 3)([force]);
      var listener = this.context.listener;
      var up = this.up;
      this.timeDelta = this._clock.getDelta();
      this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
      _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
      if (listener.positionX) {
        // code path for Chrome (see #14393)

        var endTime = this.context.currentTime + this.timeDelta;
        listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
        listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
        listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
        listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
        listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
        listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
        listener.upX.linearRampToValueAtTime(up.x, endTime);
        listener.upY.linearRampToValueAtTime(up.y, endTime);
        listener.upZ.linearRampToValueAtTime(up.z, endTime);
      } else {
        listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
        listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
      }
    }
  }]);
}(Object3D);
var Audio = exports.Audio = /*#__PURE__*/function (_Object3D13) {
  function Audio(listener) {
    var _this112;
    _classCallCheck(this, Audio);
    _this112 = _callSuper(this, Audio);
    _this112.type = 'Audio';
    _this112.listener = listener;
    _this112.context = listener.context;
    _this112.gain = _this112.context.createGain();
    _this112.gain.connect(listener.getInput());
    _this112.autoplay = false;
    _this112.buffer = null;
    _this112.detune = 0;
    _this112.loop = false;
    _this112.loopStart = 0;
    _this112.loopEnd = 0;
    _this112.offset = 0;
    _this112.duration = undefined;
    _this112.playbackRate = 1;
    _this112.isPlaying = false;
    _this112.hasPlaybackControl = true;
    _this112.source = null;
    _this112.sourceType = 'empty';
    _this112._startedAt = 0;
    _this112._progress = 0;
    _this112._connected = false;
    _this112.filters = [];
    return _this112;
  }
  _inherits(Audio, _Object3D13);
  return _createClass(Audio, [{
    key: "getOutput",
    value: function getOutput() {
      return this.gain;
    }
  }, {
    key: "setNodeSource",
    value: function setNodeSource(audioNode) {
      this.hasPlaybackControl = false;
      this.sourceType = 'audioNode';
      this.source = audioNode;
      this.connect();
      return this;
    }
  }, {
    key: "setMediaElementSource",
    value: function setMediaElementSource(mediaElement) {
      this.hasPlaybackControl = false;
      this.sourceType = 'mediaNode';
      this.source = this.context.createMediaElementSource(mediaElement);
      this.connect();
      return this;
    }
  }, {
    key: "setMediaStreamSource",
    value: function setMediaStreamSource(mediaStream) {
      this.hasPlaybackControl = false;
      this.sourceType = 'mediaStreamNode';
      this.source = this.context.createMediaStreamSource(mediaStream);
      this.connect();
      return this;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(audioBuffer) {
      this.buffer = audioBuffer;
      this.sourceType = 'buffer';
      if (this.autoplay) this.play();
      return this;
    }
  }, {
    key: "play",
    value: function play() {
      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (this.isPlaying === true) {
        console.warn('THREE.Audio: Audio is already playing.');
        return;
      }
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }
      this._startedAt = this.context.currentTime + delay;
      var source = this.context.createBufferSource();
      source.buffer = this.buffer;
      source.loop = this.loop;
      source.loopStart = this.loopStart;
      source.loopEnd = this.loopEnd;
      source.onended = this.onEnded.bind(this);
      source.start(this._startedAt, this._progress + this.offset, this.duration);
      this.isPlaying = true;
      this.source = source;
      this.setDetune(this.detune);
      this.setPlaybackRate(this.playbackRate);
      return this.connect();
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }
      if (this.isPlaying === true) {
        // update current progress

        this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
        if (this.loop === true) {
          // ensure _progress does not exceed duration with looped audios

          this._progress = this._progress % (this.duration || this.buffer.duration);
        }
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
      }
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }
      this._progress = 0;
      if (this.source !== null) {
        this.source.stop();
        this.source.onended = null;
      }
      this.isPlaying = false;
      return this;
    }
  }, {
    key: "connect",
    value: function connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (var i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].connect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else {
        this.source.connect(this.getOutput());
      }
      this._connected = true;
      return this;
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this._connected === false) {
        return;
      }
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (var i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].disconnect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else {
        this.source.disconnect(this.getOutput());
      }
      this._connected = false;
      return this;
    }
  }, {
    key: "getFilters",
    value: function getFilters() {
      return this.filters;
    }
  }, {
    key: "setFilters",
    value: function setFilters(value) {
      if (!value) value = [];
      if (this._connected === true) {
        this.disconnect();
        this.filters = value.slice();
        this.connect();
      } else {
        this.filters = value.slice();
      }
      return this;
    }
  }, {
    key: "setDetune",
    value: function setDetune(value) {
      this.detune = value;
      if (this.isPlaying === true && this.source.detune !== undefined) {
        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
      }
      return this;
    }
  }, {
    key: "getDetune",
    value: function getDetune() {
      return this.detune;
    }
  }, {
    key: "getFilter",
    value: function getFilter() {
      return this.getFilters()[0];
    }
  }, {
    key: "setFilter",
    value: function setFilter(filter) {
      return this.setFilters(filter ? [filter] : []);
    }
  }, {
    key: "setPlaybackRate",
    value: function setPlaybackRate(value) {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }
      this.playbackRate = value;
      if (this.isPlaying === true) {
        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
      }
      return this;
    }
  }, {
    key: "getPlaybackRate",
    value: function getPlaybackRate() {
      return this.playbackRate;
    }
  }, {
    key: "onEnded",
    value: function onEnded() {
      this.isPlaying = false;
    }
  }, {
    key: "getLoop",
    value: function getLoop() {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return false;
      }
      return this.loop;
    }
  }, {
    key: "setLoop",
    value: function setLoop(value) {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }
      this.loop = value;
      if (this.isPlaying === true) {
        this.source.loop = this.loop;
      }
      return this;
    }
  }, {
    key: "setLoopStart",
    value: function setLoopStart(value) {
      this.loopStart = value;
      return this;
    }
  }, {
    key: "setLoopEnd",
    value: function setLoopEnd(value) {
      this.loopEnd = value;
      return this;
    }
  }, {
    key: "getVolume",
    value: function getVolume() {
      return this.gain.gain.value;
    }
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  }]);
}(Object3D);
var _position = /*@__PURE__*/new Vector3();
var _quaternion = /*@__PURE__*/new Quaternion();
var _scale = /*@__PURE__*/new Vector3();
var _orientation = /*@__PURE__*/new Vector3();
var PositionalAudio = exports.PositionalAudio = /*#__PURE__*/function (_Audio) {
  function PositionalAudio(listener) {
    var _this113;
    _classCallCheck(this, PositionalAudio);
    _this113 = _callSuper(this, PositionalAudio, [listener]);
    _this113.panner = _this113.context.createPanner();
    _this113.panner.panningModel = 'HRTF';
    _this113.panner.connect(_this113.gain);
    return _this113;
  }
  _inherits(PositionalAudio, _Audio);
  return _createClass(PositionalAudio, [{
    key: "connect",
    value: function connect() {
      _superPropGet(PositionalAudio, "connect", this, 3)([]);
      this.panner.connect(this.gain);
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      _superPropGet(PositionalAudio, "disconnect", this, 3)([]);
      this.panner.disconnect(this.gain);
    }
  }, {
    key: "getOutput",
    value: function getOutput() {
      return this.panner;
    }
  }, {
    key: "getRefDistance",
    value: function getRefDistance() {
      return this.panner.refDistance;
    }
  }, {
    key: "setRefDistance",
    value: function setRefDistance(value) {
      this.panner.refDistance = value;
      return this;
    }
  }, {
    key: "getRolloffFactor",
    value: function getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
  }, {
    key: "setRolloffFactor",
    value: function setRolloffFactor(value) {
      this.panner.rolloffFactor = value;
      return this;
    }
  }, {
    key: "getDistanceModel",
    value: function getDistanceModel() {
      return this.panner.distanceModel;
    }
  }, {
    key: "setDistanceModel",
    value: function setDistanceModel(value) {
      this.panner.distanceModel = value;
      return this;
    }
  }, {
    key: "getMaxDistance",
    value: function getMaxDistance() {
      return this.panner.maxDistance;
    }
  }, {
    key: "setMaxDistance",
    value: function setMaxDistance(value) {
      this.panner.maxDistance = value;
      return this;
    }
  }, {
    key: "setDirectionalCone",
    value: function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
      this.panner.coneInnerAngle = coneInnerAngle;
      this.panner.coneOuterAngle = coneOuterAngle;
      this.panner.coneOuterGain = coneOuterGain;
      return this;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      _superPropGet(PositionalAudio, "updateMatrixWorld", this, 3)([force]);
      if (this.hasPlaybackControl === true && this.isPlaying === false) return;
      this.matrixWorld.decompose(_position, _quaternion, _scale);
      _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
      var panner = this.panner;
      if (panner.positionX) {
        // code path for Chrome and Firefox (see #14393)

        var endTime = this.context.currentTime + this.listener.timeDelta;
        panner.positionX.linearRampToValueAtTime(_position.x, endTime);
        panner.positionY.linearRampToValueAtTime(_position.y, endTime);
        panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
        panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
        panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
        panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
      } else {
        panner.setPosition(_position.x, _position.y, _position.z);
        panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
      }
    }
  }]);
}(Audio);
var AudioAnalyser = exports.AudioAnalyser = /*#__PURE__*/function () {
  function AudioAnalyser(audio) {
    var fftSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2048;
    _classCallCheck(this, AudioAnalyser);
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  return _createClass(AudioAnalyser, [{
    key: "getFrequencyData",
    value: function getFrequencyData() {
      this.analyser.getByteFrequencyData(this.data);
      return this.data;
    }
  }, {
    key: "getAverageFrequency",
    value: function getAverageFrequency() {
      var value = 0;
      var data = this.getFrequencyData();
      for (var i = 0; i < data.length; i++) {
        value += data[i];
      }
      return value / data.length;
    }
  }]);
}();
var PropertyMixer = exports.PropertyMixer = /*#__PURE__*/function () {
  function PropertyMixer(binding, typeName, valueSize) {
    _classCallCheck(this, PropertyMixer);
    this.binding = binding;
    this.valueSize = valueSize;
    var mixFunction, mixFunctionAdditive, setIdentity;

    // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
    //
    // interpolators can use .buffer as their .result
    // the data then goes to 'incoming'
    //
    // 'accu0' and 'accu1' are used frame-interleaved for
    // the cumulative result and are compared to detect
    // changes
    //
    // 'orig' stores the original state of the property
    //
    // 'add' is used for additive cumulative results
    //
    // 'work' is optional and is only present for quaternion types. It is used
    // to store intermediate quaternion multiplication results

    switch (typeName) {
      case 'quaternion':
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case 'string':
      case 'bool':
        mixFunction = this._select;

        // Use the regular mix function and for additive on these types,
        // additive is not relevant for non-numeric types
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }

  // accumulate data in the 'incoming' region into 'accu<i>'
  return _createClass(PropertyMixer, [{
    key: "accumulate",
    value: function accumulate(accuIndex, weight) {
      // note: happily accumulating nothing when weight = 0, the caller knows
      // the weight and shouldn't have made the call in the first place

      var buffer = this.buffer,
        stride = this.valueSize,
        offset = accuIndex * stride + stride;
      var currentWeight = this.cumulativeWeight;
      if (currentWeight === 0) {
        // accuN := incoming * weight

        for (var i = 0; i !== stride; ++i) {
          buffer[offset + i] = buffer[i];
        }
        currentWeight = weight;
      } else {
        // accuN := accuN + incoming * weight

        currentWeight += weight;
        var mix = weight / currentWeight;
        this._mixBufferRegion(buffer, offset, 0, mix, stride);
      }
      this.cumulativeWeight = currentWeight;
    }

    // accumulate data in the 'incoming' region into 'add'
  }, {
    key: "accumulateAdditive",
    value: function accumulateAdditive(weight) {
      var buffer = this.buffer,
        stride = this.valueSize,
        offset = stride * this._addIndex;
      if (this.cumulativeWeightAdditive === 0) {
        // add = identity

        this._setIdentity();
      }

      // add := add + incoming * weight

      this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
      this.cumulativeWeightAdditive += weight;
    }

    // apply the state of 'accu<i>' to the binding when accus differ
  }, {
    key: "apply",
    value: function apply(accuIndex) {
      var stride = this.valueSize,
        buffer = this.buffer,
        offset = accuIndex * stride + stride,
        weight = this.cumulativeWeight,
        weightAdditive = this.cumulativeWeightAdditive,
        binding = this.binding;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      if (weight < 1) {
        // accuN := accuN + original * ( 1 - cumulativeWeight )

        var originalValueOffset = stride * this._origIndex;
        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
      }
      if (weightAdditive > 0) {
        // accuN := accuN + additive accuN

        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
      }
      for (var i = stride, _e3 = stride + stride; i !== _e3; ++i) {
        if (buffer[i] !== buffer[i + stride]) {
          // value has changed -> update scene graph

          binding.setValue(buffer, offset);
          break;
        }
      }
    }

    // remember the state of the bound property and copy it to both accus
  }, {
    key: "saveOriginalState",
    value: function saveOriginalState() {
      var binding = this.binding;
      var buffer = this.buffer,
        stride = this.valueSize,
        originalValueOffset = stride * this._origIndex;
      binding.getValue(buffer, originalValueOffset);

      // accu[0..1] := orig -- initially detect changes against the original
      for (var i = stride, _e4 = originalValueOffset; i !== _e4; ++i) {
        buffer[i] = buffer[originalValueOffset + i % stride];
      }

      // Add to identity for additive
      this._setIdentity();
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
    }

    // apply the state previously taken via 'saveOriginalState' to the binding
  }, {
    key: "restoreOriginalState",
    value: function restoreOriginalState() {
      var originalValueOffset = this.valueSize * 3;
      this.binding.setValue(this.buffer, originalValueOffset);
    }
  }, {
    key: "_setAdditiveIdentityNumeric",
    value: function _setAdditiveIdentityNumeric() {
      var startIndex = this._addIndex * this.valueSize;
      var endIndex = startIndex + this.valueSize;
      for (var i = startIndex; i < endIndex; i++) {
        this.buffer[i] = 0;
      }
    }
  }, {
    key: "_setAdditiveIdentityQuaternion",
    value: function _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric();
      this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
  }, {
    key: "_setAdditiveIdentityOther",
    value: function _setAdditiveIdentityOther() {
      var startIndex = this._origIndex * this.valueSize;
      var targetIndex = this._addIndex * this.valueSize;
      for (var i = 0; i < this.valueSize; i++) {
        this.buffer[targetIndex + i] = this.buffer[startIndex + i];
      }
    }

    // mix functions
  }, {
    key: "_select",
    value: function _select(buffer, dstOffset, srcOffset, t, stride) {
      if (t >= 0.5) {
        for (var i = 0; i !== stride; ++i) {
          buffer[dstOffset + i] = buffer[srcOffset + i];
        }
      }
    }
  }, {
    key: "_slerp",
    value: function _slerp(buffer, dstOffset, srcOffset, t) {
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    }
  }, {
    key: "_slerpAdditive",
    value: function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
      var workOffset = this._workIndex * stride;

      // Store result in intermediate buffer offset
      Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);

      // Slerp to the intermediate result
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    }
  }, {
    key: "_lerp",
    value: function _lerp(buffer, dstOffset, srcOffset, t, stride) {
      var s = 1 - t;
      for (var i = 0; i !== stride; ++i) {
        var j = dstOffset + i;
        buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
      }
    }
  }, {
    key: "_lerpAdditive",
    value: function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
      for (var i = 0; i !== stride; ++i) {
        var j = dstOffset + i;
        buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
      }
    }
  }]);
}(); // Characters [].:/ are reserved for track binding syntax.
var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
var _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
var _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
var _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
var _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
var _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
var _supportedObjectNames = ['material', 'materials', 'bones', 'map'];
var Composite = /*#__PURE__*/function () {
  function Composite(targetGroup, path, optionalParsedPath) {
    _classCallCheck(this, Composite);
    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  return _createClass(Composite, [{
    key: "getValue",
    value: function getValue(array, offset) {
      this.bind(); // bind all binding

      var firstValidIndex = this._targetGroup.nCachedObjects_,
        binding = this._bindings[firstValidIndex];

      // and only call .getValue on the first
      if (binding !== undefined) binding.getValue(array, offset);
    }
  }, {
    key: "setValue",
    value: function setValue(array, offset) {
      var bindings = this._bindings;
      for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].setValue(array, offset);
      }
    }
  }, {
    key: "bind",
    value: function bind() {
      var bindings = this._bindings;
      for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].bind();
      }
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var bindings = this._bindings;
      for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].unbind();
      }
    }
  }]);
}(); // Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
var PropertyBinding = exports.PropertyBinding = /*#__PURE__*/function () {
  function PropertyBinding(rootNode, path, parsedPath) {
    _classCallCheck(this, PropertyBinding);
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;

    // initial state of these methods that calls 'bind'
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  return _createClass(PropertyBinding, [{
    key: "_getValue_unavailable",
    value:
    // these are used to "bind" a nonexistent property
    function _getValue_unavailable() {}
  }, {
    key: "_setValue_unavailable",
    value: function _setValue_unavailable() {}

    // Getters
  }, {
    key: "_getValue_direct",
    value: function _getValue_direct(buffer, offset) {
      buffer[offset] = this.targetObject[this.propertyName];
    }
  }, {
    key: "_getValue_array",
    value: function _getValue_array(buffer, offset) {
      var source = this.resolvedProperty;
      for (var i = 0, n = source.length; i !== n; ++i) {
        buffer[offset++] = source[i];
      }
    }
  }, {
    key: "_getValue_arrayElement",
    value: function _getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }
  }, {
    key: "_getValue_toArray",
    value: function _getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }

    // Direct
  }, {
    key: "_setValue_direct",
    value: function _setValue_direct(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
    }
  }, {
    key: "_setValue_direct_setNeedsUpdate",
    value: function _setValue_direct_setNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
  }, {
    key: "_setValue_direct_setMatrixWorldNeedsUpdate",
    value: function _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }

    // EntireArray
  }, {
    key: "_setValue_array",
    value: function _setValue_array(buffer, offset) {
      var dest = this.resolvedProperty;
      for (var i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
    }
  }, {
    key: "_setValue_array_setNeedsUpdate",
    value: function _setValue_array_setNeedsUpdate(buffer, offset) {
      var dest = this.resolvedProperty;
      for (var i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
      this.targetObject.needsUpdate = true;
    }
  }, {
    key: "_setValue_array_setMatrixWorldNeedsUpdate",
    value: function _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
      var dest = this.resolvedProperty;
      for (var i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
      this.targetObject.matrixWorldNeedsUpdate = true;
    }

    // ArrayElement
  }, {
    key: "_setValue_arrayElement",
    value: function _setValue_arrayElement(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }
  }, {
    key: "_setValue_arrayElement_setNeedsUpdate",
    value: function _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
  }, {
    key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
    value: function _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }

    // HasToFromArray
  }, {
    key: "_setValue_fromArray",
    value: function _setValue_fromArray(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
    }
  }, {
    key: "_setValue_fromArray_setNeedsUpdate",
    value: function _setValue_fromArray_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.needsUpdate = true;
    }
  }, {
    key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
    value: function _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
  }, {
    key: "_getValue_unbound",
    value: function _getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    }
  }, {
    key: "_setValue_unbound",
    value: function _setValue_unbound(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    }

    // create getter / setter pair for a property in the scene graph
  }, {
    key: "bind",
    value: function bind() {
      var targetObject = this.node;
      var parsedPath = this.parsedPath;
      var objectName = parsedPath.objectName;
      var propertyName = parsedPath.propertyName;
      var propertyIndex = parsedPath.propertyIndex;
      if (!targetObject) {
        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
        this.node = targetObject;
      }

      // set fail state so we can just 'return' on error
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;

      // ensure there is a value node
      if (!targetObject) {
        console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.');
        return;
      }
      if (objectName) {
        var objectIndex = parsedPath.objectIndex;

        // special cases were we need to reach deeper into the hierarchy to get the face materials....
        switch (objectName) {
          case 'materials':
            if (!targetObject.material) {
              console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
              return;
            }
            targetObject = targetObject.material.materials;
            break;
          case 'bones':
            if (!targetObject.skeleton) {
              console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
              return;
            }

            // potential future optimization: skip this if propertyIndex is already an integer
            // and convert the integer string to a true integer.

            targetObject = targetObject.skeleton.bones;

            // support resolving morphTarget names into indices.
            for (var i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === objectIndex) {
                objectIndex = i;
                break;
              }
            }
            break;
          case 'map':
            if ('map' in targetObject) {
              targetObject = targetObject.map;
              break;
            }
            if (!targetObject.material) {
              console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
              return;
            }
            if (!targetObject.material.map) {
              console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);
              return;
            }
            targetObject = targetObject.material.map;
            break;
          default:
            if (targetObject[objectName] === undefined) {
              console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
              return;
            }
            targetObject = targetObject[objectName];
        }
        if (objectIndex !== undefined) {
          if (targetObject[objectIndex] === undefined) {
            console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
            return;
          }
          targetObject = targetObject[objectIndex];
        }
      }

      // resolve property
      var nodeProperty = targetObject[propertyName];
      if (nodeProperty === undefined) {
        var nodeName = parsedPath.nodeName;
        console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
        return;
      }

      // determine versioning scheme
      var versioning = this.Versioning.None;
      this.targetObject = targetObject;
      if (targetObject.needsUpdate !== undefined) {
        // material

        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
        // node transform

        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }

      // determine how the property gets bound
      var bindingType = this.BindingType.Direct;
      if (propertyIndex !== undefined) {
        // access a sub element of the property array (only primitives are supported right now)

        if (propertyName === 'morphTargetInfluences') {
          // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

          // support resolving morphTarget names into indices.
          if (!targetObject.geometry) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
            return;
          }
          if (!targetObject.geometry.morphAttributes) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        }
        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
        // must use copy for Object3D.Euler/Quaternion

        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }

      // select getter / setter
      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
  }, {
    key: "unbind",
    value: function unbind() {
      this.node = null;

      // back to the prototype version of getValue / setValue
      // note: avoiding to mutate the shape of 'this' via 'delete'
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  }], [{
    key: "create",
    value: function create(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
      } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
      }
    }

    /**
     * Replaces spaces with underscores and removes unsupported characters from
     * node names, to ensure compatibility with parseTrackName().
     *
     * @param {string} name Node name to be sanitized.
     * @return {string}
     */
  }, {
    key: "sanitizeNodeName",
    value: function sanitizeNodeName(name) {
      return name.replace(/\s/g, '_').replace(_reservedRe, '');
    }
  }, {
    key: "parseTrackName",
    value: function parseTrackName(trackName) {
      var matches = _trackRe.exec(trackName);
      if (matches === null) {
        throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
      }
      var results = {
        // directoryName: matches[ 1 ], // (tschw) currently unused
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        // required
        propertyIndex: matches[6]
      };
      var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
      if (lastDot !== undefined && lastDot !== -1) {
        var objectName = results.nodeName.substring(lastDot + 1);

        // Object names must be checked against an allowlist. Otherwise, there
        // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
        // 'bar' could be the objectName, or part of a nodeName (which can
        // include '.' characters).
        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
      }
      return results;
    }
  }, {
    key: "findNode",
    value: function findNode(root, nodeName) {
      if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }

      // search into skeleton bones.
      if (root.skeleton) {
        var bone = root.skeleton.getBoneByName(nodeName);
        if (bone !== undefined) {
          return bone;
        }
      }

      // search into node subtree.
      if (root.children) {
        var _searchNodeSubtree = function searchNodeSubtree(children) {
          for (var i = 0; i < children.length; i++) {
            var childNode = children[i];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }
            var result = _searchNodeSubtree(childNode.children);
            if (result) return result;
          }
          return null;
        };
        var subTreeNode = _searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    }
  }]);
}();
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[
// Direct
PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [
// EntireArray

PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [
// ArrayElement
PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [
// HasToFromArray
PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */
var AnimationObjectGroup = exports.AnimationObjectGroup = /*#__PURE__*/function () {
  function AnimationObjectGroup() {
    _classCallCheck(this, AnimationObjectGroup);
    this.isAnimationObjectGroup = true;
    this.uuid = generateUUID();

    // cached objects followed by the active ones
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0; // threshold
    // note: read by PropertyBinding.Composite

    var indices = {};
    this._indicesByUUID = indices; // for bookkeeping

    for (var i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }
    this._paths = []; // inside: string
    this._parsedPaths = []; // inside: { we don't care, here }
    this._bindings = []; // inside: Array< PropertyBinding >
    this._bindingsIndicesByPath = {}; // inside: indices in these arrays

    var scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  return _createClass(AnimationObjectGroup, [{
    key: "add",
    value: function add() {
      var objects = this._objects,
        indicesByUUID = this._indicesByUUID,
        paths = this._paths,
        parsedPaths = this._parsedPaths,
        bindings = this._bindings,
        nBindings = bindings.length;
      var knownObject = undefined,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_;
      for (var i = 0, n = arguments.length; i !== n; ++i) {
        var object = arguments[i],
          uuid = object.uuid;
        var index = indicesByUUID[uuid];
        if (index === undefined) {
          // unknown object -> add it to the ACTIVE region

          index = nObjects++;
          indicesByUUID[uuid] = index;
          objects.push(object);

          // accounting is done, now do the same for all bindings

          for (var j = 0, m = nBindings; j !== m; ++j) {
            bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
          }
        } else if (index < nCachedObjects) {
          knownObject = objects[index];

          // move existing object to the ACTIVE region

          var firstActiveIndex = --nCachedObjects,
            lastCachedObject = objects[firstActiveIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[uuid] = firstActiveIndex;
          objects[firstActiveIndex] = object;

          // accounting is done, now do the same for all bindings

          for (var _j16 = 0, _m2 = nBindings; _j16 !== _m2; ++_j16) {
            var bindingsForPath = bindings[_j16],
              lastCached = bindingsForPath[firstActiveIndex];
            var binding = bindingsForPath[index];
            bindingsForPath[index] = lastCached;
            if (binding === undefined) {
              // since we do not bother to create new bindings
              // for objects that are cached, the binding may
              // or may not exist

              binding = new PropertyBinding(object, paths[_j16], parsedPaths[_j16]);
            }
            bindingsForPath[firstActiveIndex] = binding;
          }
        } else if (objects[index] !== knownObject) {
          console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
        } // else the object is already where we want it to be
      } // for arguments

      this.nCachedObjects_ = nCachedObjects;
    }
  }, {
    key: "remove",
    value: function remove() {
      var objects = this._objects,
        indicesByUUID = this._indicesByUUID,
        bindings = this._bindings,
        nBindings = bindings.length;
      var nCachedObjects = this.nCachedObjects_;
      for (var i = 0, n = arguments.length; i !== n; ++i) {
        var object = arguments[i],
          uuid = object.uuid,
          index = indicesByUUID[uuid];
        if (index !== undefined && index >= nCachedObjects) {
          // move existing object into the CACHED region

          var lastCachedIndex = nCachedObjects++,
            firstActiveObject = objects[lastCachedIndex];
          indicesByUUID[firstActiveObject.uuid] = index;
          objects[index] = firstActiveObject;
          indicesByUUID[uuid] = lastCachedIndex;
          objects[lastCachedIndex] = object;

          // accounting is done, now do the same for all bindings

          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j],
              firstActive = bindingsForPath[lastCachedIndex],
              binding = bindingsForPath[index];
            bindingsForPath[index] = firstActive;
            bindingsForPath[lastCachedIndex] = binding;
          }
        }
      } // for arguments

      this.nCachedObjects_ = nCachedObjects;
    }

    // remove & forget
  }, {
    key: "uncache",
    value: function uncache() {
      var objects = this._objects,
        indicesByUUID = this._indicesByUUID,
        bindings = this._bindings,
        nBindings = bindings.length;
      var nCachedObjects = this.nCachedObjects_,
        nObjects = objects.length;
      for (var i = 0, n = arguments.length; i !== n; ++i) {
        var object = arguments[i],
          uuid = object.uuid,
          index = indicesByUUID[uuid];
        if (index !== undefined) {
          delete indicesByUUID[uuid];
          if (index < nCachedObjects) {
            // object is cached, shrink the CACHED region

            var firstActiveIndex = --nCachedObjects,
              lastCachedObject = objects[firstActiveIndex],
              lastIndex = --nObjects,
              lastObject = objects[lastIndex];

            // last cached object takes this object's place
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;

            // last object goes to the activated slot and pop
            indicesByUUID[lastObject.uuid] = firstActiveIndex;
            objects[firstActiveIndex] = lastObject;
            objects.pop();

            // accounting is done, now do the same for all bindings

            for (var j = 0, m = nBindings; j !== m; ++j) {
              var bindingsForPath = bindings[j],
                lastCached = bindingsForPath[firstActiveIndex],
                last = bindingsForPath[lastIndex];
              bindingsForPath[index] = lastCached;
              bindingsForPath[firstActiveIndex] = last;
              bindingsForPath.pop();
            }
          } else {
            // object is active, just swap with the last and pop

            var _lastIndex = --nObjects,
              _lastObject = objects[_lastIndex];
            if (_lastIndex > 0) {
              indicesByUUID[_lastObject.uuid] = index;
            }
            objects[index] = _lastObject;
            objects.pop();

            // accounting is done, now do the same for all bindings

            for (var _j17 = 0, _m4 = nBindings; _j17 !== _m4; ++_j17) {
              var _bindingsForPath = bindings[_j17];
              _bindingsForPath[index] = _bindingsForPath[_lastIndex];
              _bindingsForPath.pop();
            }
          } // cached or active
        } // if object is known
      } // for arguments

      this.nCachedObjects_ = nCachedObjects;
    }

    // Internal interface used by befriended PropertyBinding.Composite:
  }, {
    key: "subscribe_",
    value: function subscribe_(path, parsedPath) {
      // returns an array of bindings for the given path that is changed
      // according to the contained objects in the group

      var indicesByPath = this._bindingsIndicesByPath;
      var index = indicesByPath[path];
      var bindings = this._bindings;
      if (index !== undefined) return bindings[index];
      var paths = this._paths,
        parsedPaths = this._parsedPaths,
        objects = this._objects,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_,
        bindingsForPath = new Array(nObjects);
      index = bindings.length;
      indicesByPath[path] = index;
      paths.push(path);
      parsedPaths.push(parsedPath);
      bindings.push(bindingsForPath);
      for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
        var object = objects[i];
        bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
      }
      return bindingsForPath;
    }
  }, {
    key: "unsubscribe_",
    value: function unsubscribe_(path) {
      // tells the group to forget about a property path and no longer
      // update the array previously obtained with 'subscribe_'

      var indicesByPath = this._bindingsIndicesByPath,
        index = indicesByPath[path];
      if (index !== undefined) {
        var paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          lastBindingsIndex = bindings.length - 1,
          lastBindings = bindings[lastBindingsIndex],
          lastBindingsPath = path[lastBindingsIndex];
        indicesByPath[lastBindingsPath] = index;
        bindings[index] = lastBindings;
        bindings.pop();
        parsedPaths[index] = parsedPaths[lastBindingsIndex];
        parsedPaths.pop();
        paths[index] = paths[lastBindingsIndex];
        paths.pop();
      }
    }
  }]);
}();
var AnimationAction = exports.AnimationAction = /*#__PURE__*/function () {
  function AnimationAction(mixer, clip) {
    var localRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var blendMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : clip.blendMode;
    _classCallCheck(this, AnimationAction);
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    var tracks = clip.tracks,
      nTracks = tracks.length,
      interpolants = new Array(nTracks);
    var interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (var i = 0; i !== nTracks; ++i) {
      var interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants; // bound by the mixer

    // inside: PropertyMixer (managed by the mixer)
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null; // for the memory manager
    this._byClipCacheIndex = null; // for the memory manager

    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;

    // global mixer time when the action is to be started
    // it's set back to 'null' upon start of the action
    this._startTime = null;

    // scaled local time of the action
    // gets clamped or wrapped to 0..clip.duration according to loop
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity; // no. of repetitions when looping

    this.paused = false; // true -> zero effective time scale
    this.enabled = true; // false -> zero effective weight

    this.clampWhenFinished = false; // keep feeding the last frame?

    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
    this.zeroSlopeAtEnd = true; // clips for start, loop and end
  }

  // State & Scheduling
  return _createClass(AnimationAction, [{
    key: "play",
    value: function play() {
      this._mixer._activateAction(this);
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      this._mixer._deactivateAction(this);
      return this.reset();
    }
  }, {
    key: "reset",
    value: function reset() {
      this.paused = false;
      this.enabled = true;
      this.time = 0; // restart clip
      this._loopCount = -1; // forget previous loops
      this._startTime = null; // forget scheduling

      return this.stopFading().stopWarping();
    }
  }, {
    key: "isRunning",
    value: function isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }

    // return true when play has been called
  }, {
    key: "isScheduled",
    value: function isScheduled() {
      return this._mixer._isActiveAction(this);
    }
  }, {
    key: "startAt",
    value: function startAt(time) {
      this._startTime = time;
      return this;
    }
  }, {
    key: "setLoop",
    value: function setLoop(mode, repetitions) {
      this.loop = mode;
      this.repetitions = repetitions;
      return this;
    }

    // Weight

    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
  }, {
    key: "setEffectiveWeight",
    value: function setEffectiveWeight(weight) {
      this.weight = weight;

      // note: same logic as when updated at runtime
      this._effectiveWeight = this.enabled ? weight : 0;
      return this.stopFading();
    }

    // return the weight considering fading and .enabled
  }, {
    key: "getEffectiveWeight",
    value: function getEffectiveWeight() {
      return this._effectiveWeight;
    }
  }, {
    key: "fadeIn",
    value: function fadeIn(duration) {
      return this._scheduleFading(duration, 0, 1);
    }
  }, {
    key: "fadeOut",
    value: function fadeOut(duration) {
      return this._scheduleFading(duration, 1, 0);
    }
  }, {
    key: "crossFadeFrom",
    value: function crossFadeFrom(fadeOutAction, duration, warp) {
      fadeOutAction.fadeOut(duration);
      this.fadeIn(duration);
      if (warp) {
        var fadeInDuration = this._clip.duration,
          fadeOutDuration = fadeOutAction._clip.duration,
          startEndRatio = fadeOutDuration / fadeInDuration,
          endStartRatio = fadeInDuration / fadeOutDuration;
        fadeOutAction.warp(1.0, startEndRatio, duration);
        this.warp(endStartRatio, 1.0, duration);
      }
      return this;
    }
  }, {
    key: "crossFadeTo",
    value: function crossFadeTo(fadeInAction, duration, warp) {
      return fadeInAction.crossFadeFrom(this, duration, warp);
    }
  }, {
    key: "stopFading",
    value: function stopFading() {
      var weightInterpolant = this._weightInterpolant;
      if (weightInterpolant !== null) {
        this._weightInterpolant = null;
        this._mixer._takeBackControlInterpolant(weightInterpolant);
      }
      return this;
    }

    // Time Scale Control

    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
  }, {
    key: "setEffectiveTimeScale",
    value: function setEffectiveTimeScale(timeScale) {
      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;
      return this.stopWarping();
    }

    // return the time scale considering warping and .paused
  }, {
    key: "getEffectiveTimeScale",
    value: function getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
  }, {
    key: "setDuration",
    value: function setDuration(duration) {
      this.timeScale = this._clip.duration / duration;
      return this.stopWarping();
    }
  }, {
    key: "syncWith",
    value: function syncWith(action) {
      this.time = action.time;
      this.timeScale = action.timeScale;
      return this.stopWarping();
    }
  }, {
    key: "halt",
    value: function halt(duration) {
      return this.warp(this._effectiveTimeScale, 0, duration);
    }
  }, {
    key: "warp",
    value: function warp(startTimeScale, endTimeScale, duration) {
      var mixer = this._mixer,
        now = mixer.time,
        timeScale = this.timeScale;
      var interpolant = this._timeScaleInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;
      }
      var times = interpolant.parameterPositions,
        values = interpolant.sampleValues;
      times[0] = now;
      times[1] = now + duration;
      values[0] = startTimeScale / timeScale;
      values[1] = endTimeScale / timeScale;
      return this;
    }
  }, {
    key: "stopWarping",
    value: function stopWarping() {
      var timeScaleInterpolant = this._timeScaleInterpolant;
      if (timeScaleInterpolant !== null) {
        this._timeScaleInterpolant = null;
        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
      }
      return this;
    }

    // Object Accessors
  }, {
    key: "getMixer",
    value: function getMixer() {
      return this._mixer;
    }
  }, {
    key: "getClip",
    value: function getClip() {
      return this._clip;
    }
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this._localRoot || this._mixer._root;
    }

    // Interna
  }, {
    key: "_update",
    value: function _update(time, deltaTime, timeDirection, accuIndex) {
      // called by the mixer

      if (!this.enabled) {
        // call ._updateWeight() to update ._effectiveWeight

        this._updateWeight(time);
        return;
      }
      var startTime = this._startTime;
      if (startTime !== null) {
        // check for scheduled start of action

        var timeRunning = (time - startTime) * timeDirection;
        if (timeRunning < 0 || timeDirection === 0) {
          deltaTime = 0;
        } else {
          this._startTime = null; // unschedule
          deltaTime = timeDirection * timeRunning;
        }
      }

      // apply time scale and advance time

      deltaTime *= this._updateTimeScale(time);
      var clipTime = this._updateTime(deltaTime);

      // note: _updateTime may disable the action resulting in
      // an effective weight of 0

      var weight = this._updateWeight(time);
      if (weight > 0) {
        var interpolants = this._interpolants;
        var propertyMixers = this._propertyBindings;
        switch (this.blendMode) {
          case AdditiveAnimationBlendMode:
            for (var j = 0, m = interpolants.length; j !== m; ++j) {
              interpolants[j].evaluate(clipTime);
              propertyMixers[j].accumulateAdditive(weight);
            }
            break;
          case NormalAnimationBlendMode:
          default:
            for (var _j18 = 0, _m5 = interpolants.length; _j18 !== _m5; ++_j18) {
              interpolants[_j18].evaluate(clipTime);
              propertyMixers[_j18].accumulate(accuIndex, weight);
            }
        }
      }
    }
  }, {
    key: "_updateWeight",
    value: function _updateWeight(time) {
      var weight = 0;
      if (this.enabled) {
        weight = this.weight;
        var interpolant = this._weightInterpolant;
        if (interpolant !== null) {
          var interpolantValue = interpolant.evaluate(time)[0];
          weight *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopFading();
            if (interpolantValue === 0) {
              // faded out, disable
              this.enabled = false;
            }
          }
        }
      }
      this._effectiveWeight = weight;
      return weight;
    }
  }, {
    key: "_updateTimeScale",
    value: function _updateTimeScale(time) {
      var timeScale = 0;
      if (!this.paused) {
        timeScale = this.timeScale;
        var interpolant = this._timeScaleInterpolant;
        if (interpolant !== null) {
          var interpolantValue = interpolant.evaluate(time)[0];
          timeScale *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopWarping();
            if (timeScale === 0) {
              // motion has halted, pause
              this.paused = true;
            } else {
              // warp done - apply final time scale
              this.timeScale = timeScale;
            }
          }
        }
      }
      this._effectiveTimeScale = timeScale;
      return timeScale;
    }
  }, {
    key: "_updateTime",
    value: function _updateTime(deltaTime) {
      var duration = this._clip.duration;
      var loop = this.loop;
      var time = this.time + deltaTime;
      var loopCount = this._loopCount;
      var pingPong = loop === LoopPingPong;
      if (deltaTime === 0) {
        if (loopCount === -1) return time;
        return pingPong && (loopCount & 1) === 1 ? duration - time : time;
      }
      if (loop === LoopOnce) {
        if (loopCount === -1) {
          // just started

          this._loopCount = 0;
          this._setEndings(true, true, false);
        }
        handle_stop: {
          if (time >= duration) {
            time = duration;
          } else if (time < 0) {
            time = 0;
          } else {
            this.time = time;
            break handle_stop;
          }
          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
          this.time = time;
          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime < 0 ? -1 : 1
          });
        }
      } else {
        // repetitive Repeat or PingPong

        if (loopCount === -1) {
          // just started

          if (deltaTime >= 0) {
            loopCount = 0;
            this._setEndings(true, this.repetitions === 0, pingPong);
          } else {
            // when looping in reverse direction, the initial
            // transition through zero counts as a repetition,
            // so leave loopCount at -1

            this._setEndings(this.repetitions === 0, true, pingPong);
          }
        }
        if (time >= duration || time < 0) {
          // wrap around

          var loopDelta = Math.floor(time / duration); // signed
          time -= duration * loopDelta;
          loopCount += Math.abs(loopDelta);
          var pending = this.repetitions - loopCount;
          if (pending <= 0) {
            // have to stop (switch state, clamp time, fire event)

            if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
            time = deltaTime > 0 ? duration : 0;
            this.time = time;
            this._mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: deltaTime > 0 ? 1 : -1
            });
          } else {
            // keep running

            if (pending === 1) {
              // entering the last round

              var atStart = deltaTime < 0;
              this._setEndings(atStart, !atStart, pingPong);
            } else {
              this._setEndings(false, false, pingPong);
            }
            this._loopCount = loopCount;
            this.time = time;
            this._mixer.dispatchEvent({
              type: 'loop',
              action: this,
              loopDelta: loopDelta
            });
          }
        } else {
          this.time = time;
        }
        if (pingPong && (loopCount & 1) === 1) {
          // invert time for the "pong round"

          return duration - time;
        }
      }
      return time;
    }
  }, {
    key: "_setEndings",
    value: function _setEndings(atStart, atEnd, pingPong) {
      var settings = this._interpolantSettings;
      if (pingPong) {
        settings.endingStart = ZeroSlopeEnding;
        settings.endingEnd = ZeroSlopeEnding;
      } else {
        // assuming for LoopOnce atStart == atEnd == true

        if (atStart) {
          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingStart = WrapAroundEnding;
        }
        if (atEnd) {
          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingEnd = WrapAroundEnding;
        }
      }
    }
  }, {
    key: "_scheduleFading",
    value: function _scheduleFading(duration, weightNow, weightThen) {
      var mixer = this._mixer,
        now = mixer.time;
      var interpolant = this._weightInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;
      }
      var times = interpolant.parameterPositions,
        values = interpolant.sampleValues;
      times[0] = now;
      values[0] = weightNow;
      times[1] = now + duration;
      values[1] = weightThen;
      return this;
    }
  }]);
}();
var _controlInterpolantsResultBuffer = new Float32Array(1);
var AnimationMixer = exports.AnimationMixer = /*#__PURE__*/function (_EventDispatcher7) {
  function AnimationMixer(root) {
    var _this114;
    _classCallCheck(this, AnimationMixer);
    _this114 = _callSuper(this, AnimationMixer);
    _this114._root = root;
    _this114._initMemoryManager();
    _this114._accuIndex = 0;
    _this114.time = 0;
    _this114.timeScale = 1.0;
    return _this114;
  }
  _inherits(AnimationMixer, _EventDispatcher7);
  return _createClass(AnimationMixer, [{
    key: "_bindAction",
    value: function _bindAction(action, prototypeAction) {
      var root = action._localRoot || this._root,
        tracks = action._clip.tracks,
        nTracks = tracks.length,
        bindings = action._propertyBindings,
        interpolants = action._interpolants,
        rootUuid = root.uuid,
        bindingsByRoot = this._bindingsByRootAndName;
      var bindingsByName = bindingsByRoot[rootUuid];
      if (bindingsByName === undefined) {
        bindingsByName = {};
        bindingsByRoot[rootUuid] = bindingsByName;
      }
      for (var i = 0; i !== nTracks; ++i) {
        var track = tracks[i],
          trackName = track.name;
        var binding = bindingsByName[trackName];
        if (binding !== undefined) {
          ++binding.referenceCount;
          bindings[i] = binding;
        } else {
          binding = bindings[i];
          if (binding !== undefined) {
            // existing binding, make sure the cache knows

            if (binding._cacheIndex === null) {
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
            }
            continue;
          }
          var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
          binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
          ++binding.referenceCount;
          this._addInactiveBinding(binding, rootUuid, trackName);
          bindings[i] = binding;
        }
        interpolants[i].resultBuffer = binding.buffer;
      }
    }
  }, {
    key: "_activateAction",
    value: function _activateAction(action) {
      if (!this._isActiveAction(action)) {
        if (action._cacheIndex === null) {
          // this action has been forgotten by the cache, but the user
          // appears to be still using it -> rebind

          var rootUuid = (action._localRoot || this._root).uuid,
            clipUuid = action._clip.uuid,
            actionsForClip = this._actionsByClip[clipUuid];
          this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
          this._addInactiveAction(action, clipUuid, rootUuid);
        }
        var bindings = action._propertyBindings;

        // increment reference counts / sort out state
        for (var i = 0, n = bindings.length; i !== n; ++i) {
          var binding = bindings[i];
          if (binding.useCount++ === 0) {
            this._lendBinding(binding);
            binding.saveOriginalState();
          }
        }
        this._lendAction(action);
      }
    }
  }, {
    key: "_deactivateAction",
    value: function _deactivateAction(action) {
      if (this._isActiveAction(action)) {
        var bindings = action._propertyBindings;

        // decrement reference counts / sort out state
        for (var i = 0, n = bindings.length; i !== n; ++i) {
          var binding = bindings[i];
          if (--binding.useCount === 0) {
            binding.restoreOriginalState();
            this._takeBackBinding(binding);
          }
        }
        this._takeBackAction(action);
      }
    }

    // Memory manager
  }, {
    key: "_initMemoryManager",
    value: function _initMemoryManager() {
      this._actions = []; // 'nActiveActions' followed by inactive ones
      this._nActiveActions = 0;
      this._actionsByClip = {};
      // inside:
      // {
      // 	knownActions: Array< AnimationAction > - used as prototypes
      // 	actionByRoot: AnimationAction - lookup
      // }

      this._bindings = []; // 'nActiveBindings' followed by inactive ones
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

      this._controlInterpolants = []; // same game as above
      this._nActiveControlInterpolants = 0;
      var scope = this;
      this.stats = {
        actions: {
          get total() {
            return scope._actions.length;
          },
          get inUse() {
            return scope._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return scope._bindings.length;
          },
          get inUse() {
            return scope._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return scope._controlInterpolants.length;
          },
          get inUse() {
            return scope._nActiveControlInterpolants;
          }
        }
      };
    }

    // Memory management for AnimationAction objects
  }, {
    key: "_isActiveAction",
    value: function _isActiveAction(action) {
      var index = action._cacheIndex;
      return index !== null && index < this._nActiveActions;
    }
  }, {
    key: "_addInactiveAction",
    value: function _addInactiveAction(action, clipUuid, rootUuid) {
      var actions = this._actions,
        actionsByClip = this._actionsByClip;
      var actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip === undefined) {
        actionsForClip = {
          knownActions: [action],
          actionByRoot: {}
        };
        action._byClipCacheIndex = 0;
        actionsByClip[clipUuid] = actionsForClip;
      } else {
        var knownActions = actionsForClip.knownActions;
        action._byClipCacheIndex = knownActions.length;
        knownActions.push(action);
      }
      action._cacheIndex = actions.length;
      actions.push(action);
      actionsForClip.actionByRoot[rootUuid] = action;
    }
  }, {
    key: "_removeInactiveAction",
    value: function _removeInactiveAction(action) {
      var actions = this._actions,
        lastInactiveAction = actions[actions.length - 1],
        cacheIndex = action._cacheIndex;
      lastInactiveAction._cacheIndex = cacheIndex;
      actions[cacheIndex] = lastInactiveAction;
      actions.pop();
      action._cacheIndex = null;
      var clipUuid = action._clip.uuid,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[clipUuid],
        knownActionsForClip = actionsForClip.knownActions,
        lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
        byClipCacheIndex = action._byClipCacheIndex;
      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[byClipCacheIndex] = lastKnownAction;
      knownActionsForClip.pop();
      action._byClipCacheIndex = null;
      var actionByRoot = actionsForClip.actionByRoot,
        rootUuid = (action._localRoot || this._root).uuid;
      delete actionByRoot[rootUuid];
      if (knownActionsForClip.length === 0) {
        delete actionsByClip[clipUuid];
      }
      this._removeInactiveBindingsForAction(action);
    }
  }, {
    key: "_removeInactiveBindingsForAction",
    value: function _removeInactiveBindingsForAction(action) {
      var bindings = action._propertyBindings;
      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];
        if (--binding.referenceCount === 0) {
          this._removeInactiveBinding(binding);
        }
      }
    }
  }, {
    key: "_lendAction",
    value: function _lendAction(action) {
      // [ active actions |  inactive actions  ]
      // [  active actions >| inactive actions ]
      //                 s        a
      //                  <-swap->
      //                 a        s

      var actions = this._actions,
        prevIndex = action._cacheIndex,
        lastActiveIndex = this._nActiveActions++,
        firstInactiveAction = actions[lastActiveIndex];
      action._cacheIndex = lastActiveIndex;
      actions[lastActiveIndex] = action;
      firstInactiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = firstInactiveAction;
    }
  }, {
    key: "_takeBackAction",
    value: function _takeBackAction(action) {
      // [  active actions  | inactive actions ]
      // [ active actions |< inactive actions  ]
      //        a        s
      //         <-swap->
      //        s        a

      var actions = this._actions,
        prevIndex = action._cacheIndex,
        firstInactiveIndex = --this._nActiveActions,
        lastActiveAction = actions[firstInactiveIndex];
      action._cacheIndex = firstInactiveIndex;
      actions[firstInactiveIndex] = action;
      lastActiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = lastActiveAction;
    }

    // Memory management for PropertyMixer objects
  }, {
    key: "_addInactiveBinding",
    value: function _addInactiveBinding(binding, rootUuid, trackName) {
      var bindingsByRoot = this._bindingsByRootAndName,
        bindings = this._bindings;
      var bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName === undefined) {
        bindingByName = {};
        bindingsByRoot[rootUuid] = bindingByName;
      }
      bindingByName[trackName] = binding;
      binding._cacheIndex = bindings.length;
      bindings.push(binding);
    }
  }, {
    key: "_removeInactiveBinding",
    value: function _removeInactiveBinding(binding) {
      var bindings = this._bindings,
        propBinding = binding.binding,
        rootUuid = propBinding.rootNode.uuid,
        trackName = propBinding.path,
        bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[rootUuid],
        lastInactiveBinding = bindings[bindings.length - 1],
        cacheIndex = binding._cacheIndex;
      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[cacheIndex] = lastInactiveBinding;
      bindings.pop();
      delete bindingByName[trackName];
      if (Object.keys(bindingByName).length === 0) {
        delete bindingsByRoot[rootUuid];
      }
    }
  }, {
    key: "_lendBinding",
    value: function _lendBinding(binding) {
      var bindings = this._bindings,
        prevIndex = binding._cacheIndex,
        lastActiveIndex = this._nActiveBindings++,
        firstInactiveBinding = bindings[lastActiveIndex];
      binding._cacheIndex = lastActiveIndex;
      bindings[lastActiveIndex] = binding;
      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = firstInactiveBinding;
    }
  }, {
    key: "_takeBackBinding",
    value: function _takeBackBinding(binding) {
      var bindings = this._bindings,
        prevIndex = binding._cacheIndex,
        firstInactiveIndex = --this._nActiveBindings,
        lastActiveBinding = bindings[firstInactiveIndex];
      binding._cacheIndex = firstInactiveIndex;
      bindings[firstInactiveIndex] = binding;
      lastActiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = lastActiveBinding;
    }

    // Memory management of Interpolants for weight and time scale
  }, {
    key: "_lendControlInterpolant",
    value: function _lendControlInterpolant() {
      var interpolants = this._controlInterpolants,
        lastActiveIndex = this._nActiveControlInterpolants++;
      var interpolant = interpolants[lastActiveIndex];
      if (interpolant === undefined) {
        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer);
        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[lastActiveIndex] = interpolant;
      }
      return interpolant;
    }
  }, {
    key: "_takeBackControlInterpolant",
    value: function _takeBackControlInterpolant(interpolant) {
      var interpolants = this._controlInterpolants,
        prevIndex = interpolant.__cacheIndex,
        firstInactiveIndex = --this._nActiveControlInterpolants,
        lastActiveInterpolant = interpolants[firstInactiveIndex];
      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[firstInactiveIndex] = interpolant;
      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[prevIndex] = lastActiveInterpolant;
    }

    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
  }, {
    key: "clipAction",
    value: function clipAction(clip, optionalRoot, blendMode) {
      var root = optionalRoot || this._root,
        rootUuid = root.uuid;
      var clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
      var clipUuid = clipObject !== null ? clipObject.uuid : clip;
      var actionsForClip = this._actionsByClip[clipUuid];
      var prototypeAction = null;
      if (blendMode === undefined) {
        if (clipObject !== null) {
          blendMode = clipObject.blendMode;
        } else {
          blendMode = NormalAnimationBlendMode;
        }
      }
      if (actionsForClip !== undefined) {
        var existingAction = actionsForClip.actionByRoot[rootUuid];
        if (existingAction !== undefined && existingAction.blendMode === blendMode) {
          return existingAction;
        }

        // we know the clip, so we don't have to parse all
        // the bindings again but can just copy
        prototypeAction = actionsForClip.knownActions[0];

        // also, take the clip from the prototype action
        if (clipObject === null) clipObject = prototypeAction._clip;
      }

      // clip must be known when specified via string
      if (clipObject === null) return null;

      // allocate all resources required to run it
      var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
      this._bindAction(newAction, prototypeAction);

      // and make the action known to the memory manager
      this._addInactiveAction(newAction, clipUuid, rootUuid);
      return newAction;
    }

    // get an existing action
  }, {
    key: "existingAction",
    value: function existingAction(clip, optionalRoot) {
      var root = optionalRoot || this._root,
        rootUuid = root.uuid,
        clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
        clipUuid = clipObject ? clipObject.uuid : clip,
        actionsForClip = this._actionsByClip[clipUuid];
      if (actionsForClip !== undefined) {
        return actionsForClip.actionByRoot[rootUuid] || null;
      }
      return null;
    }

    // deactivates all previously scheduled actions
  }, {
    key: "stopAllAction",
    value: function stopAllAction() {
      var actions = this._actions,
        nActions = this._nActiveActions;
      for (var i = nActions - 1; i >= 0; --i) {
        actions[i].stop();
      }
      return this;
    }

    // advance the time and update apply the animation
  }, {
    key: "update",
    value: function update(deltaTime) {
      deltaTime *= this.timeScale;
      var actions = this._actions,
        nActions = this._nActiveActions,
        time = this.time += deltaTime,
        timeDirection = Math.sign(deltaTime),
        accuIndex = this._accuIndex ^= 1;

      // run active actions

      for (var i = 0; i !== nActions; ++i) {
        var action = actions[i];
        action._update(time, deltaTime, timeDirection, accuIndex);
      }

      // update scene graph

      var bindings = this._bindings,
        nBindings = this._nActiveBindings;
      for (var _i96 = 0; _i96 !== nBindings; ++_i96) {
        bindings[_i96].apply(accuIndex);
      }
      return this;
    }

    // Allows you to seek to a specific time in an animation.
  }, {
    key: "setTime",
    value: function setTime(timeInSeconds) {
      this.time = 0; // Zero out time attribute for AnimationMixer object;
      for (var i = 0; i < this._actions.length; i++) {
        this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
      }
      return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
    }

    // return this mixer's root target object
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this._root;
    }

    // free all resources specific to a particular clip
  }, {
    key: "uncacheClip",
    value: function uncacheClip(clip) {
      var actions = this._actions,
        clipUuid = clip.uuid,
        actionsByClip = this._actionsByClip,
        actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip !== undefined) {
        // note: just calling _removeInactiveAction would mess up the
        // iteration state and also require updating the state we can
        // just throw away

        var actionsToRemove = actionsForClip.knownActions;
        for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
          var action = actionsToRemove[i];
          this._deactivateAction(action);
          var cacheIndex = action._cacheIndex,
            lastInactiveAction = actions[actions.length - 1];
          action._cacheIndex = null;
          action._byClipCacheIndex = null;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          this._removeInactiveBindingsForAction(action);
        }
        delete actionsByClip[clipUuid];
      }
    }

    // free all resources specific to a particular root target object
  }, {
    key: "uncacheRoot",
    value: function uncacheRoot(root) {
      var rootUuid = root.uuid,
        actionsByClip = this._actionsByClip;
      for (var clipUuid in actionsByClip) {
        var actionByRoot = actionsByClip[clipUuid].actionByRoot,
          action = actionByRoot[rootUuid];
        if (action !== undefined) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
      var bindingsByRoot = this._bindingsByRootAndName,
        bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName !== undefined) {
        for (var trackName in bindingByName) {
          var binding = bindingByName[trackName];
          binding.restoreOriginalState();
          this._removeInactiveBinding(binding);
        }
      }
    }

    // remove a targeted clip from the cache
  }, {
    key: "uncacheAction",
    value: function uncacheAction(clip, optionalRoot) {
      var action = this.existingAction(clip, optionalRoot);
      if (action !== null) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
  }]);
}(EventDispatcher);
var Uniform = exports.Uniform = /*#__PURE__*/function () {
  function Uniform(value) {
    _classCallCheck(this, Uniform);
    this.value = value;
  }
  return _createClass(Uniform, [{
    key: "clone",
    value: function clone() {
      return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    }
  }]);
}();
var _id = 0;
var UniformsGroup = exports.UniformsGroup = /*#__PURE__*/function (_EventDispatcher8) {
  function UniformsGroup() {
    var _this115;
    _classCallCheck(this, UniformsGroup);
    _this115 = _callSuper(this, UniformsGroup);
    _this115.isUniformsGroup = true;
    Object.defineProperty(_this115, 'id', {
      value: _id++
    });
    _this115.name = '';
    _this115.usage = StaticDrawUsage;
    _this115.uniforms = [];
    return _this115;
  }
  _inherits(UniformsGroup, _EventDispatcher8);
  return _createClass(UniformsGroup, [{
    key: "add",
    value: function add(uniform) {
      this.uniforms.push(uniform);
      return this;
    }
  }, {
    key: "remove",
    value: function remove(uniform) {
      var index = this.uniforms.indexOf(uniform);
      if (index !== -1) this.uniforms.splice(index, 1);
      return this;
    }
  }, {
    key: "setName",
    value: function setName(name) {
      this.name = name;
      return this;
    }
  }, {
    key: "setUsage",
    value: function setUsage(value) {
      this.usage = value;
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
      return this;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.usage = source.usage;
      var uniformsSource = source.uniforms;
      this.uniforms.length = 0;
      for (var i = 0, l = uniformsSource.length; i < l; i++) {
        var uniforms = Array.isArray(uniformsSource[i]) ? uniformsSource[i] : [uniformsSource[i]];
        for (var j = 0; j < uniforms.length; j++) {
          this.uniforms.push(uniforms[j].clone());
        }
      }
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}(EventDispatcher);
var InstancedInterleavedBuffer = exports.InstancedInterleavedBuffer = /*#__PURE__*/function (_InterleavedBuffer) {
  function InstancedInterleavedBuffer(array, stride) {
    var _this116;
    var meshPerAttribute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    _classCallCheck(this, InstancedInterleavedBuffer);
    _this116 = _callSuper(this, InstancedInterleavedBuffer, [array, stride]);
    _this116.isInstancedInterleavedBuffer = true;
    _this116.meshPerAttribute = meshPerAttribute;
    return _this116;
  }
  _inherits(InstancedInterleavedBuffer, _InterleavedBuffer);
  return _createClass(InstancedInterleavedBuffer, [{
    key: "copy",
    value: function copy(source) {
      _superPropGet(InstancedInterleavedBuffer, "copy", this, 3)([source]);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
  }, {
    key: "clone",
    value: function clone(data) {
      var ib = _superPropGet(InstancedInterleavedBuffer, "clone", this, 3)([data]);
      ib.meshPerAttribute = this.meshPerAttribute;
      return ib;
    }
  }, {
    key: "toJSON",
    value: function toJSON(data) {
      var json = _superPropGet(InstancedInterleavedBuffer, "toJSON", this, 3)([data]);
      json.isInstancedInterleavedBuffer = true;
      json.meshPerAttribute = this.meshPerAttribute;
      return json;
    }
  }]);
}(InterleavedBuffer);
var GLBufferAttribute = exports.GLBufferAttribute = /*#__PURE__*/function () {
  function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
    _classCallCheck(this, GLBufferAttribute);
    this.isGLBufferAttribute = true;
    this.name = '';
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }
  return _createClass(GLBufferAttribute, [{
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(buffer) {
      this.buffer = buffer;
      return this;
    }
  }, {
    key: "setType",
    value: function setType(type, elementSize) {
      this.type = type;
      this.elementSize = elementSize;
      return this;
    }
  }, {
    key: "setItemSize",
    value: function setItemSize(itemSize) {
      this.itemSize = itemSize;
      return this;
    }
  }, {
    key: "setCount",
    value: function setCount(count) {
      this.count = count;
      return this;
    }
  }]);
}();
var _matrix = /*@__PURE__*/new Matrix4();
var Raycaster = exports.Raycaster = /*#__PURE__*/function () {
  function Raycaster(origin, direction) {
    var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
    _classCallCheck(this, Raycaster);
    this.ray = new Ray(origin, direction);
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: {
        threshold: 1
      },
      LOD: {},
      Points: {
        threshold: 1
      },
      Sprite: {}
    };
  }
  return _createClass(Raycaster, [{
    key: "set",
    value: function set(origin, direction) {
      // direction is assumed to be normalized (for accurate distance calculations)

      this.ray.set(origin, direction);
    }
  }, {
    key: "setFromCamera",
    value: function setFromCamera(coords, camera) {
      if (camera.isPerspectiveCamera) {
        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
        this.camera = camera;
      } else if (camera.isOrthographicCamera) {
        this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        this.camera = camera;
      } else {
        console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
      }
    }
  }, {
    key: "setFromXRController",
    value: function setFromXRController(controller) {
      _matrix.identity().extractRotation(controller.matrixWorld);
      this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
      return this;
    }
  }, {
    key: "intersectObject",
    value: function intersectObject(object) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var intersects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      intersect(object, this, intersects, recursive);
      intersects.sort(ascSort);
      return intersects;
    }
  }, {
    key: "intersectObjects",
    value: function intersectObjects(objects) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var intersects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      for (var i = 0, l = objects.length; i < l; i++) {
        intersect(objects[i], this, intersects, recursive);
      }
      intersects.sort(ascSort);
      return intersects;
    }
  }]);
}();
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersect(object, raycaster, intersects, recursive) {
  var propagate = true;
  if (object.layers.test(raycaster.layers)) {
    var result = object.raycast(raycaster, intersects);
    if (result === false) propagate = false;
  }
  if (propagate === true && recursive === true) {
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      intersect(children[i], raycaster, intersects, true);
    }
  }
}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.
 * theta (the azimuthal angle) is measured from the positive z-axis.
 */
var Spherical = exports.Spherical = /*#__PURE__*/function () {
  function Spherical() {
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var phi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var theta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    _classCallCheck(this, Spherical);
    this.radius = radius;
    this.phi = phi; // polar angle
    this.theta = theta; // azimuthal angle

    return this;
  }
  return _createClass(Spherical, [{
    key: "set",
    value: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    }

    // restrict phi to be between EPS and PI-EPS
  }, {
    key: "makeSafe",
    value: function makeSafe() {
      var EPS = 0.000001;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
  }, {
    key: "setFromCartesianCoords",
    value: function setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + y * y + z * z);
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x, z);
        this.phi = Math.acos(clamp(y / this.radius, -1, 1));
      }
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */
var Cylindrical = exports.Cylindrical = /*#__PURE__*/function () {
  function Cylindrical() {
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var theta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    _classCallCheck(this, Cylindrical);
    this.radius = radius; // distance from the origin to a point in the x-z plane
    this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
    this.y = y; // height above the x-z plane

    return this;
  }
  return _createClass(Cylindrical, [{
    key: "set",
    value: function set(radius, theta, y) {
      this.radius = radius;
      this.theta = theta;
      this.y = y;
      return this;
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.theta = other.theta;
      this.y = other.y;
      return this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
  }, {
    key: "setFromCartesianCoords",
    value: function setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + z * z);
      this.theta = Math.atan2(x, z);
      this.y = y;
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var Matrix2 = exports.Matrix2 = /*#__PURE__*/function () {
  function Matrix2(n11, n12, n21, n22) {
    _classCallCheck(this, Matrix2);
    Matrix2.prototype.isMatrix2 = true;
    this.elements = [1, 0, 0, 1];
    if (n11 !== undefined) {
      this.set(n11, n12, n21, n22);
    }
  }
  return _createClass(Matrix2, [{
    key: "identity",
    value: function identity() {
      this.set(1, 0, 0, 1);
      return this;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = 0; i < 4; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
  }, {
    key: "set",
    value: function set(n11, n12, n21, n22) {
      var te = this.elements;
      te[0] = n11;
      te[2] = n12;
      te[1] = n21;
      te[3] = n22;
      return this;
    }
  }]);
}();
var _vector$4 = /*@__PURE__*/new Vector2();
var Box2 = exports.Box2 = /*#__PURE__*/function () {
  function Box2() {
    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2(+Infinity, +Infinity);
    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2(-Infinity, -Infinity);
    _classCallCheck(this, Box2);
    this.isBox2 = true;
    this.min = min;
    this.max = max;
  }
  return _createClass(Box2, [{
    key: "set",
    value: function set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points) {
      this.makeEmpty();
      for (var i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
  }, {
    key: "setFromCenterAndSize",
    value: function setFromCenterAndSize(center, size) {
      var halfSize = _vector$4.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      this.min.x = this.min.y = +Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
  }, {
    key: "getCenter",
    value: function getCenter(target) {
      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
  }, {
    key: "getSize",
    value: function getSize(target) {
      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
  }, {
    key: "expandByVector",
    value: function expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
  }, {
    key: "expandByScalar",
    value: function expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y;
    }
  }, {
    key: "containsBox",
    value: function containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
  }, {
    key: "getParameter",
    value: function getParameter(point, target) {
      // This can potentially have a divide by zero if the box
      // has a size dimension of 0.

      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      // using 4 splitting planes to rule out intersections

      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y;
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return this.clampPoint(point, _vector$4).distanceTo(point);
    }
  }, {
    key: "intersect",
    value: function intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty()) this.makeEmpty();
      return this;
    }
  }, {
    key: "union",
    value: function union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  }]);
}();
var _startP = /*@__PURE__*/new Vector3();
var _startEnd = /*@__PURE__*/new Vector3();
var Line3 = exports.Line3 = /*#__PURE__*/function () {
  function Line3() {
    var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
    _classCallCheck(this, Line3);
    this.start = start;
    this.end = end;
  }
  return _createClass(Line3, [{
    key: "set",
    value: function set(start, end) {
      this.start.copy(start);
      this.end.copy(end);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    }
  }, {
    key: "getCenter",
    value: function getCenter(target) {
      return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
  }, {
    key: "delta",
    value: function delta(target) {
      return target.subVectors(this.end, this.start);
    }
  }, {
    key: "distanceSq",
    value: function distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
  }, {
    key: "distance",
    value: function distance() {
      return this.start.distanceTo(this.end);
    }
  }, {
    key: "at",
    value: function at(t, target) {
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
  }, {
    key: "closestPointToPointParameter",
    value: function closestPointToPointParameter(point, clampToLine) {
      _startP.subVectors(point, this.start);
      _startEnd.subVectors(this.end, this.start);
      var startEnd2 = _startEnd.dot(_startEnd);
      var startEnd_startP = _startEnd.dot(_startP);
      var t = startEnd_startP / startEnd2;
      if (clampToLine) {
        t = clamp(t, 0, 1);
      }
      return t;
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(point, clampToLine, target) {
      var t = this.closestPointToPointParameter(point, clampToLine);
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
}();
var _vector$3 = /*@__PURE__*/new Vector3();
var SpotLightHelper = exports.SpotLightHelper = /*#__PURE__*/function (_Object3D14) {
  function SpotLightHelper(light, color) {
    var _this117;
    _classCallCheck(this, SpotLightHelper);
    _this117 = _callSuper(this, SpotLightHelper);
    _this117.light = light;
    _this117.matrixAutoUpdate = false;
    _this117.color = color;
    _this117.type = 'SpotLightHelper';
    var geometry = new BufferGeometry();
    var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
      var p1 = i / l * Math.PI * 2;
      var p2 = j / l * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    var material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    _this117.cone = new LineSegments(geometry, material);
    _this117.add(_this117.cone);
    _this117.update();
    return _this117;
  }
  _inherits(SpotLightHelper, _Object3D14);
  return _createClass(SpotLightHelper, [{
    key: "dispose",
    value: function dispose() {
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      this.light.updateWorldMatrix(true, false);
      this.light.target.updateWorldMatrix(true, false);

      // update the local matrix based on the parent and light target transforms
      if (this.parent) {
        this.parent.updateWorldMatrix(true);
        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld);
      } else {
        this.matrix.copy(this.light.matrixWorld);
      }
      this.matrixWorld.copy(this.light.matrixWorld);
      var coneLength = this.light.distance ? this.light.distance : 1000;
      var coneWidth = coneLength * Math.tan(this.light.angle);
      this.cone.scale.set(coneWidth, coneWidth, coneLength);
      _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
      this.cone.lookAt(_vector$3);
      if (this.color !== undefined) {
        this.cone.material.color.set(this.color);
      } else {
        this.cone.material.color.copy(this.light.color);
      }
    }
  }]);
}(Object3D);
var _vector$2 = /*@__PURE__*/new Vector3();
var _boneMatrix = /*@__PURE__*/new Matrix4();
var _matrixWorldInv = /*@__PURE__*/new Matrix4();
var SkeletonHelper = exports.SkeletonHelper = /*#__PURE__*/function (_LineSegments) {
  function SkeletonHelper(object) {
    var _this118;
    _classCallCheck(this, SkeletonHelper);
    var bones = getBoneList(object);
    var geometry = new BufferGeometry();
    var vertices = [];
    var colors = [];
    var color1 = new Color(0, 0, 1);
    var color2 = new Color(0, 1, 0);
    for (var i = 0; i < bones.length; i++) {
      var bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: true,
      depthTest: false,
      depthWrite: false,
      toneMapped: false,
      transparent: true
    });
    _this118 = _callSuper(this, SkeletonHelper, [geometry, material]);
    _this118.isSkeletonHelper = true;
    _this118.type = 'SkeletonHelper';
    _this118.root = object;
    _this118.bones = bones;
    _this118.matrix = object.matrixWorld;
    _this118.matrixAutoUpdate = false;
    return _this118;
  }
  _inherits(SkeletonHelper, _LineSegments);
  return _createClass(SkeletonHelper, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      var bones = this.bones;
      var geometry = this.geometry;
      var position = geometry.getAttribute('position');
      _matrixWorldInv.copy(this.root.matrixWorld).invert();
      for (var i = 0, j = 0; i < bones.length; i++) {
        var bone = bones[i];
        if (bone.parent && bone.parent.isBone) {
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
          j += 2;
        }
      }
      geometry.getAttribute('position').needsUpdate = true;
      _superPropGet(SkeletonHelper, "updateMatrixWorld", this, 3)([force]);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);
}(LineSegments);
function getBoneList(object) {
  var boneList = [];
  if (object.isBone === true) {
    boneList.push(object);
  }
  for (var i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
var PointLightHelper = exports.PointLightHelper = /*#__PURE__*/function (_Mesh4) {
  function PointLightHelper(light, sphereSize, color) {
    var _this119;
    _classCallCheck(this, PointLightHelper);
    var geometry = new SphereGeometry(sphereSize, 4, 2);
    var material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    _this119 = _callSuper(this, PointLightHelper, [geometry, material]);
    _this119.light = light;
    _this119.color = color;
    _this119.type = 'PointLightHelper';
    _this119.matrix = _this119.light.matrixWorld;
    _this119.matrixAutoUpdate = false;
    _this119.update();

    /*
    // TODO: delete this comment?
    const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
    const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
    const d = light.distance;
    if ( d === 0.0 ) {
    	this.lightDistance.visible = false;
    } else {
    	this.lightDistance.scale.set( d, d, d );
    }
    this.add( this.lightDistance );
    */
    return _this119;
  }
  _inherits(PointLightHelper, _Mesh4);
  return _createClass(PointLightHelper, [{
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      this.light.updateWorldMatrix(true, false);
      if (this.color !== undefined) {
        this.material.color.set(this.color);
      } else {
        this.material.color.copy(this.light.color);
      }

      /*
      const d = this.light.distance;
      	if ( d === 0.0 ) {
      		this.lightDistance.visible = false;
      	} else {
      		this.lightDistance.visible = true;
      	this.lightDistance.scale.set( d, d, d );
      	}
      */
    }
  }]);
}(Mesh);
var _vector$1 = /*@__PURE__*/new Vector3();
var _color1 = /*@__PURE__*/new Color();
var _color2 = /*@__PURE__*/new Color();
var HemisphereLightHelper = exports.HemisphereLightHelper = /*#__PURE__*/function (_Object3D15) {
  function HemisphereLightHelper(light, size, color) {
    var _this120;
    _classCallCheck(this, HemisphereLightHelper);
    _this120 = _callSuper(this, HemisphereLightHelper);
    _this120.light = light;
    _this120.matrix = light.matrixWorld;
    _this120.matrixAutoUpdate = false;
    _this120.color = color;
    _this120.type = 'HemisphereLightHelper';
    var geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    _this120.material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    if (_this120.color === undefined) _this120.material.vertexColors = true;
    var position = geometry.getAttribute('position');
    var colors = new Float32Array(position.count * 3);
    geometry.setAttribute('color', new BufferAttribute(colors, 3));
    _this120.add(new Mesh(geometry, _this120.material));
    _this120.update();
    return _this120;
  }
  _inherits(HemisphereLightHelper, _Object3D15);
  return _createClass(HemisphereLightHelper, [{
    key: "dispose",
    value: function dispose() {
      this.children[0].geometry.dispose();
      this.children[0].material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      var mesh = this.children[0];
      if (this.color !== undefined) {
        this.material.color.set(this.color);
      } else {
        var colors = mesh.geometry.getAttribute('color');
        _color1.copy(this.light.color);
        _color2.copy(this.light.groundColor);
        for (var i = 0, l = colors.count; i < l; i++) {
          var color = i < l / 2 ? _color1 : _color2;
          colors.setXYZ(i, color.r, color.g, color.b);
        }
        colors.needsUpdate = true;
      }
      this.light.updateWorldMatrix(true, false);
      mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  }]);
}(Object3D);
var GridHelper = exports.GridHelper = /*#__PURE__*/function (_LineSegments2) {
  function GridHelper() {
    var _this121;
    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    var divisions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    var color1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0x444444;
    var color2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0x888888;
    _classCallCheck(this, GridHelper);
    color1 = new Color(color1);
    color2 = new Color(color2);
    var center = divisions / 2;
    var step = size / divisions;
    var halfSize = size / 2;
    var vertices = [],
      colors = [];
    for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      var color = i === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    _this121 = _callSuper(this, GridHelper, [geometry, material]);
    _this121.type = 'GridHelper';
    return _this121;
  }
  _inherits(GridHelper, _LineSegments2);
  return _createClass(GridHelper, [{
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);
}(LineSegments);
var PolarGridHelper = exports.PolarGridHelper = /*#__PURE__*/function (_LineSegments3) {
  function PolarGridHelper() {
    var _this122;
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    var sectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
    var rings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
    var divisions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 64;
    var color1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0x444444;
    var color2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0x888888;
    _classCallCheck(this, PolarGridHelper);
    color1 = new Color(color1);
    color2 = new Color(color2);
    var vertices = [];
    var colors = [];

    // create the sectors

    if (sectors > 1) {
      for (var i = 0; i < sectors; i++) {
        var v = i / sectors * (Math.PI * 2);
        var x = Math.sin(v) * radius;
        var z = Math.cos(v) * radius;
        vertices.push(0, 0, 0);
        vertices.push(x, 0, z);
        var color = i & 1 ? color1 : color2;
        colors.push(color.r, color.g, color.b);
        colors.push(color.r, color.g, color.b);
      }
    }

    // create the rings

    for (var _i97 = 0; _i97 < rings; _i97++) {
      var _color3 = _i97 & 1 ? color1 : color2;
      var r = radius - radius / rings * _i97;
      for (var j = 0; j < divisions; j++) {
        // first vertex

        var _v = j / divisions * (Math.PI * 2);
        var _x19 = Math.sin(_v) * r;
        var _z3 = Math.cos(_v) * r;
        vertices.push(_x19, 0, _z3);
        colors.push(_color3.r, _color3.g, _color3.b);

        // second vertex

        _v = (j + 1) / divisions * (Math.PI * 2);
        _x19 = Math.sin(_v) * r;
        _z3 = Math.cos(_v) * r;
        vertices.push(_x19, 0, _z3);
        colors.push(_color3.r, _color3.g, _color3.b);
      }
    }
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    _this122 = _callSuper(this, PolarGridHelper, [geometry, material]);
    _this122.type = 'PolarGridHelper';
    return _this122;
  }
  _inherits(PolarGridHelper, _LineSegments3);
  return _createClass(PolarGridHelper, [{
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);
}(LineSegments);
var _v1 = /*@__PURE__*/new Vector3();
var _v2 = /*@__PURE__*/new Vector3();
var _v3 = /*@__PURE__*/new Vector3();
var DirectionalLightHelper = exports.DirectionalLightHelper = /*#__PURE__*/function (_Object3D16) {
  function DirectionalLightHelper(light, size, color) {
    var _this123;
    _classCallCheck(this, DirectionalLightHelper);
    _this123 = _callSuper(this, DirectionalLightHelper);
    _this123.light = light;
    _this123.matrix = light.matrixWorld;
    _this123.matrixAutoUpdate = false;
    _this123.color = color;
    _this123.type = 'DirectionalLightHelper';
    if (size === undefined) size = 1;
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
    var material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    _this123.lightPlane = new Line(geometry, material);
    _this123.add(_this123.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    _this123.targetLine = new Line(geometry, material);
    _this123.add(_this123.targetLine);
    _this123.update();
    return _this123;
  }
  _inherits(DirectionalLightHelper, _Object3D16);
  return _createClass(DirectionalLightHelper, [{
    key: "dispose",
    value: function dispose() {
      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      this.light.updateWorldMatrix(true, false);
      this.light.target.updateWorldMatrix(true, false);
      _v1.setFromMatrixPosition(this.light.matrixWorld);
      _v2.setFromMatrixPosition(this.light.target.matrixWorld);
      _v3.subVectors(_v2, _v1);
      this.lightPlane.lookAt(_v2);
      if (this.color !== undefined) {
        this.lightPlane.material.color.set(this.color);
        this.targetLine.material.color.set(this.color);
      } else {
        this.lightPlane.material.color.copy(this.light.color);
        this.targetLine.material.color.copy(this.light.color);
      }
      this.targetLine.lookAt(_v2);
      this.targetLine.scale.z = _v3.length();
    }
  }]);
}(Object3D);
var _vector = /*@__PURE__*/new Vector3();
var _camera = /*@__PURE__*/new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
 */
var CameraHelper = exports.CameraHelper = /*#__PURE__*/function (_LineSegments4) {
  function CameraHelper(camera) {
    var _this124;
    _classCallCheck(this, CameraHelper);
    var geometry = new BufferGeometry();
    var material = new LineBasicMaterial({
      color: 0xffffff,
      vertexColors: true,
      toneMapped: false
    });
    var vertices = [];
    var colors = [];
    var pointMap = {};

    // near

    addLine('n1', 'n2');
    addLine('n2', 'n4');
    addLine('n4', 'n3');
    addLine('n3', 'n1');

    // far

    addLine('f1', 'f2');
    addLine('f2', 'f4');
    addLine('f4', 'f3');
    addLine('f3', 'f1');

    // sides

    addLine('n1', 'f1');
    addLine('n2', 'f2');
    addLine('n3', 'f3');
    addLine('n4', 'f4');

    // cone

    addLine('p', 'n1');
    addLine('p', 'n2');
    addLine('p', 'n3');
    addLine('p', 'n4');

    // up

    addLine('u1', 'u2');
    addLine('u2', 'u3');
    addLine('u3', 'u1');

    // target

    addLine('c', 't');
    addLine('p', 'c');

    // cross

    addLine('cn1', 'cn2');
    addLine('cn3', 'cn4');
    addLine('cf1', 'cf2');
    addLine('cf3', 'cf4');
    function addLine(a, b) {
      addPoint(a);
      addPoint(b);
    }
    function addPoint(id) {
      vertices.push(0, 0, 0);
      colors.push(0, 0, 0);
      if (pointMap[id] === undefined) {
        pointMap[id] = [];
      }
      pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    _this124 = _callSuper(this, CameraHelper, [geometry, material]);
    _this124.type = 'CameraHelper';
    _this124.camera = camera;
    if (_this124.camera.updateProjectionMatrix) _this124.camera.updateProjectionMatrix();
    _this124.matrix = camera.matrixWorld;
    _this124.matrixAutoUpdate = false;
    _this124.pointMap = pointMap;
    _this124.update();

    // colors

    var colorFrustum = new Color(0xffaa00);
    var colorCone = new Color(0xff0000);
    var colorUp = new Color(0x00aaff);
    var colorTarget = new Color(0xffffff);
    var colorCross = new Color(0x333333);
    _this124.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
    return _this124;
  }
  _inherits(CameraHelper, _LineSegments4);
  return _createClass(CameraHelper, [{
    key: "setColors",
    value: function setColors(frustum, cone, up, target, cross) {
      var geometry = this.geometry;
      var colorAttribute = geometry.getAttribute('color');

      // near

      colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b); // n1, n2
      colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b); // n2, n4
      colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b); // n4, n3
      colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b); // n3, n1

      // far

      colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b); // f1, f2
      colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b); // f2, f4
      colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b); // f4, f3
      colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b); // f3, f1

      // sides

      colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b); // n1, f1
      colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b); // n2, f2
      colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b); // n3, f3
      colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
      colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b); // n4, f4

      // cone

      colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
      colorAttribute.setXYZ(25, cone.r, cone.g, cone.b); // p, n1
      colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
      colorAttribute.setXYZ(27, cone.r, cone.g, cone.b); // p, n2
      colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
      colorAttribute.setXYZ(29, cone.r, cone.g, cone.b); // p, n3
      colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
      colorAttribute.setXYZ(31, cone.r, cone.g, cone.b); // p, n4

      // up

      colorAttribute.setXYZ(32, up.r, up.g, up.b);
      colorAttribute.setXYZ(33, up.r, up.g, up.b); // u1, u2
      colorAttribute.setXYZ(34, up.r, up.g, up.b);
      colorAttribute.setXYZ(35, up.r, up.g, up.b); // u2, u3
      colorAttribute.setXYZ(36, up.r, up.g, up.b);
      colorAttribute.setXYZ(37, up.r, up.g, up.b); // u3, u1

      // target

      colorAttribute.setXYZ(38, target.r, target.g, target.b);
      colorAttribute.setXYZ(39, target.r, target.g, target.b); // c, t
      colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
      colorAttribute.setXYZ(41, cross.r, cross.g, cross.b); // p, c

      // cross

      colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
      colorAttribute.setXYZ(43, cross.r, cross.g, cross.b); // cn1, cn2
      colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
      colorAttribute.setXYZ(45, cross.r, cross.g, cross.b); // cn3, cn4

      colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
      colorAttribute.setXYZ(47, cross.r, cross.g, cross.b); // cf1, cf2
      colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
      colorAttribute.setXYZ(49, cross.r, cross.g, cross.b); // cf3, cf4

      colorAttribute.needsUpdate = true;
    }
  }, {
    key: "update",
    value: function update() {
      var geometry = this.geometry;
      var pointMap = this.pointMap;
      var w = 1,
        h = 1;

      // we need just camera projection matrix inverse
      // world matrix must be identity

      _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);

      // center / target

      setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
      setPoint('t', pointMap, geometry, _camera, 0, 0, 1);

      // near

      setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
      setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
      setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
      setPoint('n4', pointMap, geometry, _camera, w, h, -1);

      // far

      setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
      setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
      setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
      setPoint('f4', pointMap, geometry, _camera, w, h, 1);

      // up

      setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
      setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
      setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);

      // cross

      setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
      setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
      setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
      setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
      setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
      setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
      setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
      setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
      geometry.getAttribute('position').needsUpdate = true;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);
}(LineSegments);
function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector.set(x, y, z).unproject(camera);
  var points = pointMap[point];
  if (points !== undefined) {
    var position = geometry.getAttribute('position');
    for (var i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
    }
  }
}
var _box = /*@__PURE__*/new Box3();
var BoxHelper = exports.BoxHelper = /*#__PURE__*/function (_LineSegments5) {
  function BoxHelper(object) {
    var _this125;
    var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xffff00;
    _classCallCheck(this, BoxHelper);
    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var positions = new Float32Array(8 * 3);
    var geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new BufferAttribute(positions, 3));
    _this125 = _callSuper(this, BoxHelper, [geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    })]);
    _this125.object = object;
    _this125.type = 'BoxHelper';
    _this125.matrixAutoUpdate = false;
    _this125.update();
    return _this125;
  }
  _inherits(BoxHelper, _LineSegments5);
  return _createClass(BoxHelper, [{
    key: "update",
    value: function update(object) {
      if (object !== undefined) {
        console.warn('THREE.BoxHelper: .update() has no longer arguments.');
      }
      if (this.object !== undefined) {
        _box.setFromObject(this.object);
      }
      if (_box.isEmpty()) return;
      var min = _box.min;
      var max = _box.max;

      /*
      	5____4
      1/___0/|
      | 6__|_7
      2/___3/
      	0: max.x, max.y, max.z
      1: min.x, max.y, max.z
      2: min.x, min.y, max.z
      3: max.x, min.y, max.z
      4: max.x, max.y, min.z
      5: min.x, max.y, min.z
      6: min.x, min.y, min.z
      7: max.x, min.y, min.z
      */

      var position = this.geometry.attributes.position;
      var array = position.array;
      array[0] = max.x;
      array[1] = max.y;
      array[2] = max.z;
      array[3] = min.x;
      array[4] = max.y;
      array[5] = max.z;
      array[6] = min.x;
      array[7] = min.y;
      array[8] = max.z;
      array[9] = max.x;
      array[10] = min.y;
      array[11] = max.z;
      array[12] = max.x;
      array[13] = max.y;
      array[14] = min.z;
      array[15] = min.x;
      array[16] = max.y;
      array[17] = min.z;
      array[18] = min.x;
      array[19] = min.y;
      array[20] = min.z;
      array[21] = max.x;
      array[22] = min.y;
      array[23] = min.z;
      position.needsUpdate = true;
      this.geometry.computeBoundingSphere();
    }
  }, {
    key: "setFromObject",
    value: function setFromObject(object) {
      this.object = object;
      this.update();
      return this;
    }
  }, {
    key: "copy",
    value: function copy(source, recursive) {
      _superPropGet(BoxHelper, "copy", this, 3)([source, recursive]);
      this.object = source.object;
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);
}(LineSegments);
var Box3Helper = exports.Box3Helper = /*#__PURE__*/function (_LineSegments6) {
  function Box3Helper(box) {
    var _this126;
    var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xffff00;
    _classCallCheck(this, Box3Helper);
    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    var geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    _this126 = _callSuper(this, Box3Helper, [geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    })]);
    _this126.box = box;
    _this126.type = 'Box3Helper';
    _this126.geometry.computeBoundingSphere();
    return _this126;
  }
  _inherits(Box3Helper, _LineSegments6);
  return _createClass(Box3Helper, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      var box = this.box;
      if (box.isEmpty()) return;
      box.getCenter(this.position);
      box.getSize(this.scale);
      this.scale.multiplyScalar(0.5);
      _superPropGet(Box3Helper, "updateMatrixWorld", this, 3)([force]);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);
}(LineSegments);
var PlaneHelper = exports.PlaneHelper = /*#__PURE__*/function (_Line3) {
  function PlaneHelper(plane) {
    var _this127;
    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var hex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0xffff00;
    _classCallCheck(this, PlaneHelper);
    var color = hex;
    var positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    _this127 = _callSuper(this, PlaneHelper, [geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    })]);
    _this127.type = 'PlaneHelper';
    _this127.plane = plane;
    _this127.size = size;
    var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
    var geometry2 = new BufferGeometry();
    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    _this127.add(new Mesh(geometry2, new MeshBasicMaterial({
      color: color,
      opacity: 0.2,
      transparent: true,
      depthWrite: false,
      toneMapped: false
    })));
    return _this127;
  }
  _inherits(PlaneHelper, _Line3);
  return _createClass(PlaneHelper, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      this.position.set(0, 0, 0);
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
      this.lookAt(this.plane.normal);
      this.translateZ(-this.plane.constant);
      _superPropGet(PlaneHelper, "updateMatrixWorld", this, 3)([force]);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
      this.children[0].geometry.dispose();
      this.children[0].material.dispose();
    }
  }]);
}(Line);
var _axis = /*@__PURE__*/new Vector3();
var _lineGeometry, _coneGeometry;
var ArrowHelper = exports.ArrowHelper = /*#__PURE__*/function (_Object3D17) {
  // dir is assumed to be normalized

  function ArrowHelper() {
    var _this128;
    var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(0, 0, 1);
    var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, 0);
    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0xffff00;
    var headLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : length * 0.2;
    var headWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : headLength * 0.2;
    _classCallCheck(this, ArrowHelper);
    _this128 = _callSuper(this, ArrowHelper);
    _this128.type = 'ArrowHelper';
    if (_lineGeometry === undefined) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    _this128.position.copy(origin);
    _this128.line = new Line(_lineGeometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    _this128.line.matrixAutoUpdate = false;
    _this128.add(_this128.line);
    _this128.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
      color: color,
      toneMapped: false
    }));
    _this128.cone.matrixAutoUpdate = false;
    _this128.add(_this128.cone);
    _this128.setDirection(dir);
    _this128.setLength(length, headLength, headWidth);
    return _this128;
  }
  _inherits(ArrowHelper, _Object3D17);
  return _createClass(ArrowHelper, [{
    key: "setDirection",
    value: function setDirection(dir) {
      // dir is assumed to be normalized

      if (dir.y > 0.99999) {
        this.quaternion.set(0, 0, 0, 1);
      } else if (dir.y < -0.99999) {
        this.quaternion.set(1, 0, 0, 0);
      } else {
        _axis.set(dir.z, 0, -dir.x).normalize();
        var radians = Math.acos(dir.y);
        this.quaternion.setFromAxisAngle(_axis, radians);
      }
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      var headLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : length * 0.2;
      var headWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : headLength * 0.2;
      this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
      this.line.updateMatrix();
      this.cone.scale.set(headWidth, headLength, headWidth);
      this.cone.position.y = length;
      this.cone.updateMatrix();
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      this.line.material.color.set(color);
      this.cone.material.color.set(color);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _superPropGet(ArrowHelper, "copy", this, 3)([source, false]);
      this.line.copy(source.line);
      this.cone.copy(source.cone);
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.line.geometry.dispose();
      this.line.material.dispose();
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    }
  }]);
}(Object3D);
var AxesHelper = exports.AxesHelper = /*#__PURE__*/function (_LineSegments7) {
  function AxesHelper() {
    var _this129;
    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    _classCallCheck(this, AxesHelper);
    var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
    var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    _this129 = _callSuper(this, AxesHelper, [geometry, material]);
    _this129.type = 'AxesHelper';
    return _this129;
  }
  _inherits(AxesHelper, _LineSegments7);
  return _createClass(AxesHelper, [{
    key: "setColors",
    value: function setColors(xAxisColor, yAxisColor, zAxisColor) {
      var color = new Color();
      var array = this.geometry.attributes.color.array;
      color.set(xAxisColor);
      color.toArray(array, 0);
      color.toArray(array, 3);
      color.set(yAxisColor);
      color.toArray(array, 6);
      color.toArray(array, 9);
      color.set(zAxisColor);
      color.toArray(array, 12);
      color.toArray(array, 15);
      this.geometry.attributes.color.needsUpdate = true;
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);
}(LineSegments);
var ShapePath = exports.ShapePath = /*#__PURE__*/function () {
  function ShapePath() {
    _classCallCheck(this, ShapePath);
    this.type = 'ShapePath';
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  return _createClass(ShapePath, [{
    key: "moveTo",
    value: function moveTo(x, y) {
      this.currentPath = new Path();
      this.subPaths.push(this.currentPath);
      this.currentPath.moveTo(x, y);
      return this;
    }
  }, {
    key: "lineTo",
    value: function lineTo(x, y) {
      this.currentPath.lineTo(x, y);
      return this;
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
      this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
      return this;
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
      return this;
    }
  }, {
    key: "splineThru",
    value: function splineThru(pts) {
      this.currentPath.splineThru(pts);
      return this;
    }
  }, {
    key: "toShapes",
    value: function toShapes(isCCW) {
      function toShapesNoHoles(inSubpaths) {
        var shapes = [];
        for (var i = 0, l = inSubpaths.length; i < l; i++) {
          var _tmpPath = inSubpaths[i];
          var _tmpShape = new Shape();
          _tmpShape.curves = _tmpPath.curves;
          shapes.push(_tmpShape);
        }
        return shapes;
      }
      function isPointInsidePolygon(inPt, inPolygon) {
        var polyLen = inPolygon.length;

        // inPt on polygon contour => immediate success    or
        // toggling of inside/outside at every single! intersection point of an edge
        //  with the horizontal line through inPt, left of inPt
        //  not counting lowerY endpoints of edges and whole edges on that line
        var inside = false;
        for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
          var edgeLowPt = inPolygon[p];
          var edgeHighPt = inPolygon[q];
          var edgeDx = edgeHighPt.x - edgeLowPt.x;
          var edgeDy = edgeHighPt.y - edgeLowPt.y;
          if (Math.abs(edgeDy) > Number.EPSILON) {
            // not parallel
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p];
              edgeDy = -edgeDy;
            }
            if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
            if (inPt.y === edgeLowPt.y) {
              if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
              // continue;				// no intersection or edgeLowPt => doesn't count !!!
            } else {
              var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge === 0) return true; // inPt is on contour ?
              if (perpEdge < 0) continue;
              inside = !inside; // true intersection left of inPt
            }
          } else {
            // parallel or collinear
            if (inPt.y !== edgeLowPt.y) continue; // parallel
            // edge lies on the same horizontal line as inPt
            if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
            // continue;
          }
        }
        return inside;
      }
      var isClockWise = ShapeUtils.isClockWise;
      var subPaths = this.subPaths;
      if (subPaths.length === 0) return [];
      var solid, tmpPath, tmpShape;
      var shapes = [];
      if (subPaths.length === 1) {
        tmpPath = subPaths[0];
        tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }
      var holesFirst = !isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst;

      // console.log("Holes first", holesFirst);

      var betterShapeHoles = [];
      var newShapes = [];
      var newShapeHoles = [];
      var mainIdx = 0;
      var tmpPoints;
      newShapes[mainIdx] = undefined;
      newShapeHoles[mainIdx] = [];
      for (var i = 0, l = subPaths.length; i < l; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;
        if (solid) {
          if (!holesFirst && newShapes[mainIdx]) mainIdx++;
          newShapes[mainIdx] = {
            s: new Shape(),
            p: tmpPoints
          };
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst) mainIdx++;
          newShapeHoles[mainIdx] = [];

          //console.log('cw', i);
        } else {
          newShapeHoles[mainIdx].push({
            h: tmpPath,
            p: tmpPoints[0]
          });

          //console.log('ccw', i);
        }
      }

      // only Holes? -> probably all Shapes with wrong orientation
      if (!newShapes[0]) return toShapesNoHoles(subPaths);
      if (newShapes.length > 1) {
        var ambiguous = false;
        var toChange = 0;
        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }
        for (var _sIdx = 0, _sLen = newShapes.length; _sIdx < _sLen; _sIdx++) {
          var sho = newShapeHoles[_sIdx];
          for (var hIdx = 0; hIdx < sho.length; hIdx++) {
            var ho = sho[hIdx];
            var hole_unassigned = true;
            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (_sIdx !== s2Idx) toChange++;
                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambiguous = true;
                }
              }
            }
            if (hole_unassigned) {
              betterShapeHoles[_sIdx].push(ho);
            }
          }
        }
        if (toChange > 0 && ambiguous === false) {
          newShapeHoles = betterShapeHoles;
        }
      }
      var tmpHoles;
      for (var _i98 = 0, il = newShapes.length; _i98 < il; _i98++) {
        tmpShape = newShapes[_i98].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[_i98];
        for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      }

      //console.log("shape", shapes);

      return shapes;
    }
  }]);
}();
var WebGLMultipleRenderTargets = exports.WebGLMultipleRenderTargets = /*#__PURE__*/function (_WebGLRenderTarget4) {
  // @deprecated, r162

  function WebGLMultipleRenderTargets() {
    var _this130;
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    _classCallCheck(this, WebGLMultipleRenderTargets);
    console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.');
    _this130 = _callSuper(this, WebGLMultipleRenderTargets, [width, height, _objectSpread(_objectSpread({}, options), {}, {
      count: count
    })]);
    _this130.isWebGLMultipleRenderTargets = true;
    return _this130;
  }
  _inherits(WebGLMultipleRenderTargets, _WebGLRenderTarget4);
  return _createClass(WebGLMultipleRenderTargets, [{
    key: "texture",
    get: function get() {
      return this.textures;
    }
  }]);
}(WebGLRenderTarget);
if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
      revision: REVISION
    }
  }));
}
if (typeof window !== 'undefined') {
  if (window.__THREE__) {
    console.warn('WARNING: Multiple instances of Three.js being imported.');
  } else {
    window.__THREE__ = REVISION;
  }
}
},{}],"node_modules/three/examples/jsm/controls/OrbitControls.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OrbitControls = void 0;
var _three = require("three");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
// OrbitControls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

var _changeEvent = {
  type: 'change'
};
var _startEvent = {
  type: 'start'
};
var _endEvent = {
  type: 'end'
};
var _ray = new _three.Ray();
var _plane = new _three.Plane();
var TILT_LIMIT = Math.cos(70 * _three.MathUtils.DEG2RAD);
var OrbitControls = exports.OrbitControls = /*#__PURE__*/function (_EventDispatcher) {
  function OrbitControls(object, domElement) {
    var _this;
    _classCallCheck(this, OrbitControls);
    _this = _callSuper(this, OrbitControls);
    _this.object = object;
    _this.domElement = domElement;
    _this.domElement.style.touchAction = 'none'; // disable touch scroll

    // Set to false to disable this control
    _this.enabled = true;

    // "target" sets the location of focus, where the object orbits around
    _this.target = new _three.Vector3();

    // Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect
    _this.cursor = new _three.Vector3();

    // How far you can dolly in and out ( PerspectiveCamera only )
    _this.minDistance = 0;
    _this.maxDistance = Infinity;

    // How far you can zoom in and out ( OrthographicCamera only )
    _this.minZoom = 0;
    _this.maxZoom = Infinity;

    // Limit camera target within a spherical area around the cursor
    _this.minTargetRadius = 0;
    _this.maxTargetRadius = Infinity;

    // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.
    _this.minPolarAngle = 0; // radians
    _this.maxPolarAngle = Math.PI; // radians

    // How far you can orbit horizontally, upper and lower limits.
    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
    _this.minAzimuthAngle = -Infinity; // radians
    _this.maxAzimuthAngle = Infinity; // radians

    // Set to true to enable damping (inertia)
    // If damping is enabled, you must call controls.update() in your animation loop
    _this.enableDamping = false;
    _this.dampingFactor = 0.05;

    // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    // Set to false to disable zooming
    _this.enableZoom = true;
    _this.zoomSpeed = 1.0;

    // Set to false to disable rotating
    _this.enableRotate = true;
    _this.rotateSpeed = 1.0;

    // Set to false to disable panning
    _this.enablePan = true;
    _this.panSpeed = 1.0;
    _this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
    _this.keyPanSpeed = 7.0; // pixels moved per arrow key push
    _this.zoomToCursor = false;

    // Set to true to automatically rotate around the target
    // If auto-rotate is enabled, you must call controls.update() in your animation loop
    _this.autoRotate = false;
    _this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

    // The four arrow keys
    _this.keys = {
      LEFT: 'ArrowLeft',
      UP: 'ArrowUp',
      RIGHT: 'ArrowRight',
      BOTTOM: 'ArrowDown'
    };

    // Mouse buttons
    _this.mouseButtons = {
      LEFT: _three.MOUSE.ROTATE,
      MIDDLE: _three.MOUSE.DOLLY,
      RIGHT: _three.MOUSE.PAN
    };

    // Touch fingers
    _this.touches = {
      ONE: _three.TOUCH.ROTATE,
      TWO: _three.TOUCH.DOLLY_PAN
    };

    // for reset
    _this.target0 = _this.target.clone();
    _this.position0 = _this.object.position.clone();
    _this.zoom0 = _this.object.zoom;

    // the target DOM element for key events
    _this._domElementKeyEvents = null;

    //
    // public methods
    //

    _this.getPolarAngle = function () {
      return spherical.phi;
    };
    _this.getAzimuthalAngle = function () {
      return spherical.theta;
    };
    _this.getDistance = function () {
      return this.object.position.distanceTo(this.target);
    };
    _this.listenToKeyEvents = function (domElement) {
      domElement.addEventListener('keydown', onKeyDown);
      this._domElementKeyEvents = domElement;
    };
    _this.stopListenToKeyEvents = function () {
      this._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
      this._domElementKeyEvents = null;
    };
    _this.saveState = function () {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    _this.reset = function () {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };

    // this method is exposed, but perhaps it would be better if we can make it private...
    _this.update = function () {
      var offset = new _three.Vector3();

      // so camera.up is the orbit axis
      var quat = new _three.Quaternion().setFromUnitVectors(object.up, new _three.Vector3(0, 1, 0));
      var quatInverse = quat.clone().invert();
      var lastPosition = new _three.Vector3();
      var lastQuaternion = new _three.Quaternion();
      var lastTargetPosition = new _three.Vector3();
      var twoPI = 2 * Math.PI;
      return function update() {
        var deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);

        // rotate offset to "y-axis-is-up" space
        offset.applyQuaternion(quat);

        // angle from z-axis around y-axis
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle(deltaTime));
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }

        // restrict theta to be between desired limits

        var min = scope.minAzimuthAngle;
        var max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI) min += twoPI;else if (min > Math.PI) min -= twoPI;
          if (max < -Math.PI) max += twoPI;else if (max > Math.PI) max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }

        // restrict phi to be between desired limits
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();

        // move target to panned location

        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }

        // Limit the target distance from the cursor to create a sphere around the center of interest
        scope.target.sub(scope.cursor);
        scope.target.clampLength(scope.minTargetRadius, scope.maxTargetRadius);
        scope.target.add(scope.cursor);
        var zoomChanged = false;
        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
        // we adjust zoom later in these cases
        if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {
          spherical.radius = clampDistance(spherical.radius);
        } else {
          var prevRadius = spherical.radius;
          spherical.radius = clampDistance(spherical.radius * scale);
          zoomChanged = prevRadius != spherical.radius;
        }
        offset.setFromSpherical(spherical);

        // rotate offset back to "camera-up-vector-is-up" space
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }

        // adjust camera position
        if (scope.zoomToCursor && performCursorZoom) {
          var newRadius = null;
          if (scope.object.isPerspectiveCamera) {
            // move the camera down the pointer ray
            // this method avoids floating point error
            var _prevRadius = offset.length();
            newRadius = clampDistance(_prevRadius * scale);
            var radiusDelta = _prevRadius - newRadius;
            scope.object.position.addScaledVector(dollyDirection, radiusDelta);
            scope.object.updateMatrixWorld();
            zoomChanged = !!radiusDelta;
          } else if (scope.object.isOrthographicCamera) {
            // adjust the ortho camera position based on zoom changes
            var mouseBefore = new _three.Vector3(mouse.x, mouse.y, 0);
            mouseBefore.unproject(scope.object);
            var prevZoom = scope.object.zoom;
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));
            scope.object.updateProjectionMatrix();
            zoomChanged = prevZoom !== scope.object.zoom;
            var mouseAfter = new _three.Vector3(mouse.x, mouse.y, 0);
            mouseAfter.unproject(scope.object);
            scope.object.position.sub(mouseAfter).add(mouseBefore);
            scope.object.updateMatrixWorld();
            newRadius = offset.length();
          } else {
            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.');
            scope.zoomToCursor = false;
          }

          // handle the placement of the target
          if (newRadius !== null) {
            if (this.screenSpacePanning) {
              // position the orbit target in front of the new camera position
              scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);
            } else {
              // get the ray and translation plane to compute target
              _ray.origin.copy(scope.object.position);
              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);

              // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
              // extremely large values
              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {
                object.lookAt(scope.target);
              } else {
                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);
                _ray.intersectPlane(_plane, scope.target);
              }
            }
          }
        } else if (scope.object.isOrthographicCamera) {
          var _prevZoom = scope.object.zoom;
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));
          if (_prevZoom !== scope.object.zoom) {
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          }
        }
        scale = 1;
        performCursorZoom = false;

        // update condition is:
        // min(camera displacement, camera rotation in radians)^2 > EPS
        // using small-angle approximation cos(x/2) = 1 - x^2 / 8

        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS || lastTargetPosition.distanceToSquared(scope.target) > EPS) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          lastTargetPosition.copy(scope.target);
          return true;
        }
        return false;
      };
    }();
    _this.dispose = function () {
      scope.domElement.removeEventListener('contextmenu', onContextMenu);
      scope.domElement.removeEventListener('pointerdown', onPointerDown);
      scope.domElement.removeEventListener('pointercancel', onPointerUp);
      scope.domElement.removeEventListener('wheel', onMouseWheel);
      scope.domElement.removeEventListener('pointermove', onPointerMove);
      scope.domElement.removeEventListener('pointerup', onPointerUp);
      var document = scope.domElement.getRootNode(); // offscreen canvas compatibility

      document.removeEventListener('keydown', interceptControlDown, {
        capture: true
      });
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
        scope._domElementKeyEvents = null;
      }

      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
    };

    //
    // internals
    //

    var scope = _this;
    var STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    var state = STATE.NONE;
    var EPS = 0.000001;

    // current position in spherical coordinates
    var spherical = new _three.Spherical();
    var sphericalDelta = new _three.Spherical();
    var scale = 1;
    var panOffset = new _three.Vector3();
    var rotateStart = new _three.Vector2();
    var rotateEnd = new _three.Vector2();
    var rotateDelta = new _three.Vector2();
    var panStart = new _three.Vector2();
    var panEnd = new _three.Vector2();
    var panDelta = new _three.Vector2();
    var dollyStart = new _three.Vector2();
    var dollyEnd = new _three.Vector2();
    var dollyDelta = new _three.Vector2();
    var dollyDirection = new _three.Vector3();
    var mouse = new _three.Vector2();
    var performCursorZoom = false;
    var pointers = [];
    var pointerPositions = {};
    var controlActive = false;
    function getAutoRotationAngle(deltaTime) {
      if (deltaTime !== null) {
        return 2 * Math.PI / 60 * scope.autoRotateSpeed * deltaTime;
      } else {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
    }
    function getZoomScale(delta) {
      var normalizedDelta = Math.abs(delta * 0.01);
      return Math.pow(0.95, scope.zoomSpeed * normalizedDelta);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    var panLeft = function () {
      var v = new _three.Vector3();
      return function panLeft(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();
    var panUp = function () {
      var v = new _three.Vector3();
      return function panUp(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();

    // deltaX and deltaY are in pixels; right and down are positive
    var pan = function () {
      var offset = new _three.Vector3();
      return function pan(deltaX, deltaY) {
        var element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          // perspective
          var position = scope.object.position;
          offset.copy(position).sub(scope.target);
          var targetDistance = offset.length();

          // half of the fov is center to top of screen
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

          // we use only clientHeight here so aspect ratio does not distort speed
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          // orthographic
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          // camera neither orthographic nor perspective
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
        scale /= dollyScale;
      } else {
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
        scale *= dollyScale;
      } else {
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        scope.enableZoom = false;
      }
    }
    function updateZoomParameters(x, y) {
      if (!scope.zoomToCursor) {
        return;
      }
      performCursorZoom = true;
      var rect = scope.domElement.getBoundingClientRect();
      var dx = x - rect.left;
      var dy = y - rect.top;
      var w = rect.width;
      var h = rect.height;
      mouse.x = dx / w * 2 - 1;
      mouse.y = -(dy / h) * 2 + 1;
      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();
    }
    function clampDistance(dist) {
      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));
    }

    //
    // event callbacks - update the object state
    //

    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      updateZoomParameters(event.clientX, event.clientX);
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      var element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale(dollyDelta.y));
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale(dollyDelta.y));
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      updateZoomParameters(event.clientX, event.clientY);
      if (event.deltaY < 0) {
        dollyIn(getZoomScale(event.deltaY));
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale(event.deltaY));
      }
      scope.update();
    }
    function handleKeyDown(event) {
      var needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, -scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(-scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        // prevent the browser from scrolling on cursor keys
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate(event) {
      if (pointers.length === 1) {
        rotateStart.set(event.pageX, event.pageY);
      } else {
        var position = getSecondPointerPosition(event);
        var x = 0.5 * (event.pageX + position.x);
        var y = 0.5 * (event.pageY + position.y);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan(event) {
      if (pointers.length === 1) {
        panStart.set(event.pageX, event.pageY);
      } else {
        var position = getSecondPointerPosition(event);
        var x = 0.5 * (event.pageX + position.x);
        var y = 0.5 * (event.pageY + position.y);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly(event) {
      var position = getSecondPointerPosition(event);
      var dx = event.pageX - position.x;
      var dy = event.pageY - position.y;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan(event) {
      if (scope.enableZoom) handleTouchStartDolly(event);
      if (scope.enablePan) handleTouchStartPan(event);
    }
    function handleTouchStartDollyRotate(event) {
      if (scope.enableZoom) handleTouchStartDolly(event);
      if (scope.enableRotate) handleTouchStartRotate(event);
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        var position = getSecondPointerPosition(event);
        var x = 0.5 * (event.pageX + position.x);
        var y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      var element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        var position = getSecondPointerPosition(event);
        var x = 0.5 * (event.pageX + position.x);
        var y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      var position = getSecondPointerPosition(event);
      var dx = event.pageX - position.x;
      var dy = event.pageY - position.y;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
      var centerX = (event.pageX + position.x) * 0.5;
      var centerY = (event.pageY + position.y) * 0.5;
      updateZoomParameters(centerX, centerY);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event);
      if (scope.enablePan) handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event);
      if (scope.enableRotate) handleTouchMoveRotate(event);
    }

    //
    // event handlers - FSM: listen for events and reset state
    //

    function onPointerDown(event) {
      if (scope.enabled === false) return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener('pointermove', onPointerMove);
        scope.domElement.addEventListener('pointerup', onPointerUp);
      }

      //

      if (isTrackingPointer(event)) return;

      //

      addPointer(event);
      if (event.pointerType === 'touch') {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false) return;
      if (event.pointerType === 'touch') {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      removePointer(event);
      switch (pointers.length) {
        case 0:
          scope.domElement.releasePointerCapture(event.pointerId);
          scope.domElement.removeEventListener('pointermove', onPointerMove);
          scope.domElement.removeEventListener('pointerup', onPointerUp);
          scope.dispatchEvent(_endEvent);
          state = STATE.NONE;
          break;
        case 1:
          var pointerId = pointers[0];
          var position = pointerPositions[pointerId];

          // minimal placeholder event - allows state correction on pointer-up
          onTouchStart({
            pointerId: pointerId,
            pageX: position.x,
            pageY: position.y
          });
          break;
      }
    }
    function onMouseDown(event) {
      var mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case _three.MOUSE.DOLLY:
          if (scope.enableZoom === false) return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case _three.MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false) return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false) return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case _three.MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false) return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false) return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false) return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false) return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false) return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(customWheelEvent(event));
      scope.dispatchEvent(_endEvent);
    }
    function customWheelEvent(event) {
      var mode = event.deltaMode;

      // minimal wheel event altered to meet delta-zoom demand
      var newEvent = {
        clientX: event.clientX,
        clientY: event.clientY,
        deltaY: event.deltaY
      };
      switch (mode) {
        case 1:
          // LINE_MODE
          newEvent.deltaY *= 16;
          break;
        case 2:
          // PAGE_MODE
          newEvent.deltaY *= 100;
          break;
      }

      // detect if event was triggered by pinching
      if (event.ctrlKey && !controlActive) {
        newEvent.deltaY *= 10;
      }
      return newEvent;
    }
    function interceptControlDown(event) {
      if (event.key === 'Control') {
        controlActive = true;
        var _document = scope.domElement.getRootNode(); // offscreen canvas compatibility

        _document.addEventListener('keyup', interceptControlUp, {
          passive: true,
          capture: true
        });
      }
    }
    function interceptControlUp(event) {
      if (event.key === 'Control') {
        controlActive = false;
        var _document2 = scope.domElement.getRootNode(); // offscreen canvas compatibility

        _document2.removeEventListener('keyup', interceptControlUp, {
          passive: true,
          capture: true
        });
      }
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false) return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case _three.TOUCH.ROTATE:
              if (scope.enableRotate === false) return;
              handleTouchStartRotate(event);
              state = STATE.TOUCH_ROTATE;
              break;
            case _three.TOUCH.PAN:
              if (scope.enablePan === false) return;
              handleTouchStartPan(event);
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case _three.TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false) return;
              handleTouchStartDollyPan(event);
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case _three.TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false) return;
              handleTouchStartDollyRotate(event);
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false) return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false) return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false) return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false) return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false) return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event.pointerId);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (var i = 0; i < pointers.length; i++) {
        if (pointers[i] == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function isTrackingPointer(event) {
      for (var i = 0; i < pointers.length; i++) {
        if (pointers[i] == event.pointerId) return true;
      }
      return false;
    }
    function trackPointer(event) {
      var position = pointerPositions[event.pointerId];
      if (position === undefined) {
        position = new _three.Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      var pointerId = event.pointerId === pointers[0] ? pointers[1] : pointers[0];
      return pointerPositions[pointerId];
    }

    //

    scope.domElement.addEventListener('contextmenu', onContextMenu);
    scope.domElement.addEventListener('pointerdown', onPointerDown);
    scope.domElement.addEventListener('pointercancel', onPointerUp);
    scope.domElement.addEventListener('wheel', onMouseWheel, {
      passive: false
    });
    var document = scope.domElement.getRootNode(); // offscreen canvas compatibility

    document.addEventListener('keydown', interceptControlDown, {
      passive: true,
      capture: true
    });

    // force an update at start

    _this.update();
    return _this;
  }
  _inherits(OrbitControls, _EventDispatcher);
  return _createClass(OrbitControls);
}(_three.EventDispatcher);
},{"three":"node_modules/three/build/three.module.js"}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineWorkerModule = defineWorkerModule;
exports.stringifyFunction = stringifyFunction;
exports.terminateWorker = terminateWorker;
/**
 * Main content for the worker that handles the loading and execution of
 * modules within it.
 */
function workerBootstrap() {
  var modules = Object.create(null);

  // Handle messages for registering a module
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0) dependencies = [];
    var init = ref.init;
    if (init === void 0) init = function () {};
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0) getTransferables = null;

    // Only register once
    if (modules[id]) {
      return;
    }
    try {
      // If any dependencies are modules, ensure they're registered and grab their value
      dependencies = dependencies.map(function (dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function (depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });

      // Rehydrate functions
      init = rehydrate("<" + name + ">.init", init);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }

      // Initialize the module and store its value
      var value = null;
      if (typeof init === 'function') {
        value = init.apply(void 0, dependencies);
      } else {
        console.error('worker module init function failed to rehydrate');
      }
      modules[id] = {
        id: id,
        value: value,
        getTransferables: getTransferables
      };
      callback(value);
    } catch (err) {
      if (!(err && err.noLog)) {
        console.error(err);
      }
      callback(err);
    }
  }

  // Handle messages for calling a registered module's result function
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== 'function') {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === 'function') {
        result.then(handleResult, function (rej) {
          return callback(rej instanceof Error ? rej : new Error('' + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err) {
      callback(err);
    }
    function handleResult(result) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = undefined; //postMessage is very picky about not passing null or empty transferables
        }
        callback(result, tx);
      } catch (err) {
        console.error(err);
        callback(err);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function (r) {
      return result = r;
    };
    var url = URL.createObjectURL(new Blob(["/** " + name.replace(/\*/g, '') + " **/\n\ntroikaDefine(\n" + str + "\n)"], {
      type: 'application/javascript'
    }));
    try {
      importScripts(url);
    } catch (err) {
      console.error(err);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }

  // Handler for all messages within the worker
  self.addEventListener('message', function (e) {
    var ref = e.data;
    var messageId = ref.messageId;
    var action = ref.action;
    var data = ref.data;
    try {
      // Module registration
      if (action === 'registerModule') {
        registerModule(data, function (result) {
          if (result instanceof Error) {
            postMessage({
              messageId: messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId: messageId,
              success: true,
              result: {
                isCallable: typeof result === 'function'
              }
            });
          }
        });
      }
      // Invocation
      if (action === 'callModule') {
        callModule(data, function (result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId: messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId: messageId,
              success: true,
              result: result
            }, transferables || undefined);
          }
        });
      }
    } catch (err) {
      postMessage({
        messageId: messageId,
        success: false,
        error: err.stack
      });
    }
  });
}

/**
 * Fallback for `defineWorkerModule` that behaves identically but runs in the main
 * thread, for when the execution environment doesn't support web workers or they
 * are disallowed due to e.g. CSP security restrictions.
 */
function defineMainThreadModule(options) {
  var moduleFunc = function () {
    var args = [],
      len = arguments.length;
    while (len--) args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function (initResult) {
      if (typeof initResult === 'function') {
        return initResult.apply(void 0, args);
      } else {
        throw new Error('Worker module function was called but `init` did not return a callable function');
      }
    });
  };
  moduleFunc._getInitResult = function () {
    // We can ignore getTransferables in main thread. TODO workerId?
    var dependencies = options.dependencies;
    var init = options.init;

    // Resolve dependencies
    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) {
      return dep && dep._getInitResult ? dep._getInitResult() : dep;
    }) : [];

    // Invoke init with the resolved dependencies
    var initPromise = Promise.all(dependencies).then(function (deps) {
      return init.apply(null, deps);
    });

    // Cache the resolved promise for subsequent calls
    moduleFunc._getInitResult = function () {
      return initPromise;
    };
    return initPromise;
  };
  return moduleFunc;
}
var supportsWorkers = function () {
  var supported = false;

  // Only attempt worker initialization in browsers; elsewhere it would just be
  // noise e.g. loading into a Node environment for SSR.
  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {
    try {
      // TODO additional checks for things like importScripts within the worker?
      //  Would need to be an async check.
      var worker = new Worker(URL.createObjectURL(new Blob([''], {
        type: 'application/javascript'
      })));
      worker.terminate();
      supported = true;
    } catch (err) {
      if (typeof process !== 'undefined' && "development" === 'test') ;else {
        console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err.message + "]");
      }
    }
  }

  // Cached result
  supportsWorkers = function () {
    return supported;
  };
  return supported;
};
var _workerModuleId = 0;
var _messageId = 0;
var _allowInitAsString = false;
var workers = Object.create(null);
var registeredModules = Object.create(null); //workerId -> Set<unregisterFn>
var openRequests = Object.create(null);

/**
 * Define a module of code that will be executed with a web worker. This provides a simple
 * interface for moving chunks of logic off the main thread, and managing their dependencies
 * among one another.
 *
 * @param {object} options
 * @param {function} options.init
 * @param {array} [options.dependencies]
 * @param {function} [options.getTransferables]
 * @param {string} [options.name]
 * @param {string} [options.workerId]
 * @return {function(...[*]): {then}}
 */
function defineWorkerModule(options) {
  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {
    throw new Error('requires `options.init` function');
  }
  var dependencies = options.dependencies;
  var init = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  if (!supportsWorkers()) {
    return defineMainThreadModule(options);
  }
  if (workerId == null) {
    workerId = '#default';
  }
  var id = "workerModule" + ++_workerModuleId;
  var name = options.name || id;
  var registrationPromise = null;
  dependencies = dependencies && dependencies.map(function (dep) {
    // Wrap raw functions as worker modules with no dependencies
    if (typeof dep === 'function' && !dep.workerModuleData) {
      _allowInitAsString = true;
      dep = defineWorkerModule({
        workerId: workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction(dep) + "\n)}"
      });
      _allowInitAsString = false;
    }
    // Grab postable data for worker modules
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [],
      len = arguments.length;
    while (len--) args[len] = arguments[len];

    // Register this module if needed
    if (!registrationPromise) {
      registrationPromise = callWorker(workerId, 'registerModule', moduleFunc.workerModuleData);
      var unregister = function () {
        registrationPromise = null;
        registeredModules[workerId].delete(unregister);
      };
      (registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);
    }

    // Invoke the module, returning a promise
    return registrationPromise.then(function (ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker(workerId, 'callModule', {
          id: id,
          args: args
        });
      } else {
        throw new Error('Worker module function was called but `init` did not return a callable function');
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id: id,
    name: name,
    dependencies: dependencies,
    init: stringifyFunction(init),
    getTransferables: getTransferables && stringifyFunction(getTransferables)
  };
  return moduleFunc;
}

/**
 * Terminate an active Worker by a workerId that was passed to defineWorkerModule.
 * This only terminates the Worker itself; the worker module will remain available
 * and if you call it again its Worker will be respawned.
 * @param {string} workerId
 */
function terminateWorker(workerId) {
  // Unregister all modules that were registered in that worker
  if (registeredModules[workerId]) {
    registeredModules[workerId].forEach(function (unregister) {
      unregister();
    });
  }
  // Terminate the Worker object
  if (workers[workerId]) {
    workers[workerId].terminate();
    delete workers[workerId];
  }
}

/**
 * Stringifies a function into a form that can be deserialized in the worker
 * @param fn
 */
function stringifyFunction(fn) {
  var str = fn.toString();
  // If it was defined in object method/property format, it needs to be modified
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = 'function ' + str;
  }
  return str;
}
function getWorker(workerId) {
  var worker = workers[workerId];
  if (!worker) {
    // Bootstrap the worker's content
    var bootstrap = stringifyFunction(workerBootstrap);

    // Create the worker from the bootstrap function content
    worker = workers[workerId] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, '') + " **/\n\n;(" + bootstrap + ")()"], {
      type: 'application/javascript'
    })));

    // Single handler for response messages from the worker
    worker.onmessage = function (e) {
      var response = e.data;
      var msgId = response.messageId;
      var callback = openRequests[msgId];
      if (!callback) {
        throw new Error('WorkerModule response with empty or unknown messageId');
      }
      delete openRequests[msgId];
      callback(response);
    };
  }
  return worker;
}

// Issue a call to the worker with a callback to handle the response
function callWorker(workerId, action, data) {
  return new Promise(function (resolve, reject) {
    var messageId = ++_messageId;
    openRequests[messageId] = function (response) {
      if (response.success) {
        resolve(response.result);
      } else {
        reject(new Error("Error in worker " + action + " call: " + response.error));
      }
    };
    getWorker(workerId).postMessage({
      messageId: messageId,
      action: action,
      data: data
    });
  });
}
},{"process":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SDFGenerator;
function SDFGenerator() {
  var exports = function (exports) {
    /**
     * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]
     */
    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t, pointOut) {
      var t2 = 1 - t;
      pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;
      pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;
    }

    /**
     * Find the point on a cubic bezier curve at t where t is in the range [0, 1]
     */
    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {
      var t2 = 1 - t;
      pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;
      pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;
    }

    /**
     * Parse a path string into its constituent line/curve commands, invoking a callback for each.
     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z
     * @param {function(
     *   command: 'L'|'Q'|'C',
     *   startX: number,
     *   startY: number,
     *   endX: number,
     *   endY: number,
     *   ctrl1X?: number,
     *   ctrl1Y?: number,
     *   ctrl2X?: number,
     *   ctrl2Y?: number
     * )} commandCallback - A callback function that will be called once for each parsed path command, passing the
     *                      command identifier (only L/Q/C commands) and its numeric arguments.
     */
    function forEachPathCommand(pathString, commandCallback) {
      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
      var match, firstX, firstY, prevX, prevY;
      while (match = segmentRE.exec(pathString)) {
        var args = match[2].replace(/^\s*|\s*$/g, '').split(/[,\s]+/).map(function (v) {
          return parseFloat(v);
        });
        switch (match[1]) {
          case 'M':
            prevX = firstX = args[0];
            prevY = firstY = args[1];
            break;
          case 'L':
            if (args[0] !== prevX || args[1] !== prevY) {
              // yup, some fonts have zero-length line commands
              commandCallback('L', prevX, prevY, prevX = args[0], prevY = args[1]);
            }
            break;
          case 'Q':
            {
              commandCallback('Q', prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);
              break;
            }
          case 'C':
            {
              commandCallback('C', prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);
              break;
            }
          case 'Z':
            if (prevX !== firstX || prevY !== firstY) {
              commandCallback('L', prevX, prevY, firstX, firstY);
            }
            break;
        }
      }
    }

    /**
     * Convert a path string to a series of straight line segments
     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z
     * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback
     *        function that will be called once for every line segment
     * @param {number} [curvePoints] - How many straight line segments to use when approximating a
     *        bezier curve in the path. Defaults to 16.
     */
    function pathToLineSegments(pathString, segmentCallback, curvePoints) {
      if (curvePoints === void 0) curvePoints = 16;
      var tempPoint = {
        x: 0,
        y: 0
      };
      forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {
        switch (command) {
          case 'L':
            segmentCallback(startX, startY, endX, endY);
            break;
          case 'Q':
            {
              var prevCurveX = startX;
              var prevCurveY = startY;
              for (var i = 1; i < curvePoints; i++) {
                pointOnQuadraticBezier(startX, startY, ctrl1X, ctrl1Y, endX, endY, i / (curvePoints - 1), tempPoint);
                segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);
                prevCurveX = tempPoint.x;
                prevCurveY = tempPoint.y;
              }
              break;
            }
          case 'C':
            {
              var prevCurveX$1 = startX;
              var prevCurveY$1 = startY;
              for (var i$1 = 1; i$1 < curvePoints; i$1++) {
                pointOnCubicBezier(startX, startY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endX, endY, i$1 / (curvePoints - 1), tempPoint);
                segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);
                prevCurveX$1 = tempPoint.x;
                prevCurveY$1 = tempPoint.y;
              }
              break;
            }
        }
      });
    }
    var viewportQuadVertex = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var copyTexFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}";
    var cache = new WeakMap();
    var glContextParams = {
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      antialias: false,
      depth: false
    };

    /**
     * This is a little helper library for WebGL. It assists with state management for a GL context.
     * It's pretty tightly wrapped to the needs of this package, not very general-purpose.
     *
     * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap
     * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback
     */
    function withWebGLContext(glOrCanvas, callback) {
      var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;
      var wrapper = cache.get(gl);
      if (!wrapper) {
        var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
        var extensions = {};
        var programs = {};
        var textures = {};
        var textureUnit = -1;
        var framebufferStack = [];
        gl.canvas.addEventListener('webglcontextlost', function (e) {
          handleContextLoss();
          e.preventDefault();
        }, false);
        function getExtension(name) {
          var ext = extensions[name];
          if (!ext) {
            ext = extensions[name] = gl.getExtension(name);
            if (!ext) {
              throw new Error(name + " not supported");
            }
          }
          return ext;
        }
        function compileShader(src, type) {
          var shader = gl.createShader(type);
          gl.shaderSource(shader, src);
          gl.compileShader(shader);
          // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)
          // if (!status && !gl.isContextLost()) {
          //   throw new Error(gl.getShaderInfoLog(shader).trim())
          // }
          return shader;
        }
        function withProgram(name, vert, frag, func) {
          if (!programs[name]) {
            var attributes = {};
            var uniforms = {};
            var program = gl.createProgram();
            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));
            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));
            gl.linkProgram(program);
            programs[name] = {
              program: program,
              transaction: function transaction(func) {
                gl.useProgram(program);
                func({
                  setUniform: function setUniform(type, name) {
                    var values = [],
                      len = arguments.length - 2;
                    while (len-- > 0) values[len] = arguments[len + 2];
                    var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));
                    gl["uniform" + type].apply(gl, [uniformLoc].concat(values));
                  },
                  setAttribute: function setAttribute(name, size, usage, instancingDivisor, data) {
                    var attr = attributes[name];
                    if (!attr) {
                      attr = attributes[name] = {
                        buf: gl.createBuffer(),
                        // TODO should we destroy our buffers?
                        loc: gl.getAttribLocation(program, name),
                        data: null
                      };
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);
                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(attr.loc);
                    if (isWebGL2) {
                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);
                    } else {
                      getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);
                    }
                    if (data !== attr.data) {
                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);
                      attr.data = data;
                    }
                  }
                });
              }
            };
          }
          programs[name].transaction(func);
        }
        function withTexture(name, func) {
          textureUnit++;
          try {
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            var texture = textures[name];
            if (!texture) {
              texture = textures[name] = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
            func(texture, textureUnit);
          } finally {
            textureUnit--;
          }
        }
        function withTextureFramebuffer(texture, textureUnit, func) {
          var framebuffer = gl.createFramebuffer();
          framebufferStack.push(framebuffer);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.activeTexture(gl.TEXTURE0 + textureUnit);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          try {
            func(framebuffer);
          } finally {
            gl.deleteFramebuffer(framebuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);
          }
        }
        function handleContextLoss() {
          extensions = {};
          programs = {};
          textures = {};
          textureUnit = -1;
          framebufferStack.length = 0;
        }
        cache.set(gl, wrapper = {
          gl: gl,
          isWebGL2: isWebGL2,
          getExtension: getExtension,
          withProgram: withProgram,
          withTexture: withTexture,
          withTextureFramebuffer: withTextureFramebuffer,
          handleContextLoss: handleContextLoss
        });
      }
      callback(wrapper);
    }
    function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {
      if (channels === void 0) channels = 15;
      if (framebuffer === void 0) framebuffer = null;
      withWebGLContext(glOrCanvas, function (ref) {
        var gl = ref.gl;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        withTexture('copy', function (tex, texUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
          withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {
            var setUniform = ref.setUniform;
            var setAttribute = ref.setAttribute;
            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));
            setUniform('1i', 'image', texUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);
            gl.disable(gl.BLEND);
            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);
            gl.viewport(x, y, width, height);
            gl.scissor(x, y, width, height);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
      });
    }

    /**
     * Resizing a canvas clears its contents; this utility copies the previous contents over.
     * @param canvas
     * @param newWidth
     * @param newHeight
     */
    function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {
      var width = canvas.width;
      var height = canvas.height;
      withWebGLContext(canvas, function (ref) {
        var gl = ref.gl;
        var data = new Uint8Array(width * height * 4);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        canvas.width = newWidth;
        canvas.height = newHeight;
        renderImageData(gl, data, 0, 0, width, height);
      });
    }
    var webglUtils = /*#__PURE__*/Object.freeze({
      __proto__: null,
      withWebGLContext: withWebGLContext,
      renderImageData: renderImageData,
      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing
    });
    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (sdfExponent === void 0) sdfExponent = 1;
      var textureData = new Uint8Array(sdfWidth * sdfHeight);
      var viewBoxWidth = viewBox[2] - viewBox[0];
      var viewBoxHeight = viewBox[3] - viewBox[1];

      // Decompose all paths into straight line segments and add them to an index
      var segments = [];
      pathToLineSegments(path, function (x1, y1, x2, y2) {
        segments.push({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          minX: Math.min(x1, x2),
          minY: Math.min(y1, y2),
          maxX: Math.max(x1, x2),
          maxY: Math.max(y1, y2)
        });
      });

      // Sort segments by maxX, this will let us short-circuit some loops below
      segments.sort(function (a, b) {
        return a.maxX - b.maxX;
      });

      // For each target SDF texel, find the distance from its center to its nearest line segment,
      // map that distance to an alpha value, and write that alpha to the texel
      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {
        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {
          var signedDist = findNearestSignedDistance(viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth, viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight);

          // Use an exponential scale to ensure the texels very near the glyph path have adequate
          // precision, while allowing the distance field to cover the entire texture, given that
          // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam
          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;
          if (signedDist < 0) {
            alpha = 1 - alpha;
          }
          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp
          textureData[sdfY * sdfWidth + sdfX] = alpha;
        }
      }
      return textureData;

      /**
       * For a given x/y, search the index for the closest line segment and return
       * its signed distance. Negative = inside, positive = outside, zero = on edge
       * @param x
       * @param y
       * @returns {number}
       */
      function findNearestSignedDistance(x, y) {
        var closestDistSq = Infinity;
        var closestDist = Infinity;
        for (var i = segments.length; i--;) {
          var seg = segments[i];
          if (seg.maxX + closestDist <= x) {
            break;
          } //sorting by maxX means no more can be closer, so we can short-circuit
          if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {
            var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);
            if (distSq < closestDistSq) {
              closestDistSq = distSq;
              closestDist = Math.sqrt(closestDistSq);
            }
          }
        }

        // Flip to negative distance if inside the poly
        if (isPointInPoly(x, y)) {
          closestDist = -closestDist;
        }
        return closestDist;
      }

      /**
       * Determine whether the given point lies inside or outside the glyph. Uses a simple
       * winding-number ray casting algorithm using a ray pointing east from the point.
       */
      function isPointInPoly(x, y) {
        var winding = 0;
        for (var i = segments.length; i--;) {
          var seg = segments[i];
          if (seg.maxX <= x) {
            break;
          } //sorting by maxX means no more can cross, so we can short-circuit
          var intersects = seg.y1 > y !== seg.y2 > y && x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1;
          if (intersects) {
            winding += seg.y1 < seg.y2 ? 1 : -1;
          }
        }
        return winding !== 0;
      }
    }
    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y === void 0) y = 0;
      if (channel === void 0) channel = 0;
      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
    }
    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y === void 0) y = 0;
      if (channel === void 0) channel = 0;
      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);
      // Expand single-channel data to rbga
      var rgbaData = new Uint8Array(data.length * 4);
      for (var i = 0; i < data.length; i++) {
        rgbaData[i * 4 + channel] = data[i];
      }
      renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);
    }

    /**
     * Find the absolute distance from a point to a line segment at closest approach
     */
    function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {
      var ldx = lineX1 - lineX0;
      var ldy = lineY1 - lineY0;
      var lengthSq = ldx * ldx + ldy * ldy;
      var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;
      var dx = x - (lineX0 + t * ldx);
      var dy = y - (lineY0 + t * ldy);
      return dx * dx + dy * dy;
    }
    var javascript = /*#__PURE__*/Object.freeze({
      __proto__: null,
      generate: generate$2,
      generateIntoCanvas: generateIntoCanvas$2,
      generateIntoFramebuffer: generateIntoFramebuffer$1
    });
    var mainVertex = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var mainFragment = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}";
    var postFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}";

    // Single triangle covering viewport
    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);
    var implicitContext = null;
    var isTestingSupport = false;
    var NULL_OBJECT = {};
    var supportByCanvas = new WeakMap(); // canvas -> bool

    function validateSupport(glOrCanvas) {
      if (!isTestingSupport && !isSupported(glOrCanvas)) {
        throw new Error('WebGL generation not supported');
      }
    }
    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (glOrCanvas === void 0) glOrCanvas = null;
      if (!glOrCanvas) {
        glOrCanvas = implicitContext;
        if (!glOrCanvas) {
          var canvas = typeof OffscreenCanvas === 'function' ? new OffscreenCanvas(1, 1) : typeof document !== 'undefined' ? document.createElement('canvas') : null;
          if (!canvas) {
            throw new Error('OffscreenCanvas or DOM canvas not supported');
          }
          glOrCanvas = implicitContext = canvas.getContext('webgl', {
            depth: false
          });
        }
      }
      validateSupport(glOrCanvas);
      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari

      // Render into a background texture framebuffer
      withWebGLContext(glOrCanvas, function (ref) {
        var gl = ref.gl;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        withTexture('readable', function (texture, textureUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          withTextureFramebuffer(texture, textureUnit, function (framebuffer) {
            generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, gl, framebuffer, 0, 0, 0 // red channel
            );
            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);
          });
        });
      });

      // Throw away all but the red channel
      var data = new Uint8Array(sdfWidth * sdfHeight);
      for (var i = 0, j = 0; i < rgbaData.length; i += 4) {
        data[j++] = rgbaData[i];
      }
      return data;
    }
    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y === void 0) y = 0;
      if (channel === void 0) channel = 0;
      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
    }
    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y === void 0) y = 0;
      if (channel === void 0) channel = 0;

      // Verify support
      validateSupport(glOrCanvas);

      // Compute path segments
      var lineSegmentCoords = [];
      pathToLineSegments(path, function (x1, y1, x2, y2) {
        lineSegmentCoords.push(x1, y1, x2, y2);
      });
      lineSegmentCoords = new Float32Array(lineSegmentCoords);
      withWebGLContext(glOrCanvas, function (ref) {
        var gl = ref.gl;
        var isWebGL2 = ref.isWebGL2;
        var getExtension = ref.getExtension;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        var handleContextLoss = ref.handleContextLoss;
        withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {
          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, intermediateTexture._lastWidth = sdfWidth, intermediateTexture._lastHeight = sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }

          // Unsigned distance pass
          withProgram('main', mainVertex, mainFragment, function (ref) {
            var setAttribute = ref.setAttribute;
            var setUniform = ref.setUniform;

            // Init extensions
            var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');
            var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');

            // Init/update attributes
            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);
            setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);

            // Init/update uniforms
            setUniform.apply(void 0, ['4f', 'uGlyphBounds'].concat(viewBox));
            setUniform('1f', 'uMaxDistance', maxDistance);
            setUniform('1f', 'uExponent', sdfExponent);

            // Render initial unsigned distance / winding number info to a texture
            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {
              gl.enable(gl.BLEND);
              gl.colorMask(true, true, true, true);
              gl.viewport(0, 0, sdfWidth, sdfHeight);
              gl.scissor(0, 0, sdfWidth, sdfHeight);
              gl.blendFunc(gl.ONE, gl.ONE);
              // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a "winding number".
              // Alpha holds the closest (MAX) unsigned distance.
              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);
              gl.clear(gl.COLOR_BUFFER_BIT);
              if (isWebGL2) {
                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              } else {
                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              }
              // Debug
              // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)
              // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)
              // console.log('intermediate texture data: ', debug)
            });
          });

          // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.
          withProgram('post', viewportQuadVertex, postFragment, function (program) {
            program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);
            program.setUniform('1i', 'tex', intermediateTextureUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.disable(gl.BLEND);
            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);
            gl.viewport(x, y, sdfWidth, sdfHeight);
            gl.scissor(x, y, sdfWidth, sdfHeight);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });

        // Handle context loss occurring during any of the above calls
        if (gl.isContextLost()) {
          handleContextLoss();
          throw new Error('webgl context lost');
        }
      });
    }
    function isSupported(glOrCanvas) {
      var key = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;
      var supported = supportByCanvas.get(key);
      if (supported === undefined) {
        isTestingSupport = true;
        var failReason = null;
        try {
          // Since we can't detect all failure modes up front, let's just do a trial run of a
          // simple path and compare what we get back to the correct expected result. This will
          // also serve to prime the shader compilation.
          var expectedResult = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97];
          var testResult = generate$1(4, 4, 'M8,8L16,8L24,24L16,24Z', [0, 0, 32, 32], 24, 1, glOrCanvas);
          supported = testResult && expectedResult.length === testResult.length && testResult.every(function (val, i) {
            return val === expectedResult[i];
          });
          if (!supported) {
            failReason = 'bad trial run results';
            console.info(expectedResult, testResult);
          }
        } catch (err) {
          // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?
          supported = false;
          failReason = err.message;
        }
        if (failReason) {
          console.warn('WebGL SDF generation not supported:', failReason);
        }
        isTestingSupport = false;
        supportByCanvas.set(key, supported);
      }
      return supported;
    }
    var webgl = /*#__PURE__*/Object.freeze({
      __proto__: null,
      generate: generate$1,
      generateIntoCanvas: generateIntoCanvas$1,
      generateIntoFramebuffer: generateIntoFramebuffer,
      isSupported: isSupported
    });

    /**
     * Generate an SDF texture image for a 2D path.
     *
     * @param {number} sdfWidth - width of the SDF output image in pixels.
     * @param {number} sdfHeight - height of the SDF output image in pixels.
     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.
     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.
     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults
     *        to half the maximum viewBox dimension.
     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents
     *        will give greater precision nearer the glyph's path.
     * @return {Uint8Array}
     */
    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0) sdfExponent = 1;
      try {
        return generate$1.apply(webgl, arguments);
      } catch (e) {
        console.info('WebGL SDF generation failed, falling back to JS', e);
        return generate$2.apply(javascript, arguments);
      }
    }

    /**
     * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position
     * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels
     * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.
     *
     * @param {number} sdfWidth - width of the SDF output image in pixels.
     * @param {number} sdfHeight - height of the SDF output image in pixels.
     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.
     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.
     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults
     *        to half the maximum viewBox dimension.
     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents
     *        will give greater precision nearer the glyph's path.
     * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.
     *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results
     *        due to shared GL context state, this canvas should be dedicated to use by this library alone.
     * @param {number} x - the x position at which to render the SDF.
     * @param {number} y - the y position at which to render the SDF.
     * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.
     * @return {Uint8Array}
     */
    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0) sdfExponent = 1;
      if (x === void 0) x = 0;
      if (y === void 0) y = 0;
      if (channel === void 0) channel = 0;
      try {
        return generateIntoCanvas$1.apply(webgl, arguments);
      } catch (e) {
        console.info('WebGL SDF generation failed, falling back to JS', e);
        return generateIntoCanvas$2.apply(javascript, arguments);
      }
    }
    exports.forEachPathCommand = forEachPathCommand;
    exports.generate = generate;
    exports.generateIntoCanvas = generateIntoCanvas;
    exports.javascript = javascript;
    exports.pathToLineSegments = pathToLineSegments;
    exports.webgl = webgl;
    exports.webglUtils = webglUtils;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    return exports;
  }({});
  return exports;
}
},{}],"node_modules/bidi-js/dist/bidi.mjs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function bidiFactory() {
  var bidi = function (exports) {
    // Bidi character types data, auto generated
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1; //L is the default
    TYPES_TO_NAMES[1] = 'L';
    Object.keys(DATA).forEach(function (type, i) {
      TYPES[type] = 1 << i + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        //const start = performance.now()
        map = new Map();
        var loop = function (type) {
          if (DATA.hasOwnProperty(type)) {
            var lastCode = 0;
            DATA[type].split(',').forEach(function (range) {
              var ref = range.split('+');
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type]);
              for (var i = 0; i < step; i++) {
                map.set(++lastCode, TYPES[type]);
              }
            });
          }
        };
        for (var type in DATA) loop(type);
        //console.log(`char types parsed in ${performance.now() - start}ms`)
      }
    }

    /**
     * @param {string} char
     * @return {number}
     */
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }

    // Bidi bracket pairs data, auto generated
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };

    /**
     * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or
     * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object
     * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.
     * @param {string} encodedString
     * @param {boolean} includeReverse - true if you want reverseMap in the output
     * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}
     */
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map = new Map();
      var reverseMap = includeReverse && new Map();
      var prevPair;
      encodedString.split(',').forEach(function visit(entry) {
        if (entry.indexOf('+') !== -1) {
          for (var i = +entry; i--;) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split('>');
          var a = ref[0];
          var b = ref[1];
          a = String.fromCodePoint(lastCode += parseInt(a, radix));
          b = String.fromCodePoint(lastCode += parseInt(b, radix));
          map.set(a, b);
          includeReverse && reverseMap.set(b, a);
        }
      });
      return {
        map: map,
        reverseMap: reverseMap
      };
    }
    var openToClose, closeToOpen, canonical;
    function parse$1() {
      if (!openToClose) {
        //const start = performance.now()
        var ref = parseCharacterMap(data$1.pairs, true);
        var map = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
        //console.log(`brackets parsed in ${performance.now() - start}ms`)
      }
    }
    function openingToClosingBracket(char) {
      parse$1();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$1();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$1();
      return canonical.get(char) || null;
    }

    // Local type aliases
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;

    /**
     * @typedef {object} GetEmbeddingLevelsResult
     * @property {{start, end, level}[]} paragraphs
     * @property {Uint8Array} levels
     */

    /**
     * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels
     * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved
     * base embedding level.
     *
     * @param {string} string - The input string
     * @param {"ltr"|"rtl"|"auto"} [baseDirection] - Use "ltr" or "rtl" to force a base paragraph direction,
     *        otherwise a direction will be chosen automatically from each paragraph's contents.
     * @return {GetEmbeddingLevelsResult}
     */
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;

      // Start by mapping all characters to their unicode type, as a bitmask integer
      var charTypes = new Uint32Array(string.length);
      for (var i = 0; i < string.length; i++) {
        charTypes[i] = getBidiCharType(string[i]);
      }
      var charTypeCounts = new Map(); //will be cleared at start of each paragraph
      function changeCharType(i, type) {
        var oldType = charTypes[i];
        charTypes[i] = type;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);
        if (type & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = new Map(); //init->pdi and pdi->init

      // === 3.3.1 The Paragraph Level ===
      // 3.3.1 P1: Split the text into paragraphs
      var paragraphs = []; // [{start, end, level}, ...]
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function (n) {
        return n + (n & 1 ? 1 : 2);
      };
      var nextOdd = function (n) {
        return n + (n & 1 ? 2 : 1);
      };

      // Everything from here on will operate per paragraph.
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0 //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();

        // === 3.3.2 Explicit Levels and Directions ===
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];

          // Set initial counts
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }

          // Explicit Embeddings: 3.3.2 X2 - X3
          if (charType & FORMATTING_TYPES) {
            //prefilter all formatters
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level; // 5.2
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            }

            // Explicit Overrides: 3.3.2 X4 - X5
            else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level; // 5.2
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            }

            // Isolates: 3.3.2 X5a - X5c
            else if (charType & ISOLATE_INIT_TYPES) {
              // X5c - FSI becomes either RLI or LRI
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            }

            // Terminating Isolates: 3.3.2 X6a
            else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                // Add to isolation pairs bidirectional mapping:
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            }

            // Terminating Embeddings and Overrides: 3.3.2 X7
            else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level; // 5.2
            }

            // End of Paragraph: 3.3.2 X8
            else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          }

          // Non-formatting characters: 3.3.2 X6
          else {
            embedLevels[i$2] = stackTop._level;
            // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }

        // === 3.3.3 Preparations for Implicit Processing ===

        // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9
        // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to
        // easily ignore them all from here on out.

        // 3.3.3 X10
        // Compute the set of isolating run sequences as specified by BD13
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            // build flat list of indices across all runs:
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            // determine the sos/eos types:
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                //5.2
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  //5.2
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }

        // The next steps are done per isolating run sequence
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          /**
           * All the level runs in an isolating run sequence have the same embedding level.
           * 
           * DO NOT change any `embedLevels[i]` within the current scope.
           */
          var embedDirection = embedLevels[seqIndices$1[0]] & 1 ? TYPE_R : TYPE_L;

          // === 3.3.4 Resolving Weak Types ===

          // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose
          // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its
          // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    //5.2 scan back to first non-BN
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }

          // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)
          // is found. If an AL is found, change the type of the European number to Arabic number.
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }

          // W3. Change all ALs to R
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }

          // W4. A single European separator between two European numbers changes to a European number. A single common
          // separator between two numbers of the same type changes to that type.
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0,
                  nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    //5.2
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    //5.2
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }

          // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (si$4++; si$4 < seqIndices$1.length && charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN); si$4++) {
                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
                    changeCharType(seqIndices$1[si$4], TYPE_EN);
                  }
                }
              }
            }
          }

          // W6. Otherwise, separators and terminators change to Other Neutral.
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                // 5.2 transform adjacent BNs too:
                for (var sj$5 = si$5 - 1; sj$5 >= 0 && charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES; sj$5--) {
                  changeCharType(seqIndices$1[sj$5], TYPE_ON);
                }
                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6++) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
              }
            }
          }

          // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)
          // is found. If an L is found, then change the type of the European number to L.
          // NOTE: implemented in single forward pass for efficiency
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }

          // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===

          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text
            // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional
            // types EN and AN are treated as R.
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;

            // * Identify the bracket pairs in the current isolating run sequence according to BD16.
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                // NOTE: for any potential bracket character we also test that it still carries a NI
                // type, as that may have been changed earlier. This doesn't seem to be explicitly
                // called out in the spec, but is required for passage of certain tests.
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  // Opening bracket
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({
                        char: char,
                        seqIndex: si$7
                      });
                    } else {
                      break;
                    }
                  }
                  // Closing bracket
                  else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx; //pop the matching bracket and all following
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function (a, b) {
                return a[0] - b[0];
              });
            }
            // * For each bracket-pair element in the list of pairs of text positions
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.
              // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both
              // brackets in the pair to match the embedding direction.
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === embedDirection) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test
              // for an established context with a preceding strong type by checking backwards before the opening paired
              // bracket until the first strong type (L, R, or sos) is found.
              //    1. If the preceding strong type is also opposite the embedding direction, context is established, so
              //    set the type for both brackets in the pair to that direction.
              //    2. Otherwise set the type for both brackets in the pair to the embedding direction.
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== embedDirection) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = embedDirection;
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                // * Any number of characters that had original bidirectional character type NSM prior to the application
                // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match
                // the type of their preceding bracket.
                if (useStrongType !== embedDirection) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== embedDirection) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }

            // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the
            // same direction.
            // N2. Any remaining NIs take the embedding direction.
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12,
                  niRunEnd = si$12;
                var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
                }
                si$12 = niRunEnd;
              }
            }
          }
        }

        // === 3.3.6 Resolving Implicit Levels ===

        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          }
          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level
          // and those of type AN or EN go up two levels.
          else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }

          // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,
          // and otherwise to the base level.
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }

          // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or
          // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.
          // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }

      // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters
      // according to section 3.4 Reordering Resolved Levels
      return {
        levels: embedLevels,
        paragraphs: paragraphs
      };
      function determineAutoEmbedLevel(start, isFSI) {
        // 3.3.1 P2 - P3
        for (var i = start; i < string.length; i++) {
          var charType = charTypes[i];
          if (charType & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType & (TYPE_B | TYPE_L) || isFSI && charType === TYPE_PDI) {
            return 0;
          }
          if (charType & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i);
            i = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        // 3.1.2 BD9
        var isolationLevel = 1;
        for (var i = isolateStart + 1; i < string.length; i++) {
          var charType = charTypes[i];
          if (charType & TYPE_B) {
            break;
          }
          if (charType & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i;
            }
          } else if (charType & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
    }

    // Bidi mirrored chars data, auto generated
    var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse() {
      if (!mirrorMap) {
        //const start = performance.now()
        var ref = parseCharacterMap(data, true);
        var map = ref.map;
        var reverseMap = ref.reverseMap;
        // Combine both maps into one
        reverseMap.forEach(function (value, key) {
          map.set(key, value);
        });
        mirrorMap = map;
        //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)
      }
    }
    function getMirroredCharacter(char) {
      parse();
      return mirrorMap.get(char) || null;
    }

    /**
     * Given a string and its resolved embedding levels, build a map of indices to replacement chars
     * for any characters in right-to-left segments that have defined mirrored characters.
     * @param string
     * @param embeddingLevels
     * @param [start]
     * @param [end]
     * @return {Map<number, string>}
     */
    function getMirroredCharactersMap(string, embeddingLevels, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var map = new Map();
      for (var i = start; i <= end; i++) {
        if (embeddingLevels[i] & 1) {
          //only odd (rtl) levels
          var mirror = getMirroredCharacter(string[i]);
          if (mirror !== null) {
            map.set(i, mirror);
          }
        }
      }
      return map;
    }

    /**
     * Given a start and end denoting a single line within a string, and a set of precalculated
     * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.
     * @param {string} string - the full input string
     * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels
     * @param {number} [start] - first character in a subset of the full string
     * @param {number} [end] - last character in a subset of the full string
     * @return {number[][]} - the list of start/end segments that should be flipped, in order.
     */
    function getReorderSegments(string, embeddingLevelsResult, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function (paragraph) {
        var lineStart = Math.max(start, paragraph.start);
        var lineEnd = Math.min(end, paragraph.end);
        if (lineStart < lineEnd) {
          // Local slice for mutation
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);

          // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the
          // end of the line to the paragraph level.
          for (var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--) {
            lineLevels[i] = paragraph.level;
          }

          // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels
          // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + lineStart, i$2 + lineStart]);
                }
              }
            }
          }
        }
      });
      return segments;
    }

    /**
     * @param {string} string
     * @param {GetEmbeddingLevelsResult} embedLevelsResult
     * @param {number} [start]
     * @param {number} [end]
     * @return {string} the new string with bidi segments reordered
     */
    function getReorderedString(string, embedLevelsResult, start, end) {
      var indices = getReorderedIndices(string, embedLevelsResult, start, end);
      var chars = [].concat(string);
      indices.forEach(function (charIndex, i) {
        chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join('');
    }

    /**
     * @param {string} string
     * @param {GetEmbeddingLevelsResult} embedLevelsResult
     * @param {number} [start]
     * @param {number} [end]
     * @return {number[]} an array with character indices in their new bidi order
     */
    function getReorderedIndices(string, embedLevelsResult, start, end) {
      var segments = getReorderSegments(string, embedLevelsResult, start, end);
      // Fill an array with indices
      var indices = [];
      for (var i = 0; i < string.length; i++) {
        indices[i] = i;
      }
      // Reverse each segment in order
      segments.forEach(function (ref) {
        var start = ref[0];
        var end = ref[1];
        var slice = indices.slice(start, end + 1);
        for (var i = slice.length; i--;) {
          indices[end - i] = slice[i];
        }
      });
      return indices;
    }
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    return exports;
  }({});
  return bidi;
}
var _default = exports.default = bidiFactory;
},{}],"node_modules/troika-three-utils/dist/troika-three-utils.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BezierMesh = void 0;
exports.createDerivedMaterial = createDerivedMaterial;
exports.expandShaderIncludes = expandShaderIncludes;
exports.getShaderUniformTypes = getShaderUniformTypes;
exports.getShadersForMaterial = getShadersForMaterial;
exports.invertMatrix4 = invertMatrix4;
exports.voidMainRegExp = void 0;
var _three = require("three");
/**
 * Regular expression for matching the `void main() {` opener line in GLSL.
 * @type {RegExp}
 */
const voidMainRegExp = exports.voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;

/**
 * Recursively expands all `#include <xyz>` statements within string of shader code.
 * Copied from three's WebGLProgram#parseIncludes for external use.
 *
 * @param {string} source - The GLSL source code to evaluate
 * @return {string} The GLSL code with all includes expanded
 */
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = _three.ShaderChunk[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}

/*
 * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three
 * versions before 0.113.0 as it was changed from Math to MathUtils in that version.
 * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16
 */

const _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);
}
function generateUUID() {
  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

  const d0 = Math.random() * 0xffffffff | 0;
  const d1 = Math.random() * 0xffffffff | 0;
  const d2 = Math.random() * 0xffffffff | 0;
  const d3 = Math.random() * 0xffffffff | 0;
  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

  // .toUpperCase() here flattens concatenated strings to save heap memory space.
  return uuid.toUpperCase();
}

// Local assign polyfill to avoid importing troika-core
const assign = Object.assign || function /*target, ...sources*/
() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
};
const epoch = Date.now();
const CONSTRUCTOR_CACHE = new WeakMap();
const SHADER_UPGRADE_CACHE = new Map();

// Material ids must be integers, but we can't access the increment from Three's `Material` module,
// so let's choose a sufficiently large starting value that should theoretically never collide.
let materialInstanceId = 1e10;

/**
 * A utility for creating a custom shader material derived from another material's
 * shaders. This allows you to inject custom shader logic and transforms into the
 * builtin ThreeJS materials without having to recreate them from scratch.
 *
 * @param {THREE.Material} baseMaterial - the original material to derive from
 *
 * @param {Object} options - How the base material should be modified.
 * @param {Object} options.defines - Custom `defines` for the material
 * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`
 * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can
 *        be accessed and manipulated via the resulting material's `uniforms` property, just like
 *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.
 * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into
 *        both shaders, and it will automatically be updated on each render frame with a number of
 *        elapsed milliseconds. The "zero" epoch time is not significant so don't rely on this as a
 *        true calendar time.
 * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level
 *        definitions, above the `void main()` function.
 * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex
 *        shader's `void main` function.
 * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex
 *        shader's `void main` function.
 * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,
 *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with
 *        those attributes exposed by their normal names as read/write values.
 * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level
 *        definitions, above the `void main()` function.
 * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment
 *        shader's `void main` function.
 * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment
 *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes
 *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you
 *        want those to apply to your changes use `fragmentColorTransform` instead.
 * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`
 *        output value. Will be injected near the end of the `void main` function, but before any
 *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the
 *        `fragmentMainOutro`.
 * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function
 *        for performing custom rewrites of the full shader code. Useful if you need to do something
 *        special that's not covered by the other builtin options. This function will be executed before
 *        any other transforms are applied.
 * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base
 *        material, rather than the default behavior of copying it. This allows the derived material to
 *        automatically pick up changes made to the base material and its properties. This can be useful
 *        where the derived material is hidden from the user as an implementation detail, allowing them
 *        to work with the original material like normal. But it can result in unexpected behavior if not
 *        handled carefully.
 *
 * @return {THREE.Material}
 *
 * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,
 * which can be called to get a variant of the derived material for use in shadow casting. If the
 * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`
 * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to
 * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These
 * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look
 * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance
 * scenarios, e.g. skipping antialiasing or expensive shader logic.
 */
function createDerivedMaterial(baseMaterial, options) {
  // Generate a key that is unique to the content of these `options`. We'll use this
  // throughout for caching and for generating the upgraded shader code. This increases
  // the likelihood that the resulting shaders will line up across multiple calls so
  // their GL programs can be shared and cached.
  const optionsKey = getKeyForOptions(options);

  // First check to see if we've already derived from this baseMaterial using this
  // unique set of options, and if so reuse the constructor to avoid some allocations.
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;

  // Private onBeforeCompile handler that injects the modified shaders and uniforms when
  // the renderer switches to this material's program
  const onBeforeCompile = function (shaderInfo, renderer) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);

    // Upgrade the shaders, caching the result by incoming source code
    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
    }

    // Inject upgraded shaders and uniforms into the program
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign(shaderInfo.uniforms, this.uniforms);

    // Inject auto-updating time uniform if requested
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }

    // Users can still add their own handlers on top of ours
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function (base) {
    // Prototype chain to the base material
    const derived = Object.create(base, descriptor);

    // Store the baseMaterial for reference; this is always the original even when cloning
    Object.defineProperty(derived, 'baseMaterial', {
      value: baseMaterial
    });

    // Needs its own ids
    Object.defineProperty(derived, 'id', {
      value: materialInstanceId++
    });
    derived.uuid = generateUUID();

    // Merge uniforms, defines, and extensions
    derived.uniforms = assign({}, base.uniforms, options.uniforms);
    derived.defines = assign({}, base.defines, options.defines);
    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material
    derived.extensions = assign({}, base.extensions, options.extensions);

    // Don't inherit EventDispatcher listeners
    derived._listeners = undefined;
    return derived;
  };
  const descriptor = {
    constructor: {
      value: DerivedMaterial
    },
    isDerivedMaterial: {
      value: true
    },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function () {
        return baseMaterial.customProgramCacheKey() + '|' + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function (source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign(this.extensions, source.extensions);
          assign(this.defines, source.defines);
          assign(this.uniforms, _three.UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function () {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function () {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new _three.MeshDepthMaterial({
            depthPacking: _three.RGBADepthPacking
          }), options);
          depthMaterial.defines.IS_DEPTH_MATERIAL = '';
          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function () {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new _three.MeshDistanceMaterial(), options);
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';
          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const {
          _depthMaterial,
          _distanceMaterial
        } = this;
        if (_depthMaterial) _depthMaterial.dispose();
        if (_distanceMaterial) _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders(material, {
  vertexShader,
  fragmentShader
}, options, key) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || '';
  vertexMainIntro = vertexMainIntro || '';
  vertexMainOutro = vertexMainOutro || '';
  fragmentDefs = fragmentDefs || '';
  fragmentMainIntro = fragmentMainIntro || '';
  fragmentMainOutro = fragmentMainOutro || '';

  // Expand includes if needed
  if (vertexTransform || customRewriter) {
    vertexShader = expandShaderIncludes(vertexShader);
  }
  if (fragmentColorTransform || customRewriter) {
    // We need to be able to find postprocessing chunks after include expansion in order to
    // put them after the fragmentColorTransform, so mark them with comments first. Even if
    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,
    // so we still mark them.
    fragmentShader = fragmentShader.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n');
    fragmentShader = expandShaderIncludes(fragmentShader);
  }

  // Apply custom rewriter function
  if (customRewriter) {
    let res = customRewriter({
      vertexShader,
      fragmentShader
    });
    vertexShader = res.vertexShader;
    fragmentShader = res.fragmentShader;
  }

  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract
  // those and re-insert them into the outro in the correct place:
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader = fragmentShader.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
    // [^]+? = non-greedy match of any chars including newlines
    match => {
      postChunks.push(match);
      return '';
    });
    fragmentMainOutro = `${fragmentColorTransform}\n${postChunks.join('\n')}\n${fragmentMainOutro}`;
  }

  // Inject auto-updating time uniform if requested
  if (timeUniform) {
    const code = `\nuniform float ${timeUniform};\n`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }

  // Inject a function for the vertexTransform and rename all usages of position/normal/uv
  if (vertexTransform) {
    // Hoist these defs to the very top so they work in other function defs
    vertexShader = `vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`;
    vertexShader = vertexShader.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;
    });

    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'
    // Perhaps the other textures too going forward?
    if (!(material.map && material.map.channel > 0)) {
      vertexShader = vertexShader.replace(/\bMAP_UV\b/g, `troika_uv_${key}`);
    }
  }

  // Inject defs and intro/outro snippets
  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader,
    fragmentShader
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(voidMainRegExp, `
${defs}
void troikaOrigMain${id}() {`);
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key, value) {
  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;
}
let _idCtr = 0;
const optionsHashesToIds = new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}

// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders
// TODO how can we keep this from getting stale?
const MATERIAL_TYPES_TO_SHADERS = {
  MeshDepthMaterial: 'depth',
  MeshDistanceMaterial: 'distanceRGBA',
  MeshNormalMaterial: 'normal',
  MeshBasicMaterial: 'basic',
  MeshLambertMaterial: 'lambert',
  MeshPhongMaterial: 'phong',
  MeshToonMaterial: 'toon',
  MeshStandardMaterial: 'physical',
  MeshPhysicalMaterial: 'physical',
  MeshMatcapMaterial: 'matcap',
  LineBasicMaterial: 'basic',
  LineDashedMaterial: 'dashed',
  PointsMaterial: 'points',
  ShadowMaterial: 'shadow',
  SpriteMaterial: 'sprite'
};

/**
 * Given a Three.js `Material` instance, find the shaders/uniforms that will be
 * used to render that material.
 *
 * @param material - the Material instance
 * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`
 */
function getShadersForMaterial(material) {
  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];
  return builtinType ? _three.ShaderLib[builtinType] : material; //TODO fallback for unknown type?
}

/**
 * Find all uniforms and their types within a shader code string.
 *
 * @param {string} shader - The shader code to parse
 * @return {object} mapping of uniform names to their glsl type
 */
function getShaderUniformTypes(shader) {
  let uniformRE = /\buniform\s+(int|float|vec[234]|mat[34])\s+([A-Za-z_][\w]*)/g;
  let uniforms = Object.create(null);
  let match;
  while ((match = uniformRE.exec(shader)) !== null) {
    uniforms[match[2]] = match[1];
  }
  return uniforms;
}

/**
 * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion
 * that happened in ThreeJS r123.
 * @param {Matrix4} srcMatrix
 * @param {Matrix4} [tgtMatrix]
 */
function invertMatrix4(srcMatrix, tgtMatrix = new _three.Matrix4()) {
  if (typeof tgtMatrix.invert === 'function') {
    tgtMatrix.copy(srcMatrix).invert();
  } else {
    tgtMatrix.getInverse(srcMatrix);
  }
  return tgtMatrix;
}

/*
Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,
divided into a reasonable number of height segments.
*/

const vertexDefs = `
uniform vec3 pointA;
uniform vec3 controlA;
uniform vec3 controlB;
uniform vec3 pointB;
uniform float radius;
varying float bezierT;

vec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {
  float t2 = 1.0 - t;
  float b0 = t2 * t2 * t2;
  float b1 = 3.0 * t * t2 * t2;
  float b2 = 3.0 * t * t * t2;
  float b3 = t * t * t;
  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;
}

vec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {
  float t2 = 1.0 - t;
  return -3.0 * p1 * t2 * t2 +
    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +
    c2 * (6.0 * t2 * t - 3.0 * t * t) +
    3.0 * p2 * t * t;
}
`;
const vertexTransform = `
float t = position.y;
bezierT = t;
vec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);
vec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));

// Make "sideways" always perpendicular to the camera ray; this ensures that any twists
// in the cylinder occur where you won't see them: 
vec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);
if (bezierDir == viewDirection) {
  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));
}
vec3 sideways = normalize(cross(bezierDir, viewDirection));
vec3 upish = normalize(cross(sideways, bezierDir));

// Build a matrix for transforming this disc in the cylinder:
mat4 discTx;
discTx[0].xyz = sideways * radius;
discTx[1].xyz = bezierDir * radius;
discTx[2].xyz = upish * radius;
discTx[3].xyz = bezierCenterPos;
discTx[3][3] = 1.0;

// Apply transform, ignoring original y
position = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;
normal = normalize(mat3(discTx) * normal);
`;
const fragmentDefs = `
uniform vec3 dashing;
varying float bezierT;
`;
const fragmentMainIntro = `
if (dashing.x + dashing.y > 0.0) {
  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);
  if (dashFrac > dashing.x) {
    discard;
  }
}
`;

// Debugging: separate color for each of the 6 sides:
// const fragmentColorTransform = `
// float sideNum = floor(vUV.x * 6.0);
// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :
//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :
//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :
//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :
//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :
//   vec3(1.0, 0.0, 1.0);
// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);
// `

function createBezierMeshMaterial(baseMaterial) {
  return createDerivedMaterial(baseMaterial, {
    chained: true,
    uniforms: {
      pointA: {
        value: new _three.Vector3()
      },
      controlA: {
        value: new _three.Vector3()
      },
      controlB: {
        value: new _three.Vector3()
      },
      pointB: {
        value: new _three.Vector3()
      },
      radius: {
        value: 0.01
      },
      dashing: {
        value: new _three.Vector3()
      } //on, off, offset
    },
    vertexDefs,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro
  });
}
let geometry = null;
const defaultBaseMaterial = /*#__PURE__*/new _three.MeshStandardMaterial({
  color: 0xffffff,
  side: _three.DoubleSide
});

/**
 * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done
 * by deforming a straight cylindrical geometry in the vertex shader based on a set of four
 * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`
 * automatically.
 *
 * The cubiz bezier path is determined by its four `Vector3` properties:
 * - `pointA`
 * - `controlA`
 * - `controlB`
 * - `pointB`
 *
 * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.
 *
 * You can also give the tube a dashed appearance with two properties:
 *
 * - `dashArray` - an array of two numbers, defining the length of "on" and "off" parts of
 *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length
 *   used as input to the cubic bezier function, not its visible length.)
 * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.
 *
 * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on
 * thicker tubes.
 *
 * TODO: proper geometry bounding sphere and raycasting
 * TODO: allow control of the geometry's segment counts
 */
class BezierMesh extends _three.Mesh {
  static getGeometry() {
    return geometry || (geometry = new _three.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));
  }
  constructor() {
    super(BezierMesh.getGeometry(), defaultBaseMaterial);
    this.pointA = new _three.Vector3();
    this.controlA = new _three.Vector3();
    this.controlB = new _three.Vector3();
    this.pointB = new _three.Vector3();
    this.radius = 0.01;
    this.dashArray = new _three.Vector2();
    this.dashOffset = 0;

    // TODO - disabling frustum culling until I figure out how to customize the
    //  geometry's bounding sphere that gets used
    this.frustumCulled = false;
  }

  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let derivedMaterial = this._derivedMaterial;
    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());
    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);
      // dispose the derived material when its base material is disposed:
      baseMaterial.addEventListener('dispose', function onDispose() {
        baseMaterial.removeEventListener('dispose', onDispose);
        derivedMaterial.dispose();
      });
    }
    return derivedMaterial;
  }
  set material(baseMaterial) {
    this._baseMaterial = baseMaterial;
  }

  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return this.material.getDepthMaterial();
  }
  get customDistanceMaterial() {
    return this.material.getDistanceMaterial();
  }
  onBeforeRender() {
    const {
      uniforms
    } = this.material;
    const {
      pointA,
      controlA,
      controlB,
      pointB,
      radius,
      dashArray,
      dashOffset
    } = this;
    uniforms.pointA.value.copy(pointA);
    uniforms.controlA.value.copy(controlA);
    uniforms.controlB.value.copy(controlB);
    uniforms.pointB.value.copy(pointB);
    uniforms.radius.value = radius;
    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);
  }
  raycast( /*raycaster, intersects*/
  ) {
    // TODO - just fail for now
  }
}
exports.BezierMesh = BezierMesh;
},{"three":"node_modules/three/build/three.module.js"}],"node_modules/troika-three-text/dist/troika-three-text.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Text = exports.GlyphsGeometry = void 0;
exports.configureTextBuilder = configureTextBuilder;
exports.createTextDerivedMaterial = createTextDerivedMaterial;
exports.dumpSDFTextures = dumpSDFTextures;
exports.fontResolverWorkerModule = void 0;
exports.getCaretAtPoint = getCaretAtPoint;
exports.getSelectionRects = getSelectionRects;
exports.getTextRenderInfo = getTextRenderInfo;
exports.preloadFont = preloadFont;
exports.typesetterWorkerModule = void 0;
var _three = require("three");
var _troikaWorkerUtils = require("troika-worker-utils");
var _webglSdfGenerator = _interopRequireDefault(require("webgl-sdf-generator"));
var _bidiJs = _interopRequireDefault(require("bidi-js"));
var _troikaThreeUtils = require("troika-three-utils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function typrFactory() {
  return "undefined" == typeof window && (self.window = self), function (r) {
    var e = {
      parse: function (r) {
        var t = e._bin,
          a = new Uint8Array(r);
        if ("ttcf" == t.readASCII(a, 0, 4)) {
          var n = 4;
          t.readUshort(a, n), n += 2, t.readUshort(a, n), n += 2;
          var o = t.readUint(a, n);
          n += 4;
          for (var s = [], i = 0; i < o; i++) {
            var h = t.readUint(a, n);
            n += 4, s.push(e._readFont(a, h));
          }
          return s;
        }
        return [e._readFont(a, 0)];
      },
      _readFont: function (r, t) {
        var a = e._bin,
          n = t;
        a.readFixed(r, t), t += 4;
        var o = a.readUshort(r, t);
        t += 2, a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2;
        for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], i = {
            _data: r,
            _offset: n
          }, h = {}, d = 0; d < o; d++) {
          var f = a.readASCII(r, t, 4);
          t += 4, a.readUint(r, t), t += 4;
          var u = a.readUint(r, t);
          t += 4;
          var l = a.readUint(r, t);
          t += 4, h[f] = {
            offset: u,
            length: l
          };
        }
        for (d = 0; d < s.length; d++) {
          var v = s[d];
          h[v] && (i[v.trim()] = e[v.trim()].parse(r, h[v].offset, h[v].length, i));
        }
        return i;
      },
      _tabOffset: function (r, t, a) {
        for (var n = e._bin, o = n.readUshort(r, a + 4), s = a + 12, i = 0; i < o; i++) {
          var h = n.readASCII(r, s, 4);
          s += 4, n.readUint(r, s), s += 4;
          var d = n.readUint(r, s);
          if (s += 4, n.readUint(r, s), s += 4, h == t) return d;
        }
        return 0;
      }
    };
    e._bin = {
      readFixed: function (r, e) {
        return (r[e] << 8 | r[e + 1]) + (r[e + 2] << 8 | r[e + 3]) / 65540;
      },
      readF2dot14: function (r, t) {
        return e._bin.readShort(r, t) / 16384;
      },
      readInt: function (r, t) {
        return e._bin._view(r).getInt32(t);
      },
      readInt8: function (r, t) {
        return e._bin._view(r).getInt8(t);
      },
      readShort: function (r, t) {
        return e._bin._view(r).getInt16(t);
      },
      readUshort: function (r, t) {
        return e._bin._view(r).getUint16(t);
      },
      readUshorts: function (r, t, a) {
        for (var n = [], o = 0; o < a; o++) n.push(e._bin.readUshort(r, t + 2 * o));
        return n;
      },
      readUint: function (r, t) {
        return e._bin._view(r).getUint32(t);
      },
      readUint64: function (r, t) {
        return 4294967296 * e._bin.readUint(r, t) + e._bin.readUint(r, t + 4);
      },
      readASCII: function (r, e, t) {
        for (var a = "", n = 0; n < t; n++) a += String.fromCharCode(r[e + n]);
        return a;
      },
      readUnicode: function (r, e, t) {
        for (var a = "", n = 0; n < t; n++) {
          var o = r[e++] << 8 | r[e++];
          a += String.fromCharCode(o);
        }
        return a;
      },
      _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null,
      readUTF8: function (r, t, a) {
        var n = e._bin._tdec;
        return n && 0 == t && a == r.length ? n.decode(r) : e._bin.readASCII(r, t, a);
      },
      readBytes: function (r, e, t) {
        for (var a = [], n = 0; n < t; n++) a.push(r[e + n]);
        return a;
      },
      readASCIIArray: function (r, e, t) {
        for (var a = [], n = 0; n < t; n++) a.push(String.fromCharCode(r[e + n]));
        return a;
      },
      _view: function (r) {
        return r._dataView || (r._dataView = r.buffer ? new DataView(r.buffer, r.byteOffset, r.byteLength) : new DataView(new Uint8Array(r).buffer));
      }
    }, e._lctf = {}, e._lctf.parse = function (r, t, a, n, o) {
      var s = e._bin,
        i = {},
        h = t;
      s.readFixed(r, t), t += 4;
      var d = s.readUshort(r, t);
      t += 2;
      var f = s.readUshort(r, t);
      t += 2;
      var u = s.readUshort(r, t);
      return t += 2, i.scriptList = e._lctf.readScriptList(r, h + d), i.featureList = e._lctf.readFeatureList(r, h + f), i.lookupList = e._lctf.readLookupList(r, h + u, o), i;
    }, e._lctf.readLookupList = function (r, t, a) {
      var n = e._bin,
        o = t,
        s = [],
        i = n.readUshort(r, t);
      t += 2;
      for (var h = 0; h < i; h++) {
        var d = n.readUshort(r, t);
        t += 2;
        var f = e._lctf.readLookupTable(r, o + d, a);
        s.push(f);
      }
      return s;
    }, e._lctf.readLookupTable = function (r, t, a) {
      var n = e._bin,
        o = t,
        s = {
          tabs: []
        };
      s.ltype = n.readUshort(r, t), t += 2, s.flag = n.readUshort(r, t), t += 2;
      var i = n.readUshort(r, t);
      t += 2;
      for (var h = s.ltype, d = 0; d < i; d++) {
        var f = n.readUshort(r, t);
        t += 2;
        var u = a(r, h, o + f, s);
        s.tabs.push(u);
      }
      return s;
    }, e._lctf.numOfOnes = function (r) {
      for (var e = 0, t = 0; t < 32; t++) 0 != (r >>> t & 1) && e++;
      return e;
    }, e._lctf.readClassDef = function (r, t) {
      var a = e._bin,
        n = [],
        o = a.readUshort(r, t);
      if (t += 2, 1 == o) {
        var s = a.readUshort(r, t);
        t += 2;
        var i = a.readUshort(r, t);
        t += 2;
        for (var h = 0; h < i; h++) n.push(s + h), n.push(s + h), n.push(a.readUshort(r, t)), t += 2;
      }
      if (2 == o) {
        var d = a.readUshort(r, t);
        t += 2;
        for (h = 0; h < d; h++) n.push(a.readUshort(r, t)), t += 2, n.push(a.readUshort(r, t)), t += 2, n.push(a.readUshort(r, t)), t += 2;
      }
      return n;
    }, e._lctf.getInterval = function (r, e) {
      for (var t = 0; t < r.length; t += 3) {
        var a = r[t],
          n = r[t + 1];
        if (r[t + 2], a <= e && e <= n) return t;
      }
      return -1;
    }, e._lctf.readCoverage = function (r, t) {
      var a = e._bin,
        n = {};
      n.fmt = a.readUshort(r, t), t += 2;
      var o = a.readUshort(r, t);
      return t += 2, 1 == n.fmt && (n.tab = a.readUshorts(r, t, o)), 2 == n.fmt && (n.tab = a.readUshorts(r, t, 3 * o)), n;
    }, e._lctf.coverageIndex = function (r, t) {
      var a = r.tab;
      if (1 == r.fmt) return a.indexOf(t);
      if (2 == r.fmt) {
        var n = e._lctf.getInterval(a, t);
        if (-1 != n) return a[n + 2] + (t - a[n]);
      }
      return -1;
    }, e._lctf.readFeatureList = function (r, t) {
      var a = e._bin,
        n = t,
        o = [],
        s = a.readUshort(r, t);
      t += 2;
      for (var i = 0; i < s; i++) {
        var h = a.readASCII(r, t, 4);
        t += 4;
        var d = a.readUshort(r, t);
        t += 2;
        var f = e._lctf.readFeatureTable(r, n + d);
        f.tag = h.trim(), o.push(f);
      }
      return o;
    }, e._lctf.readFeatureTable = function (r, t) {
      var a = e._bin,
        n = t,
        o = {},
        s = a.readUshort(r, t);
      t += 2, s > 0 && (o.featureParams = n + s);
      var i = a.readUshort(r, t);
      t += 2, o.tab = [];
      for (var h = 0; h < i; h++) o.tab.push(a.readUshort(r, t + 2 * h));
      return o;
    }, e._lctf.readScriptList = function (r, t) {
      var a = e._bin,
        n = t,
        o = {},
        s = a.readUshort(r, t);
      t += 2;
      for (var i = 0; i < s; i++) {
        var h = a.readASCII(r, t, 4);
        t += 4;
        var d = a.readUshort(r, t);
        t += 2, o[h.trim()] = e._lctf.readScriptTable(r, n + d);
      }
      return o;
    }, e._lctf.readScriptTable = function (r, t) {
      var a = e._bin,
        n = t,
        o = {},
        s = a.readUshort(r, t);
      t += 2, s > 0 && (o.default = e._lctf.readLangSysTable(r, n + s));
      var i = a.readUshort(r, t);
      t += 2;
      for (var h = 0; h < i; h++) {
        var d = a.readASCII(r, t, 4);
        t += 4;
        var f = a.readUshort(r, t);
        t += 2, o[d.trim()] = e._lctf.readLangSysTable(r, n + f);
      }
      return o;
    }, e._lctf.readLangSysTable = function (r, t) {
      var a = e._bin,
        n = {};
      a.readUshort(r, t), t += 2, n.reqFeature = a.readUshort(r, t), t += 2;
      var o = a.readUshort(r, t);
      return t += 2, n.features = a.readUshorts(r, t, o), n;
    }, e.CFF = {}, e.CFF.parse = function (r, t, a) {
      var n = e._bin;
      (r = new Uint8Array(r.buffer, t, a))[t = 0], r[++t], r[++t], r[++t], t++;
      var o = [];
      t = e.CFF.readIndex(r, t, o);
      for (var s = [], i = 0; i < o.length - 1; i++) s.push(n.readASCII(r, t + o[i], o[i + 1] - o[i]));
      t += o[o.length - 1];
      var h = [];
      t = e.CFF.readIndex(r, t, h);
      var d = [];
      for (i = 0; i < h.length - 1; i++) d.push(e.CFF.readDict(r, t + h[i], t + h[i + 1]));
      t += h[h.length - 1];
      var f = d[0],
        u = [];
      t = e.CFF.readIndex(r, t, u);
      var l = [];
      for (i = 0; i < u.length - 1; i++) l.push(n.readASCII(r, t + u[i], u[i + 1] - u[i]));
      if (t += u[u.length - 1], e.CFF.readSubrs(r, t, f), f.CharStrings) {
        t = f.CharStrings;
        u = [];
        t = e.CFF.readIndex(r, t, u);
        var v = [];
        for (i = 0; i < u.length - 1; i++) v.push(n.readBytes(r, t + u[i], u[i + 1] - u[i]));
        f.CharStrings = v;
      }
      if (f.ROS) {
        t = f.FDArray;
        var c = [];
        t = e.CFF.readIndex(r, t, c), f.FDArray = [];
        for (i = 0; i < c.length - 1; i++) {
          var p = e.CFF.readDict(r, t + c[i], t + c[i + 1]);
          e.CFF._readFDict(r, p, l), f.FDArray.push(p);
        }
        t += c[c.length - 1], t = f.FDSelect, f.FDSelect = [];
        var U = r[t];
        if (t++, 3 != U) throw U;
        var g = n.readUshort(r, t);
        t += 2;
        for (i = 0; i < g + 1; i++) f.FDSelect.push(n.readUshort(r, t), r[t + 2]), t += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(r, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(r, f.charset, f.CharStrings.length)), e.CFF._readFDict(r, f, l), f;
    }, e.CFF._readFDict = function (r, t, a) {
      var n;
      for (var o in t.Private && (n = t.Private[1], t.Private = e.CFF.readDict(r, n, n + t.Private[0]), t.Private.Subrs && e.CFF.readSubrs(r, n + t.Private.Subrs, t.Private)), t) -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o) && (t[o] = a[t[o] - 426 + 35]);
    }, e.CFF.readSubrs = function (r, t, a) {
      var n = e._bin,
        o = [];
      t = e.CFF.readIndex(r, t, o);
      var s,
        i = o.length;
      s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a.Bias = s, a.Subrs = [];
      for (var h = 0; h < o.length - 1; h++) a.Subrs.push(n.readBytes(r, t + o[h], o[h + 1] - o[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function (r, e) {
      for (var t = 0; t < r.charset.length; t++) if (r.charset[t] == e) return t;
      return -1;
    }, e.CFF.glyphBySE = function (r, t) {
      return t < 0 || t > 255 ? -1 : e.CFF.glyphByUnicode(r, e.CFF.tableSE[t]);
    }, e.CFF.readEncoding = function (r, t, a) {
      e._bin;
      var n = [".notdef"],
        o = r[t];
      if (t++, 0 != o) throw "error: unknown encoding format: " + o;
      var s = r[t];
      t++;
      for (var i = 0; i < s; i++) n.push(r[t + i]);
      return n;
    }, e.CFF.readCharset = function (r, t, a) {
      var n = e._bin,
        o = [".notdef"],
        s = r[t];
      if (t++, 0 == s) for (var i = 0; i < a; i++) {
        var h = n.readUshort(r, t);
        t += 2, o.push(h);
      } else {
        if (1 != s && 2 != s) throw "error: format: " + s;
        for (; o.length < a;) {
          h = n.readUshort(r, t);
          t += 2;
          var d = 0;
          1 == s ? (d = r[t], t++) : (d = n.readUshort(r, t), t += 2);
          for (i = 0; i <= d; i++) o.push(h), h++;
        }
      }
      return o;
    }, e.CFF.readIndex = function (r, t, a) {
      var n = e._bin,
        o = n.readUshort(r, t) + 1,
        s = r[t += 2];
      if (t++, 1 == s) for (var i = 0; i < o; i++) a.push(r[t + i]);else if (2 == s) for (i = 0; i < o; i++) a.push(n.readUshort(r, t + 2 * i));else if (3 == s) for (i = 0; i < o; i++) a.push(16777215 & n.readUint(r, t + 3 * i - 1));else if (1 != o) throw "unsupported offset size: " + s + ", count: " + o;
      return (t += o * s) - 1;
    }, e.CFF.getCharString = function (r, t, a) {
      var n = e._bin,
        o = r[t],
        s = r[t + 1];
      r[t + 2], r[t + 3], r[t + 4];
      var i = 1,
        h = null,
        d = null;
      o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (d = n.readShort(r, t + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (d = o - 139, i = 1), 247 <= o && o <= 250 && (d = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (d = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (d = n.readInt(r, t + 1) / 65535, i = 5), a.val = null != d ? d : "o" + h, a.size = i;
    }, e.CFF.readCharString = function (r, t, a) {
      for (var n = t + a, o = e._bin, s = []; t < n;) {
        var i = r[t],
          h = r[t + 1];
        r[t + 2], r[t + 3], r[t + 4];
        var d = 1,
          f = null,
          u = null;
        i <= 20 && (f = i, d = 1), 12 == i && (f = 100 * i + h, d = 2), 19 != i && 20 != i || (f = i, d = 2), 21 <= i && i <= 27 && (f = i, d = 1), 28 == i && (u = o.readShort(r, t + 1), d = 3), 29 <= i && i <= 31 && (f = i, d = 1), 32 <= i && i <= 246 && (u = i - 139, d = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, d = 2), 255 == i && (u = o.readInt(r, t + 1) / 65535, d = 5), s.push(null != u ? u : "o" + f), t += d;
      }
      return s;
    }, e.CFF.readDict = function (r, t, a) {
      for (var n = e._bin, o = {}, s = []; t < a;) {
        var i = r[t],
          h = r[t + 1];
        r[t + 2], r[t + 3], r[t + 4];
        var d = 1,
          f = null,
          u = null;
        if (28 == i && (u = n.readShort(r, t + 1), d = 3), 29 == i && (u = n.readInt(r, t + 1), d = 5), 32 <= i && i <= 246 && (u = i - 139, d = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, d = 2), 255 == i) throw u = n.readInt(r, t + 1) / 65535, d = 5, "unknown number";
        if (30 == i) {
          var l = [];
          for (d = 1;;) {
            var v = r[t + d];
            d++;
            var c = v >> 4,
              p = 15 & v;
            if (15 != c && l.push(c), 15 != p && l.push(p), 15 == p) break;
          }
          for (var U = "", g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < l.length; S++) U += g[l[S]];
          u = parseFloat(U);
        }
        if (i <= 21) if (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i], d = 1, 12 == i) f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2;
        null != f ? (o[f] = 1 == s.length ? s[0] : s, s = []) : s.push(u), t += d;
      }
      return o;
    }, e.cmap = {}, e.cmap.parse = function (r, t, a) {
      r = new Uint8Array(r.buffer, t, a), t = 0;
      var n = e._bin,
        o = {};
      n.readUshort(r, t), t += 2;
      var s = n.readUshort(r, t);
      t += 2;
      var i = [];
      o.tables = [];
      for (var h = 0; h < s; h++) {
        var d = n.readUshort(r, t);
        t += 2;
        var f = n.readUshort(r, t);
        t += 2;
        var u = n.readUint(r, t);
        t += 4;
        var l = "p" + d + "e" + f,
          v = i.indexOf(u);
        if (-1 == v) {
          var c;
          v = o.tables.length, i.push(u);
          var p = n.readUshort(r, u);
          0 == p ? c = e.cmap.parse0(r, u) : 4 == p ? c = e.cmap.parse4(r, u) : 6 == p ? c = e.cmap.parse6(r, u) : 12 == p ? c = e.cmap.parse12(r, u) : console.debug("unknown format: " + p, d, f, u), o.tables.push(c);
        }
        if (null != o[l]) throw "multiple tables for one platform+encoding";
        o[l] = v;
      }
      return o;
    }, e.cmap.parse0 = function (r, t) {
      var a = e._bin,
        n = {};
      n.format = a.readUshort(r, t), t += 2;
      var o = a.readUshort(r, t);
      t += 2, a.readUshort(r, t), t += 2, n.map = [];
      for (var s = 0; s < o - 6; s++) n.map.push(r[t + s]);
      return n;
    }, e.cmap.parse4 = function (r, t) {
      var a = e._bin,
        n = t,
        o = {};
      o.format = a.readUshort(r, t), t += 2;
      var s = a.readUshort(r, t);
      t += 2, a.readUshort(r, t), t += 2;
      var i = a.readUshort(r, t);
      t += 2;
      var h = i / 2;
      o.searchRange = a.readUshort(r, t), t += 2, o.entrySelector = a.readUshort(r, t), t += 2, o.rangeShift = a.readUshort(r, t), t += 2, o.endCount = a.readUshorts(r, t, h), t += 2 * h, t += 2, o.startCount = a.readUshorts(r, t, h), t += 2 * h, o.idDelta = [];
      for (var d = 0; d < h; d++) o.idDelta.push(a.readShort(r, t)), t += 2;
      for (o.idRangeOffset = a.readUshorts(r, t, h), t += 2 * h, o.glyphIdArray = []; t < n + s;) o.glyphIdArray.push(a.readUshort(r, t)), t += 2;
      return o;
    }, e.cmap.parse6 = function (r, t) {
      var a = e._bin,
        n = {};
      n.format = a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2, n.firstCode = a.readUshort(r, t), t += 2;
      var o = a.readUshort(r, t);
      t += 2, n.glyphIdArray = [];
      for (var s = 0; s < o; s++) n.glyphIdArray.push(a.readUshort(r, t)), t += 2;
      return n;
    }, e.cmap.parse12 = function (r, t) {
      var a = e._bin,
        n = {};
      n.format = a.readUshort(r, t), t += 2, t += 2, a.readUint(r, t), t += 4, a.readUint(r, t), t += 4;
      var o = a.readUint(r, t);
      t += 4, n.groups = [];
      for (var s = 0; s < o; s++) {
        var i = t + 12 * s,
          h = a.readUint(r, i + 0),
          d = a.readUint(r, i + 4),
          f = a.readUint(r, i + 8);
        n.groups.push([h, d, f]);
      }
      return n;
    }, e.glyf = {}, e.glyf.parse = function (r, e, t, a) {
      for (var n = [], o = 0; o < a.maxp.numGlyphs; o++) n.push(null);
      return n;
    }, e.glyf._parseGlyf = function (r, t) {
      var a = e._bin,
        n = r._data,
        o = e._tabOffset(n, "glyf", r._offset) + r.loca[t];
      if (r.loca[t] == r.loca[t + 1]) return null;
      var s = {};
      if (s.noc = a.readShort(n, o), o += 2, s.xMin = a.readShort(n, o), o += 2, s.yMin = a.readShort(n, o), o += 2, s.xMax = a.readShort(n, o), o += 2, s.yMax = a.readShort(n, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax) return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i = 0; i < s.noc; i++) s.endPts.push(a.readUshort(n, o)), o += 2;
        var h = a.readUshort(n, o);
        if (o += 2, n.length - o < h) return null;
        s.instructions = a.readBytes(n, o, h), o += h;
        var d = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i = 0; i < d; i++) {
          var f = n[o];
          if (o++, s.flags.push(f), 0 != (8 & f)) {
            var u = n[o];
            o++;
            for (var l = 0; l < u; l++) s.flags.push(f), i++;
          }
        }
        s.xs = [];
        for (i = 0; i < d; i++) {
          var v = 0 != (2 & s.flags[i]),
            c = 0 != (16 & s.flags[i]);
          v ? (s.xs.push(c ? n[o] : -n[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a.readShort(n, o)), o += 2);
        }
        s.ys = [];
        for (i = 0; i < d; i++) {
          v = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);
          v ? (s.ys.push(c ? n[o] : -n[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a.readShort(n, o)), o += 2);
        }
        var p = 0,
          U = 0;
        for (i = 0; i < d; i++) p += s.xs[i], U += s.ys[i], s.xs[i] = p, s.ys[i] = U;
      } else {
        var g;
        s.parts = [];
        do {
          g = a.readUshort(n, o), o += 2;
          var S = {
            m: {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              tx: 0,
              ty: 0
            },
            p1: -1,
            p2: -1
          };
          if (s.parts.push(S), S.glyphIndex = a.readUshort(n, o), o += 2, 1 & g) {
            var m = a.readShort(n, o);
            o += 2;
            var b = a.readShort(n, o);
            o += 2;
          } else {
            m = a.readInt8(n, o);
            o++;
            b = a.readInt8(n, o);
            o++;
          }
          2 & g ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g ? (S.m.a = S.m.d = a.readF2dot14(n, o), o += 2) : 64 & g ? (S.m.a = a.readF2dot14(n, o), o += 2, S.m.d = a.readF2dot14(n, o), o += 2) : 128 & g && (S.m.a = a.readF2dot14(n, o), o += 2, S.m.b = a.readF2dot14(n, o), o += 2, S.m.c = a.readF2dot14(n, o), o += 2, S.m.d = a.readF2dot14(n, o), o += 2);
        } while (32 & g);
        if (256 & g) {
          var y = a.readUshort(n, o);
          o += 2, s.instr = [];
          for (i = 0; i < y; i++) s.instr.push(n[o]), o++;
        }
      }
      return s;
    }, e.GDEF = {}, e.GDEF.parse = function (r, t, a, n) {
      var o = t;
      t += 4;
      var s = e._bin.readUshort(r, t);
      return {
        glyphClassDef: 0 === s ? null : e._lctf.readClassDef(r, o + s)
      };
    }, e.GPOS = {}, e.GPOS.parse = function (r, t, a, n) {
      return e._lctf.parse(r, t, a, n, e.GPOS.subt);
    }, e.GPOS.subt = function (r, t, a, n) {
      var o = e._bin,
        s = a,
        i = {};
      if (i.fmt = o.readUshort(r, a), a += 2, 1 == t || 2 == t || 3 == t || 7 == t || 8 == t && i.fmt <= 2) {
        var h = o.readUshort(r, a);
        a += 2, i.coverage = e._lctf.readCoverage(r, h + s);
      }
      if (1 == t && 1 == i.fmt) {
        var d = o.readUshort(r, a);
        a += 2, 0 != d && (i.pos = e.GPOS.readValueRecord(r, a, d));
      } else if (2 == t && i.fmt >= 1 && i.fmt <= 2) {
        d = o.readUshort(r, a);
        a += 2;
        var f = o.readUshort(r, a);
        a += 2;
        var u = e._lctf.numOfOnes(d),
          l = e._lctf.numOfOnes(f);
        if (1 == i.fmt) {
          i.pairsets = [];
          var v = o.readUshort(r, a);
          a += 2;
          for (var c = 0; c < v; c++) {
            var p = s + o.readUshort(r, a);
            a += 2;
            var U = o.readUshort(r, p);
            p += 2;
            for (var g = [], S = 0; S < U; S++) {
              var m = o.readUshort(r, p);
              p += 2, 0 != d && (P = e.GPOS.readValueRecord(r, p, d), p += 2 * u), 0 != f && (x = e.GPOS.readValueRecord(r, p, f), p += 2 * l), g.push({
                gid2: m,
                val1: P,
                val2: x
              });
            }
            i.pairsets.push(g);
          }
        }
        if (2 == i.fmt) {
          var b = o.readUshort(r, a);
          a += 2;
          var y = o.readUshort(r, a);
          a += 2;
          var F = o.readUshort(r, a);
          a += 2;
          var C = o.readUshort(r, a);
          a += 2, i.classDef1 = e._lctf.readClassDef(r, s + b), i.classDef2 = e._lctf.readClassDef(r, s + y), i.matrix = [];
          for (c = 0; c < F; c++) {
            var _ = [];
            for (S = 0; S < C; S++) {
              var P = null,
                x = null;
              0 != d && (P = e.GPOS.readValueRecord(r, a, d), a += 2 * u), 0 != f && (x = e.GPOS.readValueRecord(r, a, f), a += 2 * l), _.push({
                val1: P,
                val2: x
              });
            }
            i.matrix.push(_);
          }
        }
      } else if (4 == t && 1 == i.fmt) i.markCoverage = e._lctf.readCoverage(r, o.readUshort(r, a) + s), i.baseCoverage = e._lctf.readCoverage(r, o.readUshort(r, a + 2) + s), i.markClassCount = o.readUshort(r, a + 4), i.markArray = e.GPOS.readMarkArray(r, o.readUshort(r, a + 6) + s), i.baseArray = e.GPOS.readBaseArray(r, o.readUshort(r, a + 8) + s, i.markClassCount);else if (6 == t && 1 == i.fmt) i.mark1Coverage = e._lctf.readCoverage(r, o.readUshort(r, a) + s), i.mark2Coverage = e._lctf.readCoverage(r, o.readUshort(r, a + 2) + s), i.markClassCount = o.readUshort(r, a + 4), i.mark1Array = e.GPOS.readMarkArray(r, o.readUshort(r, a + 6) + s), i.mark2Array = e.GPOS.readBaseArray(r, o.readUshort(r, a + 8) + s, i.markClassCount);else {
        if (9 == t && 1 == i.fmt) {
          var I = o.readUshort(r, a);
          a += 2;
          var w = o.readUint(r, a);
          if (a += 4, 9 == n.ltype) n.ltype = I;else if (n.ltype != I) throw "invalid extension substitution";
          return e.GPOS.subt(r, n.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t, "format", i.fmt);
      }
      return i;
    }, e.GPOS.readValueRecord = function (r, t, a) {
      var n = e._bin,
        o = [];
      return o.push(1 & a ? n.readShort(r, t) : 0), t += 1 & a ? 2 : 0, o.push(2 & a ? n.readShort(r, t) : 0), t += 2 & a ? 2 : 0, o.push(4 & a ? n.readShort(r, t) : 0), t += 4 & a ? 2 : 0, o.push(8 & a ? n.readShort(r, t) : 0), t += 8 & a ? 2 : 0, o;
    }, e.GPOS.readBaseArray = function (r, t, a) {
      var n = e._bin,
        o = [],
        s = t,
        i = n.readUshort(r, t);
      t += 2;
      for (var h = 0; h < i; h++) {
        for (var d = [], f = 0; f < a; f++) d.push(e.GPOS.readAnchorRecord(r, s + n.readUshort(r, t))), t += 2;
        o.push(d);
      }
      return o;
    }, e.GPOS.readMarkArray = function (r, t) {
      var a = e._bin,
        n = [],
        o = t,
        s = a.readUshort(r, t);
      t += 2;
      for (var i = 0; i < s; i++) {
        var h = e.GPOS.readAnchorRecord(r, a.readUshort(r, t + 2) + o);
        h.markClass = a.readUshort(r, t), n.push(h), t += 4;
      }
      return n;
    }, e.GPOS.readAnchorRecord = function (r, t) {
      var a = e._bin,
        n = {};
      return n.fmt = a.readUshort(r, t), n.x = a.readShort(r, t + 2), n.y = a.readShort(r, t + 4), n;
    }, e.GSUB = {}, e.GSUB.parse = function (r, t, a, n) {
      return e._lctf.parse(r, t, a, n, e.GSUB.subt);
    }, e.GSUB.subt = function (r, t, a, n) {
      var o = e._bin,
        s = a,
        i = {};
      if (i.fmt = o.readUshort(r, a), a += 2, 1 != t && 2 != t && 4 != t && 5 != t && 6 != t) return null;
      if (1 == t || 2 == t || 4 == t || 5 == t && i.fmt <= 2 || 6 == t && i.fmt <= 2) {
        var h = o.readUshort(r, a);
        a += 2, i.coverage = e._lctf.readCoverage(r, s + h);
      }
      if (1 == t && i.fmt >= 1 && i.fmt <= 2) {
        if (1 == i.fmt) i.delta = o.readShort(r, a), a += 2;else if (2 == i.fmt) {
          var d = o.readUshort(r, a);
          a += 2, i.newg = o.readUshorts(r, a, d), a += 2 * i.newg.length;
        }
      } else if (2 == t && 1 == i.fmt) {
        d = o.readUshort(r, a);
        a += 2, i.seqs = [];
        for (var f = 0; f < d; f++) {
          var u = o.readUshort(r, a) + s;
          a += 2;
          var l = o.readUshort(r, u);
          i.seqs.push(o.readUshorts(r, u + 2, l));
        }
      } else if (4 == t) {
        i.vals = [];
        d = o.readUshort(r, a);
        a += 2;
        for (f = 0; f < d; f++) {
          var v = o.readUshort(r, a);
          a += 2, i.vals.push(e.GSUB.readLigatureSet(r, s + v));
        }
      } else if (5 == t && 2 == i.fmt) {
        if (2 == i.fmt) {
          var c = o.readUshort(r, a);
          a += 2, i.cDef = e._lctf.readClassDef(r, s + c), i.scset = [];
          var p = o.readUshort(r, a);
          a += 2;
          for (f = 0; f < p; f++) {
            var U = o.readUshort(r, a);
            a += 2, i.scset.push(0 == U ? null : e.GSUB.readSubClassSet(r, s + U));
          }
        }
      } else if (6 == t && 3 == i.fmt) {
        if (3 == i.fmt) {
          for (f = 0; f < 3; f++) {
            d = o.readUshort(r, a);
            a += 2;
            for (var g = [], S = 0; S < d; S++) g.push(e._lctf.readCoverage(r, s + o.readUshort(r, a + 2 * S)));
            a += 2 * d, 0 == f && (i.backCvg = g), 1 == f && (i.inptCvg = g), 2 == f && (i.ahedCvg = g);
          }
          d = o.readUshort(r, a);
          a += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r, a, d);
        }
      } else {
        if (7 == t && 1 == i.fmt) {
          var m = o.readUshort(r, a);
          a += 2;
          var b = o.readUint(r, a);
          if (a += 4, 9 == n.ltype) n.ltype = m;else if (n.ltype != m) throw "invalid extension substitution";
          return e.GSUB.subt(r, n.ltype, s + b);
        }
        console.debug("unsupported GSUB table LookupType", t, "format", i.fmt);
      }
      return i;
    }, e.GSUB.readSubClassSet = function (r, t) {
      var a = e._bin.readUshort,
        n = t,
        o = [],
        s = a(r, t);
      t += 2;
      for (var i = 0; i < s; i++) {
        var h = a(r, t);
        t += 2, o.push(e.GSUB.readSubClassRule(r, n + h));
      }
      return o;
    }, e.GSUB.readSubClassRule = function (r, t) {
      var a = e._bin.readUshort,
        n = {},
        o = a(r, t),
        s = a(r, t += 2);
      t += 2, n.input = [];
      for (var i = 0; i < o - 1; i++) n.input.push(a(r, t)), t += 2;
      return n.substLookupRecords = e.GSUB.readSubstLookupRecords(r, t, s), n;
    }, e.GSUB.readSubstLookupRecords = function (r, t, a) {
      for (var n = e._bin.readUshort, o = [], s = 0; s < a; s++) o.push(n(r, t), n(r, t + 2)), t += 4;
      return o;
    }, e.GSUB.readChainSubClassSet = function (r, t) {
      var a = e._bin,
        n = t,
        o = [],
        s = a.readUshort(r, t);
      t += 2;
      for (var i = 0; i < s; i++) {
        var h = a.readUshort(r, t);
        t += 2, o.push(e.GSUB.readChainSubClassRule(r, n + h));
      }
      return o;
    }, e.GSUB.readChainSubClassRule = function (r, t) {
      for (var a = e._bin, n = {}, o = ["backtrack", "input", "lookahead"], s = 0; s < o.length; s++) {
        var i = a.readUshort(r, t);
        t += 2, 1 == s && i--, n[o[s]] = a.readUshorts(r, t, i), t += 2 * n[o[s]].length;
      }
      i = a.readUshort(r, t);
      return t += 2, n.subst = a.readUshorts(r, t, 2 * i), t += 2 * n.subst.length, n;
    }, e.GSUB.readLigatureSet = function (r, t) {
      var a = e._bin,
        n = t,
        o = [],
        s = a.readUshort(r, t);
      t += 2;
      for (var i = 0; i < s; i++) {
        var h = a.readUshort(r, t);
        t += 2, o.push(e.GSUB.readLigature(r, n + h));
      }
      return o;
    }, e.GSUB.readLigature = function (r, t) {
      var a = e._bin,
        n = {
          chain: []
        };
      n.nglyph = a.readUshort(r, t), t += 2;
      var o = a.readUshort(r, t);
      t += 2;
      for (var s = 0; s < o - 1; s++) n.chain.push(a.readUshort(r, t)), t += 2;
      return n;
    }, e.head = {}, e.head.parse = function (r, t, a) {
      var n = e._bin,
        o = {};
      return n.readFixed(r, t), t += 4, o.fontRevision = n.readFixed(r, t), t += 4, n.readUint(r, t), t += 4, n.readUint(r, t), t += 4, o.flags = n.readUshort(r, t), t += 2, o.unitsPerEm = n.readUshort(r, t), t += 2, o.created = n.readUint64(r, t), t += 8, o.modified = n.readUint64(r, t), t += 8, o.xMin = n.readShort(r, t), t += 2, o.yMin = n.readShort(r, t), t += 2, o.xMax = n.readShort(r, t), t += 2, o.yMax = n.readShort(r, t), t += 2, o.macStyle = n.readUshort(r, t), t += 2, o.lowestRecPPEM = n.readUshort(r, t), t += 2, o.fontDirectionHint = n.readShort(r, t), t += 2, o.indexToLocFormat = n.readShort(r, t), t += 2, o.glyphDataFormat = n.readShort(r, t), t += 2, o;
    }, e.hhea = {}, e.hhea.parse = function (r, t, a) {
      var n = e._bin,
        o = {};
      return n.readFixed(r, t), t += 4, o.ascender = n.readShort(r, t), t += 2, o.descender = n.readShort(r, t), t += 2, o.lineGap = n.readShort(r, t), t += 2, o.advanceWidthMax = n.readUshort(r, t), t += 2, o.minLeftSideBearing = n.readShort(r, t), t += 2, o.minRightSideBearing = n.readShort(r, t), t += 2, o.xMaxExtent = n.readShort(r, t), t += 2, o.caretSlopeRise = n.readShort(r, t), t += 2, o.caretSlopeRun = n.readShort(r, t), t += 2, o.caretOffset = n.readShort(r, t), t += 2, t += 8, o.metricDataFormat = n.readShort(r, t), t += 2, o.numberOfHMetrics = n.readUshort(r, t), t += 2, o;
    }, e.hmtx = {}, e.hmtx.parse = function (r, t, a, n) {
      for (var o = e._bin, s = {
          aWidth: [],
          lsBearing: []
        }, i = 0, h = 0, d = 0; d < n.maxp.numGlyphs; d++) d < n.hhea.numberOfHMetrics && (i = o.readUshort(r, t), t += 2, h = o.readShort(r, t), t += 2), s.aWidth.push(i), s.lsBearing.push(h);
      return s;
    }, e.kern = {}, e.kern.parse = function (r, t, a, n) {
      var o = e._bin,
        s = o.readUshort(r, t);
      if (t += 2, 1 == s) return e.kern.parseV1(r, t - 2, a, n);
      var i = o.readUshort(r, t);
      t += 2;
      for (var h = {
          glyph1: [],
          rval: []
        }, d = 0; d < i; d++) {
        t += 2;
        a = o.readUshort(r, t);
        t += 2;
        var f = o.readUshort(r, t);
        t += 2;
        var u = f >>> 8;
        if (0 != (u &= 15)) throw "unknown kern table format: " + u;
        t = e.kern.readFormat0(r, t, h);
      }
      return h;
    }, e.kern.parseV1 = function (r, t, a, n) {
      var o = e._bin;
      o.readFixed(r, t), t += 4;
      var s = o.readUint(r, t);
      t += 4;
      for (var i = {
          glyph1: [],
          rval: []
        }, h = 0; h < s; h++) {
        o.readUint(r, t), t += 4;
        var d = o.readUshort(r, t);
        t += 2, o.readUshort(r, t), t += 2;
        var f = d >>> 8;
        if (0 != (f &= 15)) throw "unknown kern table format: " + f;
        t = e.kern.readFormat0(r, t, i);
      }
      return i;
    }, e.kern.readFormat0 = function (r, t, a) {
      var n = e._bin,
        o = -1,
        s = n.readUshort(r, t);
      t += 2, n.readUshort(r, t), t += 2, n.readUshort(r, t), t += 2, n.readUshort(r, t), t += 2;
      for (var i = 0; i < s; i++) {
        var h = n.readUshort(r, t);
        t += 2;
        var d = n.readUshort(r, t);
        t += 2;
        var f = n.readShort(r, t);
        t += 2, h != o && (a.glyph1.push(h), a.rval.push({
          glyph2: [],
          vals: []
        }));
        var u = a.rval[a.rval.length - 1];
        u.glyph2.push(d), u.vals.push(f), o = h;
      }
      return t;
    }, e.loca = {}, e.loca.parse = function (r, t, a, n) {
      var o = e._bin,
        s = [],
        i = n.head.indexToLocFormat,
        h = n.maxp.numGlyphs + 1;
      if (0 == i) for (var d = 0; d < h; d++) s.push(o.readUshort(r, t + (d << 1)) << 1);
      if (1 == i) for (d = 0; d < h; d++) s.push(o.readUint(r, t + (d << 2)));
      return s;
    }, e.maxp = {}, e.maxp.parse = function (r, t, a) {
      var n = e._bin,
        o = {},
        s = n.readUint(r, t);
      return t += 4, o.numGlyphs = n.readUshort(r, t), t += 2, 65536 == s && (o.maxPoints = n.readUshort(r, t), t += 2, o.maxContours = n.readUshort(r, t), t += 2, o.maxCompositePoints = n.readUshort(r, t), t += 2, o.maxCompositeContours = n.readUshort(r, t), t += 2, o.maxZones = n.readUshort(r, t), t += 2, o.maxTwilightPoints = n.readUshort(r, t), t += 2, o.maxStorage = n.readUshort(r, t), t += 2, o.maxFunctionDefs = n.readUshort(r, t), t += 2, o.maxInstructionDefs = n.readUshort(r, t), t += 2, o.maxStackElements = n.readUshort(r, t), t += 2, o.maxSizeOfInstructions = n.readUshort(r, t), t += 2, o.maxComponentElements = n.readUshort(r, t), t += 2, o.maxComponentDepth = n.readUshort(r, t), t += 2), o;
    }, e.name = {}, e.name.parse = function (r, t, a) {
      var n = e._bin,
        o = {};
      n.readUshort(r, t), t += 2;
      var s = n.readUshort(r, t);
      t += 2, n.readUshort(r, t);
      for (var i, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = t += 2, f = 0; f < s; f++) {
        var u = n.readUshort(r, t);
        t += 2;
        var l = n.readUshort(r, t);
        t += 2;
        var v = n.readUshort(r, t);
        t += 2;
        var c = n.readUshort(r, t);
        t += 2;
        var p = n.readUshort(r, t);
        t += 2;
        var U = n.readUshort(r, t);
        t += 2;
        var g,
          S = h[c],
          m = d + 12 * s + U;
        if (0 == u) g = n.readUnicode(r, m, p / 2);else if (3 == u && 0 == l) g = n.readUnicode(r, m, p / 2);else if (0 == l) g = n.readASCII(r, m, p);else if (1 == l) g = n.readUnicode(r, m, p / 2);else if (3 == l) g = n.readUnicode(r, m, p / 2);else {
          if (1 != u) throw "unknown encoding " + l + ", platformID: " + u;
          g = n.readASCII(r, m, p), console.debug("reading unknown MAC encoding " + l + " as ASCII");
        }
        var b = "p" + u + "," + v.toString(16);
        null == o[b] && (o[b] = {}), o[b][void 0 !== S ? S : c] = g, o[b]._lang = v;
      }
      for (var y in o) if (null != o[y].postScriptName && 1033 == o[y]._lang) return o[y];
      for (var y in o) if (null != o[y].postScriptName && 0 == o[y]._lang) return o[y];
      for (var y in o) if (null != o[y].postScriptName && 3084 == o[y]._lang) return o[y];
      for (var y in o) if (null != o[y].postScriptName) return o[y];
      for (var y in o) {
        i = y;
        break;
      }
      return console.debug("returning name table with languageID " + o[i]._lang), o[i];
    }, e["OS/2"] = {}, e["OS/2"].parse = function (r, t, a) {
      var n = e._bin.readUshort(r, t);
      t += 2;
      var o = {};
      if (0 == n) e["OS/2"].version0(r, t, o);else if (1 == n) e["OS/2"].version1(r, t, o);else if (2 == n || 3 == n || 4 == n) e["OS/2"].version2(r, t, o);else {
        if (5 != n) throw "unknown OS/2 table version: " + n;
        e["OS/2"].version5(r, t, o);
      }
      return o;
    }, e["OS/2"].version0 = function (r, t, a) {
      var n = e._bin;
      return a.xAvgCharWidth = n.readShort(r, t), t += 2, a.usWeightClass = n.readUshort(r, t), t += 2, a.usWidthClass = n.readUshort(r, t), t += 2, a.fsType = n.readUshort(r, t), t += 2, a.ySubscriptXSize = n.readShort(r, t), t += 2, a.ySubscriptYSize = n.readShort(r, t), t += 2, a.ySubscriptXOffset = n.readShort(r, t), t += 2, a.ySubscriptYOffset = n.readShort(r, t), t += 2, a.ySuperscriptXSize = n.readShort(r, t), t += 2, a.ySuperscriptYSize = n.readShort(r, t), t += 2, a.ySuperscriptXOffset = n.readShort(r, t), t += 2, a.ySuperscriptYOffset = n.readShort(r, t), t += 2, a.yStrikeoutSize = n.readShort(r, t), t += 2, a.yStrikeoutPosition = n.readShort(r, t), t += 2, a.sFamilyClass = n.readShort(r, t), t += 2, a.panose = n.readBytes(r, t, 10), t += 10, a.ulUnicodeRange1 = n.readUint(r, t), t += 4, a.ulUnicodeRange2 = n.readUint(r, t), t += 4, a.ulUnicodeRange3 = n.readUint(r, t), t += 4, a.ulUnicodeRange4 = n.readUint(r, t), t += 4, a.achVendID = [n.readInt8(r, t), n.readInt8(r, t + 1), n.readInt8(r, t + 2), n.readInt8(r, t + 3)], t += 4, a.fsSelection = n.readUshort(r, t), t += 2, a.usFirstCharIndex = n.readUshort(r, t), t += 2, a.usLastCharIndex = n.readUshort(r, t), t += 2, a.sTypoAscender = n.readShort(r, t), t += 2, a.sTypoDescender = n.readShort(r, t), t += 2, a.sTypoLineGap = n.readShort(r, t), t += 2, a.usWinAscent = n.readUshort(r, t), t += 2, a.usWinDescent = n.readUshort(r, t), t += 2;
    }, e["OS/2"].version1 = function (r, t, a) {
      var n = e._bin;
      return t = e["OS/2"].version0(r, t, a), a.ulCodePageRange1 = n.readUint(r, t), t += 4, a.ulCodePageRange2 = n.readUint(r, t), t += 4;
    }, e["OS/2"].version2 = function (r, t, a) {
      var n = e._bin;
      return t = e["OS/2"].version1(r, t, a), a.sxHeight = n.readShort(r, t), t += 2, a.sCapHeight = n.readShort(r, t), t += 2, a.usDefault = n.readUshort(r, t), t += 2, a.usBreak = n.readUshort(r, t), t += 2, a.usMaxContext = n.readUshort(r, t), t += 2;
    }, e["OS/2"].version5 = function (r, t, a) {
      var n = e._bin;
      return t = e["OS/2"].version2(r, t, a), a.usLowerOpticalPointSize = n.readUshort(r, t), t += 2, a.usUpperOpticalPointSize = n.readUshort(r, t), t += 2;
    }, e.post = {}, e.post.parse = function (r, t, a) {
      var n = e._bin,
        o = {};
      return o.version = n.readFixed(r, t), t += 4, o.italicAngle = n.readFixed(r, t), t += 4, o.underlinePosition = n.readShort(r, t), t += 2, o.underlineThickness = n.readShort(r, t), t += 2, o;
    }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function (r, e) {
      var t = r.cmap,
        a = -1;
      if (null != t.p0e4 ? a = t.p0e4 : null != t.p3e1 ? a = t.p3e1 : null != t.p1e0 ? a = t.p1e0 : null != t.p0e3 && (a = t.p0e3), -1 == a) throw "no familiar platform and encoding!";
      var n = t.tables[a];
      if (0 == n.format) return e >= n.map.length ? 0 : n.map[e];
      if (4 == n.format) {
        for (var o = -1, s = 0; s < n.endCount.length; s++) if (e <= n.endCount[s]) {
          o = s;
          break;
        }
        if (-1 == o) return 0;
        if (n.startCount[o] > e) return 0;
        return 65535 & (0 != n.idRangeOffset[o] ? n.glyphIdArray[e - n.startCount[o] + (n.idRangeOffset[o] >> 1) - (n.idRangeOffset.length - o)] : e + n.idDelta[o]);
      }
      if (12 == n.format) {
        if (e > n.groups[n.groups.length - 1][1]) return 0;
        for (s = 0; s < n.groups.length; s++) {
          var i = n.groups[s];
          if (i[0] <= e && e <= i[1]) return i[2] + (e - i[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n.format;
    }, e.U.glyphToPath = function (r, t) {
      var a = {
        cmds: [],
        crds: []
      };
      if (r.SVG && r.SVG.entries[t]) {
        var n = r.SVG.entries[t];
        return null == n ? a : ("string" == typeof n && (n = e.SVG.toPath(n), r.SVG.entries[t] = n), n);
      }
      if (r.CFF) {
        var o = {
            x: 0,
            y: 0,
            stack: [],
            nStems: 0,
            haveWidth: !1,
            width: r.CFF.Private ? r.CFF.Private.defaultWidthX : 0,
            open: !1
          },
          s = r.CFF,
          i = r.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t;) h += 2;
          i = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r.CFF.CharStrings[t], o, s, i, a);
      } else r.glyf && e.U._drawGlyf(t, r, a);
      return a;
    }, e.U._drawGlyf = function (r, t, a) {
      var n = t.glyf[r];
      null == n && (n = t.glyf[r] = e.glyf._parseGlyf(t, r)), null != n && (n.noc > -1 ? e.U._simpleGlyph(n, a) : e.U._compoGlyph(n, t, a));
    }, e.U._simpleGlyph = function (r, t) {
      for (var a = 0; a < r.noc; a++) {
        for (var n = 0 == a ? 0 : r.endPts[a - 1] + 1, o = r.endPts[a], s = n; s <= o; s++) {
          var i = s == n ? o : s - 1,
            h = s == o ? n : s + 1,
            d = 1 & r.flags[s],
            f = 1 & r.flags[i],
            u = 1 & r.flags[h],
            l = r.xs[s],
            v = r.ys[s];
          if (s == n) if (d) {
            if (!f) {
              e.U.P.moveTo(t, l, v);
              continue;
            }
            e.U.P.moveTo(t, r.xs[i], r.ys[i]);
          } else f ? e.U.P.moveTo(t, r.xs[i], r.ys[i]) : e.U.P.moveTo(t, (r.xs[i] + l) / 2, (r.ys[i] + v) / 2);
          d ? f && e.U.P.lineTo(t, l, v) : u ? e.U.P.qcurveTo(t, l, v, r.xs[h], r.ys[h]) : e.U.P.qcurveTo(t, l, v, (l + r.xs[h]) / 2, (v + r.ys[h]) / 2);
        }
        e.U.P.closePath(t);
      }
    }, e.U._compoGlyph = function (r, t, a) {
      for (var n = 0; n < r.parts.length; n++) {
        var o = {
            cmds: [],
            crds: []
          },
          s = r.parts[n];
        e.U._drawGlyf(s.glyphIndex, t, o);
        for (var i = s.m, h = 0; h < o.crds.length; h += 2) {
          var d = o.crds[h],
            f = o.crds[h + 1];
          a.crds.push(d * i.a + f * i.b + i.tx), a.crds.push(d * i.c + f * i.d + i.ty);
        }
        for (h = 0; h < o.cmds.length; h++) a.cmds.push(o.cmds[h]);
      }
    }, e.U._getGlyphClass = function (r, t) {
      var a = e._lctf.getInterval(t, r);
      return -1 == a ? 0 : t[a + 2];
    }, e.U._applySubs = function (r, t, a, n) {
      for (var o = r.length - t - 1, s = 0; s < a.tabs.length; s++) if (null != a.tabs[s]) {
        var i,
          h = a.tabs[s];
        if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r[t]))) if (1 == a.ltype) r[t], 1 == h.fmt ? r[t] = r[t] + h.delta : r[t] = h.newg[i];else if (4 == a.ltype) for (var d = h.vals[i], f = 0; f < d.length; f++) {
          var u = d[f],
            l = u.chain.length;
          if (!(l > o)) {
            for (var v = !0, c = 0, p = 0; p < l; p++) {
              for (; -1 == r[t + c + (1 + p)];) c++;
              u.chain[p] != r[t + c + (1 + p)] && (v = !1);
            }
            if (v) {
              r[t] = u.nglyph;
              for (p = 0; p < l + c; p++) r[t + p + 1] = -1;
              break;
            }
          }
        } else if (5 == a.ltype && 2 == h.fmt) for (var U = e._lctf.getInterval(h.cDef, r[t]), g = h.cDef[U + 2], S = h.scset[g], m = 0; m < S.length; m++) {
          var b = S[m],
            y = b.input;
          if (!(y.length > o)) {
            for (v = !0, p = 0; p < y.length; p++) {
              var F = e._lctf.getInterval(h.cDef, r[t + 1 + p]);
              if (-1 == U && h.cDef[F + 2] != y[p]) {
                v = !1;
                break;
              }
            }
            if (v) {
              var C = b.substLookupRecords;
              for (f = 0; f < C.length; f += 2) C[f], C[f + 1];
            }
          }
        } else if (6 == a.ltype && 3 == h.fmt) {
          if (!e.U._glsCovered(r, h.backCvg, t - h.backCvg.length)) continue;
          if (!e.U._glsCovered(r, h.inptCvg, t)) continue;
          if (!e.U._glsCovered(r, h.ahedCvg, t + h.inptCvg.length)) continue;
          var _ = h.lookupRec;
          for (m = 0; m < _.length; m += 2) {
            U = _[m];
            var P = n[_[m + 1]];
            e.U._applySubs(r, t + U, P, n);
          }
        }
      }
    }, e.U._glsCovered = function (r, t, a) {
      for (var n = 0; n < t.length; n++) {
        if (-1 == e._lctf.coverageIndex(t[n], r[a + n])) return !1;
      }
      return !0;
    }, e.U.glyphsToPath = function (r, t, a) {
      for (var n = {
          cmds: [],
          crds: []
        }, o = 0, s = 0; s < t.length; s++) {
        var i = t[s];
        if (-1 != i) {
          for (var h = s < t.length - 1 && -1 != t[s + 1] ? t[s + 1] : 0, d = e.U.glyphToPath(r, i), f = 0; f < d.crds.length; f += 2) n.crds.push(d.crds[f] + o), n.crds.push(d.crds[f + 1]);
          a && n.cmds.push(a);
          for (f = 0; f < d.cmds.length; f++) n.cmds.push(d.cmds[f]);
          a && n.cmds.push("X"), o += r.hmtx.aWidth[i], s < t.length - 1 && (o += e.U.getPairAdjustment(r, i, h));
        }
      }
      return n;
    }, e.U.P = {}, e.U.P.moveTo = function (r, e, t) {
      r.cmds.push("M"), r.crds.push(e, t);
    }, e.U.P.lineTo = function (r, e, t) {
      r.cmds.push("L"), r.crds.push(e, t);
    }, e.U.P.curveTo = function (r, e, t, a, n, o, s) {
      r.cmds.push("C"), r.crds.push(e, t, a, n, o, s);
    }, e.U.P.qcurveTo = function (r, e, t, a, n) {
      r.cmds.push("Q"), r.crds.push(e, t, a, n);
    }, e.U.P.closePath = function (r) {
      r.cmds.push("Z");
    }, e.U._drawCFF = function (r, t, a, n, o) {
      for (var s = t.stack, i = t.nStems, h = t.haveWidth, d = t.width, f = t.open, u = 0, l = t.x, v = t.y, c = 0, p = 0, U = 0, g = 0, S = 0, m = 0, b = 0, y = 0, F = 0, C = 0, _ = {
          val: 0,
          size: 0
        }; u < r.length;) {
        e.CFF.getCharString(r, u, _);
        var P = _.val;
        if (u += _.size, "o1" == P || "o18" == P) s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = !0;else if ("o3" == P || "o23" == P) {
          s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = !0;
        } else if ("o4" == P) s.length > 1 && !h && (d = s.shift() + n.nominalWidthX, h = !0), f && e.U.P.closePath(o), v += s.pop(), e.U.P.moveTo(o, l, v), f = !0;else if ("o5" == P) for (; s.length > 0;) l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);else if ("o6" == P || "o7" == P) for (var x = s.length, I = "o6" == P, w = 0; w < x; w++) {
          var k = s.shift();
          I ? l += k : v += k, I = !I, e.U.P.lineTo(o, l, v);
        } else if ("o8" == P || "o24" == P) {
          x = s.length;
          for (var G = 0; G + 6 <= x;) c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v), G += 6;
          "o24" == P && (l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v));
        } else {
          if ("o11" == P) break;
          if ("o1234" == P || "o1235" == P || "o1236" == P || "o1237" == P) "o1234" == P && (p = v, U = (c = l + s.shift()) + s.shift(), C = g = p + s.shift(), m = g, y = v, l = (b = (S = (F = U + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v)), "o1235" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), F = U + s.shift(), C = g + s.shift(), S = F + s.shift(), m = C + s.shift(), b = S + s.shift(), y = m + s.shift(), l = b + s.shift(), v = y + s.shift(), s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v)), "o1236" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), C = g = p + s.shift(), m = g, b = (S = (F = U + s.shift()) + s.shift()) + s.shift(), y = m + s.shift(), l = b + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v)), "o1237" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), F = U + s.shift(), C = g + s.shift(), S = F + s.shift(), m = C + s.shift(), b = S + s.shift(), y = m + s.shift(), Math.abs(b - l) > Math.abs(y - v) ? l = b + s.shift() : v = y + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v));else if ("o14" == P) {
            if (s.length > 0 && !h && (d = s.shift() + a.nominalWidthX, h = !0), 4 == s.length) {
              var O = s.shift(),
                T = s.shift(),
                D = s.shift(),
                B = s.shift(),
                A = e.CFF.glyphBySE(a, D),
                R = e.CFF.glyphBySE(a, B);
              e.U._drawCFF(a.CharStrings[A], t, a, n, o), t.x = O, t.y = T, e.U._drawCFF(a.CharStrings[R], t, a, n, o);
            }
            f && (e.U.P.closePath(o), f = !1);
          } else if ("o19" == P || "o20" == P) {
            s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = !0, u += i + 7 >> 3;
          } else if ("o21" == P) s.length > 2 && !h && (d = s.shift() + n.nominalWidthX, h = !0), v += s.pop(), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), f = !0;else if ("o22" == P) s.length > 1 && !h && (d = s.shift() + n.nominalWidthX, h = !0), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), f = !0;else if ("o25" == P) {
            for (; s.length > 6;) l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);
            c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v);
          } else if ("o26" == P) for (s.length % 2 && (l += s.shift()); s.length > 0;) c = l, p = v + s.shift(), l = U = c + s.shift(), v = (g = p + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v);else if ("o27" == P) for (s.length % 2 && (v += s.shift()); s.length > 0;) p = v, U = (c = l + s.shift()) + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g, e.U.P.curveTo(o, c, p, U, g, l, v);else if ("o10" == P || "o29" == P) {
            var L = "o10" == P ? n : a;
            if (0 == s.length) console.debug("error: empty stack");else {
              var W = s.pop(),
                M = L.Subrs[W + L.Bias];
              t.x = l, t.y = v, t.nStems = i, t.haveWidth = h, t.width = d, t.open = f, e.U._drawCFF(M, t, a, n, o), l = t.x, v = t.y, i = t.nStems, h = t.haveWidth, d = t.width, f = t.open;
            }
          } else if ("o30" == P || "o31" == P) {
            var V = s.length,
              E = (G = 0, "o31" == P);
            for (G += V - (x = -3 & V); G < x;) E ? (p = v, U = (c = l + s.shift()) + s.shift(), v = (g = p + s.shift()) + s.shift(), x - G == 5 ? (l = U + s.shift(), G++) : l = U, E = !1) : (c = l, p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), x - G == 5 ? (v = g + s.shift(), G++) : v = g, E = !0), e.U.P.curveTo(o, c, p, U, g, l, v), G += 4;
          } else {
            if ("o" == (P + "").charAt(0)) throw console.debug("Unknown operation: " + P, r), P;
            s.push(P);
          }
        }
      }
      t.x = l, t.y = v, t.nStems = i, t.haveWidth = h, t.width = d, t.open = f;
    };
    var t = e,
      a = {
        Typr: t
      };
    return r.Typr = t, r.default = a, Object.defineProperty(r, "__esModule", {
      value: !0
    }), r;
  }({}).Typr;
}

/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function woff2otfFactory() {
  return function (r) {
    var e = Uint8Array,
      n = Uint16Array,
      t = Uint32Array,
      a = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
      i = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
      o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
      f = function (r, e) {
        for (var a = new n(31), i = 0; i < 31; ++i) a[i] = e += 1 << r[i - 1];
        var o = new t(a[30]);
        for (i = 1; i < 30; ++i) for (var f = a[i]; f < a[i + 1]; ++f) o[f] = f - a[i] << 5 | i;
        return [a, o];
      },
      u = f(a, 2),
      v = u[0],
      s = u[1];
    v[28] = 258, s[258] = 28;
    for (var l = f(i, 0)[0], c = new n(32768), g = 0; g < 32768; ++g) {
      var h = (43690 & g) >>> 1 | (21845 & g) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function (r, e, t) {
        for (var a = r.length, i = 0, o = new n(e); i < a; ++i) ++o[r[i] - 1];
        var f,
          u = new n(e);
        for (i = 0; i < e; ++i) u[i] = u[i - 1] + o[i - 1] << 1;
        if (t) {
          f = new n(1 << e);
          var v = 15 - e;
          for (i = 0; i < a; ++i) if (r[i]) for (var s = i << 4 | r[i], l = e - r[i], g = u[r[i] - 1]++ << l, h = g | (1 << l) - 1; g <= h; ++g) f[c[g] >>> v] = s;
        } else for (f = new n(a), i = 0; i < a; ++i) r[i] && (f[i] = c[u[r[i] - 1]++] >>> 15 - r[i]);
        return f;
      },
      d = new e(288);
    for (g = 0; g < 144; ++g) d[g] = 8;
    for (g = 144; g < 256; ++g) d[g] = 9;
    for (g = 256; g < 280; ++g) d[g] = 7;
    for (g = 280; g < 288; ++g) d[g] = 8;
    var m = new e(32);
    for (g = 0; g < 32; ++g) m[g] = 5;
    var b = w(d, 9, 1),
      p = w(m, 5, 1),
      y = function (r) {
        for (var e = r[0], n = 1; n < r.length; ++n) r[n] > e && (e = r[n]);
        return e;
      },
      L = function (r, e, n) {
        var t = e / 8 | 0;
        return (r[t] | r[t + 1] << 8) >> (7 & e) & n;
      },
      U = function (r, e) {
        var n = e / 8 | 0;
        return (r[n] | r[n + 1] << 8 | r[n + 2] << 16) >> (7 & e);
      },
      k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler",, "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"],
      T = function (r, e, n) {
        var t = new Error(e || k[r]);
        if (t.code = r, Error.captureStackTrace && Error.captureStackTrace(t, T), !n) throw t;
        return t;
      },
      O = function (r, f, u) {
        var s = r.length;
        if (!s || u && !u.l && s < 5) return f || new e(0);
        var c = !f || u,
          g = !u || u.i;
        u || (u = {}), f || (f = new e(3 * s));
        var h,
          d = function (r) {
            var n = f.length;
            if (r > n) {
              var t = new e(Math.max(2 * n, r));
              t.set(f), f = t;
            }
          },
          m = u.f || 0,
          k = u.p || 0,
          O = u.b || 0,
          A = u.l,
          x = u.d,
          E = u.m,
          D = u.n,
          M = 8 * s;
        do {
          if (!A) {
            u.f = m = L(r, k, 1);
            var S = L(r, k + 1, 3);
            if (k += 3, !S) {
              var V = r[(I = ((h = k) / 8 | 0) + (7 & h && 1) + 4) - 4] | r[I - 3] << 8,
                _ = I + V;
              if (_ > s) {
                g && T(0);
                break;
              }
              c && d(O + V), f.set(r.subarray(I, _), O), u.b = O += V, u.p = k = 8 * _;
              continue;
            }
            if (1 == S) A = b, x = p, E = 9, D = 5;else if (2 == S) {
              var j = L(r, k, 31) + 257,
                z = L(r, k + 10, 15) + 4,
                C = j + L(r, k + 5, 31) + 1;
              k += 14;
              for (var F = new e(C), P = new e(19), q = 0; q < z; ++q) P[o[q]] = L(r, k + 3 * q, 7);
              k += 3 * z;
              var B = y(P),
                G = (1 << B) - 1,
                H = w(P, B, 1);
              for (q = 0; q < C;) {
                var I,
                  J = H[L(r, k, G)];
                if (k += 15 & J, (I = J >>> 4) < 16) F[q++] = I;else {
                  var K = 0,
                    N = 0;
                  for (16 == I ? (N = 3 + L(r, k, 3), k += 2, K = F[q - 1]) : 17 == I ? (N = 3 + L(r, k, 7), k += 3) : 18 == I && (N = 11 + L(r, k, 127), k += 7); N--;) F[q++] = K;
                }
              }
              var Q = F.subarray(0, j),
                R = F.subarray(j);
              E = y(Q), D = y(R), A = w(Q, E, 1), x = w(R, D, 1);
            } else T(1);
            if (k > M) {
              g && T(0);
              break;
            }
          }
          c && d(O + 131072);
          for (var W = (1 << E) - 1, X = (1 << D) - 1, Y = k;; Y = k) {
            var Z = (K = A[U(r, k) & W]) >>> 4;
            if ((k += 15 & K) > M) {
              g && T(0);
              break;
            }
            if (K || T(2), Z < 256) f[O++] = Z;else {
              if (256 == Z) {
                Y = k, A = null;
                break;
              }
              var $ = Z - 254;
              if (Z > 264) {
                var rr = a[q = Z - 257];
                $ = L(r, k, (1 << rr) - 1) + v[q], k += rr;
              }
              var er = x[U(r, k) & X],
                nr = er >>> 4;
              er || T(3), k += 15 & er;
              R = l[nr];
              if (nr > 3) {
                rr = i[nr];
                R += U(r, k) & (1 << rr) - 1, k += rr;
              }
              if (k > M) {
                g && T(0);
                break;
              }
              c && d(O + 131072);
              for (var tr = O + $; O < tr; O += 4) f[O] = f[O - R], f[O + 1] = f[O + 1 - R], f[O + 2] = f[O + 2 - R], f[O + 3] = f[O + 3 - R];
              O = tr;
            }
          }
          u.l = A, u.p = Y, u.b = O, A && (m = 1, u.m = E, u.d = x, u.n = D);
        } while (!m);
        return O == f.length ? f : function (r, a, i) {
          (null == a || a < 0) && (a = 0), (null == i || i > r.length) && (i = r.length);
          var o = new (r instanceof n ? n : r instanceof t ? t : e)(i - a);
          return o.set(r.subarray(a, i)), o;
        }(f, 0, O);
      },
      A = new e(0);
    var x = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x.decode(A, {
        stream: !0
      }), 1;
    } catch (r) {}
    return r.convert_streams = function (r) {
      var e = new DataView(r),
        n = 0;
      function t() {
        var r = e.getUint16(n);
        return n += 2, r;
      }
      function a() {
        var r = e.getUint32(n);
        return n += 4, r;
      }
      function i(r) {
        m.setUint16(b, r), b += 2;
      }
      function o(r) {
        m.setUint32(b, r), b += 4;
      }
      for (var f = {
          signature: a(),
          flavor: a(),
          length: a(),
          numTables: t(),
          reserved: t(),
          totalSfntSize: a(),
          majorVersion: t(),
          minorVersion: t(),
          metaOffset: a(),
          metaLength: a(),
          metaOrigLength: a(),
          privOffset: a(),
          privLength: a()
        }, u = 0; Math.pow(2, u) <= f.numTables;) u++;
      u--;
      for (var v = 16 * Math.pow(2, u), s = 16 * f.numTables - v, l = 12, c = [], g = 0; g < f.numTables; g++) c.push({
        tag: a(),
        offset: a(),
        compLength: a(),
        origLength: a(),
        origChecksum: a()
      }), l += 16;
      var h,
        w = new Uint8Array(12 + 16 * c.length + c.reduce(function (r, e) {
          return r + e.origLength + 4;
        }, 0)),
        d = w.buffer,
        m = new DataView(d),
        b = 0;
      return o(f.flavor), i(f.numTables), i(v), i(u), i(s), c.forEach(function (r) {
        o(r.tag), o(r.origChecksum), o(l), o(r.origLength), r.outOffset = l, (l += r.origLength) % 4 != 0 && (l += 4 - l % 4);
      }), c.forEach(function (e) {
        var n,
          t = r.slice(e.offset, e.offset + e.compLength);
        if (e.compLength != e.origLength) {
          var a = new Uint8Array(e.origLength);
          n = new Uint8Array(t, 2), O(n, a);
        } else a = new Uint8Array(t);
        w.set(a, e.outOffset);
        var i = 0;
        (l = e.outOffset + e.origLength) % 4 != 0 && (i = 4 - l % 4), w.set(new Uint8Array(i).buffer, e.outOffset + e.origLength), h = l + i;
      }), d.slice(0, h);
    }, Object.defineProperty(r, "__esModule", {
      value: !0
    }), r;
  }({}).convert_streams;
}

/**
 * A factory wrapper parsing a font file using Typr.
 * Also adds support for WOFF files (not WOFF2).
 */

/**
 * @typedef ParsedFont
 * @property {number} ascender
 * @property {number} descender
 * @property {number} xHeight
 * @property {(number) => boolean} supportsCodePoint
 * @property {(text:string, fontSize:number, letterSpacing:number, callback) => number} forEachGlyph
 * @property {number} lineGap
 * @property {number} capHeight
 * @property {number} unitsPerEm
 */

/**
 * @typedef {(buffer: ArrayBuffer) => ParsedFont} FontParser
 */

/**
 * @returns {FontParser}
 */
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };

  // {joinType: "skip+step,..."}
  const joiningTypeRawData = {
    "C": "18g,ca,368,1kz",
    "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
    "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
    "L": "x9u,jff,a,fd,jv",
    "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"
  };
  const JT_LEFT = 1,
    //indicates that a character joins with the subsequent character, but does not join with the preceding character.
    JT_RIGHT = 2,
    //indicates that a character joins with the preceding character, but does not join with the subsequent character.
    JT_DUAL = 4,
    //indicates that a character joins with the preceding character and joins with the subsequent character.
    JT_TRANSPARENT = 8,
    //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.
    JT_JOIN_CAUSING = 16,
    //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.
    JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,

  let joiningTypeMap;
  function getCharJoiningType(ch) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(',').forEach(range => {
          let [skip, step] = range.split('+');
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m[type]);
          for (let i = step; i--;) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch) || JT_NON_JOINING;
  }
  const ISOL = 1,
    INIT = 2,
    FINA = 3,
    MEDI = 4;
  const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];
  function detectJoiningForms(str) {
    // This implements the algorithm described here:
    // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i = 0; i < str.length; i++) {
      const code = str.codePointAt(i);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          // isol->init, fina->medi
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          // medi->fina, init->isol
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        // medi->fina, init->isol
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i] = form;
      prevJoiningType = joiningType;
      prevIndex = i;
      if (code > 0xffff) i++;
    }
    // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))
    // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))
    // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i = 0; i < str.length; i++) {
      const cc = str.codePointAt(i);
      if (cc > 0xffff) i++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font['GSUB'];
    if (gsub) {
      const {
        lookupList,
        featureList
      } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;
      const usedLookups = [];
      featureList.forEach(feature => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]]) continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              //lazy
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }

  // Calculate advances and x/y offsets for each glyph, e.g. kerning and mark
  // attachments. This is a more complete version of Typr.U.getPairAdjustment
  // and should become an upstream replacement eventually.
  function calcGlyphPositions(font, glyphIds) {
    const positions = new Int16Array(glyphIds.length * 3); // [offsetX, offsetY, advanceX, ...]
    let glyphIndex = 0;
    for (; glyphIndex < glyphIds.length; glyphIndex++) {
      const glyphId = glyphIds[glyphIndex];
      if (glyphId === -1) continue;
      positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId]; // populate advanceX in...advance.

      const gpos = font.GPOS;
      if (gpos) {
        const llist = gpos.lookupList;
        for (let i = 0; i < llist.length; i++) {
          const lookup = llist[i];
          for (let j = 0; j < lookup.tabs.length; j++) {
            const tab = lookup.tabs[j];
            // Single char placement
            if (lookup.ltype === 1) {
              const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);
              if (ind !== -1 && tab.pos) {
                applyValueRecord(tab.pos, glyphIndex);
                break;
              }
            }
            // Pairs (kerning)
            else if (lookup.ltype === 2) {
              let adj = null;
              let prevGlyphIndex = getPrevGlyphIndex();
              if (prevGlyphIndex !== -1) {
                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);
                if (coverageIndex !== -1) {
                  if (tab.fmt === 1) {
                    const right = tab.pairsets[coverageIndex];
                    for (let k = 0; k < right.length; k++) {
                      if (right[k].gid2 === glyphId) adj = right[k];
                    }
                  } else if (tab.fmt === 2) {
                    const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);
                    const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);
                    adj = tab.matrix[c1][c2];
                  }
                  if (adj) {
                    if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);
                    if (adj.val2) applyValueRecord(adj.val2, glyphIndex);
                    break;
                  }
                }
              }
            }
            // Mark to base
            else if (lookup.ltype === 4) {
              const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);
              if (markArrIndex !== -1) {
                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);
                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);
                if (baseArrIndex !== -1) {
                  const markRecord = tab.markArray[markArrIndex];
                  const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];
                  positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];
                  positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];
                  break;
                }
              }
            }
            // Mark to mark
            else if (lookup.ltype === 6) {
              const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);
              if (mark1ArrIndex !== -1) {
                const prevGlyphIndex = getPrevGlyphIndex();
                if (prevGlyphIndex !== -1) {
                  const prevGlyphId = glyphIds[prevGlyphIndex];
                  if (getGlyphClass(font, prevGlyphId) === 3) {
                    // only check mark glyphs
                    const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);
                    if (mark2ArrIndex !== -1) {
                      const mark1Record = tab.mark1Array[mark1ArrIndex];
                      const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];
                      positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];
                      positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
      // Check kern table if no GPOS
      else if (font.kern && !font.cff) {
        const prevGlyphIndex = getPrevGlyphIndex();
        if (prevGlyphIndex !== -1) {
          const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);
          if (ind1 !== -1) {
            const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);
            if (ind2 !== -1) {
              positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];
            }
          }
        }
      }
    }
    return positions;
    function getPrevGlyphIndex(filter) {
      for (let i = glyphIndex - 1; i >= 0; i--) {
        if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {
          return i;
        }
      }
      return -1;
    }
    function isBaseGlyph(glyphId) {
      return getGlyphClass(font, glyphId) === 1;
    }
    function applyValueRecord(source, gi) {
      for (let i = 0; i < 3; i++) {
        positions[gi * 3 + i] += source[i] || 0;
      }
    }
  }
  function getGlyphClass(font, glyphId) {
    const classDef = font.GDEF && font.GDEF.glyphClassDef;
    return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;
  }
  function firstNum(...args) {
    for (let i = 0; i < args.length; i++) {
      if (typeof args[i] === 'number') {
        return args[i];
      }
    }
  }

  /**
   * @returns ParsedFont
   */
  function wrapFontObj(typrFont) {
    const glyphMap = Object.create(null);
    const os2 = typrFont['OS/2'];
    const hhea = typrFont.hhea;
    const unitsPerEm = typrFont.head.unitsPerEm;
    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);

    /** @type ParsedFont */
    const fontObj = {
      unitsPerEm,
      ascender,
      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),
      capHeight: firstNum(os2 && os2.sCapHeight, ascender),
      xHeight: firstNum(os2 && os2.sxHeight, ascender),
      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),
      supportsCodePoint(code) {
        return Typr.U.codeToGlyph(typrFont, code) > 0;
      },
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let penX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIds = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        const positions = calcGlyphPositions(typrFont, glyphIds);
        glyphIds.forEach((glyphId, i) => {
          // Typr returns a glyph index per string codepoint, with -1s in place of those that
          // were omitted due to ligature substitution. So we can track original index in the
          // string via simple increment, and skip everything else when seeing a -1.
          if (glyphId !== -1) {
            let glyphObj = glyphMap[glyphId];
            if (!glyphObj) {
              const {
                cmds,
                crds
              } = Typr.U.glyphToPath(typrFont, glyphId);

              // Build path string
              let path = '';
              let crdsIdx = 0;
              for (let i = 0, len = cmds.length; i < len; i++) {
                const numArgs = cmdArgLengths[cmds[i]];
                path += cmds[i];
                for (let j = 1; j <= numArgs; j++) {
                  path += (j > 1 ? ',' : '') + crds[crdsIdx++];
                }
              }

              // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't
              // normalize the two, so it's simplest just to iterate ourselves.
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i = 0, len = crds.length; i < len; i += 2) {
                  let x = crds[i];
                  let y = crds[i + 1];
                  if (x < xMin) xMin = x;
                  if (y < yMin) yMin = y;
                  if (x > xMax) xMax = x;
                  if (y > yMax) yMax = y;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphId] = {
                index: glyphId,
                advanceWidth: typrFont.hmtx.aWidth[glyphId],
                xMin,
                yMin,
                xMax,
                yMax,
                path
              };
            }
            callback.call(null, glyphObj, penX + positions[i * 3] * fontScale, positions[i * 3 + 1] * fontScale, charIndex);
            penX += positions[i * 3 + 2] * fontScale;
            if (letterSpacing) {
              penX += letterSpacing * fontSize;
            }
          }
          charIndex += text.codePointAt(charIndex) > 0xffff ? 2 : 1;
        });
        return penX;
      }
    };
    return fontObj;
  }

  /**
   * @type FontParser
   */
  return function parse(buffer) {
    // Look to see if we have a WOFF file and convert it if so:
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === 'wOFF') {
      buffer = woff2otf(buffer);
    } else if (tag === 'wOF2') {
      throw new Error('woff2 fonts not supported');
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
const workerModule = /*#__PURE__*/(0, _troikaWorkerUtils.defineWorkerModule)({
  name: 'Typr Font Parser',
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory, woff2otfFactory, parserFactory) {
    const Typr = typrFactory();
    const woff2otf = woff2otfFactory();
    return parserFactory(Typr, woff2otf);
  }
});

/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function unicodeFontResolverClientFactory() {
  return function (t) {
    var n = function () {
      this.buckets = new Map();
    };
    n.prototype.add = function (t) {
      var n = t >> 5;
      this.buckets.set(n, (this.buckets.get(n) || 0) | 1 << (31 & t));
    }, n.prototype.has = function (t) {
      var n = this.buckets.get(t >> 5);
      return void 0 !== n && 0 != (n & 1 << (31 & t));
    }, n.prototype.serialize = function () {
      var t = [];
      return this.buckets.forEach(function (n, r) {
        t.push((+r).toString(36) + ":" + n.toString(36));
      }), t.join(",");
    }, n.prototype.deserialize = function (t) {
      var n = this;
      this.buckets.clear(), t.split(",").forEach(function (t) {
        var r = t.split(":");
        n.buckets.set(parseInt(r[0], 36), parseInt(r[1], 36));
      });
    };
    var r = Math.pow(2, 8),
      e = r - 1,
      o = ~e;
    function a(t) {
      var n = function (t) {
          return t & o;
        }(t).toString(16),
        e = function (t) {
          return (t & o) + r - 1;
        }(t).toString(16);
      return "codepoint-index/plane" + (t >> 16) + "/" + n + "-" + e + ".json";
    }
    function i(t, n) {
      var r = t & e,
        o = n.codePointAt(r / 6 | 0);
      return 0 != ((o = (o || 48) - 48) & 1 << r % 6);
    }
    function u(t, n) {
      var r;
      (r = t, r.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function (t) {
        return t.split("-").map(function (t) {
          return parseInt(t.trim(), 16);
        });
      })).forEach(function (t) {
        var r = t[0],
          e = t[1];
        void 0 === e && (e = r), n(r, e);
      });
    }
    function c(t, n) {
      u(t, function (t, r) {
        for (var e = t; e <= r; e++) n(e);
      });
    }
    var s = {},
      f = {},
      l = new WeakMap(),
      v = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function d(t) {
      var r = l.get(t);
      return r || (r = new n(), c(t.ranges, function (t) {
        return r.add(t);
      }), l.set(t, r)), r;
    }
    var h,
      p = new Map();
    function g(t, n, r) {
      return t[n] ? n : t[r] ? r : function (t) {
        for (var n in t) return n;
      }(t);
    }
    function w(t, n) {
      var r = n;
      if (!t.includes(r)) {
        r = 1 / 0;
        for (var e = 0; e < t.length; e++) Math.abs(t[e] - n) < Math.abs(r - n) && (r = t[e]);
      }
      return r;
    }
    function k(t) {
      return h || (h = new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function (t) {
        h.add(t);
      })), h.has(t);
    }
    return t.CodePointSet = n, t.clearCache = function () {
      s = {}, f = {};
    }, t.getFontsForString = function (t, n) {
      void 0 === n && (n = {});
      var r,
        e = n.lang;
      void 0 === e && (e = /\p{Script=Hangul}/u.test(r = t) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(r) ? "ja" : "en");
      var o = n.category;
      void 0 === o && (o = "sans-serif");
      var u = n.style;
      void 0 === u && (u = "normal");
      var c = n.weight;
      void 0 === c && (c = 400);
      var l = (n.dataUrl || v).replace(/\/$/g, ""),
        h = new Map(),
        y = new Uint8Array(t.length),
        b = {},
        m = {},
        A = new Array(t.length),
        S = new Map(),
        j = !1;
      function M(t) {
        var n = p.get(t);
        return n || (n = fetch(l + "/" + t).then(function (t) {
          if (!t.ok) throw new Error(t.statusText);
          return t.json().then(function (t) {
            if (!Array.isArray(t) || 1 !== t[0]) throw new Error("Incorrect schema version; need 1, got " + t[0]);
            return t[1];
          });
        }).catch(function (n) {
          if (l !== v) return j || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + l + '", trying default CDN. ' + n.message), j = !0), l = v, p.delete(t), M(t);
          throw n;
        }), p.set(t, n)), n;
      }
      for (var P = function (n) {
          var r = t.codePointAt(n),
            e = a(r);
          A[n] = e, s[e] || S.has(e) || S.set(e, M(e).then(function (t) {
            s[e] = t;
          })), r > 65535 && (n++, E = n);
        }, E = 0; E < t.length; E++) P(E);
      return Promise.all(S.values()).then(function () {
        S.clear();
        for (var n = function (n) {
            var o = t.codePointAt(n),
              a = null,
              u = s[A[n]],
              c = void 0;
            for (var l in u) {
              var v = m[l];
              if (void 0 === v && (v = m[l] = new RegExp(l).test(e || "en")), v) {
                for (var d in c = l, u[l]) if (i(o, u[l][d])) {
                  a = d;
                  break;
                }
                break;
              }
            }
            if (!a) t: for (var h in u) if (h !== c) for (var p in u[h]) if (i(o, u[h][p])) {
              a = p;
              break t;
            }
            a || (console.debug("No font coverage for U+" + o.toString(16)), a = "latin"), A[n] = a, f[a] || S.has(a) || S.set(a, M("font-meta/" + a + ".json").then(function (t) {
              f[a] = t;
            })), o > 65535 && (n++, r = n);
          }, r = 0; r < t.length; r++) n(r);
        return Promise.all(S.values());
      }).then(function () {
        for (var n, r = null, e = 0; e < t.length; e++) {
          var a = t.codePointAt(e);
          if (r && (k(a) || d(r).has(a))) y[e] = y[e - 1];else {
            r = f[A[e]];
            var i = b[r.id];
            if (!i) {
              var s = r.typeforms,
                v = g(s, o, "sans-serif"),
                p = g(s[v], u, "normal"),
                m = w(null === (n = s[v]) || void 0 === n ? void 0 : n[p], c);
              i = b[r.id] = l + "/font-files/" + r.id + "/" + v + "." + p + "." + m + ".woff";
            }
            var S = h.get(i);
            null == S && (S = h.size, h.set(i, S)), y[e] = S;
          }
          a > 65535 && (e++, y[e] = y[e - 1]);
        }
        return {
          fontUrls: Array.from(h.keys()),
          chars: y
        };
      });
    }, Object.defineProperty(t, "__esModule", {
      value: !0
    }), t;
  }({});
}

/**
 * @typedef {string | {src:string, label?:string, unicodeRange?:string, lang?:string}} UserFont
 */

/**
 * @typedef {ClientOptions} FontResolverOptions
 * @property {Array<UserFont>|UserFont} [fonts]
 * @property {'normal'|'italic'} [style]
 * @property {'normal'|'bold'|number} [style]
 * @property {string} [unicodeFontsURL]
 */

/**
 * @typedef {Object} FontResolverResult
 * @property {Uint8Array} chars
 * @property {Array<ParsedFont & {src:string}>} fonts
 */

/**
 * @typedef {function} FontResolver
 * @param {string} text
 * @param {(FontResolverResult) => void} callback
 * @param {FontResolverOptions} [options]
 */

/**
 * Factory for the FontResolver function.
 * @param {FontParser} fontParser
 * @param {{getFontsForString: function, CodePointSet: function}} unicodeFontResolverClient
 * @return {FontResolver}
 */
function createFontResolver(fontParser, unicodeFontResolverClient) {
  /**
   * @type {Record<string, ParsedFont>}
   */
  const parsedFonts = Object.create(null);

  /**
   * @type {Record<string, Array<(ParsedFont) => void>>}
   */
  const loadingFonts = Object.create(null);

  /**
   * Load a given font url
   */
  function doLoadFont(url, callback) {
    const onError = err => {
      console.error(`Failure loading font ${url}`, err);
    };
    try {
      const request = new XMLHttpRequest();
      request.open('get', url, true);
      request.responseType = 'arraybuffer';
      request.onload = function () {
        if (request.status >= 400) {
          onError(new Error(request.statusText));
        } else if (request.status > 0) {
          try {
            const fontObj = fontParser(request.response);
            fontObj.src = url;
            callback(fontObj);
          } catch (e) {
            onError(e);
          }
        }
      };
      request.onerror = onError;
      request.send();
    } catch (err) {
      onError(err);
    }
  }

  /**
   * Load a given font url if needed, invoking a callback when it's loaded. If already
   * loaded, the callback will be called synchronously.
   * @param {string} fontUrl
   * @param {(font: ParsedFont) => void} callback
   */
  function loadFont(fontUrl, callback) {
    let font = parsedFonts[fontUrl];
    if (font) {
      callback(font);
    } else if (loadingFonts[fontUrl]) {
      loadingFonts[fontUrl].push(callback);
    } else {
      loadingFonts[fontUrl] = [callback];
      doLoadFont(fontUrl, fontObj => {
        fontObj.src = fontUrl;
        parsedFonts[fontUrl] = fontObj;
        loadingFonts[fontUrl].forEach(cb => cb(fontObj));
        delete loadingFonts[fontUrl];
      });
    }
  }

  /**
   * For a given string of text, determine which fonts are required to fully render it and
   * ensure those fonts are loaded.
   */
  return function (text, callback, {
    lang,
    fonts: userFonts = [],
    style = 'normal',
    weight = 'normal',
    unicodeFontsURL
  } = {}) {
    const charResolutions = new Uint8Array(text.length);
    const fontResolutions = [];
    if (!text.length) {
      allDone();
    }
    const fontIndices = new Map();
    const fallbackRanges = []; // [[start, end], ...]

    if (style !== 'italic') style = 'normal';
    if (typeof weight !== 'number') {
      weight = weight === 'bold' ? 700 : 400;
    }
    if (userFonts && !Array.isArray(userFonts)) {
      userFonts = [userFonts];
    }
    userFonts = userFonts.slice()
    // filter by language
    .filter(def => !def.lang || def.lang.test(lang))
    // switch order for easier iteration
    .reverse();
    if (userFonts.length) {
      const UNKNOWN = 0;
      const RESOLVED = 1;
      const NEEDS_FALLBACK = 2;
      let prevCharResult = UNKNOWN;
      (function resolveUserFonts(startIndex = 0) {
        for (let i = startIndex, iLen = text.length; i < iLen; i++) {
          const codePoint = text.codePointAt(i);
          // Carry previous character's result forward if:
          // - it resolved to a font that also covers this character
          // - this character is whitespace
          if (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint) || /\s/.test(text[i])) {
            charResolutions[i] = charResolutions[i - 1];
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          } else {
            for (let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++) {
              if (j === jLen) {
                // none of the user fonts matched; needs fallback
                const range = prevCharResult === NEEDS_FALLBACK ? fallbackRanges[fallbackRanges.length - 1] : fallbackRanges[fallbackRanges.length] = [i, i];
                range[1] = i;
                prevCharResult = NEEDS_FALLBACK;
              } else {
                charResolutions[i] = j;
                const {
                  src,
                  unicodeRange
                } = userFonts[j];
                // filter by optional explicit unicode ranges
                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {
                  const fontObj = parsedFonts[src];
                  // font not yet loaded, load it and resume
                  if (!fontObj) {
                    loadFont(src, () => {
                      resolveUserFonts(i);
                    });
                    return;
                  }
                  // if the font actually contains a glyph for this char, lock it in
                  if (fontObj.supportsCodePoint(codePoint)) {
                    let fontIndex = fontIndices.get(fontObj);
                    if (typeof fontIndex !== 'number') {
                      fontIndex = fontResolutions.length;
                      fontResolutions.push(fontObj);
                      fontIndices.set(fontObj, fontIndex);
                    }
                    charResolutions[i] = fontIndex;
                    prevCharResult = RESOLVED;
                    break;
                  }
                }
              }
            }
          }
          if (codePoint > 0xffff && i + 1 < iLen) {
            charResolutions[i + 1] = charResolutions[i];
            i++;
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          }
        }
        resolveFallbacks();
      })();
    } else {
      fallbackRanges.push([0, text.length - 1]);
      resolveFallbacks();
    }
    function resolveFallbacks() {
      if (fallbackRanges.length) {
        // Combine all fallback substrings into a single string for querying
        const fallbackString = fallbackRanges.map(range => text.substring(range[0], range[1] + 1)).join('\n');
        unicodeFontResolverClient.getFontsForString(fallbackString, {
          lang: lang || undefined,
          style,
          weight,
          dataUrl: unicodeFontsURL
        }).then(({
          fontUrls,
          chars
        }) => {
          // Extract results and put them back in the main array
          const fontIndexOffset = fontResolutions.length;
          let charIdx = 0;
          fallbackRanges.forEach(range => {
            for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {
              charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;
            }
            charIdx++; //skip segment separator
          });

          // Load and parse the fallback fonts - avoiding Promise here to prevent polyfills in the worker
          let loadedCount = 0;
          fontUrls.forEach((url, i) => {
            loadFont(url, fontObj => {
              fontResolutions[i + fontIndexOffset] = fontObj;
              if (++loadedCount === fontUrls.length) {
                allDone();
              }
            });
          });
        });
      } else {
        allDone();
      }
    }
    function allDone() {
      callback({
        chars: charResolutions,
        fonts: fontResolutions
      });
    }
    function isCodeInRanges(code, ranges) {
      // todo optimize search - CodePointSet from unicode-font-resolver?
      for (let k = 0; k < ranges.length; k++) {
        const [start, end = start] = ranges[k];
        if (start <= code && code <= end) {
          return true;
        }
      }
      return false;
    }
  };
}
const fontResolverWorkerModule = exports.fontResolverWorkerModule = /*#__PURE__*/(0, _troikaWorkerUtils.defineWorkerModule)({
  name: 'FontResolver',
  dependencies: [createFontResolver, workerModule, unicodeFontResolverClientFactory],
  init(createFontResolver, fontParser, unicodeFontResolverClientFactory) {
    return createFontResolver(fontParser, unicodeFontResolverClientFactory());
  }
});

/**
 * @typedef {number|'left'|'center'|'right'} AnchorXValue
 */
/**
 * @typedef {number|'top'|'top-baseline'|'top-cap'|'top-ex'|'middle'|'bottom-baseline'|'bottom'} AnchorYValue
 */

/**
 * @typedef {object} TypesetParams
 * @property {string} text
 * @property {UserFont|UserFont[]} [font]
 * @property {string} [lang]
 * @property {number} [sdfGlyphSize=64]
 * @property {number} [fontSize=1]
 * @property {number|'normal'|'bold'} [fontWeight='normal']
 * @property {'normal'|'italic'} [fontStyle='normal']
 * @property {number} [letterSpacing=0]
 * @property {'normal'|number} [lineHeight='normal']
 * @property {number} [maxWidth]
 * @property {'ltr'|'rtl'} [direction='ltr']
 * @property {string} [textAlign='left']
 * @property {number} [textIndent=0]
 * @property {'normal'|'nowrap'} [whiteSpace='normal']
 * @property {'normal'|'break-word'} [overflowWrap='normal']
 * @property {AnchorXValue} [anchorX=0]
 * @property {AnchorYValue} [anchorY=0]
 * @property {boolean} [metricsOnly=false]
 * @property {string} [unicodeFontsURL]
 * @property {FontResolverResult} [preResolvedFonts]
 * @property {boolean} [includeCaretPositions=false]
 * @property {number} [chunkedBoundsSize=8192]
 * @property {{[rangeStartIndex]: number}} [colorRanges]
 */

/**
 * @typedef {object} TypesetResult
 * @property {Uint16Array} glyphIds id for each glyph, specific to that glyph's font
 * @property {Uint8Array} glyphFontIndices index into fontData for each glyph
 * @property {Float32Array} glyphPositions x,y of each glyph's origin in layout
 * @property {{[font]: {[glyphId]: {path: string, pathBounds: number[]}}}} glyphData data about each glyph appearing in the text
 * @property {TypesetFontData[]} fontData data about each font used in the text
 * @property {Float32Array} [caretPositions] startX,endX,bottomY caret positions for each char
 * @property {Uint8Array} [glyphColors] color for each glyph, if color ranges supplied
 *         chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs
 *         fontSize, //calculated em height
 *         topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline
 *         blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight
 *           anchorXOffset,
 *           anchorYOffset - totalHeight,
 *           anchorXOffset + maxLineWidth,
 *           anchorYOffset
 *         ],
 *         visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds
 *         timings
 */

/**
 * @typedef {object} TypesetFontData
 * @property src
 * @property unitsPerEm
 * @property ascender
 * @property descender
 * @property lineHeight
 * @property capHeight
 * @property xHeight
 */

/**
 * @typedef {function} TypesetterTypesetFunction - compute fonts and layout for some text.
 * @param {TypesetParams} params
 * @param {(TypesetResult) => void} callback - function called when typesetting is complete.
 *    If the params included `preResolvedFonts`, this will be called synchronously.
 */

/**
 * @typedef {function} TypesetterMeasureFunction - compute width/height for some text.
 * @param {TypesetParams} params
 * @param {(width:number, height:number) => void} callback - function called when measurement is complete.
 *    If the params included `preResolvedFonts`, this will be called synchronously.
 */

/**
 * Factory function that creates a self-contained environment for processing text typesetting requests.
 *
 * It is important that this function has no closure dependencies, so that it can be easily injected
 * into the source for a Worker without requiring a build step or complex dependency loading. All its
 * dependencies must be passed in at initialization.
 *
 * @param {FontResolver} resolveFonts - function to resolve a string to parsed fonts
 * @param {object} bidi - the bidi.js implementation object
 * @return {{typeset: TypesetterTypesetFunction, measure: TypesetterMeasureFunction}}
 */
function createTypesetter(resolveFonts, bidi) {
  const INF = Infinity;

  // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs
  // eslint-disable-next-line no-misleading-character-class
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;

  // This regex (instead of /\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces
  const lineBreakingWhiteSpace = `[^\\S\\u00A0]`;

  // Incomplete set of characters that allow line breaking after them
  // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14
  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);

  /**
   * Load and parse all the necessary fonts to render a given string of text, then group
   * them into consecutive runs of characters sharing a font.
   */
  function calculateFontRuns({
    text,
    lang,
    fonts,
    style,
    weight,
    preResolvedFonts,
    unicodeFontsURL
  }, onDone) {
    const onResolved = ({
      chars,
      fonts: parsedFonts
    }) => {
      let curRun, prevVal;
      const runs = [];
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] !== prevVal) {
          prevVal = chars[i];
          runs.push(curRun = {
            start: i,
            end: i,
            fontObj: parsedFonts[chars[i]]
          });
        } else {
          curRun.end = i;
        }
      }
      onDone(runs);
    };
    if (preResolvedFonts) {
      onResolved(preResolvedFonts);
    } else {
      resolveFonts(text, onResolved, {
        lang,
        fonts,
        style,
        weight,
        unicodeFontsURL
      });
    }
  }

  /**
   * Main entry point.
   * Process a text string with given font and formatting parameters, and return all info
   * necessary to render all its glyphs.
   * @type TypesetterTypesetFunction
   */
  function typeset({
    text = '',
    font,
    lang,
    sdfGlyphSize = 64,
    fontSize = 400,
    fontWeight = 1,
    fontStyle = 'normal',
    letterSpacing = 0,
    lineHeight = 'normal',
    maxWidth = INF,
    direction,
    textAlign = 'left',
    textIndent = 0,
    whiteSpace = 'normal',
    overflowWrap = 'normal',
    anchorX = 0,
    anchorY = 0,
    metricsOnly = false,
    unicodeFontsURL,
    preResolvedFonts = null,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback) {
    const mainStart = now();
    const timings = {
      fontLoad: 0,
      typesetting: 0
    };

    // Ensure newlines are normalized
    if (text.indexOf('\r') > -1) {
      console.info('Typesetter: got text with \\r chars; normalizing to \\n');
      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    }

    // Ensure we've got numbers not strings
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || 'normal';
    textIndent = +textIndent;
    calculateFontRuns({
      text,
      lang,
      style: fontStyle,
      weight: fontWeight,
      fonts: typeof font === 'string' ? [{
        src: font
      }] : font,
      unicodeFontsURL,
      preResolvedFonts
    }, runs => {
      timings.fontLoad = now() - mainStart;
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphFontIndices = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== 'nowrap';
      const metricsByFont = new Map(); // fontObj -> metrics
      const typesetStart = now();

      // Distribute glyphs into lines based on wrapping
      let lineXOffset = textIndent;
      let prevRunEndX = 0;
      let currentLine = new TextLine();
      const lines = [currentLine];
      runs.forEach(run => {
        const {
          fontObj
        } = run;
        const {
          ascender,
          descender,
          unitsPerEm,
          lineGap,
          capHeight,
          xHeight
        } = fontObj;

        // Calculate metrics for each font used
        let fontData = metricsByFont.get(fontObj);
        if (!fontData) {
          // Find conversion between native font units and fontSize units
          const fontSizeMult = fontSize / unitsPerEm;

          // Determine appropriate value for 'normal' line height based on the font's actual metrics
          // This does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?
          const calcLineHeight = lineHeight === 'normal' ? (ascender - descender + lineGap) * fontSizeMult : lineHeight * fontSize;

          // Determine line height and leading adjustments
          const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult) / 2;
          const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult);
          const caretTop = (ascender + descender) / 2 * fontSizeMult + caretHeight / 2;
          fontData = {
            index: metricsByFont.size,
            src: fontObj.src,
            fontObj,
            fontSizeMult,
            unitsPerEm,
            ascender: ascender * fontSizeMult,
            descender: descender * fontSizeMult,
            capHeight: capHeight * fontSizeMult,
            xHeight: xHeight * fontSizeMult,
            lineHeight: calcLineHeight,
            baseline: -halfLeading - ascender * fontSizeMult,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop,
            caretBottom: caretTop - caretHeight
          };
          metricsByFont.set(fontObj, fontData);
        }
        const {
          fontSizeMult
        } = fontData;
        const runText = text.slice(run.start, run.end + 1);
        let prevGlyphX, prevGlyphObj;
        fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {
          glyphX += prevRunEndX;
          charIndex += run.start;
          prevGlyphX = glyphX;
          prevGlyphObj = glyphObj;
          const char = text.charAt(charIndex);
          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
          const curLineCount = currentLine.count;
          let nextLine;

          // Calc isWhitespace and isEmpty once per glyphObj
          if (!('isEmpty' in glyphObj)) {
            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);
            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
          }
          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
            renderableGlyphCount++;
          }

          // If a non-whitespace character overflows the max width, we need to soft-wrap
          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
            // If it's the first char after a whitespace, start a new line
            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
              nextLine = new TextLine();
              lineXOffset = -glyphX;
            } else {
              // Back up looking for a whitespace character to wrap at
              for (let i = curLineCount; i--;) {
                // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'
                if (i === 0 && overflowWrap === 'break-word') {
                  nextLine = new TextLine();
                  lineXOffset = -glyphX;
                  break;
                }
                // Found a soft break point; move all chars since it to a new line
                else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {
                  nextLine = currentLine.splitAt(i + 1);
                  const adjustX = nextLine.glyphAt(0).x;
                  lineXOffset -= adjustX;
                  for (let j = nextLine.count; j--;) {
                    nextLine.glyphAt(j).x -= adjustX;
                  }
                  break;
                }
              }
            }
            if (nextLine) {
              currentLine.isSoftWrapped = true;
              currentLine = nextLine;
              lines.push(currentLine);
              maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width
            }
          }
          let fly = currentLine.glyphAt(currentLine.count);
          fly.glyphObj = glyphObj;
          fly.x = glyphX + lineXOffset;
          fly.y = glyphY;
          fly.width = glyphWidth;
          fly.charIndex = charIndex;
          fly.fontData = fontData;

          // Handle hard line breaks
          if (char === '\n') {
            currentLine = new TextLine();
            lines.push(currentLine);
            lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
          }
        });
        // At the end of a run we must capture the x position as the starting point for the next run
        prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;
      });

      // Calculate width/height/baseline of each line (excluding trailing whitespace) and maximum block width
      let totalHeight = 0;
      lines.forEach(line => {
        let isTrailingWhitespace = true;
        for (let i = line.count; i--;) {
          const glyphInfo = line.glyphAt(i);
          // omit trailing whitespace from width calculation
          if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {
            line.width = glyphInfo.x + glyphInfo.width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            isTrailingWhitespace = false;
          }
          // use the tallest line height, lowest baseline, and highest cap/ex
          let {
            lineHeight,
            capHeight,
            xHeight,
            baseline
          } = glyphInfo.fontData;
          if (lineHeight > line.lineHeight) line.lineHeight = lineHeight;
          const baselineDiff = baseline - line.baseline;
          if (baselineDiff < 0) {
            //shift all metrics down
            line.baseline += baselineDiff;
            line.cap += baselineDiff;
            line.ex += baselineDiff;
          }
          // compare cap/ex based on new lowest baseline
          line.cap = Math.max(line.cap, line.baseline + capHeight);
          line.ex = Math.max(line.ex, line.baseline + xHeight);
        }
        line.baseline -= totalHeight;
        line.cap -= totalHeight;
        line.ex -= totalHeight;
        totalHeight += line.lineHeight;
      });

      // Find overall position adjustments for anchoring
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === 'number') {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === 'string') {
          anchorXOffset = -maxLineWidth * (anchorX === 'left' ? 0 : anchorX === 'center' ? 0.5 : anchorX === 'right' ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === 'number') {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === 'string') {
          anchorYOffset = anchorY === 'top' ? 0 : anchorY === 'top-baseline' ? -lines[0].baseline : anchorY === 'top-cap' ? -lines[0].cap : anchorY === 'top-ex' ? -lines[0].ex : anchorY === 'middle' ? totalHeight / 2 : anchorY === 'bottom' ? totalHeight : anchorY === 'bottom-baseline' ? -lines[lines.length - 1].baseline : parsePercent(anchorY) * totalHeight;
        }
      }
      if (!metricsOnly) {
        // Resolve bidi levels
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);

        // Process each line, applying alignment offsets, adding each glyph to the atlas, and
        // collecting all renderable glyphs into a single collection.
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphFontIndices = new Uint8Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 4);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let {
            count: lineGlyphCount,
            width: lineWidth
          } = line;

          // Ignore empty lines
          if (lineGlyphCount > 0) {
            // Count trailing whitespaces, we want to ignore these for certain things
            let trailingWhitespaceCount = 0;
            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {
              trailingWhitespaceCount++;
            }

            // Apply horizontal alignment adjustments
            let lineXOffset = 0;
            let justifyAdjust = 0;
            if (textAlign === 'center') {
              lineXOffset = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === 'right') {
              lineXOffset = maxLineWidth - lineWidth;
            } else if (textAlign === 'justify' && line.isSoftWrapped) {
              // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop
              let whitespaceCount = 0;
              for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {
                if (line.glyphAt(i).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset) {
              let justifyOffset = 0;
              for (let i = 0; i < lineGlyphCount; i++) {
                let glyphInfo = line.glyphAt(i);
                const glyphObj = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset + justifyOffset;
                // Expand non-trailing whitespaces for justify alignment
                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }

            // Perform bidi range flipping
            const flips = bidi.getReorderSegments(text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex);
            for (let fi = 0; fi < flips.length; fi++) {
              const [start, end] = flips[fi];
              // Map start/end string indices to indices in the line
              let left = Infinity,
                right = -Infinity;
              for (let i = 0; i < lineGlyphCount; i++) {
                if (line.glyphAt(i).charIndex >= start) {
                  // gte to handle removed characters
                  let startInLine = i,
                    endInLine = i;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      //don't include trailing ws in flip width
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j = startInLine; j < endInLine; j++) {
                    const glyphInfo = line.glyphAt(j);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }

            // Assemble final data arrays
            let glyphObj;
            const setGlyphObj = g => glyphObj = g;
            for (let i = 0; i < lineGlyphCount; i++) {
              const glyphInfo = line.glyphAt(i);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;

              // Replace mirrored characters in rtl
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }

              // Add caret positions
              if (includeCaretPositions) {
                const {
                  charIndex,
                  fontData
                } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft; //start edge x
                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight; //end edge x
                caretPositions[charIndex * 4 + 2] = line.baseline + fontData.caretBottom + anchorYOffset; //common bottom y
                caretPositions[charIndex * 4 + 3] = line.baseline + fontData.caretTop + anchorYOffset; //common top y

                // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret
                // positions for those missing char indices; currently this uses a best-guess by dividing
                // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList
                // table to get better interior caret positions.
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }

              // Track current color range
              if (colorRanges) {
                const {
                  charIndex
                } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }

              // Get atlas data for renderable glyphs
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                const {
                  fontSizeMult,
                  src: fontSrc,
                  index: fontIndex
                } = glyphInfo.fontData;

                // Add this glyph's path data
                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});
                if (!fontGlyphData[glyphId]) {
                  fontGlyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }

                // Determine final glyph position and add to glyphPositions array
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;

                // Track total visible bounds
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;

                // Track bounding rects for each chunk of N glyphs
                if (idx % chunkedBoundsSize === 0) {
                  chunk = {
                    start: idx,
                    end: idx,
                    rect: [INF, INF, -INF, -INF]
                  };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;
                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;
                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;
                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;

                // Add to glyph ids and font indices arrays
                glyphIds[idx] = glyphId;
                glyphFontIndices[idx] = fontIndex;

                // Add colors
                if (colorRanges) {
                  const start = idx * 3;
                  glyphColors[start] = currentColor >> 16 & 255;
                  glyphColors[start + 1] = currentColor >> 8 & 255;
                  glyphColors[start + 2] = currentColor & 255;
                }
              }
            }
          }
        });

        // Fill in remaining caret positions in case the final character was a ligature
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }

      // Assemble final data about each font used
      const fontData = [];
      metricsByFont.forEach(({
        index,
        src,
        unitsPerEm,
        ascender,
        descender,
        lineHeight,
        capHeight,
        xHeight
      }) => {
        fontData[index] = {
          src,
          unitsPerEm,
          ascender,
          descender,
          lineHeight,
          capHeight,
          xHeight
        };
      });

      // Timing stats
      timings.typesetting = now() - typesetStart;
      callback({
        glyphIds,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices,
        //index into fontData for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        fontData,
        //data about each font used in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        topBaseline: anchorYOffset + lines[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
        //bounds for the whole block of text, including vertical padding for lineHeight
        anchorXOffset, anchorYOffset - totalHeight, anchorXOffset + maxLineWidth, anchorYOffset],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings
      });
    });
  }

  /**
   * For a given text string and font parameters, determine the resulting block dimensions
   * after wrapping for the given maxWidth.
   * @param args
   * @param callback
   */
  function measure(args, callback) {
    typeset({
      ...args,
      metricsOnly: true
    }, result => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 4];
    const ligEndX = caretPositions[ligStartIndex * 4 + 1];
    const ligBottom = caretPositions[ligStartIndex * 4 + 2];
    const ligTop = caretPositions[ligStartIndex * 4 + 3];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i = 0; i < ligCount; i++) {
      const startIndex = (ligStartIndex + i) * 4;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);
      caretPositions[startIndex + 2] = ligBottom;
      caretPositions[startIndex + 3] = ligTop;
    }
  }
  function now() {
    return (self.performance || Date).now();
  }

  // Array-backed structure for a single line's glyphs data
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ['glyphObj', 'x', 'y', 'width', 'charIndex', 'fontData'];
  TextLine.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i;
      return fly;
    },
    splitAt(i) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {
    Object.defineProperty(obj, prop, {
      get() {
        return this.data[this.index * textLineProps.length + i];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i] = val;
      }
    });
    return obj;
  }, {
    data: null,
    index: 0
  });
  return {
    typeset,
    measure
  };
}
const now = () => (self.performance || Date).now();
const mainThreadGenerator = /*#__PURE__*/(0, _webglSdfGenerator.default)();
let warned;

/**
 * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a
 * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF
 * generation when supported.
 */
function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {
  // Allow opt-out
  if (!useWebGL) {
    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);
  }

  // Attempt GPU-accelerated generation first
  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(null, err => {
    // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers
    if (!warned) {
      console.warn(`WebGL SDF generation failed, falling back to JS`, err);
      warned = true;
    }
    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);
  });
}
const queue = [];
const chunkTimeBudget = 5; // ms
let timer = 0;
function nextChunk() {
  const start = now();
  while (queue.length && now() - start < chunkTimeBudget) {
    queue.shift()();
  }
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}

/**
 * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded
 * macrotask chunks to allow render frames to execute in between.
 */
const generateSDF_GL = (...args) => {
  return new Promise((resolve, reject) => {
    queue.push(() => {
      const start = now();
      try {
        mainThreadGenerator.webgl.generateIntoCanvas(...args);
        resolve({
          timing: now() - start
        });
      } catch (err) {
        reject(err);
      }
    });
    if (!timer) {
      timer = setTimeout(nextChunk, 0);
    }
  });
};
const threadCount = 4; // how many workers to spawn
const idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds
const threads = {};
let callNum = 0;

/**
 * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism
 */
function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {
  const workerId = 'TroikaTextSDFGenerator_JS_' + callNum++ % threadCount;
  let thread = threads[workerId];
  if (!thread) {
    thread = threads[workerId] = {
      workerModule: (0, _troikaWorkerUtils.defineWorkerModule)({
        name: workerId,
        workerId,
        dependencies: [_webglSdfGenerator.default, now],
        init(_createSDFGenerator, now) {
          const generate = _createSDFGenerator().javascript.generate;
          return function (...args) {
            const start = now();
            const textureData = generate(...args);
            return {
              textureData,
              timing: now() - start
            };
          };
        },
        getTransferables(result) {
          return [result.textureData.buffer];
        }
      }),
      requests: 0,
      idleTimer: null
    };
  }
  thread.requests++;
  clearTimeout(thread.idleTimer);
  return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({
    textureData,
    timing
  }) => {
    // copy result data into the canvas
    const start = now();
    // expand single-channel data into rgba
    const imageData = new Uint8Array(textureData.length * 4);
    for (let i = 0; i < textureData.length; i++) {
      imageData[i * 4 + channel] = textureData[i];
    }
    mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << 3 - channel);
    timing += now() - start;

    // clean up workers after a while
    if (--thread.requests === 0) {
      thread.idleTimer = setTimeout(() => {
        (0, _troikaWorkerUtils.terminateWorker)(workerId);
      }, idleTimeout);
    }
    return {
      timing
    };
  });
}
function warmUpSDFCanvas(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
const resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
const CONFIG = {
  defaultFontURL: null,
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
};
const tempColor = /*#__PURE__*/new _three.Color();
let hasRequested = false;
function now$1() {
  return (self.performance || Date).now();
}

/**
 * Customizes the text builder configuration. This must be called prior to the first font processing
 * request, and applies to all fonts.
 *
 * @param {String} config.defaultFontURL - The URL of the default font to use for text processing
 *                 requests, in case none is specified or the specifiede font fails to load or parse.
 *                 Defaults to "Roboto Regular" from Google Fonts.
 * @param {String} config.unicodeFontsURL - A custom location for the fallback unicode-font-resolver
 *                 data and font files, if you don't want to use the default CDN. See
 *                 https://github.com/lojjic/unicode-font-resolver for details. It can also be
 *                 configured per text instance, but this lets you do it once globally.
 * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)
 *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,
 *                 but note that this can also be overridden per call to `getTextRenderInfo()`.
 *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness
 *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults
 *                 to 64 which is generally a good balance of size and quality.
 * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent
 *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer
 *                 the glyph's path, with lower precision further away. Defaults to 9.
 * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's
 *                 path, as a percentage of the SDF width. A larger margin increases the quality of
 *                 extruded glyph outlines, but decreases the precision available for the glyph itself.
 *                 Defaults to 1/16th of the glyph size.
 * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to
 *                 2048 which is a safe maximum texture dimension according to the stats at
 *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a
 *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of
 *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to
 *                 increase the glyph size and/or have an extraordinary number of glyphs.
 */
function configureTextBuilder(config) {
  if (hasRequested) {
    console.warn('configureTextBuilder called after first font request; will be ignored.');
  } else {
    assign(CONFIG, config);
  }
}

/**
 * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for
 * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.
 *
 *   {
 *     [sdfGlyphSize]: {
 *       glyphCount: number,
 *       sdfGlyphSize: number,
 *       sdfTexture: Texture,
 *       sdfCanvas: HTMLCanvasElement,
 *       contextLost: boolean,
 *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>
 *     }
 *   }
 */
const atlases = Object.create(null);

/**
 * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.
 * @property {TypesetParams} parameters - The normalized input arguments to the render call.
 * @property {Texture} sdfTexture - The SDF atlas texture.
 * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.
 * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.
 * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.
 * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.
 * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.
 * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is
 *           four elements: the starting X, the ending X, the bottom Y, and the top Y for the caret.
 * @property {number} [caretHeight] - An appropriate height for all selection carets.
 * @property {number} ascender - The font's ascender metric.
 * @property {number} descender - The font's descender metric.
 * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.
 * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.
 * @property {number} lineHeight - The final computed lineHeight measurement.
 * @property {number} topBaseline - The y position of the top line's baseline.
 * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;
 *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is
 *           equivalent to the dimensions of a block-level text element in CSS.
 * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;
 *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.
 * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,
 *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.
 * @property {object} timings - Timing info for various parts of the rendering logic including SDF
 *           generation, typesetting, etc.
 * @frozen
 */

/**
 * @callback getTextRenderInfo~callback
 * @param {TroikaTextRenderInfo} textRenderInfo
 */

/**
 * Main entry point for requesting the data needed to render a text string with given font parameters.
 * This is an asynchronous call, performing most of the logic in a web worker thread.
 * @param {TypesetParams} args
 * @param {getTextRenderInfo~callback} callback
 */
function getTextRenderInfo(args, callback) {
  hasRequested = true;
  args = assign({}, args);
  const totalStart = now$1();

  // Convert relative URL to absolute so it can be resolved in the worker, and add fallbacks.
  // In the future we'll allow args.font to be a list with unicode ranges too.
  const {
    defaultFontURL
  } = CONFIG;
  const fonts = [];
  if (defaultFontURL) {
    fonts.push({
      label: 'default',
      src: toAbsoluteURL(defaultFontURL)
    });
  }
  if (args.font) {
    fonts.push({
      label: 'user',
      src: toAbsoluteURL(args.font)
    });
  }
  args.font = fonts;

  // Normalize text to a string
  args.text = '' + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;

  // Normalize colors
  if (args.colorRanges != null) {
    let colors = {};
    for (let key in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key)) {
        let val = args.colorRanges[key];
        if (typeof val !== 'number') {
          val = tempColor.set(val).getHex();
        }
        colors[key] = val;
      }
    }
    args.colorRanges = colors;
  }
  Object.freeze(args);

  // Init the atlas if needed
  const {
    textureWidth,
    sdfExponent
  } = CONFIG;
  const {
    sdfGlyphSize
  } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement('canvas');
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs
    atlas = atlases[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new _three.Texture(canvas, undefined, undefined, undefined, _three.LinearFilter, _three.LinearFilter),
      contextLost: false,
      glyphsByFont: new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling(atlas);
  }
  const {
    sdfTexture,
    sdfCanvas
  } = atlas;

  // Issue request to the typesetting engine in the worker
  typesetInWorker(args).then(result => {
    const {
      glyphIds,
      glyphFontIndices,
      fontData,
      glyphPositions,
      fontSize,
      timings
    } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$1();
    const fontGlyphMaps = fontData.map(font => {
      let map = atlas.glyphsByFont.get(font.src);
      if (!map) {
        atlas.glyphsByFont.set(font.src, map = new Map());
      }
      return map;
    });
    glyphIds.forEach((glyphId, i) => {
      const fontIndex = glyphFontIndices[i];
      const {
        src: fontSrc,
        unitsPerEm
      } = fontData[fontIndex];
      let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);

      // If this is a glyphId not seen before, add it to the atlas
      if (!glyphInfo) {
        const {
          path,
          pathBounds
        } = result.glyphData[fontSrc][glyphId];

        // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.
        // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain
        // useful interpolated values and will be ignored anyway.
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox = [pathBounds[0] - fontUnitsMargin, pathBounds[1] - fontUnitsMargin, pathBounds[2] + fontUnitsMargin, pathBounds[3] + fontUnitsMargin];
        fontGlyphMaps[fontIndex].set(glyphId, glyphInfo = {
          path,
          atlasIndex,
          sdfViewBox
        });

        // Collect those that need SDF generation
        neededSDFs.push(glyphInfo);
      }

      // Calculate bounds for renderable quads
      // TODO can we get this back off the main thread?
      const {
        sdfViewBox
      } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      const fontSizeMult = fontSize / unitsPerEm;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;

      // Convert glyphId to SDF index for the shader
      glyphIds[i] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);
    const sdfStart = now$1();
    timings.sdf = {};

    // Grow the texture height by power of 2 if needed
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
      // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it
      sdfTexture.dispose();
    }
    Promise.all(neededSDFs.map(glyphInfo => generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({
      timing
    }) => {
      timings.sdf[glyphInfo.atlasIndex] = timing;
    }))).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$1() - sdfStart;
      timings.total = now$1() - totalStart;
      // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)

      // Invoke callback with the text layout arrays and updated texture
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        capHeight: result.capHeight,
        xHeight: result.xHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings
      }));
    });
  });

  // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is
  // "warmed up"; the first request will be the longest due to shader program compilation so this gets
  // a head start on that process before SDFs actually start getting processed.
  Promise.resolve().then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas(sdfCanvas);
    }
  });
}
function generateGlyphSDF({
  path,
  atlasIndex,
  sdfViewBox
}, {
  sdfGlyphSize,
  sdfCanvas,
  contextLost
}, useGPU) {
  if (contextLost) {
    // If the context is lost there's nothing we can do, just quit silently and let it
    // get regenerated when the context is restored
    return Promise.resolve({
      timing: -1
    });
  }
  const {
    textureWidth,
    sdfExponent
  } = CONFIG;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU);
}
function initContextLossHandling(atlas) {
  const canvas = atlas.sdfCanvas;

  /*
  // Begin context loss simulation
  if (!window.WebGLDebugUtils) {
    let script = document.getElementById('WebGLDebugUtilsScript')
    if (!script) {
      script = document.createElement('script')
      script.id = 'WebGLDebugUtils'
      document.head.appendChild(script)
      script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'
    }
    script.addEventListener('load', () => {
      initContextLossHandling(atlas)
    })
    return
  }
  window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)
  canvas.loseContextInNCalls(500)
  canvas.addEventListener('webglcontextrestored', (event) => {
    canvas.loseContextInNCalls(5000)
  })
  // End context loss simulation
  */

  canvas.addEventListener('webglcontextlost', event => {
    console.log('Context Lost', event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener('webglcontextrestored', event => {
    console.log('Context Restored', event);
    atlas.contextLost = false;
    // Regenerate all glyphs into the restored canvas:
    const promises = [];
    atlas.glyphsByFont.forEach(glyphMap => {
      glyphMap.forEach(glyph => {
        promises.push(generateGlyphSDF(glyph, atlas, true));
      });
    });
    Promise.all(promises).then(() => {
      safariPre15Workaround(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}

/**
 * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.
 * This can be useful to avoid long pauses when first showing text in a scene, by preloading the
 * needed fonts and glyphs up front along with other assets.
 *
 * @param {object} options
 * @param {string} options.font - URL of the font file to preload. If not given, the default font will
 *        be loaded.
 * @param {string|string[]} options.characters - One or more character sequences for which to pre-
 *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need
 *        to specify ligature sequences in addition to their individual characters to get all
 *        possible glyphs, e.g. `["t", "h", "th"]` to get the "t" and "h" glyphs plus the "th" ligature.
 * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the
 *        specified `characters`.
 * @param {function} callback - A function that will be called when the preloading is complete.
 */
function preloadFont({
  font,
  characters,
  sdfGlyphSize
}, callback) {
  let text = Array.isArray(characters) ? characters.join('\n') : '' + characters;
  getTextRenderInfo({
    font,
    sdfGlyphSize,
    text
  }, callback);
}

// Local assign impl so we don't have to import troika-core
function assign(toObj, fromObj) {
  for (let key in fromObj) {
    if (fromObj.hasOwnProperty(key)) {
      toObj[key] = fromObj[key];
    }
  }
  return toObj;
}

// Utility for making URLs absolute
let linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === 'undefined' ? {} : document.createElement('a');
  }
  linkEl.href = path;
  return linkEl.href;
}

/**
 * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround
 * where it reads the pixels out of that canvas and uploads them as a data texture instead, at
 * a slight performance cost.
 */
function safariPre15Workaround(atlas) {
  // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers
  // have supported it for a long while so any false positives should be minimal.
  if (typeof createImageBitmap !== 'function') {
    console.info('Safari<15: applying SDF canvas workaround');
    const {
      sdfCanvas,
      sdfTexture
    } = atlas;
    const {
      width,
      height
    } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext('webgl');
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width * height * 4) {
      pixels = new Uint8Array(width * height * 4);
      sdfTexture.image = {
        width,
        height,
        data: pixels
      };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
const typesetterWorkerModule = exports.typesetterWorkerModule = /*#__PURE__*/(0, _troikaWorkerUtils.defineWorkerModule)({
  name: 'Typesetter',
  dependencies: [createTypesetter, fontResolverWorkerModule, _bidiJs.default],
  init(createTypesetter, fontResolver, bidiFactory) {
    return createTypesetter(fontResolver, bidiFactory());
  }
});
const typesetInWorker = /*#__PURE__*/(0, _troikaWorkerUtils.defineWorkerModule)({
  name: 'Typesetter',
  dependencies: [typesetterWorkerModule],
  init(typesetter) {
    return function (args) {
      return new Promise(resolve => {
        typesetter.typeset(args, resolve);
      });
    };
  },
  getTransferables(result) {
    // Mark array buffers as transferable to avoid cloning during postMessage
    const transferables = [];
    for (let p in result) {
      if (result[p] && result[p].buffer) {
        transferables.push(result[p].buffer);
      }
    }
    return transferables;
  }
});
function dumpSDFTextures() {
  Object.keys(atlases).forEach(size => {
    const canvas = atlases[size].sdfCanvas;
    const {
      width,
      height
    } = canvas;
    console.log("%c.", `
      background: url(${canvas.toDataURL()});
      background-size: ${width}px ${height}px;
      color: transparent;
      font-size: 0;
      line-height: ${height}px;
      padding-left: ${width}px;
    `);
  });
}
const templateGeometries = {};
function getTemplateGeometry(detail) {
  let geom = templateGeometries[detail];
  if (!geom) {
    // Geometry is two planes back-to-back, which will always be rendered FrontSide only but
    // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.
    // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials
    // introduced by Three.js in r130 - see https://github.com/mrdoob/three.js/pull/21967
    const front = new _three.PlaneGeometry(1, 1, detail, detail);
    const back = front.clone();
    const frontAttrs = front.attributes;
    const backAttrs = back.attributes;
    const combined = new _three.BufferGeometry();
    const vertCount = frontAttrs.uv.count;
    for (let i = 0; i < vertCount; i++) {
      backAttrs.position.array[i * 3] *= -1; // flip position x
      backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z
    }
    ['position', 'normal', 'uv'].forEach(name => {
      combined.setAttribute(name, new _three.Float32BufferAttribute([...frontAttrs[name].array, ...backAttrs[name].array], frontAttrs[name].itemSize));
    });
    combined.setIndex([...front.index.array, ...back.index.array.map(n => n + vertCount)]);
    combined.translate(0.5, 0.5, 0);
    geom = templateGeometries[detail] = combined;
  }
  return geom;
}
const glyphBoundsAttrName = 'aTroikaGlyphBounds';
const glyphIndexAttrName = 'aTroikaGlyphIndex';
const glyphColorAttrName = 'aTroikaGlyphColor';

/**
@class GlyphsGeometry

A specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to
render the glyphs using GPU instancing of a single quad, rather than constructing a whole
geometry with vertices, for much smaller attribute arraybuffers according to this math:

  Where N = number of glyphs...

  Instanced:
  - position: 4 * 3
  - index: 2 * 3
  - normal: 4 * 3
  - uv: 4 * 2
  - glyph x/y bounds: N * 4
  - glyph indices: N * 1
  = 5N + 38

  Non-instanced:
  - position: N * 4 * 3
  - index: N * 2 * 3
  - normal: N * 4 * 3
  - uv: N * 4 * 2
  - glyph indices: N * 1
  = 39N

A downside of this is the rare-but-possible lack of the instanced arrays extension,
which we could potentially work around with a fallback non-instanced implementation.

*/
class GlyphsGeometry extends _three.InstancedBufferGeometry {
  constructor() {
    super();
    this.detail = 1;
    this.curveRadius = 0;

    // Define groups for rendering text outline as a separate pass; these will only
    // be used when the `material` getter returns an array, i.e. outlineWidth > 0.
    this.groups = [{
      start: 0,
      count: Infinity,
      materialIndex: 0
    }, {
      start: 0,
      count: Infinity,
      materialIndex: 1
    }];

    // Preallocate empty bounding objects
    this.boundingSphere = new _three.Sphere();
    this.boundingBox = new _three.Box3();
  }
  computeBoundingSphere() {
    // No-op; we'll sync the boundingSphere proactively when needed.
  }
  computeBoundingBox() {
    // No-op; we'll sync the boundingBox proactively when needed.
  }

  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(side) {
    const verts = this.getIndex().count;
    this.setDrawRange(side === _three.BackSide ? verts / 2 : 0, side === _three.DoubleSide ? verts : verts / 2);
  }
  set detail(detail) {
    if (detail !== this._detail) {
      this._detail = detail;
      if (typeof detail !== 'number' || detail < 1) {
        detail = 1;
      }
      let tpl = getTemplateGeometry(detail);
      ['position', 'normal', 'uv'].forEach(attr => {
        this.attributes[attr] = tpl.attributes[attr].clone();
      });
      this.setIndex(tpl.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(r) {
    if (r !== this._curveRadius) {
      this._curveRadius = r;
      this._updateBounds();
    }
  }
  get curveRadius() {
    return this._curveRadius;
  }

  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
    // Update the instance attributes
    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);
    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);
    updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);
    this._blockBounds = blockBounds;
    this._chunkedBounds = chunkedBounds;
    this.instanceCount = glyphAtlasIndices.length;
    this._updateBounds();
  }
  _updateBounds() {
    const bounds = this._blockBounds;
    if (bounds) {
      const {
        curveRadius,
        boundingBox: bbox
      } = this;
      if (curveRadius) {
        const {
          PI,
          floor,
          min,
          max,
          sin,
          cos
        } = Math;
        const halfPi = PI / 2;
        const twoPi = PI * 2;
        const absR = Math.abs(curveRadius);
        const leftAngle = bounds[0] / absR;
        const rightAngle = bounds[2] / absR;
        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
      } else {
        bbox.min.set(bounds[0], bounds[1], 0);
        bbox.max.set(bounds[2], bounds[3], 0);
      }
      bbox.getBoundingSphere(this.boundingSphere);
    }
  }

  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(clipRect) {
    let count = this.getAttribute(glyphIndexAttrName).count;
    let chunks = this._chunkedBounds;
    if (chunks) {
      for (let i = chunks.length; i--;) {
        count = chunks[i].end;
        let rect = chunks[i].rect;
        // note: both rects are l-b-r-t
        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
          break;
        }
      }
    }
    this.instanceCount = count;
  }
}
exports.GlyphsGeometry = GlyphsGeometry;
function updateBufferAttr(geom, attrName, newArray, itemSize) {
  const attr = geom.getAttribute(attrName);
  if (newArray) {
    // If length isn't changing, just update the attribute's array data
    if (attr && attr.array.length === newArray.length) {
      attr.array.set(newArray);
      attr.needsUpdate = true;
    } else {
      geom.setAttribute(attrName, new _three.InstancedBufferAttribute(newArray, itemSize));
      // If the new attribute has a different size, we also have to (as of r117) manually clear the
      // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706
      // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in
      // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a
      // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly
      // implies it should be supported. It's possible we need to
      delete geom._maxInstanceCount; //for r117+, could be fragile
      geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like
    }
  } else if (attr) {
    geom.deleteAttribute(attrName);
  }
}

// language=GLSL
const VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;

// language=GLSL prefix="void main() {" suffix="}"
const VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${'' /* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the
     vertex shader, rather than in the fragment shader, as the latter gives strange artifacts
     on some glyphs (those in the leftmost texture column) on some systems. The exact reason
     isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;

// language=GLSL
const FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${'' /* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those
       are linearly interpolated where the encoding is exponential. Look into improving this by rounding
       to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.
       */}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${'' /*
       When the standard derivatives extension is available, we choose an antialiasing alpha threshold based
       on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes 
       readability and edge crispness at all sizes and screen resolutions.
       */}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${'' /* 
       // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...
       // This has potential but currently gives very jagged extensions, maybe due to precision issues?
       float uvStep = 1.0 / uTroikaSDFGlyphSize;
       vec2 neighbor1UV = clampedGlyphUV + (
       vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :
       vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :
       vec2(0.0)
       );
       vec2 neighbor2UV = clampedGlyphUV + (
       vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :
       vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :
       vec2(0.0)
       );
       float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);
       float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);
       float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);
       float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);
       float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);
       float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);
       distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;
       */}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;

// language=GLSL prefix="void main() {" suffix="}"
const FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;

/**
 * Create a material for rendering text, derived from a baseMaterial
 */
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = (0, _troikaThreeUtils.createDerivedMaterial)(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: {
        value: null
      },
      uTroikaSDFTextureSize: {
        value: new _three.Vector2()
      },
      uTroikaSDFGlyphSize: {
        value: 0
      },
      uTroikaSDFExponent: {
        value: 0
      },
      uTroikaTotalBounds: {
        value: new _three.Vector4(0, 0, 0, 0)
      },
      uTroikaClipRect: {
        value: new _three.Vector4(0, 0, 0, 0)
      },
      uTroikaDistanceOffset: {
        value: 0
      },
      uTroikaOutlineOpacity: {
        value: 0
      },
      uTroikaFillOpacity: {
        value: 1
      },
      uTroikaPositionOffset: {
        value: new _three.Vector2()
      },
      uTroikaCurveRadius: {
        value: 0
      },
      uTroikaBlurRadius: {
        value: 0
      },
      uTroikaStrokeWidth: {
        value: 0
      },
      uTroikaStrokeColor: {
        value: new _three.Color()
      },
      uTroikaStrokeOpacity: {
        value: 1
      },
      uTroikaOrient: {
        value: new _three.Matrix3()
      },
      uTroikaUseGlyphColors: {
        value: true
      },
      uTroikaSDFDebug: {
        value: false
      }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({
      vertexShader,
      fragmentShader
    }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader)) {
        // Replace all instances of `diffuse` with our varying
        fragmentShader = fragmentShader.replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor').replace(/\bdiffuse\b/g, 'vTroikaGlyphColor');
        // Make sure the vertex shader declares the uniform so we can grab it as a fallback
        if (!uDiffuseRE.test(vertexShader)) {
          vertexShader = vertexShader.replace(_troikaThreeUtils.voidMainRegExp, 'uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n');
        }
      }
      return {
        vertexShader,
        fragmentShader
      };
    }
  });

  // Force transparency - TODO is this reasonable?
  textMaterial.transparent = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: {
      value: true
    },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
        //no-op
      }
    }
  });
  return textMaterial;
}
const defaultMaterial = /*#__PURE__*/new _three.MeshBasicMaterial({
  color: 0xffffff,
  side: _three.DoubleSide,
  transparent: true
});
const defaultStrokeColor = 0x808080;
const tempMat4 = /*#__PURE__*/new _three.Matrix4();
const tempVec3a = /*#__PURE__*/new _three.Vector3();
const tempVec3b = /*#__PURE__*/new _three.Vector3();
const tempArray = [];
const origin = /*#__PURE__*/new _three.Vector3();
const defaultOrient = '+x+y';
function first(o) {
  return Array.isArray(o) ? o[0] : o;
}
let getFlatRaycastMesh = () => {
  const mesh = new _three.Mesh(new _three.PlaneGeometry(1, 1), defaultMaterial);
  getFlatRaycastMesh = () => mesh;
  return mesh;
};
let getCurvedRaycastMesh = () => {
  const mesh = new _three.Mesh(new _three.PlaneGeometry(1, 1, 32, 1), defaultMaterial);
  getCurvedRaycastMesh = () => mesh;
  return mesh;
};
const syncStartEvent = {
  type: 'syncstart'
};
const syncCompleteEvent = {
  type: 'synccomplete'
};
const SYNCABLE_PROPS = ['font', 'fontSize', 'fontStyle', 'fontWeight', 'lang', 'letterSpacing', 'lineHeight', 'maxWidth', 'overflowWrap', 'text', 'direction', 'textAlign', 'textIndent', 'whiteSpace', 'anchorX', 'anchorY', 'colorRanges', 'sdfGlyphSize'];
const COPYABLE_PROPS = SYNCABLE_PROPS.concat('material', 'color', 'depthOffset', 'clipRect', 'curveRadius', 'orientation', 'glyphGeometryDetail');

/**
 * @class Text
 *
 * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance
 * fields (SDF).
 */
class Text extends _three.Mesh {
  constructor() {
    const geometry = new GlyphsGeometry();
    super(geometry, null);

    // === Text layout properties: === //

    /**
     * @member {string} text
     * The string of text to be rendered.
     */
    this.text = '';

    /**
     * @member {number|string} anchorX
     * Defines the horizontal position in the text block that should line up with the local origin.
     * Can be specified as a numeric x position in local units, a string percentage of the total
     * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',
     * or 'right'.
     */
    this.anchorX = 0;

    /**
     * @member {number|string} anchorY
     * Defines the vertical position in the text block that should line up with the local origin.
     * Can be specified as a numeric y position in local units (note: down is negative y), a string
     * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:
     * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.
     */
    this.anchorY = 0;

    /**
     * @member {number} curveRadius
     * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put
     * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave
     * curvature, while negative numbers put it behind the text for a convex curvature. The centerline
     * will be aligned with the text's local origin; you can use `anchorX` to offset it.
     *
     * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane
     * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.
     */
    this.curveRadius = 0;

    /**
     * @member {string} direction
     * Sets the base direction for the text. The default value of "auto" will choose a direction based
     * on the text's content according to the bidi spec. A value of "ltr" or "rtl" will force the direction.
     */
    this.direction = 'auto';

    /**
     * @member {string|null} font
     * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.
     * Defaults to Noto Sans.
     */
    this.font = null; //will use default from TextBuilder

    this.unicodeFontsURL = null; //defaults to CDN

    /**
     * @member {number} fontSize
     * The size at which to render the font in local units; corresponds to the em-box height
     * of the chosen `font`.
     */
    this.fontSize = 0.1;

    /**
     * @member {number|'normal'|'bold'}
     * The weight of the font. Currently only used for fallback Noto fonts.
     */
    this.fontWeight = 'normal';

    /**
     * @member {'normal'|'italic'}
     * The style of the font. Currently only used for fallback Noto fonts.
     */
    this.fontStyle = 'normal';

    /**
     * @member {string|null} lang
     * The language code of this text; can be used for explicitly selecting certain CJK fonts.
     */
    this.lang = null;

    /**
    * @member {number} letterSpacing
    * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive
    * numbers increase spacing and negative numbers decrease it.
    */
    this.letterSpacing = 0;

    /**
     * @member {number|string} lineHeight
     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'
     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.
     */
    this.lineHeight = 'normal';

    /**
     * @member {number} maxWidth
     * The maximum width of the text block, above which text may start wrapping according to the
     * `whiteSpace` and `overflowWrap` properties.
     */
    this.maxWidth = Infinity;

    /**
     * @member {string} overflowWrap
     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`
     * to break at whitespace characters, or `'break-word'` to allow breaking within words.
     * Defaults to `'normal'`.
     */
    this.overflowWrap = 'normal';

    /**
     * @member {string} textAlign
     * The horizontal alignment of each line of text within the overall text bounding box.
     */
    this.textAlign = 'left';

    /**
     * @member {number} textIndent
     * Indentation for the first character of a line; see CSS `text-indent`.
     */
    this.textIndent = 0;

    /**
     * @member {string} whiteSpace
     * Defines whether text should wrap when a line reaches the `maxWidth`. Can
     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,
     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to
     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.
     */
    this.whiteSpace = 'normal';

    // === Presentation properties: === //

    /**
     * @member {THREE.Material} material
     * Defines a _base_ material to be used when rendering the text. This material will be
     * automatically replaced with a material derived from it, that adds shader code to
     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.
     * By default it will derive from a simple white MeshBasicMaterial, but you can use any
     * of the other mesh materials to gain other features like lighting, texture maps, etc.
     *
     * Also see the `color` shortcut property.
     */
    this.material = null;

    /**
     * @member {string|number|THREE.Color} color
     * This is a shortcut for setting the `color` of the text's material. You can use this
     * if you don't want to specify a whole custom `material`. Also, if you do use a custom
     * `material`, this color will only be used for this particuar Text instance, even if
     * that same material instance is shared across multiple Text objects.
     */
    this.color = null;

    /**
     * @member {object|null} colorRanges
     * WARNING: This API is experimental and may change.
     * This allows more fine-grained control of colors for individual or ranges of characters,
     * taking precedence over the material's `color`. Its format is an Object whose keys each
     * define a starting character index for a range, and whose values are the color for each
     * range. The color value can be a numeric hex color value, a `THREE.Color` object, or
     * any of the strings accepted by `THREE.Color`.
     */
    this.colorRanges = null;

    /**
     * @member {number|string} outlineWidth
     * WARNING: This API is experimental and may change.
     * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.
     * Can be specified as either an absolute number in local units, or as a percentage string e.g.
     * `"12%"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means
     * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.
     */
    this.outlineWidth = 0;

    /**
     * @member {string|number|THREE.Color} outlineColor
     * WARNING: This API is experimental and may change.
     * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.
     * Defaults to black.
     */
    this.outlineColor = 0x000000;

    /**
     * @member {number} outlineOpacity
     * WARNING: This API is experimental and may change.
     * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.
     * Defaults to `1`.
     */
    this.outlineOpacity = 1;

    /**
     * @member {number|string} outlineBlur
     * WARNING: This API is experimental and may change.
     * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is
     * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.
     * Can be specified as either an absolute number in local units, or as a percentage string e.g.
     * `"12%"` which is treated as a percentage of the `fontSize`. Defaults to `0`.
     */
    this.outlineBlur = 0;

    /**
     * @member {number|string} outlineOffsetX
     * WARNING: This API is experimental and may change.
     * A horizontal offset for the text outline.
     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `"12%"`
     * which is treated as a percentage of the `fontSize`. Defaults to `0`.
     */
    this.outlineOffsetX = 0;

    /**
     * @member {number|string} outlineOffsetY
     * WARNING: This API is experimental and may change.
     * A vertical offset for the text outline.
     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `"12%"`
     * which is treated as a percentage of the `fontSize`. Defaults to `0`.
     */
    this.outlineOffsetY = 0;

    /**
     * @member {number|string} strokeWidth
     * WARNING: This API is experimental and may change.
     * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.
     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `"12%"`
     * which is treated as a percentage of the `fontSize`. Defaults to `0`.
     */
    this.strokeWidth = 0;

    /**
     * @member {string|number|THREE.Color} strokeColor
     * WARNING: This API is experimental and may change.
     * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.
     */
    this.strokeColor = defaultStrokeColor;

    /**
     * @member {number} strokeOpacity
     * WARNING: This API is experimental and may change.
     * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.
     */
    this.strokeOpacity = 1;

    /**
     * @member {number} fillOpacity
     * WARNING: This API is experimental and may change.
     * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows
     * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the
     * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.
     */
    this.fillOpacity = 1;

    /**
     * @member {number} depthOffset
     * This is a shortcut for setting the material's `polygonOffset` and related properties,
     * which can be useful in preventing z-fighting when this text is laid on top of another
     * plane in the scene. Positive numbers are further from the camera, negatives closer.
     */
    this.depthOffset = 0;

    /**
     * @member {Array<number>} clipRect
     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all
     * pixels will be discarded. This can be used for example to clip overflowing text when
     * `whiteSpace='nowrap'`.
     */
    this.clipRect = null;

    /**
     * @member {string} orientation
     * Defines the axis plane on which the text should be laid out when the mesh has no extra
     * rotation transform. It is specified as a string with two axes: the horizontal axis with
     * positive pointing right, and the vertical axis with positive pointing up. By default this
     * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y
     * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's
     * top toward negative z and facing positive y.
     */
    this.orientation = defaultOrient;

    /**
     * @member {number} glyphGeometryDetail
     * Controls number of vertical/horizontal segments that make up each glyph's rectangular
     * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom
     * vertex shader effects, for example.
     */
    this.glyphGeometryDetail = 1;

    /**
     * @member {number|null} sdfGlyphSize
     * The size of each glyph's SDF (signed distance field) used for rendering. This must be a
     * power-of-two number. Defaults to 64 which is generally a good balance of size and quality
     * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing
     * the sharpness of corners and preventing loss of very thin lines, at the expense of
     * increased memory footprint and longer SDF generation time.
     */
    this.sdfGlyphSize = null;

    /**
     * @member {boolean} gpuAccelerateSDF
     * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,
     * making it much faster especially for complex glyphs, and falling back to a JavaScript version
     * executed in web workers when support isn't available. It should automatically detect support,
     * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS
     * version if you encounter issues with it.
     */
    this.gpuAccelerateSDF = true;
    this.debugSDF = false;
  }

  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(callback) {
    if (this._needsSync) {
      this._needsSync = false;

      // If there's another sync still in progress, queue
      if (this._isSyncing) {
        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
      } else {
        this._isSyncing = true;
        this.dispatchEvent(syncStartEvent);
        getTextRenderInfo({
          text: this.text,
          font: this.font,
          lang: this.lang,
          fontSize: this.fontSize || 0.1,
          fontWeight: this.fontWeight || 'normal',
          fontStyle: this.fontStyle || 'normal',
          letterSpacing: this.letterSpacing || 0,
          lineHeight: this.lineHeight || 'normal',
          maxWidth: this.maxWidth,
          direction: this.direction || 'auto',
          textAlign: this.textAlign,
          textIndent: this.textIndent,
          whiteSpace: this.whiteSpace,
          overflowWrap: this.overflowWrap,
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          colorRanges: this.colorRanges,
          includeCaretPositions: true,
          //TODO parameterize
          sdfGlyphSize: this.sdfGlyphSize,
          gpuAccelerateSDF: this.gpuAccelerateSDF,
          unicodeFontsURL: this.unicodeFontsURL
        }, textRenderInfo => {
          this._isSyncing = false;

          // Save result for later use in onBeforeRender
          this._textRenderInfo = textRenderInfo;

          // Update the geometry attributes
          this.geometry.updateGlyphs(textRenderInfo.glyphBounds, textRenderInfo.glyphAtlasIndices, textRenderInfo.blockBounds, textRenderInfo.chunkedBounds, textRenderInfo.glyphColors);

          // If we had extra sync requests queued up, kick it off
          const queued = this._queuedSyncs;
          if (queued) {
            this._queuedSyncs = null;
            this._needsSync = true;
            this.sync(() => {
              queued.forEach(fn => fn && fn());
            });
          }
          this.dispatchEvent(syncCompleteEvent);
          if (callback) {
            callback();
          }
        });
      }
    }
  }

  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(renderer, scene, camera, geometry, material, group) {
    this.sync();

    // This may not always be a text material, e.g. if there's a scene.overrideMaterial present
    if (material.isTroikaTextMaterial) {
      this._prepareForRender(material);
    }

    // We need to force the material to FrontSide to avoid the double-draw-call performance hit
    // introduced in Three.js r130: https://github.com/mrdoob/three.js/pull/21967 - The sidedness
    // is instead applied via drawRange in the GlyphsGeometry.
    material._hadOwnSide = material.hasOwnProperty('side');
    this.geometry.setSide(material._actualSide = material.side);
    material.side = _three.FrontSide;
  }
  onAfterRender(renderer, scene, camera, geometry, material, group) {
    // Restore original material side
    if (material._hadOwnSide) {
      material.side = material._actualSide;
    } else {
      delete material.side; // back to inheriting from base material
    }
  }

  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }

  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }

  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let derivedMaterial = this._derivedMaterial;
    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);
      // dispose the derived material when its base material is disposed:
      baseMaterial.addEventListener('dispose', function onDispose() {
        baseMaterial.removeEventListener('dispose', onDispose);
        derivedMaterial.dispose();
      });
    }
    // If text outline is configured, render it as a preliminary draw using Three's multi-material
    // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi
    // materials ensures the layers are always rendered consecutively in a consistent order.
    // Each layer will trigger onBeforeRender with the appropriate material.
    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let outlineMaterial = derivedMaterial._outlineMtl;
      if (!outlineMaterial) {
        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
          id: {
            value: derivedMaterial.id + 0.1
          }
        });
        outlineMaterial.isTextOutlineMaterial = true;
        outlineMaterial.depthWrite = false;
        outlineMaterial.map = null; //???
        derivedMaterial.addEventListener('dispose', function onDispose() {
          derivedMaterial.removeEventListener('dispose', onDispose);
          outlineMaterial.dispose();
        });
      }
      return [outlineMaterial, derivedMaterial];
    } else {
      return derivedMaterial;
    }
  }
  set material(baseMaterial) {
    if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
      //prevent double-derivation
      this._derivedMaterial = baseMaterial;
      this._baseMaterial = baseMaterial.baseMaterial;
    } else {
      this._baseMaterial = baseMaterial;
    }
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(detail) {
    this.geometry.detail = detail;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(r) {
    this.geometry.curveRadius = r;
  }

  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  _prepareForRender(material) {
    const isOutline = material.isTextOutlineMaterial;
    const uniforms = material.uniforms;
    const textInfo = this.textRenderInfo;
    if (textInfo) {
      const {
        sdfTexture,
        blockBounds
      } = textInfo;
      uniforms.uTroikaSDFTexture.value = sdfTexture;
      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
      let distanceOffset = 0;
      let blurRadius = 0;
      let strokeWidth = 0;
      let fillOpacity;
      let strokeOpacity;
      let strokeColor;
      let offsetX = 0;
      let offsetY = 0;
      if (isOutline) {
        let {
          outlineWidth,
          outlineOffsetX,
          outlineOffsetY,
          outlineBlur,
          outlineOpacity
        } = this;
        distanceOffset = this._parsePercent(outlineWidth) || 0;
        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
        fillOpacity = outlineOpacity;
        offsetX = this._parsePercent(outlineOffsetX) || 0;
        offsetY = this._parsePercent(outlineOffsetY) || 0;
      } else {
        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
        if (strokeWidth) {
          strokeColor = this.strokeColor;
          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
          strokeOpacity = this.strokeOpacity;
          if (strokeOpacity == null) strokeOpacity = 1;
        }
        fillOpacity = this.fillOpacity;
      }
      uniforms.uTroikaDistanceOffset.value = distanceOffset;
      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
      uniforms.uTroikaBlurRadius.value = blurRadius;
      uniforms.uTroikaStrokeWidth.value = strokeWidth;
      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
      let clipRect = this.clipRect;
      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
        uniforms.uTroikaClipRect.value.fromArray(clipRect);
      } else {
        // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines
        const pad = (this.fontSize || 0.1) * 100;
        uniforms.uTroikaClipRect.value.set(blockBounds[0] - pad, blockBounds[1] - pad, blockBounds[2] + pad, blockBounds[3] + pad);
      }
      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
    }
    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
    material.polygonOffset = !!this.depthOffset;
    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;

    // Shortcut for setting material color via `color` prop on the mesh; this is
    // applied only to the derived material to avoid mutating a shared base material.
    const color = isOutline ? this.outlineColor || 0 : this.color;
    if (color == null) {
      delete material.color; //inherit from base
    } else {
      const colorObj = material.hasOwnProperty('color') ? material.color : material.color = new _three.Color();
      if (color !== colorObj._input || typeof color === 'object') {
        colorObj.set(colorObj._input = color);
      }
    }

    // base orientation
    let orient = this.orientation || defaultOrient;
    if (orient !== material._orientation) {
      let rotMat = uniforms.uTroikaOrient.value;
      orient = orient.replace(/[^-+xyz]/g, '');
      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (match) {
        let [, hSign, hAxis, vSign, vAxis] = match;
        tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;
        tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;
        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
        rotMat.setFromMatrix4(tempMat4);
      } else {
        rotMat.identity();
      }
      material._orientation = orient;
    }
  }
  _parsePercent(value) {
    if (typeof value === 'string') {
      let match = value.match(/^(-?[\d.]+)%$/);
      let pct = match ? parseFloat(match[1]) : NaN;
      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
    }
    return value;
  }

  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(position, target = new _three.Vector2()) {
    target.copy(position); //simple non-curved case is 1:1
    const r = this.curveRadius;
    if (r) {
      //flatten the curve
      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);
    }
    return target;
  }

  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(position, target = new _three.Vector2()) {
    tempVec3a.copy(position);
    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);
  }

  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(raycaster, intersects) {
    const {
      textRenderInfo,
      curveRadius
    } = this;
    if (textRenderInfo) {
      const bounds = textRenderInfo.blockBounds;
      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
      const geom = raycastMesh.geometry;
      const {
        position,
        uv
      } = geom.attributes;
      for (let i = 0; i < uv.count; i++) {
        let x = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);
        const y = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);
        let z = 0;
        if (curveRadius) {
          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;
          x = Math.sin(x / curveRadius) * curveRadius;
        }
        position.setXYZ(i, x, y, z);
      }
      geom.boundingSphere = this.geometry.boundingSphere;
      geom.boundingBox = this.geometry.boundingBox;
      raycastMesh.matrixWorld = this.matrixWorld;
      raycastMesh.material.side = this.material.side;
      tempArray.length = 0;
      raycastMesh.raycast(raycaster, tempArray);
      for (let i = 0; i < tempArray.length; i++) {
        tempArray[i].object = this;
        intersects.push(tempArray[i]);
      }
    }
  }
  copy(source) {
    // Prevent copying the geometry reference so we don't end up sharing attributes between instances
    const geom = this.geometry;
    super.copy(source);
    this.geometry = geom;
    COPYABLE_PROPS.forEach(prop => {
      this[prop] = source[prop];
    });
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}

// Create setters for properties that affect text layout:
exports.Text = Text;
SYNCABLE_PROPS.forEach(prop => {
  const privateKey = '_private_' + prop;
  Object.defineProperty(Text.prototype, prop, {
    get() {
      return this[privateKey];
    },
    set(value) {
      if (value !== this[privateKey]) {
        this[privateKey] = value;
        this._needsSync = true;
      }
    }
  });
});

//=== Utility functions for dealing with carets and selection ranges ===//

/**
 * @typedef {object} TextCaret
 * @property {number} x - x position of the caret
 * @property {number} y - y position of the caret's bottom
 * @property {number} height - height of the caret
 * @property {number} charIndex - the index in the original input string of this caret's target
 *   character; the caret will be for the position _before_ that character.
 */

/**
 * Given a local x/y coordinate in the text block plane, find the nearest caret position.
 * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo
 * @param {number} x
 * @param {number} y
 * @return {TextCaret | null}
 */
function getCaretAtPoint(textRenderInfo, x, y) {
  let closestCaret = null;
  const rows = groupCaretsByRow(textRenderInfo);

  // Find nearest row by y first
  let closestRow = null;
  rows.forEach(row => {
    if (!closestRow || Math.abs(y - (row.top + row.bottom) / 2) < Math.abs(y - (closestRow.top + closestRow.bottom) / 2)) {
      closestRow = row;
    }
  });

  // Then find closest caret by x within that row
  closestRow.carets.forEach(caret => {
    if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {
      closestCaret = caret;
    }
  });
  return closestCaret;
}
const _rectsCache = new WeakMap();

/**
 * Given start and end character indexes, return a list of rectangles covering all the
 * characters within that selection.
 * @param {TroikaTextRenderInfo} textRenderInfo
 * @param {number} start - index of the first char in the selection
 * @param {number} end - index of the first char after the selection
 * @return {Array<{left, top, right, bottom}> | null}
 */
function getSelectionRects(textRenderInfo, start, end) {
  let rects;
  if (textRenderInfo) {
    // Check cache - textRenderInfo is frozen so it's safe to cache based on it
    let prevResult = _rectsCache.get(textRenderInfo);
    if (prevResult && prevResult.start === start && prevResult.end === end) {
      return prevResult.rects;
    }
    const {
      caretPositions
    } = textRenderInfo;

    // Normalize
    if (end < start) {
      const s = start;
      start = end;
      end = s;
    }
    start = Math.max(start, 0);
    end = Math.min(end, caretPositions.length + 1);

    // Build list of rects, expanding the current rect for all characters in a run and starting
    // a new rect whenever reaching a new line or a new bidi direction
    rects = [];
    let currentRect = null;
    for (let i = start; i < end; i++) {
      const x1 = caretPositions[i * 4];
      const x2 = caretPositions[i * 4 + 1];
      const left = Math.min(x1, x2);
      const right = Math.max(x1, x2);
      const bottom = caretPositions[i * 4 + 2];
      const top = caretPositions[i * 4 + 3];
      if (!currentRect || bottom !== currentRect.bottom || top !== currentRect.top || left > currentRect.right || right < currentRect.left) {
        currentRect = {
          left: Infinity,
          right: -Infinity,
          bottom,
          top
        };
        rects.push(currentRect);
      }
      currentRect.left = Math.min(left, currentRect.left);
      currentRect.right = Math.max(right, currentRect.right);
    }

    // Merge any overlapping rects, e.g. those formed by adjacent bidi runs
    rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);
    for (let i = rects.length - 1; i-- > 0;) {
      const rectA = rects[i];
      const rectB = rects[i + 1];
      if (rectA.bottom === rectB.bottom && rectA.top === rectB.top && rectA.left <= rectB.right && rectA.right >= rectB.left) {
        rectB.left = Math.min(rectB.left, rectA.left);
        rectB.right = Math.max(rectB.right, rectA.right);
        rects.splice(i, 1);
      }
    }
    _rectsCache.set(textRenderInfo, {
      start,
      end,
      rects
    });
  }
  return rects;
}
const _caretsByRowCache = new WeakMap();

/**
 * Group a set of carets by row of text, caching the result. A single row of text may contain carets of
 * differing positions/heights if it has multiple fonts, and they may overlap slightly across rows, so this
 * uses an assumption of "at least overlapping by half" to put them in the same row.
 * @return Array<{bottom: number, top: number, carets: TextCaret[]}>
 */
function groupCaretsByRow(textRenderInfo) {
  // textRenderInfo is frozen so it's safe to cache based on it
  let rows = _caretsByRowCache.get(textRenderInfo);
  if (!rows) {
    rows = [];
    const {
      caretPositions
    } = textRenderInfo;
    let curRow;
    const visitCaret = (x, bottom, top, charIndex) => {
      // new row if not overlapping by at least half
      if (!curRow || top < (curRow.top + curRow.bottom) / 2) {
        rows.push(curRow = {
          bottom,
          top,
          carets: []
        });
      }
      // expand vertical limits if necessary
      if (top > curRow.top) curRow.top = top;
      if (bottom < curRow.bottom) curRow.bottom = bottom;
      curRow.carets.push({
        x,
        y: bottom,
        height: top - bottom,
        charIndex
      });
    };
    let i = 0;
    for (; i < caretPositions.length; i += 4) {
      visitCaret(caretPositions[i], caretPositions[i + 2], caretPositions[i + 3], i / 4);
    }
    // Add one more caret after the final char
    visitCaret(caretPositions[i - 3], caretPositions[i - 2], caretPositions[i - 1], i / 4);
  }
  _caretsByRowCache.set(textRenderInfo, rows);
  return rows;
}
},{"three":"node_modules/three/build/three.module.js","troika-worker-utils":"node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js","webgl-sdf-generator":"node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs","bidi-js":"node_modules/bidi-js/dist/bidi.mjs","troika-three-utils":"node_modules/troika-three-utils/dist/troika-three-utils.esm.js"}],"node_modules/lil-gui/dist/lil-gui.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StringController = exports.OptionController = exports.NumberController = exports.GUI = exports.FunctionController = exports.Controller = exports.ColorController = exports.BooleanController = void 0;
/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.19.2
 * @author George Michael Brower
 * @license MIT
 */

/**
 * Base class for all controllers.
 */
class Controller {
  constructor(parent, object, property, className, elementType = 'div') {
    /**
     * The GUI that contains this controller.
     * @type {GUI}
     */
    this.parent = parent;

    /**
     * The object this controller will modify.
     * @type {object}
     */
    this.object = object;

    /**
     * The name of the property to control.
     * @type {string}
     */
    this.property = property;

    /**
     * Used to determine if the controller is disabled.
     * Use `controller.disable( true|false )` to modify this value.
     * @type {boolean}
     */
    this._disabled = false;

    /**
     * Used to determine if the Controller is hidden.
     * Use `controller.show()` or `controller.hide()` to change this.
     * @type {boolean}
     */
    this._hidden = false;

    /**
     * The value of `object[ property ]` when the controller was created.
     * @type {any}
     */
    this.initialValue = this.getValue();

    /**
     * The outermost container DOM element for this controller.
     * @type {HTMLElement}
     */
    this.domElement = document.createElement(elementType);
    this.domElement.classList.add('controller');
    this.domElement.classList.add(className);

    /**
     * The DOM element that contains the controller's name.
     * @type {HTMLElement}
     */
    this.$name = document.createElement('div');
    this.$name.classList.add('name');
    Controller.nextNameID = Controller.nextNameID || 0;
    this.$name.id = `lil-gui-name-${++Controller.nextNameID}`;

    /**
     * The DOM element that contains the controller's "widget" (which differs by controller type).
     * @type {HTMLElement}
     */
    this.$widget = document.createElement('div');
    this.$widget.classList.add('widget');

    /**
     * The DOM element that receives the disabled attribute when using disable().
     * @type {HTMLElement}
     */
    this.$disable = this.$widget;
    this.domElement.appendChild(this.$name);
    this.domElement.appendChild(this.$widget);

    // Don't fire global key events while typing in a controller
    this.domElement.addEventListener('keydown', e => e.stopPropagation());
    this.domElement.addEventListener('keyup', e => e.stopPropagation());
    this.parent.children.push(this);
    this.parent.controllers.push(this);
    this.parent.$children.appendChild(this.domElement);
    this._listenCallback = this._listenCallback.bind(this);
    this.name(property);
  }

  /**
   * Sets the name of the controller and its label in the GUI.
   * @param {string} name
   * @returns {this}
   */
  name(name) {
    /**
     * The controller's name. Use `controller.name( 'Name' )` to modify this value.
     * @type {string}
     */
    this._name = name;
    this.$name.textContent = name;
    return this;
  }

  /**
   * Pass a function to be called whenever the value is modified by this controller.
   * The function receives the new value as its first parameter. The value of `this` will be the
   * controller.
   *
   * For function controllers, the `onChange` callback will be fired on click, after the function
   * executes.
   * @param {Function} callback
   * @returns {this}
   * @example
   * const controller = gui.add( object, 'property' );
   *
   * controller.onChange( function( v ) {
   * 	console.log( 'The value is now ' + v );
   * 	console.assert( this === controller );
   * } );
   */
  onChange(callback) {
    /**
     * Used to access the function bound to `onChange` events. Don't modify this value directly.
     * Use the `controller.onChange( callback )` method instead.
     * @type {Function}
     */
    this._onChange = callback;
    return this;
  }

  /**
   * Calls the onChange methods of this controller and its parent GUI.
   * @protected
   */
  _callOnChange() {
    this.parent._callOnChange(this);
    if (this._onChange !== undefined) {
      this._onChange.call(this, this.getValue());
    }
    this._changed = true;
  }

  /**
   * Pass a function to be called after this controller has been modified and loses focus.
   * @param {Function} callback
   * @returns {this}
   * @example
   * const controller = gui.add( object, 'property' );
   *
   * controller.onFinishChange( function( v ) {
   * 	console.log( 'Changes complete: ' + v );
   * 	console.assert( this === controller );
   * } );
   */
  onFinishChange(callback) {
    /**
     * Used to access the function bound to `onFinishChange` events. Don't modify this value
     * directly. Use the `controller.onFinishChange( callback )` method instead.
     * @type {Function}
     */
    this._onFinishChange = callback;
    return this;
  }

  /**
   * Should be called by Controller when its widgets lose focus.
   * @protected
   */
  _callOnFinishChange() {
    if (this._changed) {
      this.parent._callOnFinishChange(this);
      if (this._onFinishChange !== undefined) {
        this._onFinishChange.call(this, this.getValue());
      }
    }
    this._changed = false;
  }

  /**
   * Sets the controller back to its initial value.
   * @returns {this}
   */
  reset() {
    this.setValue(this.initialValue);
    this._callOnFinishChange();
    return this;
  }

  /**
   * Enables this controller.
   * @param {boolean} enabled
   * @returns {this}
   * @example
   * controller.enable();
   * controller.enable( false ); // disable
   * controller.enable( controller._disabled ); // toggle
   */
  enable(enabled = true) {
    return this.disable(!enabled);
  }

  /**
   * Disables this controller.
   * @param {boolean} disabled
   * @returns {this}
   * @example
   * controller.disable();
   * controller.disable( false ); // enable
   * controller.disable( !controller._disabled ); // toggle
   */
  disable(disabled = true) {
    if (disabled === this._disabled) return this;
    this._disabled = disabled;
    this.domElement.classList.toggle('disabled', disabled);
    this.$disable.toggleAttribute('disabled', disabled);
    return this;
  }

  /**
   * Shows the Controller after it's been hidden.
   * @param {boolean} show
   * @returns {this}
   * @example
   * controller.show();
   * controller.show( false ); // hide
   * controller.show( controller._hidden ); // toggle
   */
  show(show = true) {
    this._hidden = !show;
    this.domElement.style.display = this._hidden ? 'none' : '';
    return this;
  }

  /**
   * Hides the Controller.
   * @returns {this}
   */
  hide() {
    return this.show(false);
  }

  /**
   * Changes this controller into a dropdown of options.
   *
   * Calling this method on an option controller will simply update the options. However, if this
   * controller was not already an option controller, old references to this controller are
   * destroyed, and a new controller is added to the end of the GUI.
   * @example
   * // safe usage
   *
   * gui.add( obj, 'prop1' ).options( [ 'a', 'b', 'c' ] );
   * gui.add( obj, 'prop2' ).options( { Big: 10, Small: 1 } );
   * gui.add( obj, 'prop3' );
   *
   * // danger
   *
   * const ctrl1 = gui.add( obj, 'prop1' );
   * gui.add( obj, 'prop2' );
   *
   * // calling options out of order adds a new controller to the end...
   * const ctrl2 = ctrl1.options( [ 'a', 'b', 'c' ] );
   *
   * // ...and ctrl1 now references a controller that doesn't exist
   * assert( ctrl2 !== ctrl1 )
   * @param {object|Array} options
   * @returns {Controller}
   */
  options(options) {
    const controller = this.parent.add(this.object, this.property, options);
    controller.name(this._name);
    this.destroy();
    return controller;
  }

  /**
   * Sets the minimum value. Only works on number controllers.
   * @param {number} min
   * @returns {this}
   */
  min(min) {
    return this;
  }

  /**
   * Sets the maximum value. Only works on number controllers.
   * @param {number} max
   * @returns {this}
   */
  max(max) {
    return this;
  }

  /**
   * Values set by this controller will be rounded to multiples of `step`. Only works on number
   * controllers.
   * @param {number} step
   * @returns {this}
   */
  step(step) {
    return this;
  }

  /**
   * Rounds the displayed value to a fixed number of decimals, without affecting the actual value
   * like `step()`. Only works on number controllers.
   * @example
   * gui.add( object, 'property' ).listen().decimals( 4 );
   * @param {number} decimals
   * @returns {this}
   */
  decimals(decimals) {
    return this;
  }

  /**
   * Calls `updateDisplay()` every animation frame. Pass `false` to stop listening.
   * @param {boolean} listen
   * @returns {this}
   */
  listen(listen = true) {
    /**
     * Used to determine if the controller is currently listening. Don't modify this value
     * directly. Use the `controller.listen( true|false )` method instead.
     * @type {boolean}
     */
    this._listening = listen;
    if (this._listenCallbackID !== undefined) {
      cancelAnimationFrame(this._listenCallbackID);
      this._listenCallbackID = undefined;
    }
    if (this._listening) {
      this._listenCallback();
    }
    return this;
  }
  _listenCallback() {
    this._listenCallbackID = requestAnimationFrame(this._listenCallback);

    // To prevent framerate loss, make sure the value has changed before updating the display.
    // Note: save() is used here instead of getValue() only because of ColorController. The !== operator
    // won't work for color objects or arrays, but ColorController.save() always returns a string.

    const curValue = this.save();
    if (curValue !== this._listenPrevValue) {
      this.updateDisplay();
    }
    this._listenPrevValue = curValue;
  }

  /**
   * Returns `object[ property ]`.
   * @returns {any}
   */
  getValue() {
    return this.object[this.property];
  }

  /**
   * Sets the value of `object[ property ]`, invokes any `onChange` handlers and updates the display.
   * @param {any} value
   * @returns {this}
   */
  setValue(value) {
    if (this.getValue() !== value) {
      this.object[this.property] = value;
      this._callOnChange();
      this.updateDisplay();
    }
    return this;
  }

  /**
   * Updates the display to keep it in sync with the current value. Useful for updating your
   * controllers when their values have been modified outside of the GUI.
   * @returns {this}
   */
  updateDisplay() {
    return this;
  }
  load(value) {
    this.setValue(value);
    this._callOnFinishChange();
    return this;
  }
  save() {
    return this.getValue();
  }

  /**
   * Destroys this controller and removes it from the parent GUI.
   */
  destroy() {
    this.listen(false);
    this.parent.children.splice(this.parent.children.indexOf(this), 1);
    this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1);
    this.parent.$children.removeChild(this.domElement);
  }
}
exports.Controller = Controller;
class BooleanController extends Controller {
  constructor(parent, object, property) {
    super(parent, object, property, 'boolean', 'label');
    this.$input = document.createElement('input');
    this.$input.setAttribute('type', 'checkbox');
    this.$input.setAttribute('aria-labelledby', this.$name.id);
    this.$widget.appendChild(this.$input);
    this.$input.addEventListener('change', () => {
      this.setValue(this.$input.checked);
      this._callOnFinishChange();
    });
    this.$disable = this.$input;
    this.updateDisplay();
  }
  updateDisplay() {
    this.$input.checked = this.getValue();
    return this;
  }
}
exports.BooleanController = BooleanController;
function normalizeColorString(string) {
  let match, result;
  if (match = string.match(/(#|0x)?([a-f0-9]{6})/i)) {
    result = match[2];
  } else if (match = string.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) {
    result = parseInt(match[1]).toString(16).padStart(2, 0) + parseInt(match[2]).toString(16).padStart(2, 0) + parseInt(match[3]).toString(16).padStart(2, 0);
  } else if (match = string.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) {
    result = match[1] + match[1] + match[2] + match[2] + match[3] + match[3];
  }
  if (result) {
    return '#' + result;
  }
  return false;
}
const STRING = {
  isPrimitive: true,
  match: v => typeof v === 'string',
  fromHexString: normalizeColorString,
  toHexString: normalizeColorString
};
const INT = {
  isPrimitive: true,
  match: v => typeof v === 'number',
  fromHexString: string => parseInt(string.substring(1), 16),
  toHexString: value => '#' + value.toString(16).padStart(6, 0)
};
const ARRAY = {
  isPrimitive: false,
  // The arrow function is here to appease tree shakers like esbuild or webpack.
  // See https://esbuild.github.io/api/#tree-shaking
  match: v => Array.isArray(v),
  fromHexString(string, target, rgbScale = 1) {
    const int = INT.fromHexString(string);
    target[0] = (int >> 16 & 255) / 255 * rgbScale;
    target[1] = (int >> 8 & 255) / 255 * rgbScale;
    target[2] = (int & 255) / 255 * rgbScale;
  },
  toHexString([r, g, b], rgbScale = 1) {
    rgbScale = 255 / rgbScale;
    const int = r * rgbScale << 16 ^ g * rgbScale << 8 ^ b * rgbScale << 0;
    return INT.toHexString(int);
  }
};
const OBJECT = {
  isPrimitive: false,
  match: v => Object(v) === v,
  fromHexString(string, target, rgbScale = 1) {
    const int = INT.fromHexString(string);
    target.r = (int >> 16 & 255) / 255 * rgbScale;
    target.g = (int >> 8 & 255) / 255 * rgbScale;
    target.b = (int & 255) / 255 * rgbScale;
  },
  toHexString({
    r,
    g,
    b
  }, rgbScale = 1) {
    rgbScale = 255 / rgbScale;
    const int = r * rgbScale << 16 ^ g * rgbScale << 8 ^ b * rgbScale << 0;
    return INT.toHexString(int);
  }
};
const FORMATS = [STRING, INT, ARRAY, OBJECT];
function getColorFormat(value) {
  return FORMATS.find(format => format.match(value));
}
class ColorController extends Controller {
  constructor(parent, object, property, rgbScale) {
    super(parent, object, property, 'color');
    this.$input = document.createElement('input');
    this.$input.setAttribute('type', 'color');
    this.$input.setAttribute('tabindex', -1);
    this.$input.setAttribute('aria-labelledby', this.$name.id);
    this.$text = document.createElement('input');
    this.$text.setAttribute('type', 'text');
    this.$text.setAttribute('spellcheck', 'false');
    this.$text.setAttribute('aria-labelledby', this.$name.id);
    this.$display = document.createElement('div');
    this.$display.classList.add('display');
    this.$display.appendChild(this.$input);
    this.$widget.appendChild(this.$display);
    this.$widget.appendChild(this.$text);
    this._format = getColorFormat(this.initialValue);
    this._rgbScale = rgbScale;
    this._initialValueHexString = this.save();
    this._textFocused = false;
    this.$input.addEventListener('input', () => {
      this._setValueFromHexString(this.$input.value);
    });
    this.$input.addEventListener('blur', () => {
      this._callOnFinishChange();
    });
    this.$text.addEventListener('input', () => {
      const tryParse = normalizeColorString(this.$text.value);
      if (tryParse) {
        this._setValueFromHexString(tryParse);
      }
    });
    this.$text.addEventListener('focus', () => {
      this._textFocused = true;
      this.$text.select();
    });
    this.$text.addEventListener('blur', () => {
      this._textFocused = false;
      this.updateDisplay();
      this._callOnFinishChange();
    });
    this.$disable = this.$text;
    this.updateDisplay();
  }
  reset() {
    this._setValueFromHexString(this._initialValueHexString);
    return this;
  }
  _setValueFromHexString(value) {
    if (this._format.isPrimitive) {
      const newValue = this._format.fromHexString(value);
      this.setValue(newValue);
    } else {
      this._format.fromHexString(value, this.getValue(), this._rgbScale);
      this._callOnChange();
      this.updateDisplay();
    }
  }
  save() {
    return this._format.toHexString(this.getValue(), this._rgbScale);
  }
  load(value) {
    this._setValueFromHexString(value);
    this._callOnFinishChange();
    return this;
  }
  updateDisplay() {
    this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale);
    if (!this._textFocused) {
      this.$text.value = this.$input.value.substring(1);
    }
    this.$display.style.backgroundColor = this.$input.value;
    return this;
  }
}
exports.ColorController = ColorController;
class FunctionController extends Controller {
  constructor(parent, object, property) {
    super(parent, object, property, 'function');

    // Buttons are the only case where widget contains name
    this.$button = document.createElement('button');
    this.$button.appendChild(this.$name);
    this.$widget.appendChild(this.$button);
    this.$button.addEventListener('click', e => {
      e.preventDefault();
      this.getValue().call(this.object);
      this._callOnChange();
    });

    // enables :active pseudo class on mobile
    this.$button.addEventListener('touchstart', () => {}, {
      passive: true
    });
    this.$disable = this.$button;
  }
}
exports.FunctionController = FunctionController;
class NumberController extends Controller {
  constructor(parent, object, property, min, max, step) {
    super(parent, object, property, 'number');
    this._initInput();
    this.min(min);
    this.max(max);
    const stepExplicit = step !== undefined;
    this.step(stepExplicit ? step : this._getImplicitStep(), stepExplicit);
    this.updateDisplay();
  }
  decimals(decimals) {
    this._decimals = decimals;
    this.updateDisplay();
    return this;
  }
  min(min) {
    this._min = min;
    this._onUpdateMinMax();
    return this;
  }
  max(max) {
    this._max = max;
    this._onUpdateMinMax();
    return this;
  }
  step(step, explicit = true) {
    this._step = step;
    this._stepExplicit = explicit;
    return this;
  }
  updateDisplay() {
    const value = this.getValue();
    if (this._hasSlider) {
      let percent = (value - this._min) / (this._max - this._min);
      percent = Math.max(0, Math.min(percent, 1));
      this.$fill.style.width = percent * 100 + '%';
    }
    if (!this._inputFocused) {
      this.$input.value = this._decimals === undefined ? value : value.toFixed(this._decimals);
    }
    return this;
  }
  _initInput() {
    this.$input = document.createElement('input');
    this.$input.setAttribute('type', 'text');
    this.$input.setAttribute('aria-labelledby', this.$name.id);

    // On touch devices only, use input[type=number] to force a numeric keyboard.
    // Ideally we could use one input type everywhere, but [type=number] has quirks
    // on desktop, and [inputmode=decimal] has quirks on iOS.
    // See https://github.com/georgealways/lil-gui/pull/16

    const isTouch = window.matchMedia('(pointer: coarse)').matches;
    if (isTouch) {
      this.$input.setAttribute('type', 'number');
      this.$input.setAttribute('step', 'any');
    }
    this.$widget.appendChild(this.$input);
    this.$disable = this.$input;
    const onInput = () => {
      let value = parseFloat(this.$input.value);
      if (isNaN(value)) return;
      if (this._stepExplicit) {
        value = this._snap(value);
      }
      this.setValue(this._clamp(value));
    };

    // Keys & mouse wheel
    // ---------------------------------------------------------------------

    const increment = delta => {
      const value = parseFloat(this.$input.value);
      if (isNaN(value)) return;
      this._snapClampSetValue(value + delta);

      // Force the input to updateDisplay when it's focused
      this.$input.value = this.getValue();
    };
    const onKeyDown = e => {
      // Using `e.key` instead of `e.code` also catches NumpadEnter
      if (e.key === 'Enter') {
        this.$input.blur();
      }
      if (e.code === 'ArrowUp') {
        e.preventDefault();
        increment(this._step * this._arrowKeyMultiplier(e));
      }
      if (e.code === 'ArrowDown') {
        e.preventDefault();
        increment(this._step * this._arrowKeyMultiplier(e) * -1);
      }
    };
    const onWheel = e => {
      if (this._inputFocused) {
        e.preventDefault();
        increment(this._step * this._normalizeMouseWheel(e));
      }
    };

    // Vertical drag
    // ---------------------------------------------------------------------

    let testingForVerticalDrag = false,
      initClientX,
      initClientY,
      prevClientY,
      initValue,
      dragDelta;

    // Once the mouse is dragged more than DRAG_THRESH px on any axis, we decide
    // on the user's intent: horizontal means highlight, vertical means drag.
    const DRAG_THRESH = 5;
    const onMouseDown = e => {
      initClientX = e.clientX;
      initClientY = prevClientY = e.clientY;
      testingForVerticalDrag = true;
      initValue = this.getValue();
      dragDelta = 0;
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
    };
    const onMouseMove = e => {
      if (testingForVerticalDrag) {
        const dx = e.clientX - initClientX;
        const dy = e.clientY - initClientY;
        if (Math.abs(dy) > DRAG_THRESH) {
          e.preventDefault();
          this.$input.blur();
          testingForVerticalDrag = false;
          this._setDraggingStyle(true, 'vertical');
        } else if (Math.abs(dx) > DRAG_THRESH) {
          onMouseUp();
        }
      }

      // This isn't an else so that the first move counts towards dragDelta
      if (!testingForVerticalDrag) {
        const dy = e.clientY - prevClientY;
        dragDelta -= dy * this._step * this._arrowKeyMultiplier(e);

        // Clamp dragDelta so we don't have 'dead space' after dragging past bounds.
        // We're okay with the fact that bounds can be undefined here.
        if (initValue + dragDelta > this._max) {
          dragDelta = this._max - initValue;
        } else if (initValue + dragDelta < this._min) {
          dragDelta = this._min - initValue;
        }
        this._snapClampSetValue(initValue + dragDelta);
      }
      prevClientY = e.clientY;
    };
    const onMouseUp = () => {
      this._setDraggingStyle(false, 'vertical');
      this._callOnFinishChange();
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };

    // Focus state & onFinishChange
    // ---------------------------------------------------------------------

    const onFocus = () => {
      this._inputFocused = true;
    };
    const onBlur = () => {
      this._inputFocused = false;
      this.updateDisplay();
      this._callOnFinishChange();
    };
    this.$input.addEventListener('input', onInput);
    this.$input.addEventListener('keydown', onKeyDown);
    this.$input.addEventListener('wheel', onWheel, {
      passive: false
    });
    this.$input.addEventListener('mousedown', onMouseDown);
    this.$input.addEventListener('focus', onFocus);
    this.$input.addEventListener('blur', onBlur);
  }
  _initSlider() {
    this._hasSlider = true;

    // Build DOM
    // ---------------------------------------------------------------------

    this.$slider = document.createElement('div');
    this.$slider.classList.add('slider');
    this.$fill = document.createElement('div');
    this.$fill.classList.add('fill');
    this.$slider.appendChild(this.$fill);
    this.$widget.insertBefore(this.$slider, this.$input);
    this.domElement.classList.add('hasSlider');

    // Map clientX to value
    // ---------------------------------------------------------------------

    const map = (v, a, b, c, d) => {
      return (v - a) / (b - a) * (d - c) + c;
    };
    const setValueFromX = clientX => {
      const rect = this.$slider.getBoundingClientRect();
      let value = map(clientX, rect.left, rect.right, this._min, this._max);
      this._snapClampSetValue(value);
    };

    // Mouse drag
    // ---------------------------------------------------------------------

    const mouseDown = e => {
      this._setDraggingStyle(true);
      setValueFromX(e.clientX);
      window.addEventListener('mousemove', mouseMove);
      window.addEventListener('mouseup', mouseUp);
    };
    const mouseMove = e => {
      setValueFromX(e.clientX);
    };
    const mouseUp = () => {
      this._callOnFinishChange();
      this._setDraggingStyle(false);
      window.removeEventListener('mousemove', mouseMove);
      window.removeEventListener('mouseup', mouseUp);
    };

    // Touch drag
    // ---------------------------------------------------------------------

    let testingForScroll = false,
      prevClientX,
      prevClientY;
    const beginTouchDrag = e => {
      e.preventDefault();
      this._setDraggingStyle(true);
      setValueFromX(e.touches[0].clientX);
      testingForScroll = false;
    };
    const onTouchStart = e => {
      if (e.touches.length > 1) return;

      // If we're in a scrollable container, we should wait for the first
      // touchmove to see if the user is trying to slide or scroll.
      if (this._hasScrollBar) {
        prevClientX = e.touches[0].clientX;
        prevClientY = e.touches[0].clientY;
        testingForScroll = true;
      } else {
        // Otherwise, we can set the value straight away on touchstart.
        beginTouchDrag(e);
      }
      window.addEventListener('touchmove', onTouchMove, {
        passive: false
      });
      window.addEventListener('touchend', onTouchEnd);
    };
    const onTouchMove = e => {
      if (testingForScroll) {
        const dx = e.touches[0].clientX - prevClientX;
        const dy = e.touches[0].clientY - prevClientY;
        if (Math.abs(dx) > Math.abs(dy)) {
          // We moved horizontally, set the value and stop checking.
          beginTouchDrag(e);
        } else {
          // This was, in fact, an attempt to scroll. Abort.
          window.removeEventListener('touchmove', onTouchMove);
          window.removeEventListener('touchend', onTouchEnd);
        }
      } else {
        e.preventDefault();
        setValueFromX(e.touches[0].clientX);
      }
    };
    const onTouchEnd = () => {
      this._callOnFinishChange();
      this._setDraggingStyle(false);
      window.removeEventListener('touchmove', onTouchMove);
      window.removeEventListener('touchend', onTouchEnd);
    };

    // Mouse wheel
    // ---------------------------------------------------------------------

    // We have to use a debounced function to call onFinishChange because
    // there's no way to tell when the user is "done" mouse-wheeling.
    const callOnFinishChange = this._callOnFinishChange.bind(this);
    const WHEEL_DEBOUNCE_TIME = 400;
    let wheelFinishChangeTimeout;
    const onWheel = e => {
      // ignore vertical wheels if there's a scrollbar
      const isVertical = Math.abs(e.deltaX) < Math.abs(e.deltaY);
      if (isVertical && this._hasScrollBar) return;
      e.preventDefault();

      // set value
      const delta = this._normalizeMouseWheel(e) * this._step;
      this._snapClampSetValue(this.getValue() + delta);

      // force the input to updateDisplay when it's focused
      this.$input.value = this.getValue();

      // debounce onFinishChange
      clearTimeout(wheelFinishChangeTimeout);
      wheelFinishChangeTimeout = setTimeout(callOnFinishChange, WHEEL_DEBOUNCE_TIME);
    };
    this.$slider.addEventListener('mousedown', mouseDown);
    this.$slider.addEventListener('touchstart', onTouchStart, {
      passive: false
    });
    this.$slider.addEventListener('wheel', onWheel, {
      passive: false
    });
  }
  _setDraggingStyle(active, axis = 'horizontal') {
    if (this.$slider) {
      this.$slider.classList.toggle('active', active);
    }
    document.body.classList.toggle('lil-gui-dragging', active);
    document.body.classList.toggle(`lil-gui-${axis}`, active);
  }
  _getImplicitStep() {
    if (this._hasMin && this._hasMax) {
      return (this._max - this._min) / 1000;
    }
    return 0.1;
  }
  _onUpdateMinMax() {
    if (!this._hasSlider && this._hasMin && this._hasMax) {
      // If this is the first time we're hearing about min and max
      // and we haven't explicitly stated what our step is, let's
      // update that too.
      if (!this._stepExplicit) {
        this.step(this._getImplicitStep(), false);
      }
      this._initSlider();
      this.updateDisplay();
    }
  }
  _normalizeMouseWheel(e) {
    let {
      deltaX,
      deltaY
    } = e;

    // Safari and Chrome report weird non-integral values for a notched wheel,
    // but still expose actual lines scrolled via wheelDelta. Notched wheels
    // should behave the same way as arrow keys.
    if (Math.floor(e.deltaY) !== e.deltaY && e.wheelDelta) {
      deltaX = 0;
      deltaY = -e.wheelDelta / 120;
      deltaY *= this._stepExplicit ? 1 : 10;
    }
    const wheel = deltaX + -deltaY;
    return wheel;
  }
  _arrowKeyMultiplier(e) {
    let mult = this._stepExplicit ? 1 : 10;
    if (e.shiftKey) {
      mult *= 10;
    } else if (e.altKey) {
      mult /= 10;
    }
    return mult;
  }
  _snap(value) {
    // This would be the logical way to do things, but floating point errors.
    // return Math.round( value / this._step ) * this._step;

    // Using inverse step solves a lot of them, but not all
    // const inverseStep = 1 / this._step;
    // return Math.round( value * inverseStep ) / inverseStep;

    // Not happy about this, but haven't seen it break.
    const r = Math.round(value / this._step) * this._step;
    return parseFloat(r.toPrecision(15));
  }
  _clamp(value) {
    // either condition is false if min or max is undefined
    if (value < this._min) value = this._min;
    if (value > this._max) value = this._max;
    return value;
  }
  _snapClampSetValue(value) {
    this.setValue(this._clamp(this._snap(value)));
  }
  get _hasScrollBar() {
    const root = this.parent.root.$children;
    return root.scrollHeight > root.clientHeight;
  }
  get _hasMin() {
    return this._min !== undefined;
  }
  get _hasMax() {
    return this._max !== undefined;
  }
}
exports.NumberController = NumberController;
class OptionController extends Controller {
  constructor(parent, object, property, options) {
    super(parent, object, property, 'option');
    this.$select = document.createElement('select');
    this.$select.setAttribute('aria-labelledby', this.$name.id);
    this.$display = document.createElement('div');
    this.$display.classList.add('display');
    this.$select.addEventListener('change', () => {
      this.setValue(this._values[this.$select.selectedIndex]);
      this._callOnFinishChange();
    });
    this.$select.addEventListener('focus', () => {
      this.$display.classList.add('focus');
    });
    this.$select.addEventListener('blur', () => {
      this.$display.classList.remove('focus');
    });
    this.$widget.appendChild(this.$select);
    this.$widget.appendChild(this.$display);
    this.$disable = this.$select;
    this.options(options);
  }
  options(options) {
    this._values = Array.isArray(options) ? options : Object.values(options);
    this._names = Array.isArray(options) ? options : Object.keys(options);
    this.$select.replaceChildren();
    this._names.forEach(name => {
      const $option = document.createElement('option');
      $option.textContent = name;
      this.$select.appendChild($option);
    });
    this.updateDisplay();
    return this;
  }
  updateDisplay() {
    const value = this.getValue();
    const index = this._values.indexOf(value);
    this.$select.selectedIndex = index;
    this.$display.textContent = index === -1 ? value : this._names[index];
    return this;
  }
}
exports.OptionController = OptionController;
class StringController extends Controller {
  constructor(parent, object, property) {
    super(parent, object, property, 'string');
    this.$input = document.createElement('input');
    this.$input.setAttribute('type', 'text');
    this.$input.setAttribute('spellcheck', 'false');
    this.$input.setAttribute('aria-labelledby', this.$name.id);
    this.$input.addEventListener('input', () => {
      this.setValue(this.$input.value);
    });
    this.$input.addEventListener('keydown', e => {
      if (e.code === 'Enter') {
        this.$input.blur();
      }
    });
    this.$input.addEventListener('blur', () => {
      this._callOnFinishChange();
    });
    this.$widget.appendChild(this.$input);
    this.$disable = this.$input;
    this.updateDisplay();
  }
  updateDisplay() {
    this.$input.value = this.getValue();
    return this;
  }
}
exports.StringController = StringController;
const stylesheet = `.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
  background: var(--background-color);
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  line-height: calc(var(--title-height) - 4px);
  font-weight: 600;
  padding: 0 var(--padding);
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
  outline: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui label, .lil-gui input, .lil-gui button {
  -webkit-tap-highlight-color: transparent;
}
.lil-gui input {
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
  -moz-appearance: textfield;
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input[type=checkbox] {
  appearance: none;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  border: none;
}
@media (hover: hover) {
  .lil-gui button:hover {
    background: var(--hover-color);
  }
  .lil-gui button:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;
function _injectStyles(cssContent) {
  const injected = document.createElement('style');
  injected.innerHTML = cssContent;
  const before = document.querySelector('head link[rel=stylesheet], head style');
  if (before) {
    document.head.insertBefore(injected, before);
  } else {
    document.head.appendChild(injected);
  }
}
let stylesInjected = false;
class GUI {
  /**
   * Creates a panel that holds controllers.
   * @example
   * new GUI();
   * new GUI( { container: document.getElementById( 'custom' ) } );
   *
   * @param {object} [options]
   * @param {boolean} [options.autoPlace=true]
   * Adds the GUI to `document.body` and fixes it to the top right of the page.
   *
   * @param {HTMLElement} [options.container]
   * Adds the GUI to this DOM element. Overrides `autoPlace`.
   *
   * @param {number} [options.width=245]
   * Width of the GUI in pixels, usually set when name labels become too long. Note that you can make
   * name labels wider in CSS with `.lilgui { namewidth: 55% }`.
   *
   * @param {string} [options.title=Controls]
   * Name to display in the title bar.
   *
   * @param {boolean} [options.closeFolders=false]
   * Pass `true` to close all folders in this GUI by default.
   *
   * @param {boolean} [options.injectStyles=true]
   * Injects the default stylesheet into the page if this is the first GUI.
   * Pass `false` to use your own stylesheet.
   *
   * @param {number} [options.touchStyles=true]
   * Makes controllers larger on touch devices. Pass `false` to disable touch styles.
   *
   * @param {GUI} [options.parent]
   * Adds this GUI as a child in another GUI. Usually this is done for you by `addFolder()`.
   *
   */
  constructor({
    parent,
    autoPlace = parent === undefined,
    container,
    width,
    title = 'Controls',
    closeFolders = false,
    injectStyles = true,
    touchStyles = true
  } = {}) {
    /**
     * The GUI containing this folder, or `undefined` if this is the root GUI.
     * @type {GUI}
     */
    this.parent = parent;

    /**
     * The top level GUI containing this folder, or `this` if this is the root GUI.
     * @type {GUI}
     */
    this.root = parent ? parent.root : this;

    /**
     * The list of controllers and folders contained by this GUI.
     * @type {Array<GUI|Controller>}
     */
    this.children = [];

    /**
     * The list of controllers contained by this GUI.
     * @type {Array<Controller>}
     */
    this.controllers = [];

    /**
     * The list of folders contained by this GUI.
     * @type {Array<GUI>}
     */
    this.folders = [];

    /**
     * Used to determine if the GUI is closed. Use `gui.open()` or `gui.close()` to change this.
     * @type {boolean}
     */
    this._closed = false;

    /**
     * Used to determine if the GUI is hidden. Use `gui.show()` or `gui.hide()` to change this.
     * @type {boolean}
     */
    this._hidden = false;

    /**
     * The outermost container element.
     * @type {HTMLElement}
     */
    this.domElement = document.createElement('div');
    this.domElement.classList.add('lil-gui');

    /**
     * The DOM element that contains the title.
     * @type {HTMLElement}
     */
    this.$title = document.createElement('div');
    this.$title.classList.add('title');
    this.$title.setAttribute('role', 'button');
    this.$title.setAttribute('aria-expanded', true);
    this.$title.setAttribute('tabindex', 0);
    this.$title.addEventListener('click', () => this.openAnimated(this._closed));
    this.$title.addEventListener('keydown', e => {
      if (e.code === 'Enter' || e.code === 'Space') {
        e.preventDefault();
        this.$title.click();
      }
    });

    // enables :active pseudo class on mobile
    this.$title.addEventListener('touchstart', () => {}, {
      passive: true
    });

    /**
     * The DOM element that contains children.
     * @type {HTMLElement}
     */
    this.$children = document.createElement('div');
    this.$children.classList.add('children');
    this.domElement.appendChild(this.$title);
    this.domElement.appendChild(this.$children);
    this.title(title);
    if (this.parent) {
      this.parent.children.push(this);
      this.parent.folders.push(this);
      this.parent.$children.appendChild(this.domElement);

      // Stop the constructor early, everything onward only applies to root GUI's
      return;
    }
    this.domElement.classList.add('root');
    if (touchStyles) {
      this.domElement.classList.add('allow-touch-styles');
    }

    // Inject stylesheet if we haven't done that yet
    if (!stylesInjected && injectStyles) {
      _injectStyles(stylesheet);
      stylesInjected = true;
    }
    if (container) {
      container.appendChild(this.domElement);
    } else if (autoPlace) {
      this.domElement.classList.add('autoPlace');
      document.body.appendChild(this.domElement);
    }
    if (width) {
      this.domElement.style.setProperty('--width', width + 'px');
    }
    this._closeFolders = closeFolders;
  }

  /**
   * Adds a controller to the GUI, inferring controller type using the `typeof` operator.
   * @example
   * gui.add( object, 'property' );
   * gui.add( object, 'number', 0, 100, 1 );
   * gui.add( object, 'options', [ 1, 2, 3 ] );
   *
   * @param {object} object The object the controller will modify.
   * @param {string} property Name of the property to control.
   * @param {number|object|Array} [$1] Minimum value for number controllers, or the set of
   * selectable values for a dropdown.
   * @param {number} [max] Maximum value for number controllers.
   * @param {number} [step] Step value for number controllers.
   * @returns {Controller}
   */
  add(object, property, $1, max, step) {
    if (Object($1) === $1) {
      return new OptionController(this, object, property, $1);
    }
    const initialValue = object[property];
    switch (typeof initialValue) {
      case 'number':
        return new NumberController(this, object, property, $1, max, step);
      case 'boolean':
        return new BooleanController(this, object, property);
      case 'string':
        return new StringController(this, object, property);
      case 'function':
        return new FunctionController(this, object, property);
    }
    console.error(`gui.add failed
	property:`, property, `
	object:`, object, `
	value:`, initialValue);
  }

  /**
   * Adds a color controller to the GUI.
   * @example
   * params = {
   * 	cssColor: '#ff00ff',
   * 	rgbColor: { r: 0, g: 0.2, b: 0.4 },
   * 	customRange: [ 0, 127, 255 ],
   * };
   *
   * gui.addColor( params, 'cssColor' );
   * gui.addColor( params, 'rgbColor' );
   * gui.addColor( params, 'customRange', 255 );
   *
   * @param {object} object The object the controller will modify.
   * @param {string} property Name of the property to control.
   * @param {number} rgbScale Maximum value for a color channel when using an RGB color. You may
   * need to set this to 255 if your colors are too bright.
   * @returns {Controller}
   */
  addColor(object, property, rgbScale = 1) {
    return new ColorController(this, object, property, rgbScale);
  }

  /**
   * Adds a folder to the GUI, which is just another GUI. This method returns
   * the nested GUI so you can add controllers to it.
   * @example
   * const folder = gui.addFolder( 'Position' );
   * folder.add( position, 'x' );
   * folder.add( position, 'y' );
   * folder.add( position, 'z' );
   *
   * @param {string} title Name to display in the folder's title bar.
   * @returns {GUI}
   */
  addFolder(title) {
    const folder = new GUI({
      parent: this,
      title
    });
    if (this.root._closeFolders) folder.close();
    return folder;
  }

  /**
   * Recalls values that were saved with `gui.save()`.
   * @param {object} obj
   * @param {boolean} recursive Pass false to exclude folders descending from this GUI.
   * @returns {this}
   */
  load(obj, recursive = true) {
    if (obj.controllers) {
      this.controllers.forEach(c => {
        if (c instanceof FunctionController) return;
        if (c._name in obj.controllers) {
          c.load(obj.controllers[c._name]);
        }
      });
    }
    if (recursive && obj.folders) {
      this.folders.forEach(f => {
        if (f._title in obj.folders) {
          f.load(obj.folders[f._title]);
        }
      });
    }
    return this;
  }

  /**
   * Returns an object mapping controller names to values. The object can be passed to `gui.load()` to
   * recall these values.
   * @example
   * {
   * 	controllers: {
   * 		prop1: 1,
   * 		prop2: 'value',
   * 		...
   * 	},
   * 	folders: {
   * 		folderName1: { controllers, folders },
   * 		folderName2: { controllers, folders }
   * 		...
   * 	}
   * }
   *
   * @param {boolean} recursive Pass false to exclude folders descending from this GUI.
   * @returns {object}
   */
  save(recursive = true) {
    const obj = {
      controllers: {},
      folders: {}
    };
    this.controllers.forEach(c => {
      if (c instanceof FunctionController) return;
      if (c._name in obj.controllers) {
        throw new Error(`Cannot save GUI with duplicate property "${c._name}"`);
      }
      obj.controllers[c._name] = c.save();
    });
    if (recursive) {
      this.folders.forEach(f => {
        if (f._title in obj.folders) {
          throw new Error(`Cannot save GUI with duplicate folder "${f._title}"`);
        }
        obj.folders[f._title] = f.save();
      });
    }
    return obj;
  }

  /**
   * Opens a GUI or folder. GUI and folders are open by default.
   * @param {boolean} open Pass false to close.
   * @returns {this}
   * @example
   * gui.open(); // open
   * gui.open( false ); // close
   * gui.open( gui._closed ); // toggle
   */
  open(open = true) {
    this._setClosed(!open);
    this.$title.setAttribute('aria-expanded', !this._closed);
    this.domElement.classList.toggle('closed', this._closed);
    return this;
  }

  /**
   * Closes the GUI.
   * @returns {this}
   */
  close() {
    return this.open(false);
  }
  _setClosed(closed) {
    if (this._closed === closed) return;
    this._closed = closed;
    this._callOnOpenClose(this);
  }

  /**
   * Shows the GUI after it's been hidden.
   * @param {boolean} show
   * @returns {this}
   * @example
   * gui.show();
   * gui.show( false ); // hide
   * gui.show( gui._hidden ); // toggle
   */
  show(show = true) {
    this._hidden = !show;
    this.domElement.style.display = this._hidden ? 'none' : '';
    return this;
  }

  /**
   * Hides the GUI.
   * @returns {this}
   */
  hide() {
    return this.show(false);
  }
  openAnimated(open = true) {
    // set state immediately
    this._setClosed(!open);
    this.$title.setAttribute('aria-expanded', !this._closed);

    // wait for next frame to measure $children
    requestAnimationFrame(() => {
      // explicitly set initial height for transition
      const initialHeight = this.$children.clientHeight;
      this.$children.style.height = initialHeight + 'px';
      this.domElement.classList.add('transition');
      const onTransitionEnd = e => {
        if (e.target !== this.$children) return;
        this.$children.style.height = '';
        this.domElement.classList.remove('transition');
        this.$children.removeEventListener('transitionend', onTransitionEnd);
      };
      this.$children.addEventListener('transitionend', onTransitionEnd);

      // todo: this is wrong if children's scrollHeight makes for a gui taller than maxHeight
      const targetHeight = !open ? 0 : this.$children.scrollHeight;
      this.domElement.classList.toggle('closed', !open);
      requestAnimationFrame(() => {
        this.$children.style.height = targetHeight + 'px';
      });
    });
    return this;
  }

  /**
   * Change the title of this GUI.
   * @param {string} title
   * @returns {this}
   */
  title(title) {
    /**
     * Current title of the GUI. Use `gui.title( 'Title' )` to modify this value.
     * @type {string}
     */
    this._title = title;
    this.$title.textContent = title;
    return this;
  }

  /**
   * Resets all controllers to their initial values.
   * @param {boolean} recursive Pass false to exclude folders descending from this GUI.
   * @returns {this}
   */
  reset(recursive = true) {
    const controllers = recursive ? this.controllersRecursive() : this.controllers;
    controllers.forEach(c => c.reset());
    return this;
  }

  /**
   * Pass a function to be called whenever a controller in this GUI changes.
   * @param {function({object:object, property:string, value:any, controller:Controller})} callback
   * @returns {this}
   * @example
   * gui.onChange( event => {
   * 	event.object     // object that was modified
   * 	event.property   // string, name of property
   * 	event.value      // new value of controller
   * 	event.controller // controller that was modified
   * } );
   */
  onChange(callback) {
    /**
     * Used to access the function bound to `onChange` events. Don't modify this value
     * directly. Use the `gui.onChange( callback )` method instead.
     * @type {Function}
     */
    this._onChange = callback;
    return this;
  }
  _callOnChange(controller) {
    if (this.parent) {
      this.parent._callOnChange(controller);
    }
    if (this._onChange !== undefined) {
      this._onChange.call(this, {
        object: controller.object,
        property: controller.property,
        value: controller.getValue(),
        controller
      });
    }
  }

  /**
   * Pass a function to be called whenever a controller in this GUI has finished changing.
   * @param {function({object:object, property:string, value:any, controller:Controller})} callback
   * @returns {this}
   * @example
   * gui.onFinishChange( event => {
   * 	event.object     // object that was modified
   * 	event.property   // string, name of property
   * 	event.value      // new value of controller
   * 	event.controller // controller that was modified
   * } );
   */
  onFinishChange(callback) {
    /**
     * Used to access the function bound to `onFinishChange` events. Don't modify this value
     * directly. Use the `gui.onFinishChange( callback )` method instead.
     * @type {Function}
     */
    this._onFinishChange = callback;
    return this;
  }
  _callOnFinishChange(controller) {
    if (this.parent) {
      this.parent._callOnFinishChange(controller);
    }
    if (this._onFinishChange !== undefined) {
      this._onFinishChange.call(this, {
        object: controller.object,
        property: controller.property,
        value: controller.getValue(),
        controller
      });
    }
  }

  /**
   * Pass a function to be called when this GUI or its descendants are opened or closed.
   * @param {function(GUI)} callback
   * @returns {this}
   * @example
   * gui.onOpenClose( changedGUI => {
   * 	console.log( changedGUI._closed );
   * } );
   */
  onOpenClose(callback) {
    this._onOpenClose = callback;
    return this;
  }
  _callOnOpenClose(changedGUI) {
    if (this.parent) {
      this.parent._callOnOpenClose(changedGUI);
    }
    if (this._onOpenClose !== undefined) {
      this._onOpenClose.call(this, changedGUI);
    }
  }

  /**
   * Destroys all DOM elements and event listeners associated with this GUI.
   */
  destroy() {
    if (this.parent) {
      this.parent.children.splice(this.parent.children.indexOf(this), 1);
      this.parent.folders.splice(this.parent.folders.indexOf(this), 1);
    }
    if (this.domElement.parentElement) {
      this.domElement.parentElement.removeChild(this.domElement);
    }
    Array.from(this.children).forEach(c => c.destroy());
  }

  /**
   * Returns an array of controllers contained by this GUI and its descendents.
   * @returns {Controller[]}
   */
  controllersRecursive() {
    let controllers = Array.from(this.controllers);
    this.folders.forEach(f => {
      controllers = controllers.concat(f.controllersRecursive());
    });
    return controllers;
  }

  /**
   * Returns an array of folders contained by this GUI and its descendents.
   * @returns {GUI[]}
   */
  foldersRecursive() {
    let folders = Array.from(this.folders);
    this.folders.forEach(f => {
      folders = folders.concat(f.foldersRecursive());
    });
    return folders;
  }
}
exports.GUI = GUI;
var _default = exports.default = GUI;
},{}],"node_modules/three/examples/jsm/shaders/CopyShader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CopyShader = void 0;
/**
 * Full-screen textured quad shader
 */

var CopyShader = exports.CopyShader = {
  name: 'CopyShader',
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'opacity': {
      value: 1.0
    }
  },
  vertexShader: /* glsl */"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
  fragmentShader: /* glsl */"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"
};
},{}],"node_modules/three/examples/jsm/postprocessing/Pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pass = exports.FullScreenQuad = void 0;
var _three = require("three");
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Pass = exports.Pass = /*#__PURE__*/function () {
  function Pass() {
    _classCallCheck(this, Pass);
    this.isPass = true;

    // if set to true, the pass is processed by the composer
    this.enabled = true;

    // if set to true, the pass indicates to swap read and write buffer after rendering
    this.needsSwap = true;

    // if set to true, the pass clears its buffer before rendering
    this.clear = false;

    // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
    this.renderToScreen = false;
  }
  return _createClass(Pass, [{
    key: "setSize",
    value: function setSize( /* width, height */) {}
  }, {
    key: "render",
    value: function render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */
    ) {
      console.error('THREE.Pass: .render() must be implemented in derived pass.');
    }
  }, {
    key: "dispose",
    value: function dispose() {}
  }]);
}(); // Helper for passes that need to fill the viewport with a single quad.
var _camera = new _three.OrthographicCamera(-1, 1, 1, -1, 0, 1);

// https://github.com/mrdoob/three.js/pull/21358
var FullscreenTriangleGeometry = /*#__PURE__*/function (_BufferGeometry) {
  function FullscreenTriangleGeometry() {
    var _this;
    _classCallCheck(this, FullscreenTriangleGeometry);
    _this = _callSuper(this, FullscreenTriangleGeometry);
    _this.setAttribute('position', new _three.Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    _this.setAttribute('uv', new _three.Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
    return _this;
  }
  _inherits(FullscreenTriangleGeometry, _BufferGeometry);
  return _createClass(FullscreenTriangleGeometry);
}(_three.BufferGeometry);
var _geometry = new FullscreenTriangleGeometry();
var FullScreenQuad = exports.FullScreenQuad = /*#__PURE__*/function () {
  function FullScreenQuad(material) {
    _classCallCheck(this, FullScreenQuad);
    this._mesh = new _three.Mesh(_geometry, material);
  }
  return _createClass(FullScreenQuad, [{
    key: "dispose",
    value: function dispose() {
      this._mesh.geometry.dispose();
    }
  }, {
    key: "render",
    value: function render(renderer) {
      renderer.render(this._mesh, _camera);
    }
  }, {
    key: "material",
    get: function get() {
      return this._mesh.material;
    },
    set: function set(value) {
      this._mesh.material = value;
    }
  }]);
}();
},{"three":"node_modules/three/build/three.module.js"}],"node_modules/three/examples/jsm/postprocessing/ShaderPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShaderPass = void 0;
var _three = require("three");
var _Pass2 = require("./Pass.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var ShaderPass = exports.ShaderPass = /*#__PURE__*/function (_Pass) {
  function ShaderPass(shader, textureID) {
    var _this;
    _classCallCheck(this, ShaderPass);
    _this = _callSuper(this, ShaderPass);
    _this.textureID = textureID !== undefined ? textureID : 'tDiffuse';
    if (shader instanceof _three.ShaderMaterial) {
      _this.uniforms = shader.uniforms;
      _this.material = shader;
    } else if (shader) {
      _this.uniforms = _three.UniformsUtils.clone(shader.uniforms);
      _this.material = new _three.ShaderMaterial({
        name: shader.name !== undefined ? shader.name : 'unspecified',
        defines: Object.assign({}, shader.defines),
        uniforms: _this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    _this.fsQuad = new _Pass2.FullScreenQuad(_this.material);
    return _this;
  }
  _inherits(ShaderPass, _Pass);
  return _createClass(ShaderPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
      if (this.uniforms[this.textureID]) {
        this.uniforms[this.textureID].value = readBuffer.texture;
      }
      this.fsQuad.material = this.material;
      if (this.renderToScreen) {
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      } else {
        renderer.setRenderTarget(writeBuffer);
        // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
        if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        this.fsQuad.render(renderer);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.material.dispose();
      this.fsQuad.dispose();
    }
  }]);
}(_Pass2.Pass);
},{"three":"node_modules/three/build/three.module.js","./Pass.js":"node_modules/three/examples/jsm/postprocessing/Pass.js"}],"node_modules/three/examples/jsm/postprocessing/MaskPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MaskPass = exports.ClearMaskPass = void 0;
var _Pass3 = require("./Pass.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var MaskPass = exports.MaskPass = /*#__PURE__*/function (_Pass) {
  function MaskPass(scene, camera) {
    var _this;
    _classCallCheck(this, MaskPass);
    _this = _callSuper(this, MaskPass);
    _this.scene = scene;
    _this.camera = camera;
    _this.clear = true;
    _this.needsSwap = false;
    _this.inverse = false;
    return _this;
  }
  _inherits(MaskPass, _Pass);
  return _createClass(MaskPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
      var context = renderer.getContext();
      var state = renderer.state;

      // don't update color or depth

      state.buffers.color.setMask(false);
      state.buffers.depth.setMask(false);

      // lock buffers

      state.buffers.color.setLocked(true);
      state.buffers.depth.setLocked(true);

      // set up stencil

      var writeValue, clearValue;
      if (this.inverse) {
        writeValue = 0;
        clearValue = 1;
      } else {
        writeValue = 1;
        clearValue = 0;
      }
      state.buffers.stencil.setTest(true);
      state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
      state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
      state.buffers.stencil.setClear(clearValue);
      state.buffers.stencil.setLocked(true);

      // draw into the stencil buffer

      renderer.setRenderTarget(readBuffer);
      if (this.clear) renderer.clear();
      renderer.render(this.scene, this.camera);
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      renderer.render(this.scene, this.camera);

      // unlock color and depth buffer and make them writable for subsequent rendering/clearing

      state.buffers.color.setLocked(false);
      state.buffers.depth.setLocked(false);
      state.buffers.color.setMask(true);
      state.buffers.depth.setMask(true);

      // only render where stencil is set to 1

      state.buffers.stencil.setLocked(false);
      state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
      state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
      state.buffers.stencil.setLocked(true);
    }
  }]);
}(_Pass3.Pass);
var ClearMaskPass = exports.ClearMaskPass = /*#__PURE__*/function (_Pass2) {
  function ClearMaskPass() {
    var _this2;
    _classCallCheck(this, ClearMaskPass);
    _this2 = _callSuper(this, ClearMaskPass);
    _this2.needsSwap = false;
    return _this2;
  }
  _inherits(ClearMaskPass, _Pass2);
  return _createClass(ClearMaskPass, [{
    key: "render",
    value: function render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */) {
      renderer.state.buffers.stencil.setLocked(false);
      renderer.state.buffers.stencil.setTest(false);
    }
  }]);
}(_Pass3.Pass);
},{"./Pass.js":"node_modules/three/examples/jsm/postprocessing/Pass.js"}],"node_modules/three/examples/jsm/postprocessing/EffectComposer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EffectComposer = void 0;
var _three = require("three");
var _CopyShader = require("../shaders/CopyShader.js");
var _ShaderPass = require("./ShaderPass.js");
var _MaskPass = require("./MaskPass.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var EffectComposer = exports.EffectComposer = /*#__PURE__*/function () {
  function EffectComposer(renderer, renderTarget) {
    _classCallCheck(this, EffectComposer);
    this.renderer = renderer;
    this._pixelRatio = renderer.getPixelRatio();
    if (renderTarget === undefined) {
      var size = renderer.getSize(new _three.Vector2());
      this._width = size.width;
      this._height = size.height;
      renderTarget = new _three.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, {
        type: _three.HalfFloatType
      });
      renderTarget.texture.name = 'EffectComposer.rt1';
    } else {
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = 'EffectComposer.rt2';
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];
    this.copyPass = new _ShaderPass.ShaderPass(_CopyShader.CopyShader);
    this.copyPass.material.blending = _three.NoBlending;
    this.clock = new _three.Clock();
  }
  return _createClass(EffectComposer, [{
    key: "swapBuffers",
    value: function swapBuffers() {
      var tmp = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp;
    }
  }, {
    key: "addPass",
    value: function addPass(pass) {
      this.passes.push(pass);
      pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
  }, {
    key: "insertPass",
    value: function insertPass(pass, index) {
      this.passes.splice(index, 0, pass);
      pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
  }, {
    key: "removePass",
    value: function removePass(pass) {
      var index = this.passes.indexOf(pass);
      if (index !== -1) {
        this.passes.splice(index, 1);
      }
    }
  }, {
    key: "isLastEnabledPass",
    value: function isLastEnabledPass(passIndex) {
      for (var i = passIndex + 1; i < this.passes.length; i++) {
        if (this.passes[i].enabled) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "render",
    value: function render(deltaTime) {
      // deltaTime value is in seconds

      if (deltaTime === undefined) {
        deltaTime = this.clock.getDelta();
      }
      var currentRenderTarget = this.renderer.getRenderTarget();
      var maskActive = false;
      for (var i = 0, il = this.passes.length; i < il; i++) {
        var pass = this.passes[i];
        if (pass.enabled === false) continue;
        pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
        pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
        if (pass.needsSwap) {
          if (maskActive) {
            var context = this.renderer.getContext();
            var stencil = this.renderer.state.buffers.stencil;

            //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
            stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);
            this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);

            //context.stencilFunc( context.EQUAL, 1, 0xffffffff );
            stencil.setFunc(context.EQUAL, 1, 0xffffffff);
          }
          this.swapBuffers();
        }
        if (_MaskPass.MaskPass !== undefined) {
          if (pass instanceof _MaskPass.MaskPass) {
            maskActive = true;
          } else if (pass instanceof _MaskPass.ClearMaskPass) {
            maskActive = false;
          }
        }
      }
      this.renderer.setRenderTarget(currentRenderTarget);
    }
  }, {
    key: "reset",
    value: function reset(renderTarget) {
      if (renderTarget === undefined) {
        var size = this.renderer.getSize(new _three.Vector2());
        this._pixelRatio = this.renderer.getPixelRatio();
        this._width = size.width;
        this._height = size.height;
        renderTarget = this.renderTarget1.clone();
        renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      this.renderTarget1.dispose();
      this.renderTarget2.dispose();
      this.renderTarget1 = renderTarget;
      this.renderTarget2 = renderTarget.clone();
      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this._width = width;
      this._height = height;
      var effectiveWidth = this._width * this._pixelRatio;
      var effectiveHeight = this._height * this._pixelRatio;
      this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
      this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
      for (var i = 0; i < this.passes.length; i++) {
        this.passes[i].setSize(effectiveWidth, effectiveHeight);
      }
    }
  }, {
    key: "setPixelRatio",
    value: function setPixelRatio(pixelRatio) {
      this._pixelRatio = pixelRatio;
      this.setSize(this._width, this._height);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.renderTarget1.dispose();
      this.renderTarget2.dispose();
      this.copyPass.dispose();
    }
  }]);
}();
},{"three":"node_modules/three/build/three.module.js","../shaders/CopyShader.js":"node_modules/three/examples/jsm/shaders/CopyShader.js","./ShaderPass.js":"node_modules/three/examples/jsm/postprocessing/ShaderPass.js","./MaskPass.js":"node_modules/three/examples/jsm/postprocessing/MaskPass.js"}],"node_modules/three/examples/jsm/postprocessing/RenderPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderPass = void 0;
var _three = require("three");
var _Pass2 = require("./Pass.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var RenderPass = exports.RenderPass = /*#__PURE__*/function (_Pass) {
  function RenderPass(scene, camera) {
    var _this;
    var overrideMaterial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var clearColor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var clearAlpha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    _classCallCheck(this, RenderPass);
    _this = _callSuper(this, RenderPass);
    _this.scene = scene;
    _this.camera = camera;
    _this.overrideMaterial = overrideMaterial;
    _this.clearColor = clearColor;
    _this.clearAlpha = clearAlpha;
    _this.clear = true;
    _this.clearDepth = false;
    _this.needsSwap = false;
    _this._oldClearColor = new _three.Color();
    return _this;
  }
  _inherits(RenderPass, _Pass);
  return _createClass(RenderPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
      var oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      var oldClearAlpha, oldOverrideMaterial;
      if (this.overrideMaterial !== null) {
        oldOverrideMaterial = this.scene.overrideMaterial;
        this.scene.overrideMaterial = this.overrideMaterial;
      }
      if (this.clearColor !== null) {
        renderer.getClearColor(this._oldClearColor);
        renderer.setClearColor(this.clearColor, renderer.getClearAlpha());
      }
      if (this.clearAlpha !== null) {
        oldClearAlpha = renderer.getClearAlpha();
        renderer.setClearAlpha(this.clearAlpha);
      }
      if (this.clearDepth == true) {
        renderer.clearDepth();
      }
      renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
      if (this.clear === true) {
        // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }
      renderer.render(this.scene, this.camera);

      // restore

      if (this.clearColor !== null) {
        renderer.setClearColor(this._oldClearColor);
      }
      if (this.clearAlpha !== null) {
        renderer.setClearAlpha(oldClearAlpha);
      }
      if (this.overrideMaterial !== null) {
        this.scene.overrideMaterial = oldOverrideMaterial;
      }
      renderer.autoClear = oldAutoClear;
    }
  }]);
}(_Pass2.Pass);
},{"three":"node_modules/three/build/three.module.js","./Pass.js":"node_modules/three/examples/jsm/postprocessing/Pass.js"}],"js/CustomPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomPass = void 0;
var _three = require("three");
var CustomPass = exports.CustomPass = {
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'time': {
      value: 0
    },
    'scale': {
      value: 1
    },
    'progress': {
      value: 0
    },
    'tSize': {
      value: new _three.Vector2(256, 256)
    },
    'center': {
      value: new _three.Vector2(0.5, 0.5)
    },
    'angle': {
      value: 1.57
    }
  },
  vertexShader: /* glsl */"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
  fragmentShader: /* glsl */"\n\n\t\tuniform vec2 center;\n\t\tuniform float angle;\n        uniform float time;\n        uniform float scale;\n        uniform float progress;\n\t\tuniform vec2 tSize;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tfloat pattern() {\n\n\t\t\tfloat s = sin( angle ), c = cos( angle );\n\n\t\t\tvec2 tex = vUv * tSize - center;\n\t\t\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\n\n\t\t\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n\n\t\t}\n\n\t\tvoid main() {\n            vec2 newUV = vUv;\n\n            // newUV = vUv + 0.1*vec2(sin(10.*vUv.x), sin(10.*vUv.y));\n\n\n            \n\n\n            vec2 p = 2.*vUv - vec2(1.);\n\n\n            p += 0.1*cos(scale*3.*p.yx + time + vec2(1.2,3.4));\n            p += 0.1*cos(scale*3.7*p.yx + 1.4*time + vec2(2.2,3.4));\n            p += 0.1*cos(scale*5.*p.yx + 2.6*time + vec2(4.2,1.4));\n            p += 0.3*cos(scale*7.*p.yx + 3.6*time + vec2(15.2,3.4));\n\n\n\n            // newUV = vUv + centeredUV*vec2(1.,0.);\n\n            // newUV.y = 0.;\n            // newUV.x = length(centeredUV);\n\n            newUV.x = mix(vUv.x,length(p), progress);\n            newUV.y = mix(vUv.y,0.5, progress);\n\n            vec4 color = texture2D( tDiffuse, newUV );\n\n            gl_FragColor = color;\n            // gl_FragColor = vec4(length(p),0.,0.,1.);\n\n\t\t}"
};
},{"three":"node_modules/three/build/three.module.js"}],"node_modules/three/examples/jsm/shaders/RGBShiftShader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RGBShiftShader = void 0;
/**
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from https://web.archive.org/web/20090820185047/http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / https://web.archive.org/web/20090810054752/http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

var RGBShiftShader = exports.RGBShiftShader = {
  name: 'RGBShiftShader',
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'amount': {
      value: 0.005
    },
    'angle': {
      value: 0.0
    }
  },
  vertexShader: /* glsl */"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
  fragmentShader: /* glsl */"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float amount;\n\t\tuniform float angle;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));\n\t\t\tvec4 cr = texture2D(tDiffuse, vUv + offset);\n\t\t\tvec4 cga = texture2D(tDiffuse, vUv);\n\t\t\tvec4 cb = texture2D(tDiffuse, vUv - offset);\n\t\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n\n\t\t}"
};
},{}],"node_modules/three/examples/jsm/shaders/OutputShader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OutputShader = void 0;
var OutputShader = exports.OutputShader = {
  name: 'OutputShader',
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'toneMappingExposure': {
      value: 1
    }
  },
  vertexShader: /* glsl */"\n\t\tprecision highp float;\n\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
  fragmentShader: /* glsl */"\n\t\n\t\tprecision highp float;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\t#include <tonemapping_pars_fragment>\n\t\t#include <colorspace_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\n\t\t\t// tone mapping\n\n\t\t\t#ifdef LINEAR_TONE_MAPPING\n\n\t\t\t\tgl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( REINHARD_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( CINEON_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( ACES_FILMIC_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( AGX_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( NEUTRAL_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );\n\n\t\t\t#endif\n\n\t\t\t// color space\n\n\t\t\t#ifdef SRGB_TRANSFER\n\n\t\t\t\tgl_FragColor = sRGBTransferOETF( gl_FragColor );\n\n\t\t\t#endif\n\n\t\t}"
};
},{}],"node_modules/three/examples/jsm/postprocessing/OutputPass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OutputPass = void 0;
var _three = require("three");
var _Pass2 = require("./Pass.js");
var _OutputShader = require("../shaders/OutputShader.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var OutputPass = exports.OutputPass = /*#__PURE__*/function (_Pass) {
  function OutputPass() {
    var _this;
    _classCallCheck(this, OutputPass);
    _this = _callSuper(this, OutputPass);

    //

    var shader = _OutputShader.OutputShader;
    _this.uniforms = _three.UniformsUtils.clone(shader.uniforms);
    _this.material = new _three.RawShaderMaterial({
      name: shader.name,
      uniforms: _this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
    _this.fsQuad = new _Pass2.FullScreenQuad(_this.material);

    // internal cache

    _this._outputColorSpace = null;
    _this._toneMapping = null;
    return _this;
  }
  _inherits(OutputPass, _Pass);
  return _createClass(OutputPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {
      this.uniforms['tDiffuse'].value = readBuffer.texture;
      this.uniforms['toneMappingExposure'].value = renderer.toneMappingExposure;

      // rebuild defines if required

      if (this._outputColorSpace !== renderer.outputColorSpace || this._toneMapping !== renderer.toneMapping) {
        this._outputColorSpace = renderer.outputColorSpace;
        this._toneMapping = renderer.toneMapping;
        this.material.defines = {};
        if (_three.ColorManagement.getTransfer(this._outputColorSpace) === _three.SRGBTransfer) this.material.defines.SRGB_TRANSFER = '';
        if (this._toneMapping === _three.LinearToneMapping) this.material.defines.LINEAR_TONE_MAPPING = '';else if (this._toneMapping === _three.ReinhardToneMapping) this.material.defines.REINHARD_TONE_MAPPING = '';else if (this._toneMapping === _three.CineonToneMapping) this.material.defines.CINEON_TONE_MAPPING = '';else if (this._toneMapping === _three.ACESFilmicToneMapping) this.material.defines.ACES_FILMIC_TONE_MAPPING = '';else if (this._toneMapping === _three.AgXToneMapping) this.material.defines.AGX_TONE_MAPPING = '';else if (this._toneMapping === _three.NeutralToneMapping) this.material.defines.NEUTRAL_TONE_MAPPING = '';
        this.material.needsUpdate = true;
      }

      //

      if (this.renderToScreen === true) {
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      } else {
        renderer.setRenderTarget(writeBuffer);
        if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        this.fsQuad.render(renderer);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.material.dispose();
      this.fsQuad.dispose();
    }
  }]);
}(_Pass2.Pass);
},{"three":"node_modules/three/build/three.module.js","./Pass.js":"node_modules/three/examples/jsm/postprocessing/Pass.js","../shaders/OutputShader.js":"node_modules/three/examples/jsm/shaders/OutputShader.js"}],"node_modules/@theatre/dataverse/dist/index.js":[function(require,module,exports) {
var global = arguments[3];
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {
    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = target => __defProp(target, "__esModule", {
  value: true
});
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all) __defProp(target, name, {
    get: all[name],
    enumerable: true
  });
};

// src/index.ts
__export(exports, {
  Atom: () => Atom,
  PointerProxy: () => PointerProxy,
  Ticker: () => Ticker,
  getPointerParts: () => getPointerParts,
  isPointer: () => isPointer,
  isPrism: () => isPrism,
  iterateAndCountTicks: () => iterateAndCountTicks,
  iterateOver: () => iterateOver,
  pointer: () => pointer_default,
  pointerToPrism: () => pointerToPrism,
  prism: () => prism_default,
  val: () => val
});

// ../../node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// ../../node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// ../../node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../../node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// ../../node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
    tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {}
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// ../../node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../../node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../../node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// ../../node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// ../../node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// ../../node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// ../../node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// ../../node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// ../../node_modules/lodash-es/_isMasked.js
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// ../../node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + "";
    } catch (e) {}
  }
  return "";
}
var toSource_default = toSource;

// ../../node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// ../../node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// ../../node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// ../../node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// ../../node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// ../../node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// ../../node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// ../../node_modules/lodash-es/_hashHas.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var hashHas_default = hashHas;

// ../../node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// ../../node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// ../../node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// ../../node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// ../../node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// ../../node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__,
    index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// ../../node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__,
    index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// ../../node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// ../../node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__,
    index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// ../../node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// ../../node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// ../../node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// ../../node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// ../../node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// ../../node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// ../../node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// ../../node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// ../../node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key),
    size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// ../../node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// ../../node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function () {
    var args = arguments,
      key = resolver ? resolver.apply(this, args) : args[0],
      cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// ../../node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// ../../node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function (string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// ../../node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1,
    length = array == null ? 0 : array.length,
    result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// ../../node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// ../../node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// ../../node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// ../../node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;

// ../../node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0,
    length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// ../../node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// ../../node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// ../../node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// ../../node_modules/lodash-es/isPlainObject.js
var objectTag = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto6 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty5.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// ../../node_modules/lodash-es/last.js
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_default = last;

// src/pointer.ts
var pointerMetaWeakMap = new WeakMap();
var cachedSubPathPointersWeakMap = new WeakMap();
var pointerMetaSymbol = Symbol("pointerMeta");
var proxyHandler = {
  get(pointerKey, prop) {
    if (prop === pointerMetaSymbol) return pointerMetaWeakMap.get(pointerKey);
    let subPathPointers = cachedSubPathPointersWeakMap.get(pointerKey);
    if (!subPathPointers) {
      subPathPointers = new Map();
      cachedSubPathPointersWeakMap.set(pointerKey, subPathPointers);
    }
    const existing = subPathPointers.get(prop);
    if (existing !== void 0) return existing;
    const meta = pointerMetaWeakMap.get(pointerKey);
    const subPointer = pointer({
      root: meta.root,
      path: [...meta.path, prop]
    });
    subPathPointers.set(prop, subPointer);
    return subPointer;
  }
};
var getPointerMeta = p => {
  const meta = p[pointerMetaSymbol];
  return meta;
};
var getPointerParts = p => {
  const {
    root: root2,
    path
  } = getPointerMeta(p);
  return {
    root: root2,
    path
  };
};
function pointer(args) {
  var _a;
  const meta = {
    root: args.root,
    path: (_a = args.path) != null ? _a : []
  };
  const pointerKey = {};
  pointerMetaWeakMap.set(pointerKey, meta);
  return new Proxy(pointerKey, proxyHandler);
}
var pointer_default = pointer;
var isPointer = p => {
  return p && !!getPointerMeta(p);
};

// src/utils/updateDeep.ts
function updateDeep(state2, path, reducer) {
  if (path.length === 0) return reducer(state2);
  return hoop(state2, path, reducer);
}
var hoop = (s, path, reducer) => {
  if (path.length === 0) {
    return reducer(s);
  }
  if (Array.isArray(s)) {
    let [index, ...restOfPath] = path;
    index = parseInt(String(index), 10);
    if (isNaN(index)) index = 0;
    const oldVal = s[index];
    const newVal = hoop(oldVal, restOfPath, reducer);
    if (oldVal === newVal) return s;
    const newS = [...s];
    newS.splice(index, 1, newVal);
    return newS;
  } else if (typeof s === "object" && s !== null) {
    const [key, ...restOfPath] = path;
    const oldVal = s[key];
    const newVal = hoop(oldVal, restOfPath, reducer);
    if (oldVal === newVal) return s;
    const newS = __spreadProps(__spreadValues({}, s), {
      [key]: newVal
    });
    return newS;
  } else {
    const [key, ...restOfPath] = path;
    return {
      [key]: hoop(void 0, restOfPath, reducer)
    };
  }
};

// src/utils/Stack.ts
var Stack = class {
  constructor() {
    this._head = void 0;
  }
  peek() {
    return this._head && this._head.data;
  }
  pop() {
    const head = this._head;
    if (!head) {
      return void 0;
    }
    this._head = head.next;
    return head.data;
  }
  push(data) {
    const node = {
      next: this._head,
      data
    };
    this._head = node;
  }
};

// src/prism/Interface.ts
function isPrism(d) {
  return !!(d && d.isPrism && d.isPrism === true);
}

// src/prism/discoveryMechanism.ts
function createMechanism() {
  const noop = () => {};
  const stack = new Stack();
  const noopCollector = noop;
  const pushCollector2 = collector => {
    stack.push(collector);
  };
  const popCollector2 = collector => {
    const existing = stack.peek();
    if (existing !== collector) {
      throw new Error(`Popped collector is not on top of the stack`);
    }
    stack.pop();
  };
  const startIgnoringDependencies2 = () => {
    stack.push(noopCollector);
  };
  const stopIgnoringDependencies2 = () => {
    if (stack.peek() !== noopCollector) {
      if ("development" === "development") {
        console.warn("This should never happen");
      }
    } else {
      stack.pop();
    }
  };
  const reportResolutionStart2 = d => {
    const possibleCollector = stack.peek();
    if (possibleCollector) {
      possibleCollector(d);
    }
    stack.push(noopCollector);
  };
  const reportResolutionEnd2 = _d => {
    stack.pop();
  };
  return {
    type: "Dataverse_discoveryMechanism",
    startIgnoringDependencies: startIgnoringDependencies2,
    stopIgnoringDependencies: stopIgnoringDependencies2,
    reportResolutionStart: reportResolutionStart2,
    reportResolutionEnd: reportResolutionEnd2,
    pushCollector: pushCollector2,
    popCollector: popCollector2
  };
}
function getSharedMechanism() {
  const varName = "__dataverse_discoveryMechanism_sharedStack";
  const root2 = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  if (root2) {
    const existingMechanism = root2[varName];
    if (existingMechanism && typeof existingMechanism === "object" && existingMechanism.type === "Dataverse_discoveryMechanism") {
      return existingMechanism;
    } else {
      const mechanism = createMechanism();
      root2[varName] = mechanism;
      return mechanism;
    }
  } else {
    return createMechanism();
  }
}
var {
  startIgnoringDependencies,
  stopIgnoringDependencies,
  reportResolutionEnd,
  reportResolutionStart,
  pushCollector,
  popCollector
} = getSharedMechanism();

// src/prism/prism.ts
var voidFn = () => {};
var HotHandle = class {
  constructor(_fn, _prismInstance) {
    this._fn = _fn;
    this._prismInstance = _prismInstance;
    this._didMarkDependentsAsStale = false;
    this._isFresh = false;
    this._cacheOfDendencyValues = new Map();
    this._dependents = new Set();
    this._dependencies = new Set();
    this._possiblyStaleDeps = new Set();
    this._scope = new HotScope(this);
    this._lastValue = void 0;
    this._forciblySetToStale = false;
    this._reactToDependencyGoingStale = which => {
      this._possiblyStaleDeps.add(which);
      this._markAsStale();
    };
    for (const d of this._dependencies) {
      d._addDependent(this._reactToDependencyGoingStale);
    }
    startIgnoringDependencies();
    this.getValue();
    stopIgnoringDependencies();
  }
  get hasDependents() {
    return this._dependents.size > 0;
  }
  removeDependent(d) {
    this._dependents.delete(d);
  }
  addDependent(d) {
    this._dependents.add(d);
  }
  destroy() {
    for (const d of this._dependencies) {
      d._removeDependent(this._reactToDependencyGoingStale);
    }
    cleanupScopeStack(this._scope);
  }
  getValue() {
    if (!this._isFresh) {
      const newValue = this._recalculate();
      this._lastValue = newValue;
      this._isFresh = true;
      this._didMarkDependentsAsStale = false;
      this._forciblySetToStale = false;
    }
    return this._lastValue;
  }
  _recalculate() {
    let value;
    if (!this._forciblySetToStale) {
      if (this._possiblyStaleDeps.size > 0) {
        let anActuallyStaleDepWasFound = false;
        startIgnoringDependencies();
        for (const dep of this._possiblyStaleDeps) {
          if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {
            anActuallyStaleDepWasFound = true;
            break;
          }
        }
        stopIgnoringDependencies();
        this._possiblyStaleDeps.clear();
        if (!anActuallyStaleDepWasFound) {
          return this._lastValue;
        }
      }
    }
    const newDeps = new Set();
    this._cacheOfDendencyValues.clear();
    const collector = observedDep => {
      newDeps.add(observedDep);
      this._addDependency(observedDep);
    };
    pushCollector(collector);
    hookScopeStack.push(this._scope);
    try {
      value = this._fn();
    } catch (error) {
      console.error(error);
    } finally {
      const topOfTheStack = hookScopeStack.pop();
      if (topOfTheStack !== this._scope) {
        console.warn(`The Prism hook stack has slipped. This is a bug.`);
      }
    }
    popCollector(collector);
    for (const dep of this._dependencies) {
      if (!newDeps.has(dep)) {
        this._removeDependency(dep);
      }
    }
    this._dependencies = newDeps;
    startIgnoringDependencies();
    for (const dep of newDeps) {
      this._cacheOfDendencyValues.set(dep, dep.getValue());
    }
    stopIgnoringDependencies();
    return value;
  }
  forceStale() {
    this._forciblySetToStale = true;
    this._markAsStale();
  }
  _markAsStale() {
    if (this._didMarkDependentsAsStale) return;
    this._didMarkDependentsAsStale = true;
    this._isFresh = false;
    for (const dependent of this._dependents) {
      dependent(this._prismInstance);
    }
  }
  _addDependency(d) {
    if (this._dependencies.has(d)) return;
    this._dependencies.add(d);
    d._addDependent(this._reactToDependencyGoingStale);
  }
  _removeDependency(d) {
    if (!this._dependencies.has(d)) return;
    this._dependencies.delete(d);
    d._removeDependent(this._reactToDependencyGoingStale);
  }
};
var emptyObject = {};
var PrismInstance = class {
  constructor(_fn) {
    this._fn = _fn;
    this.isPrism = true;
    this._state = {
      hot: false,
      handle: void 0
    };
  }
  get isHot() {
    return this._state.hot;
  }
  onChange(ticker, listener, immediate = false) {
    const dependent = () => {
      ticker.onThisOrNextTick(refresh);
    };
    let lastValue = emptyObject;
    const refresh = () => {
      const newValue = this.getValue();
      if (newValue === lastValue) return;
      lastValue = newValue;
      listener(newValue);
    };
    this._addDependent(dependent);
    if (immediate) {
      lastValue = this.getValue();
      listener(lastValue);
    }
    const unsubscribe = () => {
      this._removeDependent(dependent);
      ticker.offThisOrNextTick(refresh);
      ticker.offNextTick(refresh);
    };
    return unsubscribe;
  }
  onStale(callback) {
    const untap = () => {
      this._removeDependent(fn);
    };
    const fn = () => callback();
    this._addDependent(fn);
    return untap;
  }
  keepHot() {
    return this.onStale(() => {});
  }
  _addDependent(d) {
    if (!this._state.hot) {
      this._goHot();
    }
    this._state.handle.addDependent(d);
  }
  _goHot() {
    const hotHandle = new HotHandle(this._fn, this);
    this._state = {
      hot: true,
      handle: hotHandle
    };
  }
  _removeDependent(d) {
    const state2 = this._state;
    if (!state2.hot) {
      return;
    }
    const handle = state2.handle;
    handle.removeDependent(d);
    if (!handle.hasDependents) {
      this._state = {
        hot: false,
        handle: void 0
      };
      handle.destroy();
    }
  }
  getValue() {
    reportResolutionStart(this);
    const state2 = this._state;
    let val2;
    if (state2.hot) {
      val2 = state2.handle.getValue();
    } else {
      val2 = calculateColdPrism(this._fn);
    }
    reportResolutionEnd(this);
    return val2;
  }
};
var HotScope = class {
  constructor(_hotHandle) {
    this._hotHandle = _hotHandle;
    this._refs = new Map();
    this.isPrismScope = true;
    this.subs = {};
    this.effects = new Map();
    this.memos = new Map();
  }
  ref(key, initialValue) {
    let ref2 = this._refs.get(key);
    if (ref2 !== void 0) {
      return ref2;
    } else {
      const ref3 = {
        current: initialValue
      };
      this._refs.set(key, ref3);
      return ref3;
    }
  }
  effect(key, cb, deps) {
    let effect2 = this.effects.get(key);
    if (effect2 === void 0) {
      effect2 = {
        cleanup: voidFn,
        deps: void 0
      };
      this.effects.set(key, effect2);
    }
    if (depsHaveChanged(effect2.deps, deps)) {
      effect2.cleanup();
      startIgnoringDependencies();
      effect2.cleanup = safelyRun(cb, voidFn).value;
      stopIgnoringDependencies();
      effect2.deps = deps;
    }
  }
  memo(key, fn, deps) {
    let memo2 = this.memos.get(key);
    if (memo2 === void 0) {
      memo2 = {
        cachedValue: null,
        deps: void 0
      };
      this.memos.set(key, memo2);
    }
    if (depsHaveChanged(memo2.deps, deps)) {
      startIgnoringDependencies();
      memo2.cachedValue = safelyRun(fn, void 0).value;
      stopIgnoringDependencies();
      memo2.deps = deps;
    }
    return memo2.cachedValue;
  }
  state(key, initialValue) {
    const {
      value,
      setValue
    } = this.memo("state/" + key, () => {
      const value2 = {
        current: initialValue
      };
      const setValue2 = newValue => {
        value2.current = newValue;
        this._hotHandle.forceStale();
      };
      return {
        value: value2,
        setValue: setValue2
      };
    }, []);
    return [value.current, setValue];
  }
  sub(key) {
    if (!this.subs[key]) {
      this.subs[key] = new HotScope(this._hotHandle);
    }
    return this.subs[key];
  }
  cleanupEffects() {
    for (const effect2 of this.effects.values()) {
      safelyRun(effect2.cleanup, void 0);
    }
    this.effects.clear();
  }
  source(subscribe, getValue2) {
    const sourceKey = "$$source/blah";
    this.effect(sourceKey, () => {
      const unsub = subscribe(() => {
        this._hotHandle.forceStale();
      });
      return unsub;
    }, [subscribe]);
    return getValue2();
  }
};
function cleanupScopeStack(scope2) {
  for (const sub2 of Object.values(scope2.subs)) {
    cleanupScopeStack(sub2);
  }
  scope2.cleanupEffects();
}
function safelyRun(fn, returnValueInCaseOfError) {
  try {
    return {
      value: fn(),
      ok: true
    };
  } catch (error) {
    setTimeout(function PrismReportThrow() {
      throw error;
    });
    return {
      value: returnValueInCaseOfError,
      ok: false
    };
  }
}
var hookScopeStack = new Stack();
function ref(key, initialValue) {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`prism.ref() is called outside of a prism() call.`);
  }
  return scope2.ref(key, initialValue);
}
function effect(key, cb, deps) {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`prism.effect() is called outside of a prism() call.`);
  }
  return scope2.effect(key, cb, deps);
}
function depsHaveChanged(oldDeps, newDeps) {
  if (oldDeps === void 0 || newDeps === void 0) {
    return true;
  }
  const len = oldDeps.length;
  if (len !== newDeps.length) return true;
  for (let i = 0; i < len; i++) {
    if (oldDeps[i] !== newDeps[i]) return true;
  }
  return false;
}
function memo(key, fn, deps) {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`prism.memo() is called outside of a prism() call.`);
  }
  return scope2.memo(key, fn, deps);
}
function state(key, initialValue) {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`prism.state() is called outside of a prism() call.`);
  }
  return scope2.state(key, initialValue);
}
function ensurePrism() {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`The parent function is called outside of a prism() call.`);
  }
}
function scope(key, fn) {
  const parentScope = hookScopeStack.peek();
  if (!parentScope) {
    throw new Error(`prism.scope() is called outside of a prism() call.`);
  }
  const subScope = parentScope.sub(key);
  hookScopeStack.push(subScope);
  const ret = safelyRun(fn, void 0).value;
  hookScopeStack.pop();
  return ret;
}
function sub(key, fn, deps) {
  return memo(key, () => prism(fn), deps).getValue();
}
function inPrism() {
  return !!hookScopeStack.peek();
}
function source(subscribe, getValue2) {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`prism.source() is called outside of a prism() call.`);
  }
  return scope2.source(subscribe, getValue2);
}
var prism = fn => {
  return new PrismInstance(fn);
};
var ColdScope = class {
  effect(key, cb, deps) {
    console.warn(`prism.effect() does not run in cold prisms`);
  }
  memo(key, fn, deps) {
    return fn();
  }
  state(key, initialValue) {
    return [initialValue, () => {}];
  }
  ref(key, initialValue) {
    return {
      current: initialValue
    };
  }
  sub(key) {
    return new ColdScope();
  }
  source(subscribe, getValue2) {
    return getValue2();
  }
};
function calculateColdPrism(fn) {
  const scope2 = new ColdScope();
  hookScopeStack.push(scope2);
  let value;
  try {
    value = fn();
  } catch (error) {
    console.error(error);
  } finally {
    const topOfTheStack = hookScopeStack.pop();
    if (topOfTheStack !== scope2) {
      console.warn(`The Prism hook stack has slipped. This is a bug.`);
    }
  }
  return value;
}
prism.ref = ref;
prism.effect = effect;
prism.memo = memo;
prism.ensurePrism = ensurePrism;
prism.state = state;
prism.scope = scope;
prism.sub = sub;
prism.inPrism = inPrism;
prism.source = source;
var prism_default = prism;

// src/Atom.ts
var ValueTypes;
(function (ValueTypes2) {
  ValueTypes2[ValueTypes2["Dict"] = 0] = "Dict";
  ValueTypes2[ValueTypes2["Array"] = 1] = "Array";
  ValueTypes2[ValueTypes2["Other"] = 2] = "Other";
})(ValueTypes || (ValueTypes = {}));
var getTypeOfValue = v => {
  if (Array.isArray(v)) return 1;
  if (isPlainObject_default(v)) return 0;
  return 2;
};
var getKeyOfValue = (v, key, vType = getTypeOfValue(v)) => {
  if (vType === 0 && typeof key === "string") {
    return v[key];
  } else if (vType === 1 && isValidArrayIndex(key)) {
    return v[key];
  } else {
    return void 0;
  }
};
var isValidArrayIndex = key => {
  const inNumber = typeof key === "number" ? key : parseInt(key, 10);
  return !isNaN(inNumber) && inNumber >= 0 && inNumber < Infinity && (inNumber | 0) === inNumber;
};
var Scope = class {
  constructor(_parent, _path) {
    this._parent = _parent;
    this._path = _path;
    this.children = new Map();
    this.identityChangeListeners = new Set();
  }
  addIdentityChangeListener(cb) {
    this.identityChangeListeners.add(cb);
  }
  removeIdentityChangeListener(cb) {
    this.identityChangeListeners.delete(cb);
    this._checkForGC();
  }
  removeChild(key) {
    this.children.delete(key);
    this._checkForGC();
  }
  getChild(key) {
    return this.children.get(key);
  }
  getOrCreateChild(key) {
    let child = this.children.get(key);
    if (!child) {
      child = child = new Scope(this, this._path.concat([key]));
      this.children.set(key, child);
    }
    return child;
  }
  _checkForGC() {
    if (this.identityChangeListeners.size > 0) return;
    if (this.children.size > 0) return;
    if (this._parent) {
      this._parent.removeChild(last_default(this._path));
    }
  }
};
var Atom = class {
  constructor(initialState) {
    this.$$isPointerToPrismProvider = true;
    this.pointer = pointer_default({
      root: this,
      path: []
    });
    this.prism = this.pointerToPrism(this.pointer);
    this._onPointerValueChange = (pointer2, cb) => {
      const {
        path
      } = getPointerParts(pointer2);
      const scope2 = this._getOrCreateScopeForPath(path);
      scope2.identityChangeListeners.add(cb);
      const unsubscribe = () => {
        scope2.identityChangeListeners.delete(cb);
      };
      return unsubscribe;
    };
    this._currentState = initialState;
    this._rootScope = new Scope(void 0, []);
  }
  set(newState) {
    const oldState = this._currentState;
    this._currentState = newState;
    this._checkUpdates(this._rootScope, oldState, newState);
  }
  get() {
    return this._currentState;
  }
  getByPointer(pointerOrFn) {
    const pointer2 = isPointer(pointerOrFn) ? pointerOrFn : pointerOrFn(this.pointer);
    const path = getPointerParts(pointer2).path;
    return this._getIn(path);
  }
  _getIn(path) {
    return path.length === 0 ? this.get() : get_default(this.get(), path);
  }
  reduce(fn) {
    this.set(fn(this.get()));
  }
  reduceByPointer(pointerOrFn, reducer) {
    const pointer2 = isPointer(pointerOrFn) ? pointerOrFn : pointerOrFn(this.pointer);
    const path = getPointerParts(pointer2).path;
    const newState = updateDeep(this.get(), path, reducer);
    this.set(newState);
  }
  setByPointer(pointerOrFn, val2) {
    this.reduceByPointer(pointerOrFn, () => val2);
  }
  _checkUpdates(scope2, oldState, newState) {
    if (oldState === newState) return;
    for (const cb of scope2.identityChangeListeners) {
      cb(newState);
    }
    if (scope2.children.size === 0) return;
    const oldValueType = getTypeOfValue(oldState);
    const newValueType = getTypeOfValue(newState);
    if (oldValueType === 2 && oldValueType === newValueType) return;
    for (const [childKey, childScope] of scope2.children) {
      const oldChildVal = getKeyOfValue(oldState, childKey, oldValueType);
      const newChildVal = getKeyOfValue(newState, childKey, newValueType);
      this._checkUpdates(childScope, oldChildVal, newChildVal);
    }
  }
  _getOrCreateScopeForPath(path) {
    let curScope = this._rootScope;
    for (const pathEl of path) {
      curScope = curScope.getOrCreateChild(pathEl);
    }
    return curScope;
  }
  pointerToPrism(pointer2) {
    const {
      path
    } = getPointerParts(pointer2);
    const subscribe = listener => this._onPointerValueChange(pointer2, listener);
    const getValue2 = () => this._getIn(path);
    return prism_default(() => {
      return prism_default.source(subscribe, getValue2);
    });
  }
};

// src/pointerToPrism.ts
var identifyPrismWeakMap = new WeakMap();
function isPointerToPrismProvider(val2) {
  return typeof val2 === "object" && val2 !== null && val2["$$isPointerToPrismProvider"] === true;
}
var pointerToPrism = pointer2 => {
  const meta = getPointerMeta(pointer2);
  let prismInstance = identifyPrismWeakMap.get(meta);
  if (!prismInstance) {
    const root2 = meta.root;
    if (!isPointerToPrismProvider(root2)) {
      throw new Error(`Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider`);
    }
    prismInstance = root2.pointerToPrism(pointer2);
    identifyPrismWeakMap.set(meta, prismInstance);
  }
  return prismInstance;
};

// src/val.ts
var val = input => {
  if (isPointer(input)) {
    return pointerToPrism(input).getValue();
  } else if (isPrism(input)) {
    return input.getValue();
  } else {
    return input;
  }
};

// src/prism/iterateAndCountTicks.ts
function* iterateAndCountTicks(pointerOrPrism) {
  let d;
  if (isPointer(pointerOrPrism)) {
    d = pointerToPrism(pointerOrPrism);
  } else if (isPrism(pointerOrPrism)) {
    d = pointerOrPrism;
  } else {
    throw new Error(`Only pointers and prisms are supported`);
  }
  let ticksCountedSinceLastYield = 0;
  const untap = d.onStale(() => {
    ticksCountedSinceLastYield++;
  });
  try {
    while (true) {
      const ticks = ticksCountedSinceLastYield;
      ticksCountedSinceLastYield = 0;
      yield {
        value: d.getValue(),
        ticks
      };
    }
  } finally {
    untap();
  }
}

// src/Ticker.ts
var EMPTY_TICKS_BEFORE_GOING_DORMANT = 60 * 3;
var Ticker = class {
  constructor(_conf) {
    this._conf = _conf;
    this._ticking = false;
    this._dormant = true;
    this._numberOfDormantTicks = 0;
    this.__ticks = 0;
    this._scheduledForThisOrNextTick = new Set();
    this._scheduledForNextTick = new Set();
    this._timeAtCurrentTick = 0;
  }
  get dormant() {
    return this._dormant;
  }
  onThisOrNextTick(fn) {
    this._scheduledForThisOrNextTick.add(fn);
    if (this._dormant) {
      this._goActive();
    }
  }
  onNextTick(fn) {
    this._scheduledForNextTick.add(fn);
    if (this._dormant) {
      this._goActive();
    }
  }
  offThisOrNextTick(fn) {
    this._scheduledForThisOrNextTick.delete(fn);
  }
  offNextTick(fn) {
    this._scheduledForNextTick.delete(fn);
  }
  get time() {
    if (this._ticking) {
      return this._timeAtCurrentTick;
    } else return performance.now();
  }
  _goActive() {
    var _a, _b;
    if (!this._dormant) return;
    this._dormant = false;
    (_b = (_a = this._conf) == null ? void 0 : _a.onActive) == null ? void 0 : _b.call(_a);
  }
  _goDormant() {
    var _a, _b;
    if (this._dormant) return;
    this._dormant = true;
    this._numberOfDormantTicks = 0;
    (_b = (_a = this._conf) == null ? void 0 : _a.onDormant) == null ? void 0 : _b.call(_a);
  }
  tick(t = performance.now()) {
    if ("development" === "development") {
      if (!(this instanceof Ticker)) {
        throw new Error('ticker.tick must be called while bound to the ticker. As in, "ticker.tick(time)" or "requestAnimationFrame((t) => ticker.tick(t))" for performance.');
      }
    }
    this.__ticks++;
    if (!this._dormant) {
      if (this._scheduledForNextTick.size === 0 && this._scheduledForThisOrNextTick.size === 0) {
        this._numberOfDormantTicks++;
        if (this._numberOfDormantTicks >= EMPTY_TICKS_BEFORE_GOING_DORMANT) {
          this._goDormant();
          return;
        }
      }
    }
    this._ticking = true;
    this._timeAtCurrentTick = t;
    for (const v of this._scheduledForNextTick) {
      this._scheduledForThisOrNextTick.add(v);
    }
    this._scheduledForNextTick.clear();
    this._tick(0);
    this._ticking = false;
  }
  _tick(iterationNumber) {
    const time = this.time;
    if (iterationNumber > 10) {
      console.warn("_tick() recursing for 10 times");
    }
    if (iterationNumber > 100) {
      throw new Error(`Maximum recursion limit for _tick()`);
    }
    const oldSet = this._scheduledForThisOrNextTick;
    this._scheduledForThisOrNextTick = new Set();
    for (const fn of oldSet) {
      fn(time);
    }
    if (this._scheduledForThisOrNextTick.size > 0) {
      return this._tick(iterationNumber + 1);
    }
  }
};

// src/prism/iterateOver.ts
function* iterateOver(pointerOrPrism) {
  let d;
  if (isPointer(pointerOrPrism)) {
    d = pointerToPrism(pointerOrPrism);
  } else if (isPrism(pointerOrPrism)) {
    d = pointerOrPrism;
  } else {
    throw new Error(`Only pointers and prisms are supported`);
  }
  const ticker = new Ticker();
  const untap = d.onChange(ticker, v => {});
  try {
    while (true) {
      ticker.tick();
      yield d.getValue();
    }
  } finally {
    untap();
  }
}

// src/PointerProxy.ts
var PointerProxy = class {
  constructor(currentPointer) {
    this.$$isPointerToPrismProvider = true;
    this._currentPointerBox = new Atom(currentPointer);
    this.pointer = pointer_default({
      root: this,
      path: []
    });
  }
  setPointer(p) {
    this._currentPointerBox.set(p);
  }
  pointerToPrism(pointer2) {
    const {
      path
    } = getPointerMeta(pointer2);
    return prism_default(() => {
      const currentPointer = this._currentPointerBox.prism.getValue();
      const subPointer = path.reduce((pointerSoFar, pathItem) => pointerSoFar[pathItem], currentPointer);
      return val(subPointer);
    });
  }
};
},{}],"node_modules/@theatre/core/dist/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {})) if (__hasOwnProp.call(b2, prop)) __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b2)) {
    if (__propIsEnum.call(b2, prop)) __defNormalProp(a2, prop, b2[prop]);
  }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
    exports: {}
  }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all) __defProp(target, name, {
    get: all[name],
    enumerable: true
  });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
// If the importer is in node compatibility mode or this is not an ESM
// file that has been converted to a CommonJS file using a Babel-
// compatible transform (i.e. "__esModule" has not been set), then set
// "default" to the CommonJS "module.exports" for node compatibility.
isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
  value: mod,
  enumerable: true
}) : target, mod));
var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
  value: true
}), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../node_modules/timing-function/lib/UnitBezier.js
var require_UnitBezier = __commonJS({
  "../node_modules/timing-function/lib/UnitBezier.js"(exports2, module2) {
    var UnitBezier2;
    module2.exports = UnitBezier2 = function () {
      function UnitBezier3(p1x, p1y, p2x, p2y) {
        this.set(p1x, p1y, p2x, p2y);
      }
      UnitBezier3.prototype.set = function (p1x, p1y, p2x, p2y) {
        this._cx = 3 * p1x;
        this._bx = 3 * (p2x - p1x) - this._cx;
        this._ax = 1 - this._cx - this._bx;
        this._cy = 3 * p1y;
        this._by = 3 * (p2y - p1y) - this._cy;
        this._ay = 1 - this._cy - this._by;
      };
      UnitBezier3.epsilon = 1e-6;
      UnitBezier3.prototype._sampleCurveX = function (t2) {
        return ((this._ax * t2 + this._bx) * t2 + this._cx) * t2;
      };
      UnitBezier3.prototype._sampleCurveY = function (t2) {
        return ((this._ay * t2 + this._by) * t2 + this._cy) * t2;
      };
      UnitBezier3.prototype._sampleCurveDerivativeX = function (t2) {
        return (3 * this._ax * t2 + 2 * this._bx) * t2 + this._cx;
      };
      UnitBezier3.prototype._solveCurveX = function (x2, epsilon) {
        var d2, i2, t0, t1, t2, x22;
        t0 = void 0;
        t1 = void 0;
        t2 = void 0;
        x22 = void 0;
        d2 = void 0;
        i2 = void 0;
        t2 = x2;
        i2 = 0;
        while (i2 < 8) {
          x22 = this._sampleCurveX(t2) - x2;
          if (Math.abs(x22) < epsilon) {
            return t2;
          }
          d2 = this._sampleCurveDerivativeX(t2);
          if (Math.abs(d2) < epsilon) {
            break;
          }
          t2 = t2 - x22 / d2;
          i2++;
        }
        t0 = 0;
        t1 = 1;
        t2 = x2;
        if (t2 < t0) {
          return t0;
        }
        if (t2 > t1) {
          return t1;
        }
        while (t0 < t1) {
          x22 = this._sampleCurveX(t2);
          if (Math.abs(x22 - x2) < epsilon) {
            return t2;
          }
          if (x2 > x22) {
            t0 = t2;
          } else {
            t1 = t2;
          }
          t2 = (t1 - t0) * 0.5 + t0;
        }
        return t2;
      };
      UnitBezier3.prototype.solve = function (x2, epsilon) {
        return this._sampleCurveY(this._solveCurveX(x2, epsilon));
      };
      UnitBezier3.prototype.solveSimple = function (x2) {
        return this._sampleCurveY(this._solveCurveX(x2, 1e-6));
      };
      return UnitBezier3;
    }();
  }
});

// ../node_modules/levenshtein-edit-distance/index.js
var require_levenshtein_edit_distance = __commonJS({
  "../node_modules/levenshtein-edit-distance/index.js"(exports2, module2) {
    var cache2;
    var codes;
    cache2 = [];
    codes = [];
    function levenshtein(value, other, insensitive) {
      var length, lengthOther, code, result, distance, distanceOther, index, indexOther;
      if (value === other) {
        return 0;
      }
      length = value.length;
      lengthOther = other.length;
      if (length === 0) {
        return lengthOther;
      }
      if (lengthOther === 0) {
        return length;
      }
      if (insensitive) {
        value = value.toLowerCase();
        other = other.toLowerCase();
      }
      index = 0;
      while (index < length) {
        codes[index] = value.charCodeAt(index);
        cache2[index] = ++index;
      }
      indexOther = 0;
      while (indexOther < lengthOther) {
        code = other.charCodeAt(indexOther);
        result = distance = indexOther++;
        index = -1;
        while (++index < length) {
          distanceOther = code === codes[index] ? distance : distance + 1;
          distance = cache2[index];
          cache2[index] = result = distance > result ? distanceOther > result ? result + 1 : distanceOther : distanceOther > distance ? distance + 1 : distanceOther;
        }
      }
      return result;
    }
    module2.exports = levenshtein;
  }
});

// ../node_modules/propose/propose.js
var require_propose = __commonJS({
  "../node_modules/propose/propose.js"(exports2, module2) {
    var levenshtein = require_levenshtein_edit_distance();
    function propose2() {
      var ratio;
      var distance;
      var proposed;
      var threshold;
      var ignoreCase;
      var max_ratio = 0;
      var word = arguments[0];
      var dictionary = arguments[1];
      var len = dictionary.length;
      var options = arguments[2];
      if (options) {
        threshold = options.threshold;
        ignoreCase = options.ignoreCase;
      }
      if (threshold === void 0) threshold = 0;
      for (var i2 = 0; i2 < len; ++i2) {
        if (ignoreCase) distance = levenshtein(word, dictionary[i2], true);else distance = levenshtein(word, dictionary[i2]);
        if (distance > word.length) ratio = 1 - distance / dictionary[i2].length;else ratio = 1 - distance / word.length;
        if (ratio > max_ratio) {
          max_ratio = ratio;
          proposed = dictionary[i2];
        }
      }
      if (max_ratio >= threshold) return proposed;
      return null;
    }
    module2.exports = propose2;
  }
});

// ../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";

    module2.exports = function equal(a2, b2) {
      if (a2 === b2) return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor) return false;
        var length, i2, keys2;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length) return false;
          for (i2 = length; i2-- !== 0;) if (!equal(a2[i2], b2[i2])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
        keys2 = Object.keys(a2);
        length = keys2.length;
        if (length !== Object.keys(b2).length) return false;
        for (i2 = length; i2-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2])) return false;
        for (i2 = length; i2-- !== 0;) {
          var key = keys2[i2];
          if (!equal(a2[key], b2[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// core/src/index.ts
var src_exports = {};
__export(src_exports, {
  createRafDriver: () => createRafDriver,
  getProject: () => getProject,
  notify: () => notify,
  onChange: () => onChange,
  types: () => propTypes_exports,
  val: () => val7
});
module.exports = __toCommonJS(src_exports);

// core/src/coreExports.ts
var coreExports_exports = {};
__export(coreExports_exports, {
  createRafDriver: () => createRafDriver,
  getProject: () => getProject,
  notify: () => notify,
  onChange: () => onChange,
  types: () => propTypes_exports,
  val: () => val7
});

// core/src/projects/projectsSingleton.ts
var import_dataverse = require("@theatre/dataverse");
var ProjectsSingleton = class {
  constructor() {
    __publicField(this, "atom", new import_dataverse.Atom({
      projects: {}
    }));
  }
  /**
   * We're trusting here that each project id is unique
   */
  add(id, project) {
    this.atom.setByPointer(p2 => p2.projects[id], project);
  }
  get(id) {
    return this.atom.get().projects[id];
  }
  has(id) {
    return !!this.get(id);
  }
};
var singleton = new ProjectsSingleton();
var projectsSingleton_default = singleton;

// core/src/privateAPIs.ts
var publicAPIToPrivateAPIMap = /* @__PURE__ */new WeakMap();
function privateAPI(pub) {
  return publicAPIToPrivateAPIMap.get(pub);
}
function setPrivateAPI(pub, priv) {
  publicAPIToPrivateAPIMap.set(pub, priv);
}

// shared/src/utils/index.ts
var emptyArray = [];

// ../node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// ../node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// ../node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// ../node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
    tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e2) {}
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// ../node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// ../node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// ../node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// ../node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// ../node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// ../node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// ../node_modules/lodash-es/_isMasked.js
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// ../node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e2) {}
    try {
      return func + "";
    } catch (e2) {}
  }
  return "";
}
var toSource_default = toSource;

// ../node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// ../node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// ../node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// ../node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// ../node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// ../node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// ../node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// ../node_modules/lodash-es/_hashHas.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var hashHas_default = hashHas;

// ../node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// ../node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// ../node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// ../node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// ../node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// ../node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__,
    index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// ../node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__,
    index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// ../node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// ../node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__,
    index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// ../node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// ../node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// ../node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// ../node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// ../node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// ../node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// ../node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// ../node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// ../node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key),
    size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// ../node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// ../node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function () {
    var args = arguments,
      key = resolver ? resolver.apply(this, args) : args[0],
      cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// ../node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function (key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// ../node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function (string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function (match, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// ../node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1,
    length = array == null ? 0 : array.length,
    result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// ../node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// ../node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// ../node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// ../node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;

// ../node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0,
    length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// ../node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// shared/src/utils/getDeep.ts
function getDeep(v2, path) {
  if (path.length === 0) return v2;
  return get_default(v2, path);
}

// shared/src/utils/SimpleCache.ts
var SimpleCache = class {
  constructor() {
    /**
     * NOTE this could also be a Map.
     */
    __publicField(this, "_values", {});
  }
  /**
   * get the cache item at `key` or produce it using `producer` and cache _that_.
   *
   * Note that this won't work if you change the producer, like `get(key, producer1); get(key, producer2)`.
   */
  get(key, producer) {
    if (this.has(key)) {
      return this._values[key];
    } else {
      const cachedValue = producer();
      this._values[key] = cachedValue;
      return cachedValue;
    }
  }
  /**
   * Returns true if the cache has an item at `key`.
   */
  has(key) {
    return this._values.hasOwnProperty(key);
  }
};

// core/src/sheetObjects/SheetObjectTemplate.ts
var import_dataverse6 = require("@theatre/dataverse");

// ../node_modules/lodash-es/_defineProperty.js
var defineProperty = function () {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {}
}();
var defineProperty_default = defineProperty;

// ../node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// ../node_modules/lodash-es/_assignValue.js
var objectProto6 = Object.prototype;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty5.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// ../node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var isIndex_default = isIndex;

// ../node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1,
    length = path.length,
    lastIndex = length - 1,
    nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path[index]),
      newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// ../node_modules/lodash-es/set.js
function set(object, path, value) {
  return object == null ? object : baseSet_default(object, path, value);
}
var set_default = set;

// core/src/sheetObjects/getPropDefaultsOfSheetObject.ts
var cachedDefaults = /* @__PURE__ */new WeakMap();
function getPropDefaultsOfSheetObject(config) {
  return getDefaultsOfPropTypeConfig(config);
}
function getDefaultsOfPropTypeConfig(config) {
  if (cachedDefaults.has(config)) {
    return cachedDefaults.get(config);
  }
  const generated = config.type === "compound" ? generateDefaultsForCompound(config) : config.type === "enum" ? generateDefaultsForEnum(config) : config.default;
  cachedDefaults.set(config, generated);
  return generated;
}
function generateDefaultsForEnum(config) {
  const defaults = {
    $case: config.defaultCase
  };
  for (const [case_, caseConf] of Object.entries(config.cases)) {
    defaults[case_] = getDefaultsOfPropTypeConfig(caseConf);
  }
  return defaults;
}
function generateDefaultsForCompound(config) {
  const defaults = {};
  for (const [key, propConf] of Object.entries(config.props)) {
    defaults[key] = getDefaultsOfPropTypeConfig(propConf);
  }
  return defaults;
}

// core/src/sequences/interpolationTripleAtPosition.ts
var import_dataverse2 = require("@theatre/dataverse");
var import_UnitBezier = __toESM(require_UnitBezier());
function interpolationTripleAtPosition(ctx, trackP, timeD) {
  return (0, import_dataverse2.prism)(() => {
    const track = (0, import_dataverse2.val)(trackP);
    const driverD = import_dataverse2.prism.memo("driver", () => {
      if (!track) {
        return (0, import_dataverse2.prism)(() => void 0);
      } else if (track.type === "BasicKeyframedTrack") {
        return _forKeyframedTrack(ctx, track, timeD);
      } else {
        ctx.logger.error("Track type not yet supported.");
        return (0, import_dataverse2.prism)(() => void 0);
      }
    }, [track]);
    return driverD.getValue();
  });
}
function _forKeyframedTrack(ctx, track, timeD) {
  return (0, import_dataverse2.prism)(() => {
    let stateRef = import_dataverse2.prism.ref("state", {
      started: false
    });
    let state = stateRef.current;
    const time = timeD.getValue();
    if (!state.started || time < state.validFrom || state.validTo <= time) {
      stateRef.current = state = updateState(ctx, timeD, track);
    }
    return state.der.getValue();
  });
}
var undefinedConstD = (0, import_dataverse2.prism)(() => void 0);
function updateState(ctx, progressionD, track) {
  const progression = progressionD.getValue();
  if (track.keyframes.length === 0) {
    return {
      started: true,
      validFrom: -Infinity,
      validTo: Infinity,
      der: undefinedConstD
    };
  }
  let currentKeyframeIndex = 0;
  while (true) {
    const currentKeyframe = track.keyframes[currentKeyframeIndex];
    if (!currentKeyframe) {
      if ("development" !== "production") {
        ctx.logger.error("Bug here");
      }
      return states.error;
    }
    const isLastKeyframe = currentKeyframeIndex === track.keyframes.length - 1;
    if (progression < currentKeyframe.position) {
      if (currentKeyframeIndex === 0) {
        return states.beforeFirstKeyframe(currentKeyframe);
      } else {
        if ("development" !== "production") {
          ctx.logger.error("Bug here");
        }
        return states.error;
      }
    } else if (currentKeyframe.position === progression) {
      if (isLastKeyframe) {
        return states.lastKeyframe(currentKeyframe);
      } else {
        return states.between(currentKeyframe, track.keyframes[currentKeyframeIndex + 1], progressionD);
      }
    } else {
      if (currentKeyframeIndex === track.keyframes.length - 1) {
        return states.lastKeyframe(currentKeyframe);
      } else {
        const nextKeyframeIndex = currentKeyframeIndex + 1;
        if (track.keyframes[nextKeyframeIndex].position <= progression) {
          currentKeyframeIndex = nextKeyframeIndex;
          continue;
        } else {
          return states.between(currentKeyframe, track.keyframes[currentKeyframeIndex + 1], progressionD);
        }
      }
    }
  }
}
var states = {
  beforeFirstKeyframe(kf) {
    return {
      started: true,
      validFrom: -Infinity,
      validTo: kf.position,
      der: (0, import_dataverse2.prism)(() => ({
        left: kf.value,
        progression: 0
      }))
    };
  },
  lastKeyframe(kf) {
    return {
      started: true,
      validFrom: kf.position,
      validTo: Infinity,
      der: (0, import_dataverse2.prism)(() => ({
        left: kf.value,
        progression: 0
      }))
    };
  },
  between(left, right, progressionD) {
    if (!left.connectedRight) {
      return {
        started: true,
        validFrom: left.position,
        validTo: right.position,
        der: (0, import_dataverse2.prism)(() => ({
          left: left.value,
          progression: 0
        }))
      };
    }
    const globalProgressionToLocalProgression = globalProgression => {
      return (globalProgression - left.position) / (right.position - left.position);
    };
    if (!left.type || left.type === "bezier") {
      const solver = new import_UnitBezier.default(left.handles[2], left.handles[3], right.handles[0], right.handles[1]);
      const bezierDer = (0, import_dataverse2.prism)(() => {
        const progression = globalProgressionToLocalProgression(progressionD.getValue());
        const valueProgression = solver.solveSimple(progression);
        return {
          left: left.value,
          right: right.value,
          progression: valueProgression
        };
      });
      return {
        started: true,
        validFrom: left.position,
        validTo: right.position,
        der: bezierDer
      };
    }
    const holdDer = (0, import_dataverse2.prism)(() => {
      const progression = globalProgressionToLocalProgression(progressionD.getValue());
      const valueProgression = Math.floor(progression);
      return {
        left: left.value,
        right: right.value,
        progression: valueProgression
      };
    });
    return {
      started: true,
      validFrom: left.position,
      validTo: right.position,
      der: holdDer
    };
  },
  error: {
    started: true,
    validFrom: -Infinity,
    validTo: Infinity,
    der: undefinedConstD
  }
};

// shared/src/utils/deepMergeWithCache.ts
function deepMergeWithCache(base, override, cache2) {
  const _cache = cache2;
  const possibleCachedValue = _cache.get(base);
  if (possibleCachedValue && possibleCachedValue.override === override) {
    return possibleCachedValue.merged;
  }
  const merged = __spreadValues({}, base);
  for (const key of Object.keys(override)) {
    const valueInOverride = override[key];
    const valueInBase = base[key];
    merged[key] = typeof valueInOverride === "object" && typeof valueInBase === "object" ? deepMergeWithCache(valueInBase, valueInOverride, cache2) : valueInOverride === void 0 ? valueInBase : valueInOverride;
  }
  cache2.set(base, {
    override,
    merged
  });
  return merged;
}

// shared/src/utils/pointerDeep.ts
function pointerDeep(base, toAppend) {
  let p2 = base;
  for (const k2 of toAppend) {
    p2 = p2[k2];
  }
  return p2;
}

// shared/src/utils/valToAtom.ts
var import_dataverse3 = require("@theatre/dataverse");
var valToAtom = (key, vals) => {
  const a2 = import_dataverse3.prism.memo(key, () => new import_dataverse3.Atom(vals), []);
  a2.set(vals);
  return a2;
};

// core/src/sheetObjects/SheetObject.ts
var import_dataverse5 = require("@theatre/dataverse");

// core/src/sheetObjects/TheatreSheetObject.ts
var import_dataverse4 = require("@theatre/dataverse");

// ../node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
  var index = string2.length;
  while (index-- && reWhitespace.test(string2.charAt(index))) {}
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// ../node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;

// ../node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// ../node_modules/lodash-es/toFinite.js
var INFINITY3 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY3 || value === -INFINITY3) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// ../node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result = toFinite_default(value),
    remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_default = toInteger;

// ../node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// ../node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// ../node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function () {
  function object() {}
  return function (proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// ../node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1,
    length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// ../node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee) {
  var index = -1,
    length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// ../node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
    length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// ../node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// ../node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// ../node_modules/lodash-es/_isPrototype.js
var objectProto7 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor,
    proto = typeof Ctor == "function" && Ctor.prototype || objectProto7;
  return value === proto;
}
var isPrototype_default = isPrototype;

// ../node_modules/lodash-es/_baseTimes.js
function baseTimes(n2, iteratee) {
  var index = -1,
    result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// ../node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// ../node_modules/lodash-es/isArguments.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
var propertyIsEnumerable = objectProto8.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function () {
  return arguments;
}()) ? baseIsArguments_default : function (value) {
  return isObjectLike_default(value) && hasOwnProperty6.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// ../node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// ../node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// ../node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// ../node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// ../node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function () {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {}
}();
var nodeUtil_default = nodeUtil;

// ../node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// ../node_modules/lodash-es/_arrayLikeKeys.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value),
    isArg = !isArr && isArguments_default(value),
    isBuff = !isArr && !isArg && isBuffer_default(value),
    isType = !isArr && !isArg && !isBuff && isTypedArray_default(value),
    skipIndexes = isArr || isArg || isBuff || isType,
    result = skipIndexes ? baseTimes_default(value.length, String) : [],
    length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty7.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == "length" ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") ||
    // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// ../node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// ../node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// ../node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty8.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// ../node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// ../node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// ../node_modules/lodash-es/_baseKeysIn.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object),
    result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty9.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// ../node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// ../node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values) {
  var index = -1,
    length = values.length,
    offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var arrayPush_default = arrayPush;

// ../node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// ../node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto12 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// ../node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index = -1,
    length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var baseSlice_default = baseSlice;

// ../node_modules/lodash-es/_castSlice.js
function castSlice(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice_default(array, start, end);
}
var castSlice_default = castSlice;

// ../node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string2) {
  return reHasUnicode.test(string2);
}
var hasUnicode_default = hasUnicode;

// ../node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string2) {
  return string2.split("");
}
var asciiToArray_default = asciiToArray;

// ../node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string2) {
  return string2.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// ../node_modules/lodash-es/_stringToArray.js
function stringToArray(string2) {
  return hasUnicode_default(string2) ? unicodeToArray_default(string2) : asciiToArray_default(string2);
}
var stringToArray_default = stringToArray;

// ../node_modules/lodash-es/_baseClamp.js
function baseClamp(number2, lower, upper) {
  if (number2 === number2) {
    if (upper !== void 0) {
      number2 = number2 <= upper ? number2 : upper;
    }
    if (lower !== void 0) {
      number2 = number2 >= lower ? number2 : lower;
    }
  }
  return number2;
}
var baseClamp_default = baseClamp;

// ../node_modules/lodash-es/clamp.js
function clamp(number2, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_default(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber_default(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp_default(toNumber_default(number2), lower, upper);
}
var clamp_default = clamp;

// ../node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// ../node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__,
    result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// ../node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// ../node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// ../node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// ../node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// ../node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// ../node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// ../node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
    result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// ../node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1,
    length = array == null ? 0 : array.length,
    resIndex = 0,
    result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// ../node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// ../node_modules/lodash-es/_getSymbols.js
var objectProto13 = Object.prototype;
var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function (object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// ../node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// ../node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function (object) {
  var result = [];
  while (object) {
    arrayPush_default(result, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result;
};
var getSymbolsIn_default = getSymbolsIn;

// ../node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// ../node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// ../node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// ../node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// ../node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// ../node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// ../node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// ../node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function (value) {
    var result = baseGetTag_default(value),
      Ctor = result == objectTag3 ? value.constructor : void 0,
      ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// ../node_modules/lodash-es/_initCloneArray.js
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length,
    result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty11.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var initCloneArray_default = initCloneArray;

// ../node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// ../node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// ../node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// ../node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var cloneRegExp_default = cloneRegExp;

// ../node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// ../node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// ../node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// ../node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// ../node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// ../node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// ../node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// ../node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// ../node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
    isDeep = bitmask & CLONE_DEEP_FLAG,
    isFlat = bitmask & CLONE_FLAT_FLAG,
    isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result);
    }
  } else {
    var tag = getTag_default(value),
      isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_default(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function (subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function (subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var baseClone_default = baseClone;

// ../node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG2 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
}
var cloneDeep_default = cloneDeep;

// ../node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// ../node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// ../node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index = -1,
    length = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// ../node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1,
    length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// ../node_modules/lodash-es/_cacheHas.js
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var cacheHas_default = cacheHas;

// ../node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
    arrLength = array.length,
    othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
    result = true,
    seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index],
      othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function (othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var equalArrays_default = equalArrays;

// ../node_modules/lodash-es/_mapToArray.js
function mapToArray(map) {
  var index = -1,
    result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// ../node_modules/lodash-es/_setToArray.js
function setToArray(set2) {
  var index = -1,
    result = Array(set2.size);
  set2.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// ../node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag3 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag3:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// ../node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto15 = Object.prototype;
var hasOwnProperty12 = objectProto15.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3,
    objProps = getAllKeys_default(object),
    objLength = objProps.length,
    othProps = getAllKeys_default(other),
    othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
      othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
      othCtor = other.constructor;
    if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var equalObjects_default = equalObjects;

// ../node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto16 = Object.prototype;
var hasOwnProperty13 = objectProto16.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object),
    othIsArr = isArray_default(other),
    objTag = objIsArr ? arrayTag3 : getTag_default(object),
    othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5,
    othIsObj = othTag == objectTag5,
    isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty13.call(object, "__wrapped__"),
      othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
        othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// ../node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// ../node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
    length = index,
    noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
      objValue = object[key],
      srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// ../node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// ../node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object),
    length = result.length;
  while (length--) {
    var key = result[length],
      value = object[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default = getMatchData;

// ../node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// ../node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function (object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// ../node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// ../node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1,
    length = path.length,
    result = false;
  while (++index < length) {
    var key = toKey_default(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// ../node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// ../node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function (object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// ../node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function (object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// ../node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function (object) {
    return baseGet_default(object, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// ../node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property;

// ../node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// ../node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
      iterable = Object(object),
      props = keysFunc(object),
      length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// ../node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// ../node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn;

// ../node_modules/lodash-es/now.js
var now = function () {
  return root_default.Date.now();
};
var now_default = now;

// ../node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var nativeMax = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime,
    lastInvokeTime = 0,
    leading = false,
    maxing = false,
    trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs,
      thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime,
      timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
      timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(),
      isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// ../node_modules/lodash-es/last.js
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_default = last;

// ../node_modules/lodash-es/_parent.js
function parent(object, path) {
  return path.length < 2 ? object : baseGet_default(object, baseSlice_default(path, 0, -1));
}
var parent_default = parent;

// ../node_modules/lodash-es/isInteger.js
function isInteger(value) {
  return typeof value == "number" && value == toInteger_default(value);
}
var isInteger_default = isInteger;

// ../node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee_default(iteratee, 3);
  baseForOwn_default(object, function (value, key, object2) {
    baseAssignValue_default(result, key, iteratee(value, key, object2));
  });
  return result;
}
var mapValues_default = mapValues;

// ../node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  return object == null || delete object[toKey_default(last_default(path))];
}
var baseUnset_default = baseUnset;

// ../node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string2, n2) {
  var result = "";
  if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER3) {
    return result;
  }
  do {
    if (n2 % 2) {
      result += string2;
    }
    n2 = nativeFloor(n2 / 2);
    if (n2) {
      string2 += string2;
    }
  } while (n2);
  return result;
}
var baseRepeat_default = baseRepeat;

// ../node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// ../node_modules/lodash-es/_unicodeSize.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange3 + "]";
var rsCombo2 = "[" + rsComboRange3 + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo2 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ3 = "\\u200d";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsSymbol2 = "(?:" + [rsNonAstral2 + rsCombo2 + "?", rsCombo2, rsRegional2, rsSurrPair2, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz2 + "(?=" + rsFitz2 + ")|" + rsSymbol2 + rsSeq2, "g");
function unicodeSize(string2) {
  var result = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string2)) {
    ++result;
  }
  return result;
}
var unicodeSize_default = unicodeSize;

// ../node_modules/lodash-es/_stringSize.js
function stringSize(string2) {
  return hasUnicode_default(string2) ? unicodeSize_default(string2) : asciiSize_default(string2);
}
var stringSize_default = stringSize;

// ../node_modules/lodash-es/_createPadding.js
var nativeCeil = Math.ceil;
function createPadding(length, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length) : chars;
  }
  var result = baseRepeat_default(chars, nativeCeil(length / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result), 0, length).join("") : result.slice(0, length);
}
var createPadding_default = createPadding;

// ../node_modules/lodash-es/padStart.js
function padStart(string2, length, chars) {
  string2 = toString_default(string2);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string2) : 0;
  return length && strLength < length ? createPadding_default(length - strLength, chars) + string2 : string2;
}
var padStart_default = padStart;

// ../node_modules/lodash-es/unset.js
function unset(object, path) {
  return object == null ? true : baseUnset_default(object, path);
}
var unset_default = unset;

// core/src/sheetObjects/TheatreSheetObject.ts
var KEEP_HOT_FOR_MS = 5 * 1e3;
var TheatreSheetObject = class {
  /**
   * @internal
   */
  constructor(internals) {
    __publicField(this, "_cache", new SimpleCache());
    /** @internal See https://linear.app/theatre/issue/P-217/if-objvalue-is-read-make-sure-its-derivation-remains-hot-for-a-while */
    __publicField(this, "_keepHotUntapDebounce");
    setPrivateAPI(this, internals);
  }
  get type() {
    return "Theatre_SheetObject_PublicAPI";
  }
  get props() {
    return privateAPI(this).propsP;
  }
  get sheet() {
    return privateAPI(this).sheet.publicApi;
  }
  get project() {
    return privateAPI(this).sheet.project.publicApi;
  }
  get address() {
    return __spreadValues({}, privateAPI(this).address);
  }
  _valuesPrism() {
    return this._cache.get("_valuesPrism", () => {
      const sheetObject = privateAPI(this);
      const d2 = (0, import_dataverse4.prism)(() => {
        return (0, import_dataverse4.val)(sheetObject.getValues().getValue());
      });
      return d2;
    });
  }
  onValuesChange(fn2, rafDriver) {
    return onChange(this._valuesPrism(), fn2, rafDriver);
  }
  // internal: Make the deviration keepHot if directly read
  get value() {
    const der = this._valuesPrism();
    if (KEEP_HOT_FOR_MS != null) {
      if (!der.isHot) {
        if (this._keepHotUntapDebounce != null) {
          if ("development" === "development") {
            privateAPI(this)._logger.errorDev("`sheet.value` keepHot debouncer is set, even though the derivation is not actually hot.");
          }
          this._keepHotUntapDebounce.flush();
        }
        const untap = der.keepHot();
        this._keepHotUntapDebounce = debounce_default(() => {
          untap();
          this._keepHotUntapDebounce = void 0;
        }, KEEP_HOT_FOR_MS);
      }
      if (this._keepHotUntapDebounce) {
        this._keepHotUntapDebounce();
      }
    }
    return der.getValue();
  }
  set initialValue(val8) {
    privateAPI(this).setInitialValue(val8);
  }
};

// shared/src/utils/memoizeFn.ts
function memoizeFn(producer) {
  const cache2 = /* @__PURE__ */new WeakMap();
  return k2 => {
    if (!cache2.has(k2)) {
      cache2.set(k2, producer(k2));
    }
    return cache2.get(k2);
  };
}

// shared/src/propTypes/utils.ts
function isPropConfigComposite(c2) {
  return c2.type === "compound" || c2.type === "enum";
}
function getPropConfigByPath(parentConf, path) {
  if (!parentConf) return void 0;
  const [key, ...rest] = path;
  if (key === void 0) return parentConf;
  if (!isPropConfigComposite(parentConf)) return void 0;
  const sub = parentConf.type === "enum" ? parentConf.cases[key] : parentConf.props[key];
  return getPropConfigByPath(sub, rest);
}
function isPropConfSequencable(conf) {
  return !isPropConfigComposite(conf);
}
var compoundHasSimpleDescendants = memoizeFn(conf => {
  if (conf.type === "enum") {
    throw new Error("Not implemented yet for enums");
  }
  for (const key in conf.props) {
    const subConf = conf.props[key];
    if (isPropConfigComposite(subConf)) {
      if (compoundHasSimpleDescendants(subConf)) {
        return true;
      }
    } else {
      return true;
    }
  }
  return false;
});

// core/src/sheetObjects/SheetObject.ts
var SheetObject = class {
  constructor(sheet, template, nativeObject) {
    this.sheet = sheet;
    this.template = template;
    this.nativeObject = nativeObject;
    __publicField(this, "$$isPointerToPrismProvider", true);
    __publicField(this, "address");
    __publicField(this, "publicApi");
    __publicField(this, "_initialValue", new import_dataverse5.Atom({}));
    __publicField(this, "_cache", new SimpleCache());
    __publicField(this, "_logger");
    __publicField(this, "_internalUtilCtx");
    this._logger = sheet._logger.named("SheetObject", template.address.objectKey);
    this._logger._trace("creating object");
    this._internalUtilCtx = {
      logger: this._logger.utilFor.internal()
    };
    this.address = __spreadProps(__spreadValues({}, template.address), {
      sheetInstanceId: sheet.address.sheetInstanceId
    });
    this.publicApi = new TheatreSheetObject(this);
  }
  get type() {
    return "Theatre_SheetObject";
  }
  getValues() {
    return this._cache.get("getValues()", () => (0, import_dataverse5.prism)(() => {
      const defaults = (0, import_dataverse5.val)(this.template.getDefaultValues());
      const initial = (0, import_dataverse5.val)(this._initialValue.pointer);
      const withInitialCache = import_dataverse5.prism.memo("withInitialCache", () => /* @__PURE__ */new WeakMap(), []);
      const withInitial = deepMergeWithCache(defaults, initial, withInitialCache);
      const statics = (0, import_dataverse5.val)(this.template.getStaticValues());
      const withStaticsCache = import_dataverse5.prism.memo("withStatics", () => /* @__PURE__ */new WeakMap(), []);
      const withStatics = deepMergeWithCache(withInitial, statics, withStaticsCache);
      let final = withStatics;
      let sequenced;
      {
        const pointerToSequencedValuesD = import_dataverse5.prism.memo("seq", () => this.getSequencedValues(), []);
        const withSeqsCache = import_dataverse5.prism.memo("withSeqsCache", () => /* @__PURE__ */new WeakMap(), []);
        sequenced = (0, import_dataverse5.val)((0, import_dataverse5.val)(pointerToSequencedValuesD));
        const withSeqs = deepMergeWithCache(final, sequenced, withSeqsCache);
        final = withSeqs;
      }
      const a2 = valToAtom("finalAtom", final);
      return a2.pointer;
    }));
  }
  getValueByPointer(pointer3) {
    const allValuesP = (0, import_dataverse5.val)(this.getValues());
    const {
      path
    } = (0, import_dataverse5.getPointerParts)(pointer3);
    return (0, import_dataverse5.val)(pointerDeep(allValuesP, path));
  }
  pointerToPrism(pointer3) {
    const {
      path
    } = (0, import_dataverse5.getPointerParts)(pointer3);
    return (0, import_dataverse5.prism)(() => {
      const allValuesP = (0, import_dataverse5.val)(this.getValues());
      return (0, import_dataverse5.val)(pointerDeep(allValuesP, path));
    });
  }
  /**
   * Returns values of props that are sequenced.
   */
  getSequencedValues() {
    return (0, import_dataverse5.prism)(() => {
      const tracksToProcessD = import_dataverse5.prism.memo("tracksToProcess", () => this.template.getArrayOfValidSequenceTracks(), []);
      const tracksToProcess = (0, import_dataverse5.val)(tracksToProcessD);
      const valsAtom = new import_dataverse5.Atom({});
      const config = (0, import_dataverse5.val)(this.template.configPointer);
      import_dataverse5.prism.effect("processTracks", () => {
        const untaps = [];
        for (const {
          trackId,
          pathToProp
        } of tracksToProcess) {
          const pr = this._trackIdToPrism(trackId);
          const propConfig = getPropConfigByPath(config, pathToProp);
          const deserializeAndSanitize = propConfig.deserializeAndSanitize;
          const interpolate = propConfig.interpolate;
          const updateSequenceValueFromItsPrism = () => {
            const triple = pr.getValue();
            if (!triple) return valsAtom.setByPointer(p2 => pointerDeep(p2, pathToProp), void 0);
            const leftDeserialized = deserializeAndSanitize(triple.left);
            const left = leftDeserialized === void 0 ? propConfig.default : leftDeserialized;
            if (triple.right === void 0) return valsAtom.setByPointer(p2 => pointerDeep(p2, pathToProp), left);
            const rightDeserialized = deserializeAndSanitize(triple.right);
            const right = rightDeserialized === void 0 ? propConfig.default : rightDeserialized;
            return valsAtom.setByPointer(p2 => pointerDeep(p2, pathToProp), interpolate(left, right, triple.progression));
          };
          const untap = pr.onStale(updateSequenceValueFromItsPrism);
          updateSequenceValueFromItsPrism();
          untaps.push(untap);
        }
        return () => {
          for (const untap of untaps) {
            untap();
          }
        };
      }, [config, ...tracksToProcess]);
      return valsAtom.pointer;
    });
  }
  _trackIdToPrism(trackId) {
    const trackP = this.template.project.pointers.historic.sheetsById[this.address.sheetId].sequence.tracksByObject[this.address.objectKey].trackData[trackId];
    const timeD = this.sheet.getSequence().positionPrism;
    return interpolationTripleAtPosition(this._internalUtilCtx, trackP, timeD);
  }
  get propsP() {
    return this._cache.get("propsP", () => (0, import_dataverse5.pointer)({
      root: this,
      path: []
    }));
  }
  validateValue(pointer3, value) {}
  setInitialValue(val8) {
    this.validateValue(this.propsP, val8);
    this._initialValue.set(val8);
  }
};

// shared/src/_logger/logger.ts
function lazy(f2) {
  return function lazyLogIncluded(m, lazyArg) {
    return f2(m, lazyArg());
  };
}
var LEVELS = {
  _hmm: getLogMeta(524 /* _HMM */),
  _todo: getLogMeta(522 /* _TODO */),
  _error: getLogMeta(521 /* _ERROR */),
  errorDev: getLogMeta(529 /* ERROR_DEV */),
  errorPublic: getLogMeta(545 /* ERROR_PUBLIC */),
  _kapow: getLogMeta(268 /* _KAPOW */),
  _warn: getLogMeta(265 /* _WARN */),
  warnDev: getLogMeta(273 /* WARN_DEV */),
  warnPublic: getLogMeta(289 /* WARN_PUBLIC */),
  _debug: getLogMeta(137 /* _DEBUG */),
  debugDev: getLogMeta(145 /* DEBUG_DEV */),
  _trace: getLogMeta(73 /* _TRACE */),
  traceDev: getLogMeta(81 /* TRACE_DEV */)
};
function getLogMeta(level) {
  return Object.freeze({
    audience: hasFlag(level, 8 /* INTERNAL */) ? "internal" : hasFlag(level, 16 /* DEV */) ? "dev" : "public",
    category: hasFlag(level, 4 /* TROUBLESHOOTING */) ? "troubleshooting" : hasFlag(level, 2 /* TODO */) ? "todo" : "general",
    level:
    // I think this is equivalent... but I'm not using it until we have tests.
    // this code won't really impact performance much anyway, since it's just computed once
    // up front.
    // level &
    // (TheatreLoggerLevel.TRACE |
    //   TheatreLoggerLevel.DEBUG |
    //   TheatreLoggerLevel.WARN |
    //   TheatreLoggerLevel.ERROR),
    hasFlag(level, 512 /* ERROR */) ? 512 /* ERROR */ : hasFlag(level, 256 /* WARN */) ? 256 /* WARN */ : hasFlag(level, 128 /* DEBUG */) ? 128 /* DEBUG */ :
    // no other option
    64 /* TRACE */
  });
}
function hasFlag(level, flag) {
  return (level & flag) === flag;
}
function shouldLog(includes, level) {
  return ((level & 32 /* PUBLIC */) === 32 /* PUBLIC */ ? true : (level & 16 /* DEV */) === 16 /* DEV */ ? includes.dev : (level & 8 /* INTERNAL */) === 8 /* INTERNAL */ ? includes.internal : false) && includes.min <= level;
}
var DEFAULTS = {
  loggingConsoleStyle: true,
  loggerConsoleStyle: true,
  includes: Object.freeze({
    internal: false,
    dev: false,
    min: 256 /* WARN */
  }),
  filtered: function defaultFiltered() {},
  include: function defaultInclude() {
    return {};
  },
  create: null,
  creatExt: null,
  named(parent2, name, key) {
    return this.create({
      names: [...parent2.names, {
        name,
        key
      }]
    });
  },
  style: {
    bold: void 0,
    // /Service$/
    italic: void 0,
    // /Model$/
    cssMemo: /* @__PURE__ */new Map([
    // handle empty names so we don't have to check for
    // name.length > 0 during this.css('')
    ["", ""]
    // bring a specific override
    // ["Marker", "color:#aea9ff;font-size:0.75em;text-transform:uppercase"]
    ]),
    collapseOnRE: /[a-z- ]+/g,
    color: void 0,
    // create collapsed name
    // insert collapsed name into cssMemo with original's style
    collapsed(name) {
      if (name.length < 5) return name;
      const collapsed = name.replace(this.collapseOnRE, "");
      if (!this.cssMemo.has(collapsed)) {
        this.cssMemo.set(collapsed, this.css(name));
      }
      return collapsed;
    },
    css(name) {
      var _a, _b, _c, _d;
      const found = this.cssMemo.get(name);
      if (found) return found;
      let css = "color:".concat((_b = (_a = this.color) == null ? void 0 : _a.call(this, name)) != null ? _b : "hsl(".concat((name.charCodeAt(0) + name.charCodeAt(name.length - 1)) % 360, ", 100%, 60%)"));
      if ((_c = this.bold) == null ? void 0 : _c.test(name)) {
        css += ";font-weight:600";
      }
      if ((_d = this.italic) == null ? void 0 : _d.test(name)) {
        css += ";font-style:italic";
      }
      this.cssMemo.set(name, css);
      return css;
    }
  }
};
function createTheatreInternalLogger(useConsole = console, _options = {}) {
  const ref = __spreadProps(__spreadValues({}, DEFAULTS), {
    includes: __spreadValues({}, DEFAULTS.includes)
  });
  const createConsole = {
    styled: createConsoleLoggerStyled.bind(ref, useConsole),
    noStyle: createConsoleLoggerNoStyle.bind(ref, useConsole)
  };
  const createExtBound = createExtLogger.bind(ref);
  function getConCreate() {
    return ref.loggingConsoleStyle && ref.loggerConsoleStyle ? createConsole.styled : createConsole.noStyle;
  }
  ref.create = getConCreate();
  return {
    configureLogger(config) {
      var _a;
      if (config === "console") {
        ref.loggerConsoleStyle = DEFAULTS.loggerConsoleStyle;
        ref.create = getConCreate();
      } else if (config.type === "console") {
        ref.loggerConsoleStyle = (_a = config.style) != null ? _a : DEFAULTS.loggerConsoleStyle;
        ref.create = getConCreate();
      } else if (config.type === "keyed") {
        ref.creatExt = source => config.keyed(source.names);
        ref.create = createExtBound;
      } else if (config.type === "named") {
        ref.creatExt = configNamedToKeyed.bind(null, config.named);
        ref.create = createExtBound;
      }
    },
    configureLogging(config) {
      var _a, _b, _c, _d, _e;
      ref.includes.dev = (_a = config.dev) != null ? _a : DEFAULTS.includes.dev;
      ref.includes.internal = (_b = config.internal) != null ? _b : DEFAULTS.includes.internal;
      ref.includes.min = (_c = config.min) != null ? _c : DEFAULTS.includes.min;
      ref.include = (_d = config.include) != null ? _d : DEFAULTS.include;
      ref.loggingConsoleStyle = (_e = config.consoleStyle) != null ? _e : DEFAULTS.loggingConsoleStyle;
      ref.create = getConCreate();
    },
    getLogger() {
      return ref.create({
        names: []
      });
    }
  };
}
function configNamedToKeyed(namedFn, source) {
  const names = [];
  for (let {
    name,
    key
  } of source.names) {
    names.push(key == null ? name : "".concat(name, " (").concat(key, ")"));
  }
  return namedFn(names);
}
function createExtLogger(source) {
  const includes = __spreadValues(__spreadValues({}, this.includes), this.include(source));
  const f2 = this.filtered;
  const named = this.named.bind(this, source);
  const ext = this.creatExt(source);
  const _HMM = shouldLog(includes, 524 /* _HMM */);
  const _TODO = shouldLog(includes, 522 /* _TODO */);
  const _ERROR = shouldLog(includes, 521 /* _ERROR */);
  const ERROR_DEV = shouldLog(includes, 529 /* ERROR_DEV */);
  const ERROR_PUBLIC = shouldLog(includes, 545 /* ERROR_PUBLIC */);
  const _WARN = shouldLog(includes, 265 /* _WARN */);
  const _KAPOW = shouldLog(includes, 268 /* _KAPOW */);
  const WARN_DEV = shouldLog(includes, 273 /* WARN_DEV */);
  const WARN_PUBLIC = shouldLog(includes, 289 /* WARN_PUBLIC */);
  const _DEBUG = shouldLog(includes, 137 /* _DEBUG */);
  const DEBUG_DEV = shouldLog(includes, 145 /* DEBUG_DEV */);
  const _TRACE = shouldLog(includes, 73 /* _TRACE */);
  const TRACE_DEV = shouldLog(includes, 81 /* TRACE_DEV */);
  const _hmm = _HMM ? ext.error.bind(ext, LEVELS._hmm) : f2.bind(source, 524 /* _HMM */);
  const _todo = _TODO ? ext.error.bind(ext, LEVELS._todo) : f2.bind(source, 522 /* _TODO */);
  const _error = _ERROR ? ext.error.bind(ext, LEVELS._error) : f2.bind(source, 521 /* _ERROR */);
  const errorDev = ERROR_DEV ? ext.error.bind(ext, LEVELS.errorDev) : f2.bind(source, 529 /* ERROR_DEV */);
  const errorPublic = ERROR_PUBLIC ? ext.error.bind(ext, LEVELS.errorPublic) : f2.bind(source, 545 /* ERROR_PUBLIC */);
  const _kapow = _KAPOW ? ext.warn.bind(ext, LEVELS._kapow) : f2.bind(source, 268 /* _KAPOW */);
  const _warn = _WARN ? ext.warn.bind(ext, LEVELS._warn) : f2.bind(source, 265 /* _WARN */);
  const warnDev = WARN_DEV ? ext.warn.bind(ext, LEVELS.warnDev) : f2.bind(source, 273 /* WARN_DEV */);
  const warnPublic = WARN_PUBLIC ? ext.warn.bind(ext, LEVELS.warnPublic) : f2.bind(source, 273 /* WARN_DEV */);
  const _debug = _DEBUG ? ext.debug.bind(ext, LEVELS._debug) : f2.bind(source, 137 /* _DEBUG */);
  const debugDev = DEBUG_DEV ? ext.debug.bind(ext, LEVELS.debugDev) : f2.bind(source, 145 /* DEBUG_DEV */);
  const _trace = _TRACE ? ext.trace.bind(ext, LEVELS._trace) : f2.bind(source, 73 /* _TRACE */);
  const traceDev = TRACE_DEV ? ext.trace.bind(ext, LEVELS.traceDev) : f2.bind(source, 81 /* TRACE_DEV */);
  const logger = {
    _hmm,
    _todo,
    _error,
    errorDev,
    errorPublic,
    _kapow,
    _warn,
    warnDev,
    warnPublic,
    _debug,
    debugDev,
    _trace,
    traceDev,
    lazy: {
      _hmm: _HMM ? lazy(_hmm) : _hmm,
      _todo: _TODO ? lazy(_todo) : _todo,
      _error: _ERROR ? lazy(_error) : _error,
      errorDev: ERROR_DEV ? lazy(errorDev) : errorDev,
      errorPublic: ERROR_PUBLIC ? lazy(errorPublic) : errorPublic,
      _kapow: _KAPOW ? lazy(_kapow) : _kapow,
      _warn: _WARN ? lazy(_warn) : _warn,
      warnDev: WARN_DEV ? lazy(warnDev) : warnDev,
      warnPublic: WARN_PUBLIC ? lazy(warnPublic) : warnPublic,
      _debug: _DEBUG ? lazy(_debug) : _debug,
      debugDev: DEBUG_DEV ? lazy(debugDev) : debugDev,
      _trace: _TRACE ? lazy(_trace) : _trace,
      traceDev: TRACE_DEV ? lazy(traceDev) : traceDev
    },
    //
    named,
    utilFor: {
      internal() {
        return {
          debug: logger._debug,
          error: logger._error,
          warn: logger._warn,
          trace: logger._trace,
          named(name, key) {
            return logger.named(name, key).utilFor.internal();
          }
        };
      },
      dev() {
        return {
          debug: logger.debugDev,
          error: logger.errorDev,
          warn: logger.warnDev,
          trace: logger.traceDev,
          named(name, key) {
            return logger.named(name, key).utilFor.dev();
          }
        };
      },
      public() {
        return {
          error: logger.errorPublic,
          warn: logger.warnPublic,
          debug(message, obj) {
            logger._warn('(public "debug" filtered out) '.concat(message), obj);
          },
          trace(message, obj) {
            logger._warn('(public "trace" filtered out) '.concat(message), obj);
          },
          named(name, key) {
            return logger.named(name, key).utilFor.public();
          }
        };
      }
    }
  };
  return logger;
}
function createConsoleLoggerStyled(con, source) {
  const includes = __spreadValues(__spreadValues({}, this.includes), this.include(source));
  const styleArgs = [];
  let prefix = "";
  for (let i2 = 0; i2 < source.names.length; i2++) {
    const {
      name,
      key
    } = source.names[i2];
    prefix += " %c".concat(name);
    styleArgs.push(this.style.css(name));
    if (key != null) {
      const keyStr = "%c#".concat(key);
      prefix += keyStr;
      styleArgs.push(this.style.css(keyStr));
    }
  }
  const f2 = this.filtered;
  const named = this.named.bind(this, source);
  const prefixArr = [prefix, ...styleArgs];
  return _createConsoleLogger(f2, source, includes, con, prefixArr, styledKapowPrefix(prefixArr), named);
}
function styledKapowPrefix(args) {
  const start = args.slice(0);
  for (let i2 = 1; i2 < start.length; i2++) start[i2] += ";background-color:#e0005a;padding:2px;color:white";
  return start;
}
function createConsoleLoggerNoStyle(con, source) {
  const includes = __spreadValues(__spreadValues({}, this.includes), this.include(source));
  let prefix = "";
  for (let i2 = 0; i2 < source.names.length; i2++) {
    const {
      name,
      key
    } = source.names[i2];
    prefix += " ".concat(name);
    if (key != null) {
      prefix += "#".concat(key);
    }
  }
  const f2 = this.filtered;
  const named = this.named.bind(this, source);
  const prefixArr = [prefix];
  return _createConsoleLogger(f2, source, includes, con, prefixArr, prefixArr, named);
}
function _createConsoleLogger(f2, source, includes, con, prefix, kapowPrefix, named) {
  const _HMM = shouldLog(includes, 524 /* _HMM */);
  const _TODO = shouldLog(includes, 522 /* _TODO */);
  const _ERROR = shouldLog(includes, 521 /* _ERROR */);
  const ERROR_DEV = shouldLog(includes, 529 /* ERROR_DEV */);
  const ERROR_PUBLIC = shouldLog(includes, 545 /* ERROR_PUBLIC */);
  const _WARN = shouldLog(includes, 265 /* _WARN */);
  const _KAPOW = shouldLog(includes, 268 /* _KAPOW */);
  const WARN_DEV = shouldLog(includes, 273 /* WARN_DEV */);
  const WARN_PUBLIC = shouldLog(includes, 289 /* WARN_PUBLIC */);
  const _DEBUG = shouldLog(includes, 137 /* _DEBUG */);
  const DEBUG_DEV = shouldLog(includes, 145 /* DEBUG_DEV */);
  const _TRACE = shouldLog(includes, 73 /* _TRACE */);
  const TRACE_DEV = shouldLog(includes, 81 /* TRACE_DEV */);
  const _hmm = _HMM ? con.error.bind(con, ...prefix) : f2.bind(source, 524 /* _HMM */);
  const _todo = _TODO ? con.error.bind(con, ...prefix) : f2.bind(source, 522 /* _TODO */);
  const _error = _ERROR ? con.error.bind(con, ...prefix) : f2.bind(source, 521 /* _ERROR */);
  const errorDev = ERROR_DEV ? con.error.bind(con, ...prefix) : f2.bind(source, 529 /* ERROR_DEV */);
  const errorPublic = ERROR_PUBLIC ? con.error.bind(con, ...prefix) : f2.bind(source, 545 /* ERROR_PUBLIC */);
  const _kapow = _KAPOW ? con.warn.bind(con, ...kapowPrefix) : f2.bind(source, 268 /* _KAPOW */);
  const _warn = _WARN ? con.warn.bind(con, ...prefix) : f2.bind(source, 265 /* _WARN */);
  const warnDev = WARN_DEV ? con.warn.bind(con, ...prefix) : f2.bind(source, 273 /* WARN_DEV */);
  const warnPublic = WARN_PUBLIC ? con.warn.bind(con, ...prefix) : f2.bind(source, 273 /* WARN_DEV */);
  const _debug = _DEBUG ? con.info.bind(con, ...prefix) : f2.bind(source, 137 /* _DEBUG */);
  const debugDev = DEBUG_DEV ? con.info.bind(con, ...prefix) : f2.bind(source, 145 /* DEBUG_DEV */);
  const _trace = _TRACE ? con.debug.bind(con, ...prefix) : f2.bind(source, 73 /* _TRACE */);
  const traceDev = TRACE_DEV ? con.debug.bind(con, ...prefix) : f2.bind(source, 81 /* TRACE_DEV */);
  const logger = {
    _hmm,
    _todo,
    _error,
    errorDev,
    errorPublic,
    _kapow,
    _warn,
    warnDev,
    warnPublic,
    _debug,
    debugDev,
    _trace,
    traceDev,
    lazy: {
      _hmm: _HMM ? lazy(_hmm) : _hmm,
      _todo: _TODO ? lazy(_todo) : _todo,
      _error: _ERROR ? lazy(_error) : _error,
      errorDev: ERROR_DEV ? lazy(errorDev) : errorDev,
      errorPublic: ERROR_PUBLIC ? lazy(errorPublic) : errorPublic,
      _kapow: _KAPOW ? lazy(_kapow) : _kapow,
      _warn: _WARN ? lazy(_warn) : _warn,
      warnDev: WARN_DEV ? lazy(warnDev) : warnDev,
      warnPublic: WARN_PUBLIC ? lazy(warnPublic) : warnPublic,
      _debug: _DEBUG ? lazy(_debug) : _debug,
      debugDev: DEBUG_DEV ? lazy(debugDev) : debugDev,
      _trace: _TRACE ? lazy(_trace) : _trace,
      traceDev: TRACE_DEV ? lazy(traceDev) : traceDev
    },
    //
    named,
    utilFor: {
      internal() {
        return {
          debug: logger._debug,
          error: logger._error,
          warn: logger._warn,
          trace: logger._trace,
          named(name, key) {
            return logger.named(name, key).utilFor.internal();
          }
        };
      },
      dev() {
        return {
          debug: logger.debugDev,
          error: logger.errorDev,
          warn: logger.warnDev,
          trace: logger.traceDev,
          named(name, key) {
            return logger.named(name, key).utilFor.dev();
          }
        };
      },
      public() {
        return {
          error: logger.errorPublic,
          warn: logger.warnPublic,
          debug(message, obj) {
            logger._warn('(public "debug" filtered out) '.concat(message), obj);
          },
          trace(message, obj) {
            logger._warn('(public "trace" filtered out) '.concat(message), obj);
          },
          named(name, key) {
            return logger.named(name, key).utilFor.public();
          }
        };
      }
    }
  };
  return logger;
}

// shared/src/logger.ts
var internal = createTheatreInternalLogger(console, {
  _debug: function () {},
  _error: function () {}
});
internal.configureLogging({
  dev: true,
  min: 64 /* TRACE */
});
var logger_default = internal.getLogger().named("Theatre.js (default logger)").utilFor.dev();

// core/src/sheetObjects/getOrderingOfPropTypeConfig.ts
var cache = /* @__PURE__ */new WeakMap();
function getOrderingOfPropTypeConfig(config) {
  const existing = cache.get(config);
  if (existing) return existing;
  const map = /* @__PURE__ */new Map();
  cache.set(config, map);
  iterateOnCompound([], config, map);
  return map;
}
function iterateOnCompound(path, config, map) {
  for (const [key, subConf] of Object.entries(config.props)) {
    if (!isPropConfigComposite(subConf)) {
      const subPath = [...path, key];
      map.set(JSON.stringify(subPath), map.size);
      iterateOnAny(subPath, subConf, map);
    }
  }
  for (const [key, subConf] of Object.entries(config.props)) {
    if (isPropConfigComposite(subConf)) {
      const subPath = [...path, key];
      map.set(JSON.stringify(subPath), map.size);
      iterateOnAny(subPath, subConf, map);
    }
  }
}
function iterateOnAny(path, config, map) {
  if (config.type === "compound") {
    iterateOnCompound(path, config, map);
  } else if (config.type === "enum") {
    throw new Error("Enums aren't supported yet");
  } else {
    map.set(JSON.stringify(path), map.size);
  }
}

// core/src/sheetObjects/SheetObjectTemplate.ts
function isObjectEmpty(obj) {
  return typeof obj === "object" && obj !== null && Object.keys(obj).length === 0;
}
var SheetObjectTemplate = class {
  constructor(sheetTemplate, objectKey, nativeObject, config, _temp_actions) {
    this.sheetTemplate = sheetTemplate;
    __publicField(this, "address");
    __publicField(this, "type", "Theatre_SheetObjectTemplate");
    __publicField(this, "_config");
    __publicField(this, "_temp_actions_atom");
    __publicField(this, "_cache", new SimpleCache());
    __publicField(this, "project");
    __publicField(this, "pointerToSheetState");
    __publicField(this, "pointerToStaticOverrides");
    this.address = __spreadProps(__spreadValues({}, sheetTemplate.address), {
      objectKey
    });
    this._config = new import_dataverse6.Atom(config);
    this._temp_actions_atom = new import_dataverse6.Atom(_temp_actions);
    this.project = sheetTemplate.project;
    this.pointerToSheetState = this.sheetTemplate.project.pointers.historic.sheetsById[this.address.sheetId];
    this.pointerToStaticOverrides = this.pointerToSheetState.staticOverrides.byObject[this.address.objectKey];
  }
  get staticConfig() {
    return this._config.get();
  }
  get configPointer() {
    return this._config.pointer;
  }
  get _temp_actions() {
    return this._temp_actions_atom.get();
  }
  get _temp_actionsPointer() {
    return this._temp_actions_atom.pointer;
  }
  createInstance(sheet, nativeObject, config) {
    this._config.set(config);
    return new SheetObject(sheet, this, nativeObject);
  }
  reconfigure(config) {
    this._config.set(config);
  }
  /**
   * The `actions` api is temporary until we implement events.
   */
  _temp_setActions(actions) {
    this._temp_actions_atom.set(actions);
  }
  /**
   * Returns the default values (all defaults are read from the config)
   */
  getDefaultValues() {
    return this._cache.get("getDefaultValues()", () => (0, import_dataverse6.prism)(() => {
      const config = (0, import_dataverse6.val)(this.configPointer);
      return getPropDefaultsOfSheetObject(config);
    }));
  }
  /**
   * Returns values that are set statically (ie, not sequenced, and not defaults)
   */
  getStaticValues() {
    return this._cache.get("getStaticValues", () => (0, import_dataverse6.prism)(() => {
      var _a;
      const json = (_a = (0, import_dataverse6.val)(this.pointerToStaticOverrides)) != null ? _a : {};
      const config = (0, import_dataverse6.val)(this.configPointer);
      const deserialized = config.deserializeAndSanitize(json) || {};
      return deserialized;
    }));
  }
  /**
   * Filters through the sequenced tracks and returns those tracks who are valid
   * according to the object's prop types, then sorted in the same order as the config
   *
   * Returns an array.
   */
  getArrayOfValidSequenceTracks() {
    return this._cache.get("getArrayOfValidSequenceTracks", () => (0, import_dataverse6.prism)(() => {
      const pointerToSheetState = this.project.pointers.historic.sheetsById[this.address.sheetId];
      const trackIdByPropPath = (0, import_dataverse6.val)(pointerToSheetState.sequence.tracksByObject[this.address.objectKey].trackIdByPropPath);
      if (!trackIdByPropPath) return emptyArray;
      const arrayOfIds = [];
      if (!trackIdByPropPath) return emptyArray;
      const objectConfig = (0, import_dataverse6.val)(this.configPointer);
      const _entries = Object.entries(trackIdByPropPath);
      for (const [pathToPropInString, trackId] of _entries) {
        const pathToProp = parsePathToProp(pathToPropInString);
        if (!pathToProp) continue;
        const propConfig = getPropConfigByPath(objectConfig, pathToProp);
        const isSequencable = propConfig && isPropConfSequencable(propConfig);
        if (!isSequencable) continue;
        arrayOfIds.push({
          pathToProp,
          trackId
        });
      }
      const mapping = getOrderingOfPropTypeConfig(objectConfig);
      arrayOfIds.sort((a2, b2) => {
        const pathToPropA = a2.pathToProp;
        const pathToPropB = b2.pathToProp;
        const indexA = mapping.get(JSON.stringify(pathToPropA));
        const indexB = mapping.get(JSON.stringify(pathToPropB));
        if (indexA > indexB) {
          return 1;
        }
        return -1;
      });
      if (arrayOfIds.length === 0) {
        return emptyArray;
      } else {
        return arrayOfIds;
      }
    }));
  }
  /**
   * Filters through the sequenced tracks those tracks that are valid
   * according to the object's prop types.
   *
   * Returns a map.
   *
   * Not available in core.
   */
  getMapOfValidSequenceTracks_forStudio() {
    return this._cache.get("getMapOfValidSequenceTracks_forStudio", () => (0, import_dataverse6.prism)(() => {
      const arr = (0, import_dataverse6.val)(this.getArrayOfValidSequenceTracks());
      let map = {};
      for (const {
        pathToProp,
        trackId
      } of arr) {
        set_default(map, pathToProp, trackId);
      }
      return map;
    }));
  }
  /**
   * @returns The static overrides that are not sequenced. Returns undefined if there are no static overrides,
   * or if all those static overrides are sequenced.
   */
  getStaticButNotSequencedOverrides() {
    return this._cache.get("getStaticButNotSequencedOverrides", () => (0, import_dataverse6.prism)(() => {
      const staticOverrides = (0, import_dataverse6.val)(this.getStaticValues());
      const arrayOfValidSequenceTracks = (0, import_dataverse6.val)(this.getArrayOfValidSequenceTracks());
      const staticButNotSequencedOverrides = cloneDeep_default(staticOverrides);
      for (const {
        pathToProp
      } of arrayOfValidSequenceTracks) {
        unset_default(staticButNotSequencedOverrides, pathToProp);
        let parentPath = pathToProp.slice(0, -1);
        while (parentPath.length > 0) {
          const parentValue = getDeep(staticButNotSequencedOverrides, parentPath);
          if (!isObjectEmpty(parentValue)) break;
          unset_default(staticButNotSequencedOverrides, parentPath);
          parentPath = parentPath.slice(0, -1);
        }
      }
      if (isObjectEmpty(staticButNotSequencedOverrides)) {
        return void 0;
      } else {
        return staticButNotSequencedOverrides;
      }
    }));
  }
  getDefaultsAtPointer(pointer3) {
    const {
      path
    } = (0, import_dataverse6.getPointerParts)(pointer3);
    const defaults = this.getDefaultValues().getValue();
    const defaultsAtPath = getDeep(defaults, path);
    return defaultsAtPath;
  }
};
function parsePathToProp(pathToPropInString) {
  try {
    const pathToProp = JSON.parse(pathToPropInString);
    return pathToProp;
  } catch (e2) {
    logger_default.warn("property ".concat(JSON.stringify(pathToPropInString), " cannot be parsed. Skipping."));
    return void 0;
  }
}

// core/src/sheets/SheetTemplate.ts
var import_dataverse15 = require("@theatre/dataverse");

// shared/src/utils/addresses.ts
var encodePathToProp = memoizeFn(p2 =>
// we're using JSON.stringify here, but we could use a faster alternative.
// If you happen to do that, first make sure no `PathToProp_Encoded` is ever
// used in the store, otherwise you'll have to write a migration.
JSON.stringify(p2));

// shared/src/utils/didYouMean.ts
var import_propose = __toESM(require_propose());
function didYouMean(str, dictionary, prepend = "Did you mean ", append = "?") {
  const p2 = (0, import_propose.default)(str, dictionary, {
    threshold: 0.7
  });
  if (p2) {
    return prepend + JSON.stringify(p2) + append;
  } else {
    return "";
  }
}

// shared/src/utils/errors.ts
var TheatreError = class extends Error {};
var InvalidArgumentError = class extends TheatreError {};

// core/src/sequences/Sequence.ts
var import_dataverse10 = require("@theatre/dataverse");
var import_dataverse11 = require("@theatre/dataverse");
var import_dataverse12 = require("@theatre/dataverse");
var import_dataverse13 = require("@theatre/dataverse");

// shared/src/utils/defer.ts
function defer() {
  let resolve;
  let reject;
  const promise = new Promise((rs, rj) => {
    resolve = v2 => {
      rs(v2);
      deferred.status = "resolved";
    };
    reject = v2 => {
      rj(v2);
      deferred.status = "rejected";
    };
  });
  const deferred = {
    resolve,
    reject,
    promise,
    status: "pending"
  };
  return deferred;
}

// shared/src/utils/noop.ts
var noop = () => {};
var noop_default = noop;

// core/src/sequences/playbackControllers/DefaultPlaybackController.ts
var import_dataverse7 = require("@theatre/dataverse");
var DefaultPlaybackController = class {
  constructor() {
    __publicField(this, "_stopPlayCallback", noop_default);
    __publicField(this, "_state", new import_dataverse7.Atom({
      position: 0,
      playing: false
    }));
    __publicField(this, "statePointer");
    this.statePointer = this._state.pointer;
  }
  destroy() {}
  pause() {
    this._stopPlayCallback();
    this.playing = false;
    this._stopPlayCallback = noop_default;
  }
  gotoPosition(time) {
    this._updatePositionInState(time);
  }
  _updatePositionInState(time) {
    this._state.setByPointer(p2 => p2.position, time);
  }
  getCurrentPosition() {
    return this._state.get().position;
  }
  get playing() {
    return this._state.get().playing;
  }
  set playing(playing) {
    this._state.setByPointer(p2 => p2.playing, playing);
  }
  play(iterationCount, range, rate, direction, ticker) {
    if (this.playing) {
      this.pause();
    }
    this.playing = true;
    const iterationLength = range[1] - range[0];
    {
      const startPos = this.getCurrentPosition();
      if (startPos < range[0] || startPos > range[1]) {
        if (direction === "normal" || direction === "alternate") {
          this._updatePositionInState(range[0]);
        } else if (direction === "reverse" || direction === "alternateReverse") {
          this._updatePositionInState(range[1]);
        }
      } else if (direction === "normal" || direction === "alternate") {
        if (startPos === range[1]) {
          this._updatePositionInState(range[0]);
        }
      } else {
        if (startPos === range[0]) {
          this._updatePositionInState(range[1]);
        }
      }
    }
    const deferred = defer();
    const initialTickerTime = ticker.time;
    const totalPlaybackLength = iterationLength * iterationCount;
    let initialElapsedPos = this.getCurrentPosition() - range[0];
    if (direction === "reverse" || direction === "alternateReverse") {
      initialElapsedPos = range[1] - this.getCurrentPosition();
    }
    const tick = currentTickerTime => {
      const elapsedTickerTime = Math.max(currentTickerTime - initialTickerTime, 0);
      const elapsedTickerTimeInSeconds = elapsedTickerTime / 1e3;
      const elapsedPos = Math.min(elapsedTickerTimeInSeconds * rate + initialElapsedPos, totalPlaybackLength);
      if (elapsedPos !== totalPlaybackLength) {
        const iterationNumber = Math.floor(elapsedPos / iterationLength);
        let currentIterationPos = elapsedPos / iterationLength % 1 * iterationLength;
        if (direction !== "normal") {
          if (direction === "reverse") {
            currentIterationPos = iterationLength - currentIterationPos;
          } else {
            const isCurrentIterationNumberEven = iterationNumber % 2 === 0;
            if (direction === "alternate") {
              if (!isCurrentIterationNumberEven) {
                currentIterationPos = iterationLength - currentIterationPos;
              }
            } else {
              if (isCurrentIterationNumberEven) {
                currentIterationPos = iterationLength - currentIterationPos;
              }
            }
          }
        }
        this._updatePositionInState(currentIterationPos + range[0]);
        requestNextTick();
      } else {
        if (direction === "normal") {
          this._updatePositionInState(range[1]);
        } else if (direction === "reverse") {
          this._updatePositionInState(range[0]);
        } else {
          const isLastIterationEven = (iterationCount - 1) % 2 === 0;
          if (direction === "alternate") {
            if (isLastIterationEven) {
              this._updatePositionInState(range[1]);
            } else {
              this._updatePositionInState(range[0]);
            }
          } else {
            if (isLastIterationEven) {
              this._updatePositionInState(range[0]);
            } else {
              this._updatePositionInState(range[1]);
            }
          }
        }
        this.playing = false;
        deferred.resolve(true);
      }
    };
    this._stopPlayCallback = () => {
      ticker.offThisOrNextTick(tick);
      ticker.offNextTick(tick);
      if (this.playing) deferred.resolve(false);
    };
    const requestNextTick = () => ticker.onNextTick(tick);
    ticker.onThisOrNextTick(tick);
    return deferred.promise;
  }
  playDynamicRange(rangeD, ticker) {
    if (this.playing) {
      this.pause();
    }
    this.playing = true;
    const deferred = defer();
    const untapFromRangeD = rangeD.keepHot();
    void deferred.promise.then(untapFromRangeD, untapFromRangeD);
    let lastTickerTime = ticker.time;
    const tick = currentTickerTime => {
      const elapsedSinceLastTick = Math.max(currentTickerTime - lastTickerTime, 0);
      lastTickerTime = currentTickerTime;
      const elapsedSinceLastTickInSeconds = elapsedSinceLastTick / 1e3;
      const lastPosition = this.getCurrentPosition();
      const range = rangeD.getValue();
      if (lastPosition < range[0] || lastPosition > range[1]) {
        this.gotoPosition(range[0]);
      } else {
        let newPosition = lastPosition + elapsedSinceLastTickInSeconds;
        if (newPosition > range[1]) {
          newPosition = range[0] + (newPosition - range[1]);
        }
        this.gotoPosition(newPosition);
      }
      requestNextTick();
    };
    this._stopPlayCallback = () => {
      ticker.offThisOrNextTick(tick);
      ticker.offNextTick(tick);
      deferred.resolve(false);
    };
    const requestNextTick = () => ticker.onNextTick(tick);
    ticker.onThisOrNextTick(tick);
    return deferred.promise;
  }
};

// core/src/sequences/playbackControllers/AudioPlaybackController.ts
var import_dataverse8 = require("@theatre/dataverse");

// shared/src/globalVariableNames.ts
var studioBundle = "__TheatreJS_StudioBundle";
var coreBundle = "__TheatreJS_CoreBundle";
var notifications = "__TheatreJS_Notifications";

// shared/src/notify.ts
var createHandler = type => (...args) => {
  var _a;
  switch (type) {
    case "success":
      {
        logger_default.debug(args.slice(0, 2).join("\n"));
        break;
      }
    case "info":
      {
        logger_default.debug(args.slice(0, 2).join("\n"));
        break;
      }
    case "warning":
      {
        logger_default.warn(args.slice(0, 2).join("\n"));
        break;
      }
    case "error":
      {}
  }
  return typeof window !== "undefined" ?
  // @ts-ignore
  (_a = window[notifications]) == null ? void 0 : _a.notify[type](...args) : void 0;
};
var notify = {
  warning: createHandler("warning"),
  success: createHandler("success"),
  info: createHandler("info"),
  error: createHandler("error")
};
if (typeof window !== "undefined") {
  window.addEventListener("error", e2 => {
    notify.error("An error occurred", "<pre>".concat(e2.message, "</pre>\n\nSee **console** for details."));
  });
  window.addEventListener("unhandledrejection", e2 => {
    notify.error("An error occurred", "<pre>".concat(e2.reason, "</pre>\n\nSee **console** for details."));
  });
}

// core/src/sequences/playbackControllers/AudioPlaybackController.ts
var AudioPlaybackController = class {
  constructor(_decodedBuffer, _audioContext, _nodeDestination) {
    this._decodedBuffer = _decodedBuffer;
    this._audioContext = _audioContext;
    this._nodeDestination = _nodeDestination;
    __publicField(this, "_mainGain");
    __publicField(this, "_state", new import_dataverse8.Atom({
      position: 0,
      playing: false
    }));
    __publicField(this, "statePointer");
    __publicField(this, "_stopPlayCallback", noop_default);
    this.statePointer = this._state.pointer;
    this._mainGain = this._audioContext.createGain();
    this._mainGain.connect(this._nodeDestination);
  }
  playDynamicRange(rangeD, ticker) {
    const deferred = defer();
    if (this._playing) this.pause();
    this._playing = true;
    let stop = void 0;
    const play = () => {
      stop == null ? void 0 : stop();
      stop = this._loopInRange(rangeD.getValue(), ticker).stop;
    };
    const untapFromRangeD = rangeD.onStale(play);
    play();
    this._stopPlayCallback = () => {
      stop == null ? void 0 : stop();
      untapFromRangeD();
      deferred.resolve(false);
    };
    return deferred.promise;
  }
  _loopInRange(range, ticker) {
    const rate = 1;
    let startPos = this.getCurrentPosition();
    const iterationLength = range[1] - range[0];
    if (startPos < range[0] || startPos > range[1]) {
      this._updatePositionInState(range[0]);
    } else if (startPos === range[1]) {
      this._updatePositionInState(range[0]);
    }
    startPos = this.getCurrentPosition();
    const currentSource = this._audioContext.createBufferSource();
    currentSource.buffer = this._decodedBuffer;
    currentSource.connect(this._mainGain);
    currentSource.playbackRate.value = rate;
    currentSource.loop = true;
    currentSource.loopStart = range[0];
    currentSource.loopEnd = range[1];
    const initialTickerTime = ticker.time;
    let initialElapsedPos = startPos - range[0];
    currentSource.start(0, startPos);
    const tick = currentTickerTime => {
      const elapsedTickerTime = Math.max(currentTickerTime - initialTickerTime, 0);
      const elapsedTickerTimeInSeconds = elapsedTickerTime / 1e3;
      const elapsedPos = elapsedTickerTimeInSeconds * rate + initialElapsedPos;
      let currentIterationPos = elapsedPos / iterationLength % 1 * iterationLength;
      this._updatePositionInState(currentIterationPos + range[0]);
      requestNextTick();
    };
    const requestNextTick = () => ticker.onNextTick(tick);
    ticker.onThisOrNextTick(tick);
    const stop = () => {
      currentSource.stop();
      currentSource.disconnect();
      ticker.offThisOrNextTick(tick);
      ticker.offNextTick(tick);
    };
    return {
      stop
    };
  }
  get _playing() {
    return this._state.get().playing;
  }
  set _playing(playing) {
    this._state.setByPointer(p2 => p2.playing, playing);
  }
  destroy() {}
  pause() {
    this._stopPlayCallback();
    this._playing = false;
    this._stopPlayCallback = noop_default;
  }
  gotoPosition(time) {
    this._updatePositionInState(time);
  }
  _updatePositionInState(time) {
    this._state.reduce(s2 => __spreadProps(__spreadValues({}, s2), {
      position: time
    }));
  }
  getCurrentPosition() {
    return this._state.get().position;
  }
  play(iterationCount, range, rate, direction, ticker) {
    if (this._playing) {
      this.pause();
    }
    this._playing = true;
    let startPos = this.getCurrentPosition();
    const iterationLength = range[1] - range[0];
    if (direction !== "normal") {
      throw new InvalidArgumentError('Audio-controlled sequences can only be played in the "normal" direction. ' + "'".concat(direction, "' given."));
    }
    if (startPos < range[0] || startPos > range[1]) {
      this._updatePositionInState(range[0]);
    } else if (startPos === range[1]) {
      this._updatePositionInState(range[0]);
    }
    startPos = this.getCurrentPosition();
    const deferred = defer();
    const currentSource = this._audioContext.createBufferSource();
    currentSource.buffer = this._decodedBuffer;
    currentSource.connect(this._mainGain);
    currentSource.playbackRate.value = rate;
    if (iterationCount > 1e3) {
      notify.warning("Can't play sequences with audio more than 1000 times", "The sequence will still play, but only 1000 times. The `iterationCount: ".concat(iterationCount, "` provided to `sequence.play()`\nis too high for a sequence with audio.\n\nTo fix this, either set `iterationCount` to a lower value, or remove the audio from the sequence."), [{
        url: "https://www.theatrejs.com/docs/latest/manual/audio",
        title: "Using Audio"
      }, {
        url: "https://www.theatrejs.com/docs/latest/api/core#sequence.attachaudio",
        title: "Audio API"
      }]);
      iterationCount = 1e3;
    }
    if (iterationCount > 1) {
      currentSource.loop = true;
      currentSource.loopStart = range[0];
      currentSource.loopEnd = range[1];
    }
    const initialTickerTime = ticker.time;
    let initialElapsedPos = startPos - range[0];
    const totalPlaybackLength = iterationLength * iterationCount;
    currentSource.start(0, startPos, totalPlaybackLength - initialElapsedPos);
    const tick = currentTickerTime => {
      const elapsedTickerTime = Math.max(currentTickerTime - initialTickerTime, 0);
      const elapsedTickerTimeInSeconds = elapsedTickerTime / 1e3;
      const elapsedPos = Math.min(elapsedTickerTimeInSeconds * rate + initialElapsedPos, totalPlaybackLength);
      if (elapsedPos !== totalPlaybackLength) {
        let currentIterationPos = elapsedPos / iterationLength % 1 * iterationLength;
        this._updatePositionInState(currentIterationPos + range[0]);
        requestNextTick();
      } else {
        this._updatePositionInState(range[1]);
        this._playing = false;
        cleanup();
        deferred.resolve(true);
      }
    };
    const cleanup = () => {
      currentSource.stop();
      currentSource.disconnect();
    };
    this._stopPlayCallback = () => {
      cleanup();
      ticker.offThisOrNextTick(tick);
      ticker.offNextTick(tick);
      if (this._playing) deferred.resolve(false);
    };
    const requestNextTick = () => ticker.onNextTick(tick);
    ticker.onThisOrNextTick(tick);
    return deferred.promise;
  }
};

// core/src/rafDrivers.ts
var import_dataverse9 = require("@theatre/dataverse");
var lastDriverId = 0;
function createRafDriver(conf) {
  var _a;
  const tick = time => {
    ticker.tick(time);
  };
  const ticker = new import_dataverse9.Ticker({
    onActive() {
      var _a2;
      (_a2 = conf == null ? void 0 : conf.start) == null ? void 0 : _a2.call(conf);
    },
    onDormant() {
      var _a2;
      (_a2 = conf == null ? void 0 : conf.stop) == null ? void 0 : _a2.call(conf);
    }
  });
  const driverPublicApi = {
    tick,
    id: lastDriverId++,
    name: (_a = conf == null ? void 0 : conf.name) != null ? _a : "CustomRafDriver-".concat(lastDriverId),
    type: "Theatre_RafDriver_PublicAPI"
  };
  const driverPrivateApi = {
    type: "Theatre_RafDriver_PrivateAPI",
    publicApi: driverPublicApi,
    ticker,
    start: conf == null ? void 0 : conf.start,
    stop: conf == null ? void 0 : conf.stop
  };
  setPrivateAPI(driverPublicApi, driverPrivateApi);
  return driverPublicApi;
}

// core/src/coreTicker.ts
function createBasicRafDriver() {
  let rafId = null;
  const start = () => {
    if (typeof window !== "undefined") {
      const onAnimationFrame = t2 => {
        driver.tick(t2);
        rafId = window.requestAnimationFrame(onAnimationFrame);
      };
      rafId = window.requestAnimationFrame(onAnimationFrame);
    } else {
      driver.tick(0);
      setTimeout(() => driver.tick(1), 0);
    }
  };
  const stop = () => {
    if (typeof window !== "undefined") {
      if (rafId !== null) {
        window.cancelAnimationFrame(rafId);
      }
    } else {}
  };
  const driver = createRafDriver({
    name: "DefaultCoreRafDriver",
    start,
    stop
  });
  return driver;
}
var coreRafDriver;
function getCoreRafDriver() {
  if (!coreRafDriver) {
    setCoreRafDriver(createBasicRafDriver());
  }
  return coreRafDriver;
}
function getCoreTicker() {
  return getCoreRafDriver().ticker;
}
function setCoreRafDriver(driver) {
  if (coreRafDriver) {
    throw new Error("`setCoreRafDriver()` is already called.");
  }
  const driverPrivateApi = privateAPI(driver);
  coreRafDriver = driverPrivateApi;
}

// core/src/sequences/TheatreSequence.ts
var TheatreSequence = class {
  get type() {
    return "Theatre_Sequence_PublicAPI";
  }
  /**
   * @internal
   */
  constructor(sheet) {
    setPrivateAPI(this, sheet);
  }
  play(conf) {
    const priv = privateAPI(this);
    if (priv._project.isReady()) {
      const ticker = (conf == null ? void 0 : conf.rafDriver) ? privateAPI(conf.rafDriver).ticker : getCoreTicker();
      return priv.play(conf != null ? conf : {}, ticker);
    } else {
      if ("development" !== "production") {
        notify.warning("Sequence can't be played", "You seem to have called `sequence.play()` before the project has finished loading.\n\nThis would **not** a problem in production when using `@theatre/core`, since Theatre.js loads instantly in core mode. However, when using `@theatre/studio`, it takes a few milliseconds for it to load your project's state, before which your sequences cannot start playing.\n\nTo fix this, simply defer calling `sequence.play()` until after the project is loaded, like this:\n\n```\nproject.ready.then(() => {\n  sequence.play()\n})\n```", [{
          url: "https://www.theatrejs.com/docs/0.5/api/core#project.ready",
          title: "Project.ready"
        }]);
      }
      const d2 = defer();
      d2.resolve(true);
      return d2.promise;
    }
  }
  pause() {
    privateAPI(this).pause();
  }
  get position() {
    return privateAPI(this).position;
  }
  set position(position) {
    privateAPI(this).position = position;
  }
  __experimental_getKeyframes(prop) {
    return privateAPI(this).getKeyframesOfSimpleProp(prop);
  }
  async attachAudio(args) {
    const {
      audioContext,
      destinationNode,
      decodedBuffer,
      gainNode
    } = await resolveAudioBuffer(args);
    const playbackController = new AudioPlaybackController(decodedBuffer, audioContext, gainNode);
    privateAPI(this).replacePlaybackController(playbackController);
    return {
      audioContext,
      destinationNode,
      decodedBuffer,
      gainNode
    };
  }
  get pointer() {
    return privateAPI(this).pointer;
  }
};
async function resolveAudioBuffer(args) {
  function getAudioContext() {
    if (args.audioContext) return Promise.resolve(args.audioContext);
    const ctx = new AudioContext();
    if (ctx.state === "running") return Promise.resolve(ctx);
    if (typeof window === "undefined") {
      return Promise.resolve(ctx);
    }
    return new Promise(resolve => {
      const listener = () => {
        ctx.resume().catch(err => {
          console.error(err);
        });
      };
      const eventsToHookInto = ["mousedown", "keydown", "touchstart"];
      const eventListenerOpts = {
        capture: true,
        passive: false
      };
      eventsToHookInto.forEach(eventName => {
        window.addEventListener(eventName, listener, eventListenerOpts);
      });
      ctx.addEventListener("statechange", () => {
        if (ctx.state === "running") {
          eventsToHookInto.forEach(eventName => {
            window.removeEventListener(eventName, listener, eventListenerOpts);
          });
          resolve(ctx);
        }
      });
    });
  }
  async function getAudioBuffer() {
    if (args.source instanceof AudioBuffer) {
      return args.source;
    }
    const decodedBufferDeferred = defer();
    if (typeof args.source !== "string") {
      throw new Error("Error validating arguments to sequence.attachAudio(). args.source must either be a string or an instance of AudioBuffer.");
    }
    let fetchResponse;
    try {
      fetchResponse = await fetch(args.source);
    } catch (e2) {
      console.error(e2);
      throw new Error("Could not fetch '".concat(args.source, "'. Network error logged above."));
    }
    let arrayBuffer;
    try {
      arrayBuffer = await fetchResponse.arrayBuffer();
    } catch (e2) {
      console.error(e2);
      throw new Error("Could not read '".concat(args.source, "' as an arrayBuffer."));
    }
    const audioContext2 = await audioContextPromise;
    audioContext2.decodeAudioData(arrayBuffer, decodedBufferDeferred.resolve, decodedBufferDeferred.reject);
    let decodedBuffer2;
    try {
      decodedBuffer2 = await decodedBufferDeferred.promise;
    } catch (e2) {
      console.error(e2);
      throw new Error("Could not decode ".concat(args.source, " as an audio file."));
    }
    return decodedBuffer2;
  }
  const audioContextPromise = getAudioContext();
  const audioBufferPromise = getAudioBuffer();
  const [audioContext, decodedBuffer] = await Promise.all([audioContextPromise, audioBufferPromise]);
  const destinationNode = args.destinationNode || audioContext.destination;
  const gainNode = audioContext.createGain();
  gainNode.connect(destinationNode);
  return {
    audioContext,
    decodedBuffer,
    gainNode,
    destinationNode
  };
}

// shared/src/instanceTypes.ts
var isProject = typeAsserter("Theatre_Project");
var isSheet = typeAsserter("Theatre_Sheet");
var isSheetTemplate = typeAsserter("Theatre_SheetTemplate");
var isSheetObject = typeAsserter("Theatre_SheetObject");
var isSequence = typeAsserter("Theatre_Sequence");
var isSheetObjectTemplate = typeAsserter("Theatre_SheetObjectTemplate");
var isProjectPublicAPI = typeAsserter("Theatre_Project_PublicAPI");
var isSheetPublicAPI = typeAsserter("Theatre_Sheet_PublicAPI");
var isSheetObjectPublicAPI = typeAsserter("Theatre_SheetObject_PublicAPI");
function typeAsserter(t2) {
  return v2 => typeof v2 === "object" && !!v2 && v2.type === t2;
}

// core/src/sequences/Sequence.ts
var possibleDirections = ["normal", "reverse", "alternate", "alternateReverse"];
var Sequence = class {
  constructor(_project, _sheet, _lengthD, _subUnitsPerUnitD, playbackController) {
    this._project = _project;
    this._sheet = _sheet;
    this._lengthD = _lengthD;
    this._subUnitsPerUnitD = _subUnitsPerUnitD;
    __publicField(this, "address");
    __publicField(this, "publicApi");
    __publicField(this, "_playbackControllerBox");
    __publicField(this, "_prismOfStatePointer");
    __publicField(this, "_positionD");
    __publicField(this, "_positionFormatterD");
    __publicField(this, "_playableRangeD");
    __publicField(this, "pointer", (0, import_dataverse12.pointer)({
      root: this,
      path: []
    }));
    __publicField(this, "$$isPointerToPrismProvider", true);
    __publicField(this, "_logger");
    __publicField(this, "closestGridPosition", posInUnitSpace => {
      const subUnitsPerUnit = this.subUnitsPerUnit;
      const gridLength = 1 / subUnitsPerUnit;
      return parseFloat((Math.round(posInUnitSpace / gridLength) * gridLength).toFixed(3));
    });
    this._logger = _project._logger.named("Sheet", _sheet.address.sheetId).named("Instance", _sheet.address.sheetInstanceId);
    this.address = __spreadProps(__spreadValues({}, this._sheet.address), {
      sequenceName: "default"
    });
    this.publicApi = new TheatreSequence(this);
    this._playbackControllerBox = new import_dataverse11.Atom(playbackController != null ? playbackController : new DefaultPlaybackController());
    this._prismOfStatePointer = (0, import_dataverse13.prism)(() => this._playbackControllerBox.prism.getValue().statePointer);
    this._positionD = (0, import_dataverse13.prism)(() => {
      const statePointer = this._prismOfStatePointer.getValue();
      return (0, import_dataverse13.val)(statePointer.position);
    });
    this._positionFormatterD = (0, import_dataverse13.prism)(() => {
      const subUnitsPerUnit = (0, import_dataverse13.val)(this._subUnitsPerUnitD);
      return new TimeBasedPositionFormatter(subUnitsPerUnit);
    });
  }
  get type() {
    return "Theatre_Sequence";
  }
  pointerToPrism(pointer3) {
    const {
      path
    } = (0, import_dataverse10.getPointerParts)(pointer3);
    if (path.length === 0) {
      return (0, import_dataverse13.prism)(() => ({
        length: (0, import_dataverse13.val)(this.pointer.length),
        playing: (0, import_dataverse13.val)(this.pointer.playing),
        position: (0, import_dataverse13.val)(this.pointer.position),
        subUnitsPerUnit: (0, import_dataverse13.val)(this.pointer.subUnitsPerUnit)
      }));
    }
    if (path.length > 1) {
      return (0, import_dataverse13.prism)(() => void 0);
    }
    const [prop] = path;
    if (prop === "length") {
      return this._lengthD;
    } else if (prop === "subUnitsPerUnit") {
      return this._subUnitsPerUnitD;
    } else if (prop === "position") {
      return this._positionD;
    } else if (prop === "playing") {
      return (0, import_dataverse13.prism)(() => {
        return (0, import_dataverse13.val)(this._prismOfStatePointer.getValue().playing);
      });
    } else {
      return (0, import_dataverse13.prism)(() => void 0);
    }
  }
  /**
   * Takes a pointer to a property of a SheetObject and returns the keyframes of that property.
   *
   * Theoretically, this method can be called from inside a prism so it can be reactive.
   */
  getKeyframesOfSimpleProp(prop) {
    const {
      path,
      root: root2
    } = (0, import_dataverse10.getPointerParts)(prop);
    if (!isSheetObject(root2)) {
      throw new InvalidArgumentError("Argument prop must be a pointer to a SheetObject property");
    }
    const trackP = (0, import_dataverse13.val)(this._project.pointers.historic.sheetsById[this._sheet.address.sheetId].sequence.tracksByObject[root2.address.objectKey]);
    if (!trackP) {
      return [];
    }
    const {
      trackData,
      trackIdByPropPath
    } = trackP;
    const objectAddress = encodePathToProp(path);
    const id = trackIdByPropPath[objectAddress];
    if (!id) {
      return [];
    }
    const track = trackData[id];
    if (!track) {
      return [];
    }
    return track.keyframes;
  }
  get positionFormatter() {
    return this._positionFormatterD.getValue();
  }
  get prismOfStatePointer() {
    return this._prismOfStatePointer;
  }
  get length() {
    return this._lengthD.getValue();
  }
  get positionPrism() {
    return this._positionD;
  }
  get position() {
    return this._playbackControllerBox.get().getCurrentPosition();
  }
  get subUnitsPerUnit() {
    return this._subUnitsPerUnitD.getValue();
  }
  get positionSnappedToGrid() {
    return this.closestGridPosition(this.position);
  }
  set position(requestedPosition) {
    let position = requestedPosition;
    this.pause();
    if ("development" !== "production") {
      if (typeof position !== "number") {
        console.error("value t in sequence.position = t must be a number. ".concat(typeof position, " given"));
        position = 0;
      }
      if (position < 0) {
        console.error("sequence.position must be a positive number. ".concat(position, " given"));
        position = 0;
      }
    }
    if (position > this.length) {
      position = this.length;
    }
    const dur = this.length;
    this._playbackControllerBox.get().gotoPosition(position > dur ? dur : position);
  }
  getDurationCold() {
    return this._lengthD.getValue();
  }
  get playing() {
    return (0, import_dataverse13.val)(this._playbackControllerBox.get().statePointer.playing);
  }
  _makeRangeFromSequenceTemplate() {
    return (0, import_dataverse13.prism)(() => {
      return [0, (0, import_dataverse13.val)(this._lengthD)];
    });
  }
  /**
   * Controls the playback within a range. Repeats infinitely unless stopped.
   *
   * @remarks
   *   One use case for this is to play the playback within the focus range.
   *
   * @param rangeD - The prism that contains the range that will be used for the playback
   *
   * @returns  a promise that gets rejected if the playback stopped for whatever reason
   *
   */
  playDynamicRange(rangeD, ticker) {
    return this._playbackControllerBox.get().playDynamicRange(rangeD, ticker);
  }
  async play(conf, ticker) {
    const sequenceDuration = this.length;
    const range = conf && conf.range ? conf.range : [0, sequenceDuration];
    if ("development" !== "production") {
      if (typeof range[0] !== "number" || range[0] < 0) {
        throw new InvalidArgumentError("Argument conf.range[0] in sequence.play(conf) must be a positive number. ".concat(JSON.stringify(range[0]), " given."));
      }
      if (range[0] >= sequenceDuration) {
        throw new InvalidArgumentError("Argument conf.range[0] in sequence.play(conf) cannot be longer than the duration of the sequence, which is ".concat(sequenceDuration, "s. ").concat(JSON.stringify(range[0]), " given."));
      }
      if (typeof range[1] !== "number" || range[1] <= 0) {
        throw new InvalidArgumentError("Argument conf.range[1] in sequence.play(conf) must be a number larger than zero. ".concat(JSON.stringify(range[1]), " given."));
      }
      if (range[1] > sequenceDuration) {
        notify.warning("Couldn't play sequence in given range", "Your animation will still play until the end of the sequence, however the argument `conf.range[1]` given in `sequence.play(conf)` (".concat(JSON.stringify(range[1]), "s) is longer than the duration of the sequence (").concat(sequenceDuration, "s).\n\nTo fix this, either set `conf.range[1]` to be less the duration of the sequence, or adjust the sequence duration in the UI."), [{
          url: "https://www.theatrejs.com/docs/latest/manual/sequences",
          title: "Sequences"
        }, {
          url: "https://www.theatrejs.com/docs/latest/manual/sequences",
          title: "Playback API"
        }]);
        range[1] = sequenceDuration;
      }
      if (range[1] <= range[0]) {
        throw new InvalidArgumentError("Argument conf.range[1] in sequence.play(conf) must be larger than conf.range[0]. ".concat(JSON.stringify(range), " given."));
      }
    }
    const iterationCount = conf && typeof conf.iterationCount === "number" ? conf.iterationCount : 1;
    if ("development" !== "production") {
      if (!(Number.isInteger(iterationCount) && iterationCount > 0) && iterationCount !== Infinity) {
        throw new InvalidArgumentError("Argument conf.iterationCount in sequence.play(conf) must be an integer larger than 0. ".concat(JSON.stringify(iterationCount), " given."));
      }
    }
    const rate = conf && typeof conf.rate !== "undefined" ? conf.rate : 1;
    if ("development" !== "production") {
      if (typeof rate !== "number" || rate === 0) {
        throw new InvalidArgumentError("Argument conf.rate in sequence.play(conf) must be a number larger than 0. ".concat(JSON.stringify(rate), " given."));
      }
      if (rate < 0) {
        throw new InvalidArgumentError("Argument conf.rate in sequence.play(conf) must be a number larger than 0. ".concat(JSON.stringify(rate), " given. If you want the animation to play backwards, try setting conf.direction to 'reverse' or 'alternateReverse'."));
      }
    }
    const direction = conf && conf.direction ? conf.direction : "normal";
    if ("development" !== "production") {
      if (possibleDirections.indexOf(direction) === -1) {
        throw new InvalidArgumentError("Argument conf.direction in sequence.play(conf) must be one of ".concat(JSON.stringify(possibleDirections), ". ").concat(JSON.stringify(direction), " given. ").concat(didYouMean(direction, possibleDirections)));
      }
    }
    return await this._play(iterationCount, [range[0], range[1]], rate, direction, ticker);
  }
  _play(iterationCount, range, rate, direction, ticker) {
    return this._playbackControllerBox.get().play(iterationCount, range, rate, direction, ticker);
  }
  pause() {
    this._playbackControllerBox.get().pause();
  }
  replacePlaybackController(playbackController) {
    this.pause();
    const oldController = this._playbackControllerBox.get();
    this._playbackControllerBox.set(playbackController);
    const time = oldController.getCurrentPosition();
    oldController.destroy();
    playbackController.gotoPosition(time);
  }
};
var TimeBasedPositionFormatter = class {
  constructor(_fps) {
    this._fps = _fps;
  }
  formatSubUnitForGrid(posInUnitSpace) {
    const subSecondPos = posInUnitSpace % 1;
    const frame = 1 / this._fps;
    const frames = Math.round(subSecondPos / frame);
    return frames + "f";
  }
  formatFullUnitForGrid(posInUnitSpace) {
    let p2 = posInUnitSpace;
    let s2 = "";
    if (p2 >= hour) {
      const hours = Math.floor(p2 / hour);
      s2 += hours + "h";
      p2 = p2 % hour;
    }
    if (p2 >= minute) {
      const minutes = Math.floor(p2 / minute);
      s2 += minutes + "m";
      p2 = p2 % minute;
    }
    if (p2 >= second) {
      const seconds = Math.floor(p2 / second);
      s2 += seconds + "s";
      p2 = p2 % second;
    }
    const frame = 1 / this._fps;
    if (p2 >= frame) {
      const frames = Math.floor(p2 / frame);
      s2 += frames + "f";
      p2 = p2 % frame;
    }
    return s2.length === 0 ? "0s" : s2;
  }
  formatForPlayhead(posInUnitSpace) {
    let p2 = posInUnitSpace;
    let s2 = "";
    if (p2 >= hour) {
      const hours = Math.floor(p2 / hour);
      s2 += padStart_default(hours.toString(), 2, "0") + "h";
      p2 = p2 % hour;
    }
    if (p2 >= minute) {
      const minutes = Math.floor(p2 / minute);
      s2 += padStart_default(minutes.toString(), 2, "0") + "m";
      p2 = p2 % minute;
    } else if (s2.length > 0) {
      s2 += "00m";
    }
    if (p2 >= second) {
      const seconds = Math.floor(p2 / second);
      s2 += padStart_default(seconds.toString(), 2, "0") + "s";
      p2 = p2 % second;
    } else {
      s2 += "00s";
    }
    const frameLength = 1 / this._fps;
    if (p2 >= frameLength) {
      const frames = Math.round(p2 / frameLength);
      s2 += padStart_default(frames.toString(), 2, "0") + "f";
      p2 = p2 % frameLength;
    } else if (p2 / frameLength > 0.98) {
      const frames = 1;
      s2 += padStart_default(frames.toString(), 2, "0") + "f";
      p2 = p2 % frameLength;
    } else {
      s2 += "00f";
    }
    return s2.length === 0 ? "00s00f" : s2;
  }
  formatBasic(posInUnitSpace) {
    return posInUnitSpace.toFixed(2) + "s";
  }
};
var second = 1;
var minute = second * 60;
var hour = minute * 60;

// core/src/propTypes/index.ts
var propTypes_exports = {};
__export(propTypes_exports, {
  boolean: () => boolean,
  compound: () => compound,
  file: () => file,
  image: () => image,
  number: () => number,
  rgba: () => rgba,
  string: () => string,
  stringLiteral: () => stringLiteral
});

// shared/src/utils/ellipsify.ts
function ellipsify(str, maxLength) {
  if (str.length <= maxLength) return str;
  return str.substr(0, maxLength - 3) + "...";
}

// shared/src/utils/userReadableTypeOfValue.ts
var userReadableTypeOfValue = v2 => {
  if (typeof v2 === "string") {
    return 'string("'.concat(ellipsify(v2, 10), '")');
  } else if (typeof v2 === "number") {
    return "number(".concat(ellipsify(String(v2), 10), ")");
  } else if (v2 === null) {
    return "null";
  } else if (v2 === void 0) {
    return "undefined";
  } else if (typeof v2 === "boolean") {
    return String(v2);
  } else if (Array.isArray(v2)) {
    return "array";
  } else if (typeof v2 === "object") {
    return "object";
  } else {
    return "unknown";
  }
};
var userReadableTypeOfValue_default = userReadableTypeOfValue;

// shared/src/utils/color.ts
function rgba2hex(rgba2, {
  /** Alpha is usually an optional value for most hex inputs, so if it's opaque, we can omit its value. */
  removeAlphaIfOpaque = false
} = {}) {
  const alpha = (rgba2.a * 255 | 1 << 8).toString(16).slice(1);
  const hex = (rgba2.r * 255 | 1 << 8).toString(16).slice(1) + (rgba2.g * 255 | 1 << 8).toString(16).slice(1) + (rgba2.b * 255 | 1 << 8).toString(16).slice(1) + (removeAlphaIfOpaque && alpha === "ff" ? "" : alpha);
  return "#".concat(hex);
}
function decorateRgba(rgba2) {
  return __spreadProps(__spreadValues({}, rgba2), {
    toString() {
      return rgba2hex(this, {
        removeAlphaIfOpaque: true
      });
    }
  });
}
function clampRgba(rgba2) {
  return Object.fromEntries(Object.entries(rgba2).map(([key, value]) => [key, clamp_default(value, 0, 1)]));
}
function linearSrgbToSrgb(rgba2) {
  function compress(x2) {
    if (x2 >= 31308e-7) return 1.055 * x2 ** (1 / 2.4) - 0.055;else return 12.92 * x2;
  }
  return clampRgba({
    r: compress(rgba2.r),
    g: compress(rgba2.g),
    b: compress(rgba2.b),
    a: rgba2.a
  });
}
function srgbToLinearSrgb(rgba2) {
  function expand(x2) {
    if (x2 >= 0.04045) return ((x2 + 0.055) / (1 + 0.055)) ** 2.4;else return x2 / 12.92;
  }
  return {
    r: expand(rgba2.r),
    g: expand(rgba2.g),
    b: expand(rgba2.b),
    a: rgba2.a
  };
}
function linearSrgbToOklab(rgba2) {
  let l2 = 0.4122214708 * rgba2.r + 0.5363325363 * rgba2.g + 0.0514459929 * rgba2.b;
  let m = 0.2119034982 * rgba2.r + 0.6806995451 * rgba2.g + 0.1073969566 * rgba2.b;
  let s2 = 0.0883024619 * rgba2.r + 0.2817188376 * rgba2.g + 0.6299787005 * rgba2.b;
  let l_ = Math.cbrt(l2);
  let m_ = Math.cbrt(m);
  let s_ = Math.cbrt(s2);
  return {
    L: 0.2104542553 * l_ + 0.793617785 * m_ - 0.0040720468 * s_,
    a: 1.9779984951 * l_ - 2.428592205 * m_ + 0.4505937099 * s_,
    b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.808675766 * s_,
    alpha: rgba2.a
  };
}
function oklabToLinearSrgb(laba) {
  let l_ = laba.L + 0.3963377774 * laba.a + 0.2158037573 * laba.b;
  let m_ = laba.L - 0.1055613458 * laba.a - 0.0638541728 * laba.b;
  let s_ = laba.L - 0.0894841775 * laba.a - 1.291485548 * laba.b;
  let l2 = l_ * l_ * l_;
  let m = m_ * m_ * m_;
  let s2 = s_ * s_ * s_;
  return {
    r: 4.0767416621 * l2 - 3.3077115913 * m + 0.2309699292 * s2,
    g: -1.2684380046 * l2 + 2.6097574011 * m - 0.3413193965 * s2,
    b: -0.0041960863 * l2 - 0.7034186147 * m + 1.707614701 * s2,
    a: laba.alpha
  };
}

// core/src/propTypes/internals.ts
var propTypeSymbol = Symbol("TheatrePropType_Basic");
function isLonghandPropType(t2) {
  return typeof t2 === "object" && !!t2 && t2[propTypeSymbol] === "TheatrePropType";
}
function toLonghandProp(p2) {
  if (typeof p2 === "number") {
    return number(p2);
  } else if (typeof p2 === "boolean") {
    return boolean(p2);
  } else if (typeof p2 === "string") {
    return string(p2);
  } else if (typeof p2 === "object" && !!p2) {
    if (isLonghandPropType(p2)) return p2;
    if (isPlainObject_default(p2)) {
      return compound(p2);
    } else {
      throw new InvalidArgumentError("This value is not a valid prop type: ".concat(userReadableTypeOfValue_default(p2)));
    }
  } else {
    throw new InvalidArgumentError("This value is not a valid prop type: ".concat(userReadableTypeOfValue_default(p2)));
  }
}
function sanitizeCompoundProps(props) {
  const sanitizedProps = {};
  if ("development" !== "production") {
    if (typeof props !== "object" || !props) {
      throw new InvalidArgumentError("t.compound() expects an object, like: {x: 10}. ".concat(userReadableTypeOfValue_default(props), " given."));
    }
  }
  for (const key of Object.keys(props)) {
    if ("development" !== "production") {
      if (typeof key !== "string") {
        throw new InvalidArgumentError("t.compound()'s keys must be all strings. ".concat(userReadableTypeOfValue_default(key), " given."));
      } else if (key.length === 0 || !key.match(/^\w+$/)) {
        throw new InvalidArgumentError("compound key ".concat(userReadableTypeOfValue_default(key), " is invalid. The keys must be alphanumeric and start with a letter."));
      } else if (key.length > 64) {
        throw new InvalidArgumentError("compound key ".concat(userReadableTypeOfValue_default(key), " is too long."));
      }
    }
    const val8 = props[key];
    if (isLonghandPropType(val8)) {
      sanitizedProps[key] = val8;
    } else {
      sanitizedProps[key] = toLonghandProp(val8);
    }
  }
  return sanitizedProps;
}

// core/src/propTypes/index.ts
var validateCommonOpts = (fnCallSignature, opts) => {
  if ("development" !== "production") {
    if (opts === void 0) return;
    if (typeof opts !== "object" || opts === null) {
      throw new Error("opts in ".concat(fnCallSignature, " must either be undefined or an object."));
    }
    if (Object.prototype.hasOwnProperty.call(opts, "label")) {
      const {
        label
      } = opts;
      if (typeof label !== "string") {
        throw new Error("opts.label in ".concat(fnCallSignature, " should be a string. ").concat(userReadableTypeOfValue_default(label), " given."));
      }
      if (label.trim().length !== label.length) {
        throw new Error("opts.label in ".concat(fnCallSignature, ' should not start/end with whitespace. "').concat(label, '" given.'));
      }
      if (label.length === 0) {
        throw new Error("opts.label in ".concat(fnCallSignature, " should not be an empty string. If you wish to have no label, remove opts.label from opts."));
      }
    }
  }
};
var compound = (props, opts = {}) => {
  validateCommonOpts("t.compound(props, opts)", opts);
  const sanitizedProps = sanitizeCompoundProps(props);
  const deserializationCache = /* @__PURE__ */new WeakMap();
  const config = {
    type: "compound",
    props: sanitizedProps,
    valueType: null,
    [propTypeSymbol]: "TheatrePropType",
    label: opts.label,
    default: mapValues_default(sanitizedProps, p2 => p2.default),
    deserializeAndSanitize: json => {
      if (typeof json !== "object" || !json) return void 0;
      if (deserializationCache.has(json)) {
        return deserializationCache.get(json);
      }
      const deserialized = {};
      let atLeastOnePropWasDeserialized = false;
      for (const [key, propConfig] of Object.entries(sanitizedProps)) {
        if (Object.prototype.hasOwnProperty.call(json, key)) {
          const deserializedSub = propConfig.deserializeAndSanitize(json[key]);
          if (deserializedSub != null) {
            atLeastOnePropWasDeserialized = true;
            deserialized[key] = deserializedSub;
          }
        }
      }
      deserializationCache.set(json, deserialized);
      if (atLeastOnePropWasDeserialized) {
        return deserialized;
      }
    }
  };
  return config;
};
var file = (defaultValue, opts = {}) => {
  if ("development" !== "production") {
    validateCommonOpts("t.file(defaultValue, opts)", opts);
  }
  const interpolate = (left, right, progression) => {
    var _a;
    const stringInterpolate = (_a = opts.interpolate) != null ? _a : leftInterpolate;
    return {
      type: "file",
      id: stringInterpolate(left.id, right.id, progression)
    };
  };
  return {
    type: "file",
    default: {
      type: "file",
      id: defaultValue
    },
    valueType: null,
    [propTypeSymbol]: "TheatrePropType",
    label: opts.label,
    interpolate,
    deserializeAndSanitize: _ensureFile
  };
};
var _ensureFile = val8 => {
  if (!val8) return void 0;
  let valid = true;
  if (typeof val8.id !== "string" && ![null, void 0].includes(val8.id)) {
    valid = false;
  }
  if (val8.type !== "file") valid = false;
  if (!valid) return void 0;
  return val8;
};
var image = (defaultValue, opts = {}) => {
  if ("development" !== "production") {
    validateCommonOpts("t.image(defaultValue, opts)", opts);
  }
  const interpolate = (left, right, progression) => {
    var _a;
    const stringInterpolate = (_a = opts.interpolate) != null ? _a : leftInterpolate;
    return {
      type: "image",
      id: stringInterpolate(left.id, right.id, progression)
    };
  };
  return {
    type: "image",
    default: {
      type: "image",
      id: defaultValue
    },
    valueType: null,
    [propTypeSymbol]: "TheatrePropType",
    label: opts.label,
    interpolate,
    deserializeAndSanitize: _ensureImage
  };
};
var _ensureImage = val8 => {
  if (!val8) return void 0;
  let valid = true;
  if (typeof val8.id !== "string" && ![null, void 0].includes(val8.id)) {
    valid = false;
  }
  if (val8.type !== "image") valid = false;
  if (!valid) return void 0;
  return val8;
};
var number = (defaultValue, opts = {}) => {
  var _a;
  if ("development" !== "production") {
    validateCommonOpts("t.number(defaultValue, opts)", opts);
    if (typeof defaultValue !== "number" || !isFinite(defaultValue)) {
      throw new Error("Argument defaultValue in t.number(defaultValue) must be a number. ".concat(userReadableTypeOfValue_default(defaultValue), " given."));
    }
    if (typeof opts === "object" && opts !== null) {
      if (Object.prototype.hasOwnProperty.call(opts, "range")) {
        if (!Array.isArray(opts.range)) {
          throw new Error("opts.range in t.number(defaultValue, opts) must be a tuple of two numbers. ".concat(userReadableTypeOfValue_default(opts.range), " given."));
        }
        if (opts.range.length !== 2) {
          throw new Error("opts.range in t.number(defaultValue, opts) must have two elements. ".concat(opts.range.length, " given."));
        }
        if (!opts.range.every(n2 => typeof n2 === "number" && !isNaN(n2))) {
          throw new Error("opts.range in t.number(defaultValue, opts) must be a tuple of two numbers.");
        }
        if (opts.range[0] >= opts.range[1]) {
          throw new Error("opts.range[0] in t.number(defaultValue, opts) must be smaller than opts.range[1]. Given: ".concat(JSON.stringify(opts.range)));
        }
      }
      if (Object.prototype.hasOwnProperty.call(opts, "nudgeMultiplier")) {
        if (typeof opts.nudgeMultiplier !== "number" || !isFinite(opts.nudgeMultiplier)) {
          throw new Error("opts.nudgeMultiplier in t.number(defaultValue, opts) must be a finite number. ".concat(userReadableTypeOfValue_default(opts.nudgeMultiplier), " given."));
        }
      }
      if (Object.prototype.hasOwnProperty.call(opts, "nudgeFn")) {
        if (typeof opts.nudgeFn !== "function") {
          throw new Error("opts.nudgeFn in t.number(defaultValue, opts) must be a function. ".concat(userReadableTypeOfValue_default(opts.nudgeFn), " given."));
        }
      }
    }
  }
  return __spreadProps(__spreadValues({
    type: "number",
    valueType: 0,
    default: defaultValue,
    [propTypeSymbol]: "TheatrePropType"
  }, opts ? opts : {}), {
    label: opts.label,
    nudgeFn: (_a = opts.nudgeFn) != null ? _a : defaultNumberNudgeFn,
    nudgeMultiplier: typeof opts.nudgeMultiplier === "number" ? opts.nudgeMultiplier : void 0,
    interpolate: _interpolateNumber,
    deserializeAndSanitize: numberDeserializer(opts.range)
  });
};
var numberDeserializer = range => range ? json => {
  if (!(typeof json === "number" && isFinite(json))) return void 0;
  return clamp_default(json, range[0], range[1]);
} : _ensureNumber;
var _ensureNumber = value => typeof value === "number" && isFinite(value) ? value : void 0;
var _interpolateNumber = (left, right, progression) => {
  return left + progression * (right - left);
};
var rgba = (defaultValue = {
  r: 0,
  g: 0,
  b: 0,
  a: 1
}, opts = {}) => {
  if ("development" !== "production") {
    validateCommonOpts("t.rgba(defaultValue, opts)", opts);
    let valid = true;
    for (const p2 of ["r", "g", "b", "a"]) {
      if (!Object.prototype.hasOwnProperty.call(defaultValue, p2) || typeof defaultValue[p2] !== "number") {
        valid = false;
      }
    }
    if (!valid) {
      throw new Error("Argument defaultValue in t.rgba(defaultValue) must be of the shape { r: number; g: number, b: number, a: number; }.");
    }
  }
  const sanitized = {};
  for (const component of ["r", "g", "b", "a"]) {
    ;
    sanitized[component] = Math.min(Math.max(defaultValue[component], 0), 1);
  }
  return {
    type: "rgba",
    valueType: null,
    default: decorateRgba(sanitized),
    [propTypeSymbol]: "TheatrePropType",
    label: opts.label,
    interpolate: _interpolateRgba,
    deserializeAndSanitize: _sanitizeRgba
  };
};
var _sanitizeRgba = val8 => {
  if (!val8) return void 0;
  let valid = true;
  for (const c2 of ["r", "g", "b", "a"]) {
    if (!Object.prototype.hasOwnProperty.call(val8, c2) || typeof val8[c2] !== "number") {
      valid = false;
    }
  }
  if (!valid) return void 0;
  const sanitized = {};
  for (const c2 of ["r", "g", "b", "a"]) {
    ;
    sanitized[c2] = Math.min(Math.max(val8[c2], 0), 1);
  }
  return decorateRgba(sanitized);
};
var _interpolateRgba = (left, right, progression) => {
  const leftLab = linearSrgbToOklab(srgbToLinearSrgb(left));
  const rightLab = linearSrgbToOklab(srgbToLinearSrgb(right));
  const interpolatedLab = {
    L: (1 - progression) * leftLab.L + progression * rightLab.L,
    a: (1 - progression) * leftLab.a + progression * rightLab.a,
    b: (1 - progression) * leftLab.b + progression * rightLab.b,
    alpha: (1 - progression) * leftLab.alpha + progression * rightLab.alpha
  };
  const interpolatedRgba = linearSrgbToSrgb(oklabToLinearSrgb(interpolatedLab));
  return decorateRgba(interpolatedRgba);
};
var boolean = (defaultValue, opts = {}) => {
  var _a;
  if ("development" !== "production") {
    validateCommonOpts("t.boolean(defaultValue, opts)", opts);
    if (typeof defaultValue !== "boolean") {
      throw new Error("defaultValue in t.boolean(defaultValue) must be a boolean. ".concat(userReadableTypeOfValue_default(defaultValue), " given."));
    }
  }
  return {
    type: "boolean",
    default: defaultValue,
    valueType: null,
    [propTypeSymbol]: "TheatrePropType",
    label: opts.label,
    interpolate: (_a = opts.interpolate) != null ? _a : leftInterpolate,
    deserializeAndSanitize: _ensureBoolean
  };
};
var _ensureBoolean = val8 => {
  return typeof val8 === "boolean" ? val8 : void 0;
};
function leftInterpolate(left) {
  return left;
}
var string = (defaultValue, opts = {}) => {
  var _a;
  if ("development" !== "production") {
    validateCommonOpts("t.string(defaultValue, opts)", opts);
    if (typeof defaultValue !== "string") {
      throw new Error("defaultValue in t.string(defaultValue) must be a string. ".concat(userReadableTypeOfValue_default(defaultValue), " given."));
    }
  }
  return {
    type: "string",
    default: defaultValue,
    valueType: null,
    [propTypeSymbol]: "TheatrePropType",
    label: opts.label,
    interpolate: (_a = opts.interpolate) != null ? _a : leftInterpolate,
    deserializeAndSanitize: _ensureString
  };
};
function _ensureString(s2) {
  return typeof s2 === "string" ? s2 : void 0;
}
function stringLiteral(defaultValue, valuesAndLabels, opts = {}) {
  var _a, _b;
  return {
    type: "stringLiteral",
    default: defaultValue,
    valuesAndLabels: __spreadValues({}, valuesAndLabels),
    [propTypeSymbol]: "TheatrePropType",
    valueType: null,
    as: (_a = opts.as) != null ? _a : "menu",
    label: opts.label,
    interpolate: (_b = opts.interpolate) != null ? _b : leftInterpolate,
    deserializeAndSanitize(json) {
      if (typeof json !== "string") return void 0;
      if (Object.prototype.hasOwnProperty.call(valuesAndLabels, json)) {
        return json;
      } else {
        return void 0;
      }
    }
  };
}
var defaultNumberNudgeFn = ({
  config,
  deltaX,
  deltaFraction,
  magnitude
}) => {
  var _a;
  const {
    range
  } = config;
  if (!config.nudgeMultiplier && range && !range.includes(Infinity) && !range.includes(-Infinity)) {
    return deltaFraction * (range[1] - range[0]) * magnitude;
  }
  return deltaX * magnitude * ((_a = config.nudgeMultiplier) != null ? _a : 1);
};

// shared/src/utils/slashedPaths.ts
var normalizeSlashedPath = p2 => p2.replace(/^[\s\/]*/, "").replace(/[\s\/]*$/, "").replace(/\s*\/\s*/g, " / ");
var getValidationErrorsOfSlashedPath = p2 => {
  if (typeof p2 !== "string") return "it is not a string. (it is a ".concat(typeof p2, ")");
  const components = p2.split(/\//);
  if (components.length === 0) return "it is empty.";
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2].trim();
    if (component.length === 0) return "the component #".concat(i2 + 1, " is empty.");
    if (component.length > 64) return "the component '".concat(component, "' must have 64 characters or less.");
  }
};
function validateAndSanitiseSlashedPathOrThrow(unsanitisedPath, fnName) {
  const sanitisedPath = normalizeSlashedPath(unsanitisedPath);
  if ("development" !== "development") {
    return sanitisedPath;
  }
  const validation = getValidationErrorsOfSlashedPath(sanitisedPath);
  if (validation) {
    throw new InvalidArgumentError("The path in ".concat(fnName, "(").concat(typeof unsanitisedPath === "string" ? '"'.concat(unsanitisedPath, '"') : "", ") is invalid because ").concat(validation));
  }
  if (unsanitisedPath !== sanitisedPath) {
    notify.warning("Invalid path provided to object", "The path in `".concat(fnName, '("').concat(unsanitisedPath, '")` was sanitized to `"').concat(sanitisedPath, '"`.\n\n') + "Please replace the path with the sanitized one, otherwise it will likely break in the future.", [{
      url: "https://www.theatrejs.com/docs/latest/manual/objects#creating-sheet-objects",
      title: "Sheet Objects"
    }, {
      url: "https://www.theatrejs.com/docs/latest/api/core#sheet.object",
      title: "API"
    }]);
  }
  return sanitisedPath;
}

// core/src/sheets/TheatreSheet.ts
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var weakMapOfUnsanitizedProps = /* @__PURE__ */new WeakMap();
var TheatreSheet = class {
  get type() {
    return "Theatre_Sheet_PublicAPI";
  }
  /**
   * @internal
   */
  constructor(sheet) {
    setPrivateAPI(this, sheet);
  }
  object(key, config, opts) {
    const internal2 = privateAPI(this);
    const sanitizedPath = validateAndSanitiseSlashedPathOrThrow(key, "sheet.object");
    const existingObject = internal2.getObject(sanitizedPath);
    const nativeObject = null;
    const actions = opts == null ? void 0 : opts.__actions__THIS_API_IS_UNSTABLE_AND_WILL_CHANGE_IN_THE_NEXT_VERSION;
    if (existingObject) {
      if ("development" !== "production") {
        const prevConfig = weakMapOfUnsanitizedProps.get(existingObject);
        if (prevConfig) {
          if (!(0, import_fast_deep_equal.default)(config, prevConfig)) {
            if ((opts == null ? void 0 : opts.reconfigure) === true) {
              const sanitizedConfig = compound(config);
              existingObject.template.reconfigure(sanitizedConfig);
              weakMapOfUnsanitizedProps.set(existingObject, config);
              return existingObject.publicApi;
            } else {
              throw new Error('You seem to have called sheet.object("'.concat(key, '", config) twice, with different values for `config`. ') + "This is disallowed because changing the config of an object on the fly would make it difficult to reason about.\n\n" + 'You can fix this by either re-using the existing object, or calling sheet.object("'.concat(key, '", config) with the same config.\n\n') + "If you mean to reconfigure the object's config, set `{reconfigure: true}` in sheet.object(\"".concat(key, '", config, {reconfigure: true})'));
            }
          }
        }
      }
      if (actions) {
        existingObject.template._temp_setActions(actions);
      }
      return existingObject.publicApi;
    } else {
      const sanitizedConfig = compound(config);
      const object = internal2.createObject(sanitizedPath, nativeObject, sanitizedConfig, actions);
      if ("development" !== "production") {
        weakMapOfUnsanitizedProps.set(object, config);
      }
      return object.publicApi;
    }
  }
  __experimental_getExistingObject(key) {
    const internal2 = privateAPI(this);
    const sanitizedPath = validateAndSanitiseSlashedPathOrThrow(key, "sheet.object");
    const existingObject = internal2.getObject(sanitizedPath);
    return existingObject == null ? void 0 : existingObject.publicApi;
  }
  get sequence() {
    return privateAPI(this).getSequence().publicApi;
  }
  get project() {
    return privateAPI(this).project.publicApi;
  }
  get address() {
    return __spreadValues({}, privateAPI(this).address);
  }
  detachObject(key) {
    const internal2 = privateAPI(this);
    const sanitizedPath = validateAndSanitiseSlashedPathOrThrow(key, 'sheet.deleteObject("'.concat(key, '")'));
    const obj = internal2.getObject(sanitizedPath);
    if (!obj) {
      notify.warning("Couldn't delete object \"".concat(sanitizedPath, '"'), 'There is no object with key "'.concat(sanitizedPath, '".\n\nTo fix this, make sure you are calling `sheet.deleteObject("').concat(sanitizedPath, '")` with the correct key.'));
      console.warn('Object key "'.concat(sanitizedPath, '" does not exist.'));
      return;
    }
    internal2.deleteObject(sanitizedPath);
  }
};

// core/src/sheets/Sheet.ts
var import_dataverse14 = require("@theatre/dataverse");
var Sheet = class {
  constructor(template, instanceId) {
    this.template = template;
    this.instanceId = instanceId;
    __publicField(this, "_objects", new import_dataverse14.Atom({}));
    __publicField(this, "_sequence");
    __publicField(this, "address");
    __publicField(this, "publicApi");
    __publicField(this, "project");
    __publicField(this, "objectsP", this._objects.pointer);
    __publicField(this, "type", "Theatre_Sheet");
    __publicField(this, "_logger");
    this._logger = template.project._logger.named("Sheet", instanceId);
    this._logger._trace("creating sheet");
    this.project = template.project;
    this.address = __spreadProps(__spreadValues({}, template.address), {
      sheetInstanceId: this.instanceId
    });
    this.publicApi = new TheatreSheet(this);
  }
  /**
   * @remarks At some point, we have to reconcile the concept of "an object"
   * with that of "an element."
   */
  createObject(objectKey, nativeObject, config, actions = {}) {
    const objTemplate = this.template.getObjectTemplate(objectKey, nativeObject, config, actions);
    const object = objTemplate.createInstance(this, nativeObject, config);
    this._objects.setByPointer(p2 => p2[objectKey], object);
    return object;
  }
  getObject(key) {
    return this._objects.get()[key];
  }
  deleteObject(objectKey) {
    this._objects.reduce(state => {
      const newState = __spreadValues({}, state);
      delete newState[objectKey];
      return newState;
    });
  }
  getSequence() {
    if (!this._sequence) {
      const lengthD = (0, import_dataverse14.prism)(() => {
        const unsanitized = (0, import_dataverse14.val)(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.length);
        return sanitizeSequenceLength(unsanitized);
      });
      const subUnitsPerUnitD = (0, import_dataverse14.prism)(() => {
        const unsanitized = (0, import_dataverse14.val)(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.subUnitsPerUnit);
        return sanitizeSequenceSubUnitsPerUnit(unsanitized);
      });
      this._sequence = new Sequence(this.template.project, this, lengthD, subUnitsPerUnitD);
    }
    return this._sequence;
  }
};
var sanitizeSequenceLength = len => typeof len === "number" && isFinite(len) && len > 0 ? len : 10;
var sanitizeSequenceSubUnitsPerUnit = subs => typeof subs === "number" && isInteger_default(subs) && subs >= 1 && subs <= 1e3 ? subs : 30;

// core/src/sheets/SheetTemplate.ts
var SheetTemplate = class {
  constructor(project, sheetId) {
    this.project = project;
    __publicField(this, "type", "Theatre_SheetTemplate");
    __publicField(this, "address");
    __publicField(this, "_instances", new import_dataverse15.Atom({}));
    __publicField(this, "instancesP", this._instances.pointer);
    __publicField(this, "_objectTemplates", new import_dataverse15.Atom({}));
    __publicField(this, "objectTemplatesP", this._objectTemplates.pointer);
    this.address = __spreadProps(__spreadValues({}, project.address), {
      sheetId
    });
  }
  getInstance(instanceId) {
    let inst = this._instances.get()[instanceId];
    if (!inst) {
      inst = new Sheet(this, instanceId);
      this._instances.setByPointer(p2 => p2[instanceId], inst);
    }
    return inst;
  }
  getObjectTemplate(objectKey, nativeObject, config, actions) {
    let template = this._objectTemplates.get()[objectKey];
    if (!template) {
      template = new SheetObjectTemplate(this, objectKey, nativeObject, config, actions);
      this._objectTemplates.setByPointer(p2 => p2[objectKey], template);
    }
    return template;
  }
};

// core/src/projects/Project.ts
var import_dataverse16 = require("@theatre/dataverse");
var import_dataverse17 = require("@theatre/dataverse");

// shared/src/utils/delay.ts
var delay = dur => new Promise(resolve => setTimeout(resolve, dur));
var delay_default = delay;

// ../node_modules/immer/dist/immer.esm.js
function n(n2) {
  for (var t2 = arguments.length, r2 = Array(t2 > 1 ? t2 - 1 : 0), e2 = 1; e2 < t2; e2++) r2[e2 - 1] = arguments[e2];
  if ("production" !== "development") {
    var i2 = Y[n2],
      o2 = i2 ? "function" == typeof i2 ? i2.apply(null, r2) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (r2.length ? " " + r2.map(function (n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function t(n2) {
  return !!n2 && !!n2[Q];
}
function r(n2) {
  return !!n2 && (function (n3) {
    if (!n3 || "object" != typeof n3) return false;
    var t2 = Object.getPrototypeOf(n3);
    if (null === t2) return true;
    var r2 = Object.hasOwnProperty.call(t2, "constructor") && t2.constructor;
    return r2 === Object || "function" == typeof r2 && Function.toString.call(r2) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!n2.constructor[L] || s(n2) || v(n2));
}
function e(r2) {
  return t(r2) || n(23, r2), r2[Q].t;
}
function i(n2, t2, r2) {
  void 0 === r2 && (r2 = false), 0 === o(n2) ? (r2 ? Object.keys : nn)(n2).forEach(function (e2) {
    r2 && "symbol" == typeof e2 || t2(e2, n2[e2], n2);
  }) : n2.forEach(function (r3, e2) {
    return t2(e2, r3, n2);
  });
}
function o(n2) {
  var t2 = n2[Q];
  return t2 ? t2.i > 3 ? t2.i - 4 : t2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, t2) {
  return 2 === o(n2) ? n2.has(t2) : Object.prototype.hasOwnProperty.call(n2, t2);
}
function a(n2, t2) {
  return 2 === o(n2) ? n2.get(t2) : n2[t2];
}
function f(n2, t2, r2) {
  var e2 = o(n2);
  2 === e2 ? n2.set(t2, r2) : 3 === e2 ? (n2.delete(t2), n2.add(r2)) : n2[t2] = r2;
}
function c(n2, t2) {
  return n2 === t2 ? 0 !== n2 || 1 / n2 == 1 / t2 : n2 != n2 && t2 != t2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2)) return Array.prototype.slice.call(n2);
  var t2 = tn(n2);
  delete t2[Q];
  for (var r2 = nn(t2), e2 = 0; e2 < r2.length; e2++) {
    var i2 = r2[e2],
      o2 = t2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (t2[i2] = {
      configurable: true,
      writable: true,
      enumerable: o2.enumerable,
      value: n2[i2]
    });
  }
  return Object.create(Object.getPrototypeOf(n2), t2);
}
function d(n2, e2) {
  return void 0 === e2 && (e2 = false), y(n2) || t(n2) || !r(n2) ? n2 : (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e2 && i(n2, function (n3, t2) {
    return d(t2, true);
  }, true), n2);
}
function h() {
  n(2);
}
function y(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b(t2) {
  var r2 = rn[t2];
  return r2 || n(18, t2), r2;
}
function _() {
  return "production" === "development" || U || n(0), U;
}
function j(n2, t2) {
  t2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = t2);
}
function O(n2) {
  g(n2), n2.p.forEach(S), n2.p = null;
}
function g(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = {
    p: [],
    l: U,
    h: n2,
    m: true,
    _: 0
  };
}
function S(n2) {
  var t2 = n2[Q];
  0 === t2.i || 1 === t2.i ? t2.j() : t2.O = true;
}
function P(t2, e2) {
  e2._ = e2.p.length;
  var i2 = e2.p[0],
    o2 = void 0 !== t2 && t2 !== i2;
  return e2.h.g || b("ES5").S(e2, t2, o2), o2 ? (i2[Q].P && (O(e2), n(4)), r(t2) && (t2 = M(e2, t2), e2.l || x(e2, t2)), e2.u && b("Patches").M(i2[Q], t2, e2.u, e2.s)) : t2 = M(e2, i2, []), O(e2), e2.u && e2.v(e2.u, e2.s), t2 !== H ? t2 : void 0;
}
function M(n2, t2, r2) {
  if (y(t2)) return t2;
  var e2 = t2[Q];
  if (!e2) return i(t2, function (i2, o3) {
    return A(n2, e2, t2, i2, o3, r2);
  }, true), t2;
  if (e2.A !== n2) return t2;
  if (!e2.P) return x(n2, e2.t, true), e2.t;
  if (!e2.I) {
    e2.I = true, e2.A._--;
    var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l(e2.k) : e2.o;
    i(3 === e2.i ? new Set(o2) : o2, function (t3, i2) {
      return A(n2, e2, o2, t3, i2, r2);
    }), x(n2, o2, false), r2 && n2.u && b("Patches").R(e2, r2, n2.u, n2.s);
  }
  return e2.o;
}
function A(e2, i2, o2, a2, c2, s2) {
  if ("production" !== "development" && c2 === o2 && n(5), t(c2)) {
    var v2 = M(e2, c2, s2 && i2 && 3 !== i2.i && !u(i2.D, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, v2), !t(v2)) return;
    e2.m = false;
  }
  if (r(c2) && !y(c2)) {
    if (!e2.h.F && e2._ < 1) return;
    M(e2, c2), i2 && i2.A.l || x(e2, c2);
  }
}
function x(n2, t2, r2) {
  void 0 === r2 && (r2 = false), n2.h.F && n2.m && d(t2, r2);
}
function z(n2, t2) {
  var r2 = n2[Q];
  return (r2 ? p(r2) : n2)[t2];
}
function I(n2, t2) {
  if (t2 in n2) for (var r2 = Object.getPrototypeOf(n2); r2;) {
    var e2 = Object.getOwnPropertyDescriptor(r2, t2);
    if (e2) return e2;
    r2 = Object.getPrototypeOf(r2);
  }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function R(n2, t2, r2) {
  var e2 = s(t2) ? b("MapSet").N(t2, r2) : v(t2) ? b("MapSet").T(t2, r2) : n2.g ? function (n3, t3) {
    var r3 = Array.isArray(n3),
      e3 = {
        i: r3 ? 1 : 0,
        A: t3 ? t3.A : _(),
        P: false,
        I: false,
        D: {},
        l: t3,
        t: n3,
        k: null,
        o: null,
        j: null,
        C: false
      },
      i2 = e3,
      o2 = en;
    r3 && (i2 = [e3], o2 = on);
    var u2 = Proxy.revocable(i2, o2),
      a2 = u2.revoke,
      f2 = u2.proxy;
    return e3.k = f2, e3.j = a2, f2;
  }(t2, r2) : b("ES5").J(t2, r2);
  return (r2 ? r2.A : _()).p.push(e2), e2;
}
function D(e2) {
  return t(e2) || n(22, e2), function n2(t2) {
    if (!r(t2)) return t2;
    var e3,
      u2 = t2[Q],
      c2 = o(t2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2))) return u2.t;
      u2.I = true, e3 = F(t2, c2), u2.I = false;
    } else e3 = F(t2, c2);
    return i(e3, function (t3, r2) {
      u2 && a(u2.t, t3) === r2 || f(e3, t3, n2(r2));
    }), 3 === c2 ? new Set(e3) : e3;
  }(e2);
}
function F(n2, t2) {
  switch (t2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = {
  0: "Illegal state",
  1: "Immer drafts cannot have computed properties",
  2: "This object has been frozen and should not be mutated",
  3: function (n2) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
  },
  4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  5: "Immer forbids circular references",
  6: "The first or second argument to `produce` must be a function",
  7: "The third argument to `produce` must be a function or undefined",
  8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
  10: "The given draft is already finalized",
  11: "Object.defineProperty() cannot be used on an Immer draft",
  12: "Object.setPrototypeOf() cannot be used on an Immer draft",
  13: "Immer only supports deleting array indices",
  14: "Immer only supports setting array indices and the 'length' property",
  15: function (n2) {
    return "Cannot apply patch, path doesn't resolve: " + n2;
  },
  16: 'Sets cannot have "replace" patches.',
  17: function (n2) {
    return "Unsupported patch operation: " + n2;
  },
  18: function (n2) {
    return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
  },
  20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
  21: function (n2) {
    return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
  },
  22: function (n2) {
    return "'current' expects a draft, got: " + n2;
  },
  23: function (n2) {
    return "'original' expects a draft, got: " + n2;
  },
  24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
};
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function (n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var tn = Object.getOwnPropertyDescriptors || function (n2) {
  var t2 = {};
  return nn(n2).forEach(function (r2) {
    t2[r2] = Object.getOwnPropertyDescriptor(n2, r2);
  }), t2;
};
var rn = {};
var en = {
  get: function (n2, t2) {
    if (t2 === Q) return n2;
    var e2 = p(n2);
    if (!u(e2, t2)) return function (n3, t3, r2) {
      var e3,
        i3 = I(t3, r2);
      return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
    }(n2, e2, t2);
    var i2 = e2[t2];
    return n2.I || !r(i2) ? i2 : i2 === z(n2.t, t2) ? (E(n2), n2.o[t2] = R(n2.A.h, i2, n2)) : i2;
  },
  has: function (n2, t2) {
    return t2 in p(n2);
  },
  ownKeys: function (n2) {
    return Reflect.ownKeys(p(n2));
  },
  set: function (n2, t2, r2) {
    var e2 = I(p(n2), t2);
    if (null == e2 ? void 0 : e2.set) return e2.set.call(n2.k, r2), true;
    if (!n2.P) {
      var i2 = z(p(n2), t2),
        o2 = null == i2 ? void 0 : i2[Q];
      if (o2 && o2.t === r2) return n2.o[t2] = r2, n2.D[t2] = false, true;
      if (c(r2, i2) && (void 0 !== r2 || u(n2.t, t2))) return true;
      E(n2), k(n2);
    }
    return n2.o[t2] === r2 && "number" != typeof r2 && (void 0 !== r2 || t2 in n2.o) || (n2.o[t2] = r2, n2.D[t2] = true, true);
  },
  deleteProperty: function (n2, t2) {
    return void 0 !== z(n2.t, t2) || t2 in n2.t ? (n2.D[t2] = false, E(n2), k(n2)) : delete n2.D[t2], n2.o && delete n2.o[t2], true;
  },
  getOwnPropertyDescriptor: function (n2, t2) {
    var r2 = p(n2),
      e2 = Reflect.getOwnPropertyDescriptor(r2, t2);
    return e2 ? {
      writable: true,
      configurable: 1 !== n2.i || "length" !== t2,
      enumerable: e2.enumerable,
      value: r2[t2]
    } : e2;
  },
  defineProperty: function () {
    n(11);
  },
  getPrototypeOf: function (n2) {
    return Object.getPrototypeOf(n2.t);
  },
  setPrototypeOf: function () {
    n(12);
  }
};
var on = {};
i(en, function (n2, t2) {
  on[n2] = function () {
    return arguments[0] = arguments[0][0], t2.apply(this, arguments);
  };
}), on.deleteProperty = function (t2, r2) {
  return "production" !== "development" && isNaN(parseInt(r2)) && n(13), en.deleteProperty.call(this, t2[0], r2);
}, on.set = function (t2, r2, e2) {
  return "production" !== "development" && "length" !== r2 && isNaN(parseInt(r2)) && n(14), en.set.call(this, t2[0], r2, e2, t2[0]);
};
var un = function () {
  function e2(t2) {
    var e3 = this;
    this.g = B, this.F = true, this.produce = function (t3, i3, o2) {
      if ("function" == typeof t3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = t3;
        var a2 = e3;
        return function (n2) {
          var t4 = this;
          void 0 === n2 && (n2 = u2);
          for (var r2 = arguments.length, e4 = Array(r2 > 1 ? r2 - 1 : 0), o3 = 1; o3 < r2; o3++) e4[o3 - 1] = arguments[o3];
          return a2.produce(n2, function (n3) {
            var r3;
            return (r3 = i3).call.apply(r3, [t4, n3].concat(e4));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), r(t3)) {
        var c2 = w(e3),
          s2 = R(e3, t3, void 0),
          v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? O(c2) : g(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function (n2) {
          return j(c2, o2), P(n2, c2);
        }, function (n2) {
          throw O(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!t3 || "object" != typeof t3) {
        if ((f2 = i3(t3)) === H) return;
        return void 0 === f2 && (f2 = t3), e3.F && d(f2, true), f2;
      }
      n(21, t3);
    }, this.produceWithPatches = function (n2, t3) {
      return "function" == typeof n2 ? function (t4) {
        for (var r3 = arguments.length, i4 = Array(r3 > 1 ? r3 - 1 : 0), o2 = 1; o2 < r3; o2++) i4[o2 - 1] = arguments[o2];
        return e3.produceWithPatches(t4, function (t5) {
          return n2.apply(void 0, [t5].concat(i4));
        });
      } : [e3.produce(n2, t3, function (n3, t4) {
        r2 = n3, i3 = t4;
      }), r2, i3];
      var r2, i3;
    }, "boolean" == typeof (null == t2 ? void 0 : t2.useProxies) && this.setUseProxies(t2.useProxies), "boolean" == typeof (null == t2 ? void 0 : t2.autoFreeze) && this.setAutoFreeze(t2.autoFreeze);
  }
  var i2 = e2.prototype;
  return i2.createDraft = function (e3) {
    r(e3) || n(8), t(e3) && (e3 = D(e3));
    var i3 = w(this),
      o2 = R(this, e3, void 0);
    return o2[Q].C = true, g(i3), o2;
  }, i2.finishDraft = function (t2, r2) {
    var e3 = t2 && t2[Q];
    "production" !== "development" && (e3 && e3.C || n(9), e3.I && n(10));
    var i3 = e3.A;
    return j(i3, r2), P(void 0, i3);
  }, i2.setAutoFreeze = function (n2) {
    this.F = n2;
  }, i2.setUseProxies = function (t2) {
    t2 && !B && n(20), this.g = t2;
  }, i2.applyPatches = function (n2, r2) {
    var e3;
    for (e3 = r2.length - 1; e3 >= 0; e3--) {
      var i3 = r2[e3];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    var o2 = b("Patches").$;
    return t(n2) ? o2(n2, r2) : this.produce(n2, function (n3) {
      return o2(n3, r2.slice(e3 + 1));
    });
  }, e2;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);

// shared/src/globals.ts
var globals = {
  /**
   * If the schema of the redux store changes in a backwards-incompatible way, then this version number should be incremented.
   *
   * While this looks like semver, it is not. There are no patch numbers, so any change in this number is a breaking change.
   *
   * However, as long as the schema of the redux store is backwards-compatible, then we don't have to change this number.
   *
   * Since the 0.4.0 release, this number has not had to change.
   */
  currentProjectStateDefinitionVersion: "0.4.0"
};
var globals_default = globals;

// core/src/projects/initialiseProjectState.ts
async function initialiseProjectState(studio, project, onDiskState) {
  await delay_default(0);
  studio.transaction(({
    drafts
  }) => {
    var _a;
    const projectId = project.address.projectId;
    drafts.ephemeral.coreByProject[projectId] = {
      lastExportedObject: null,
      loadingState: {
        type: "loading"
      }
    };
    drafts.ahistoric.coreByProject[projectId] = {
      ahistoricStuff: ""
    };
    function useInitialState() {
      drafts.ephemeral.coreByProject[projectId].loadingState = {
        type: "loaded"
      };
      drafts.historic.coreByProject[projectId] = {
        sheetsById: {},
        definitionVersion: globals_default.currentProjectStateDefinitionVersion,
        revisionHistory: []
      };
    }
    function useOnDiskState(state) {
      drafts.ephemeral.coreByProject[projectId].loadingState = {
        type: "loaded"
      };
      drafts.historic.coreByProject[projectId] = state;
    }
    function useBrowserState() {
      drafts.ephemeral.coreByProject[projectId].loadingState = {
        type: "loaded"
      };
    }
    function browserStateIsNotBasedOnDiskState(onDiskState2) {
      drafts.ephemeral.coreByProject[projectId].loadingState = {
        type: "browserStateIsNotBasedOnDiskState",
        onDiskState: onDiskState2
      };
    }
    const browserState = (_a = e(drafts.historic)) == null ? void 0 : _a.coreByProject[project.address.projectId];
    if (!browserState) {
      if (!onDiskState) {
        useInitialState();
      } else {
        useOnDiskState(onDiskState);
      }
    } else {
      if (!onDiskState) {
        useBrowserState();
      } else {
        if (browserState.revisionHistory.indexOf(onDiskState.revisionHistory[0]) == -1) {
          browserStateIsNotBasedOnDiskState(onDiskState);
        } else {
          useBrowserState();
        }
      }
    }
  });
}

// core/src/_coreLogger.ts
function noop2() {}
function _coreLogger(config) {
  var _a, _b;
  const internalMin = ((_a = config == null ? void 0 : config.logging) == null ? void 0 : _a.internal) ? (_b = config.logging.min) != null ? _b : 256 /* WARN */ : Infinity;
  const shouldDebugLogger = internalMin <= 128 /* DEBUG */;
  const shouldShowLoggerErrors = internalMin <= 512 /* ERROR */;
  const internal2 = createTheatreInternalLogger(void 0, {
    _debug: shouldDebugLogger ? console.debug.bind(console, "_coreLogger(TheatreInternalLogger) debug") : noop2,
    _error: shouldShowLoggerErrors ? console.error.bind(console, "_coreLogger(TheatreInternalLogger) error") : noop2
  });
  if (config) {
    const {
      logger,
      logging
    } = config;
    if (logger) internal2.configureLogger(logger);
    if (logging) internal2.configureLogging(logging);else {
      internal2.configureLogging({
        dev: "development" !== "production"
      });
    }
  }
  return internal2.getLogger().named("Theatre");
}

// core/src/projects/Project.ts
var Project = class {
  constructor(id, config = {}, publicApi) {
    this.config = config;
    this.publicApi = publicApi;
    __publicField(this, "pointers");
    __publicField(this, "_pointerProxies");
    __publicField(this, "address");
    __publicField(this, "_studioReadyDeferred");
    __publicField(this, "_assetStorageReadyDeferred");
    __publicField(this, "_readyPromise");
    __publicField(this, "_sheetTemplates", new import_dataverse17.Atom({}));
    __publicField(this, "sheetTemplatesP", this._sheetTemplates.pointer);
    __publicField(this, "_studio");
    __publicField(this, "assetStorage");
    __publicField(this, "type", "Theatre_Project");
    __publicField(this, "_logger");
    var _a;
    this._logger = _coreLogger({
      logging: {
        dev: true
      }
    }).named("Project", id);
    this._logger.traceDev("creating project");
    this.address = {
      projectId: id
    };
    const onDiskStateAtom = new import_dataverse17.Atom({
      ahistoric: {
        ahistoricStuff: ""
      },
      historic: (_a = config.state) != null ? _a : {
        sheetsById: {},
        definitionVersion: globals_default.currentProjectStateDefinitionVersion,
        revisionHistory: []
      },
      ephemeral: {
        loadingState: {
          type: "loaded"
        },
        lastExportedObject: null
      }
    });
    this._assetStorageReadyDeferred = defer();
    this.assetStorage = {
      getAssetUrl: assetId => {
        var _a2;
        return "".concat((_a2 = config.assets) == null ? void 0 : _a2.baseUrl, "/").concat(assetId);
      },
      // Until the asset storage is ready, we'll throw an error when the user tries to use it
      createAsset: () => {
        throw new Error("Please wait for Project.ready to use assets.");
      }
    };
    this._pointerProxies = {
      historic: new import_dataverse16.PointerProxy(onDiskStateAtom.pointer.historic),
      ahistoric: new import_dataverse16.PointerProxy(onDiskStateAtom.pointer.ahistoric),
      ephemeral: new import_dataverse16.PointerProxy(onDiskStateAtom.pointer.ephemeral)
    };
    this.pointers = {
      historic: this._pointerProxies.historic.pointer,
      ahistoric: this._pointerProxies.ahistoric.pointer,
      ephemeral: this._pointerProxies.ephemeral.pointer
    };
    projectsSingleton_default.add(id, this);
    this._studioReadyDeferred = defer();
    this._readyPromise = Promise.all([this._studioReadyDeferred.promise, this._assetStorageReadyDeferred.promise
    // hide the array from the user, i.e. make it Promise<void> instead of Promise<[undefined, undefined]>
    ]).then(() => {});
    if (config.state) {
      setTimeout(() => {
        if (!this._studio) {
          this._studioReadyDeferred.resolve(void 0);
          this._assetStorageReadyDeferred.resolve(void 0);
          this._logger._trace("ready deferred resolved with no state");
        }
      }, 0);
    } else {
      if (typeof window === "undefined") {
        if ("development" === "production") {
          console.error('Argument config.state in Theatre.getProject("'.concat(id, '", config) is empty. ') + "You can safely ignore this message if you're developing a Next.js/Remix project in development mode. But if you are shipping to your end-users, then you need to set config.state, otherwise your project's state will be empty and nothing will animate. Learn more at https://www.theatrejs.com/docs/latest/manual/projects#state");
        }
      } else {
        setTimeout(() => {
          if (!this._studio) {
            throw new Error('Argument config.state in Theatre.getProject("'.concat(id, '", config) is empty. This is fine ') + "while you are using @theatre/core along with @theatre/studio. But since @theatre/studio " + 'is not loaded, the state of project "'.concat(id, '" will be empty.\n\n') + "To fix this, you need to add @theatre/studio into the bundle and export the project's state. Learn how to do that at https://www.theatrejs.com/docs/latest/manual/projects#state\n");
          }
        }, 1e3);
      }
    }
  }
  attachToStudio(studio) {
    if (this._studio) {
      if (this._studio !== studio) {
        throw new Error("Project ".concat(this.address.projectId, " is already attached to studio ").concat(this._studio.address.studioId));
      } else {
        console.warn("Project ".concat(this.address.projectId, " is already attached to studio ").concat(this._studio.address.studioId));
        return;
      }
    }
    this._studio = studio;
    studio.initialized.then(async () => {
      var _a;
      await initialiseProjectState(studio, this, this.config.state);
      this._pointerProxies.historic.setPointer(studio.atomP.historic.coreByProject[this.address.projectId]);
      this._pointerProxies.ahistoric.setPointer(studio.atomP.ahistoric.coreByProject[this.address.projectId]);
      this._pointerProxies.ephemeral.setPointer(studio.atomP.ephemeral.coreByProject[this.address.projectId]);
      await studio.createAssetStorage(this, (_a = this.config.assets) == null ? void 0 : _a.baseUrl).then(assetStorage => {
        this.assetStorage = assetStorage;
        this._assetStorageReadyDeferred.resolve(void 0);
      });
      this._studioReadyDeferred.resolve(void 0);
    }).catch(err => {
      console.error(err);
      throw err;
    });
  }
  get isAttachedToStudio() {
    return !!this._studio;
  }
  get ready() {
    return this._readyPromise;
  }
  isReady() {
    return this._studioReadyDeferred.status === "resolved" && this._assetStorageReadyDeferred.status === "resolved";
  }
  getOrCreateSheet(sheetId, instanceId = "default") {
    let template = this._sheetTemplates.get()[sheetId];
    if (!template) {
      template = new SheetTemplate(this, sheetId);
      this._sheetTemplates.reduce(s2 => __spreadProps(__spreadValues({}, s2), {
        [sheetId]: template
      }));
    }
    return template.getInstance(instanceId);
  }
};

// shared/src/utils/sanitizers.ts
var _validateSym = (val8, thingy, range) => {
  if (typeof val8 !== "string") {
    return "".concat(thingy, " must be a string. ").concat(userReadableTypeOfValue_default(val8), " given.");
  } else if (val8.trim().length !== val8.length) {
    return "".concat(thingy, " must not have leading or trailing spaces. '").concat(val8, "' given.");
  } else if (val8.length < range[0] || val8.length > range[1]) {
    return "".concat(thingy, " must have between ").concat(range[0], " and ").concat(range[1], " characters. '").concat(val8, "' given.");
  }
};
var validateName = (name, thingy, shouldThrow = false) => {
  const result = _validateSym(name, thingy, [3, 32]);
  if (typeof result === "string" && shouldThrow) {
    throw new InvalidArgumentError(result);
  } else {
    return result;
  }
};
var validateInstanceId = (name, thingy, shouldThrow = false) => {
  const result = _validateSym(name, thingy, [1, 32]);
  if (typeof result === "string" && shouldThrow) {
    throw new InvalidArgumentError(result);
  } else {
    return result;
  }
};

// core/src/projects/TheatreProject.ts
var TheatreProject = class {
  get type() {
    return "Theatre_Project_PublicAPI";
  }
  /**
   * @internal
   */
  constructor(id, config = {}) {
    setPrivateAPI(this, new Project(id, config, this));
  }
  get ready() {
    return privateAPI(this).ready;
  }
  get isReady() {
    return privateAPI(this).isReady();
  }
  get address() {
    return __spreadValues({}, privateAPI(this).address);
  }
  getAssetUrl(asset) {
    if (!this.isReady) {
      console.error("Calling `project.getAssetUrl()` before `project.ready` is resolved, will always return `undefined`. Either use `project.ready.then(() => project.getAssetUrl())` or `await project.ready` before calling `project.getAssetUrl()`.");
      return void 0;
    }
    return asset.id ? privateAPI(this).assetStorage.getAssetUrl(asset.id) : void 0;
  }
  sheet(sheetId, instanceId = "default") {
    const sanitizedPath = validateAndSanitiseSlashedPathOrThrow(sheetId, "project.sheet");
    if ("development" !== "production") {
      validateInstanceId(instanceId, "instanceId in project.sheet(sheetId, instanceId)", true);
    }
    return privateAPI(this).getOrCreateSheet(sanitizedPath, instanceId).publicApi;
  }
};

// core/src/coreExports.ts
var import_fast_deep_equal2 = __toESM(require_fast_deep_equal());
var import_dataverse18 = require("@theatre/dataverse");
var import_dataverse19 = require("@theatre/dataverse");
function getProject(id, config = {}) {
  const existingProject = projectsSingleton_default.get(id);
  if (existingProject) {
    if ("development" !== "production") {
      if (!(0, import_fast_deep_equal2.default)(config, existingProject.config)) {
        throw new Error('You seem to have called Theatre.getProject("'.concat(id, '", config) twice, with different config objects. ') + "This is disallowed because changing the config of a project on the fly can lead to hard-to-debug issues.\n\nYou can fix this by either calling Theatre.getProject() once per projectId, or calling it multiple times but with the exact same config.");
      }
    }
    return existingProject.publicApi;
  }
  const rootLogger = _coreLogger();
  const plogger = rootLogger.named("Project", id);
  if ("development" !== "production") {
    validateName(id, "projectName in Theatre.getProject(projectName)", true);
    validateProjectIdOrThrow(id);
    plogger._debug("validated projectName", {
      projectName: id
    });
  }
  if (config.state) {
    if ("development" !== "production") {
      shallowValidateOnDiskState(id, config.state);
      plogger._debug("shallow validated config.state on disk");
    } else {
      deepValidateOnDiskState(id, config.state);
      plogger._debug("deep validated config.state on disk");
    }
  } else {
    plogger._debug("no config.state");
  }
  return new TheatreProject(id, config);
}
var shallowValidateOnDiskState = (projectId, s2) => {
  if (Array.isArray(s2) || s2 == null || s2.definitionVersion !== globals_default.currentProjectStateDefinitionVersion) {
    throw new InvalidArgumentError("Error validating conf.state in Theatre.getProject(".concat(JSON.stringify(projectId), ", conf). The state seems to be formatted in a way that is unreadable to Theatre.js. Read more at https://www.theatrejs.com/docs/latest/manual/projects#state"));
  }
};
var deepValidateOnDiskState = (projectId, s2) => {
  shallowValidateOnDiskState(projectId, s2);
};
var validateProjectIdOrThrow = value => {
  if (typeof value !== "string") {
    throw new InvalidArgumentError("Argument 'projectId' in `Theatre.getProject(projectId, ...)` must be a string. Instead, it was ".concat(userReadableTypeOfValue_default(value), "."));
  }
  const idTrimmed = value.trim();
  if (idTrimmed.length !== value.length) {
    throw new InvalidArgumentError("Argument 'projectId' in `Theatre.getProject(\"".concat(value, '", ...)` should not have surrounding whitespace.'));
  }
  if (idTrimmed.length < 3) {
    throw new InvalidArgumentError("Argument 'projectId' in `Theatre.getProject(\"".concat(value, '", ...)` should be at least 3 characters long.'));
  }
};
function onChange(pointer3, callback, rafDriver) {
  const ticker = rafDriver ? privateAPI(rafDriver).ticker : getCoreTicker();
  if ((0, import_dataverse18.isPointer)(pointer3)) {
    const pr = (0, import_dataverse19.pointerToPrism)(pointer3);
    return pr.onChange(ticker, callback, true);
  } else if ((0, import_dataverse19.isPrism)(pointer3)) {
    return pointer3.onChange(ticker, callback, true);
  } else {
    throw new Error("Called onChange(p) where p is neither a pointer nor a prism.");
  }
}
function val7(pointer3) {
  if ((0, import_dataverse18.isPointer)(pointer3)) {
    return (0, import_dataverse19.pointerToPrism)(pointer3).getValue();
  } else {
    throw new Error("Called val(p) where p is not a pointer.");
  }
}

// core/src/CoreBundle.ts
var CoreBundle = class {
  constructor() {
    __publicField(this, "_studio");
  }
  get type() {
    return "Theatre_CoreBundle";
  }
  get version() {
    return "0.7.2";
  }
  getBitsForStudio(studio, callback) {
    if (this._studio) {
      throw new Error("@theatre/core is already attached to @theatre/studio");
    }
    this._studio = studio;
    const bits = {
      projectsP: projectsSingleton_default.atom.pointer.projects,
      privateAPI,
      coreExports: coreExports_exports,
      getCoreRafDriver
    };
    callback(bits);
  }
};

// core/src/index.ts
registerCoreBundle();
function registerCoreBundle() {
  if (typeof window == "undefined") return;
  const existingBundle =
  // @ts-ignore ignore
  window[coreBundle];
  if (typeof existingBundle !== "undefined") {
    if (typeof existingBundle === "object" && existingBundle && typeof existingBundle.version === "string") {
      throw new Error("It seems that the module '@theatre/core' is loaded more than once. This could have two possible causes:\n1. You might have two separate versions of Theatre.js in node_modules.\n2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.\n\nNote that it **is okay** to import '@theatre/core' multiple times. But those imports should point to the same module.");
    } else {
      throw new Error("The variable window.".concat(coreBundle, " seems to be already set by a module other than @theatre/core."));
    }
  }
  const coreBundle2 = new CoreBundle();
  window[coreBundle] = coreBundle2;
  const possibleExistingStudioBundle =
  // @ts-ignore ignore
  window[studioBundle];
  if (possibleExistingStudioBundle && possibleExistingStudioBundle !== null && possibleExistingStudioBundle.type === "Theatre_StudioBundle") {
    possibleExistingStudioBundle.registerCoreBundle(coreBundle2);
  }
}
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
},{"@theatre/dataverse":"node_modules/@theatre/dataverse/dist/index.js"}],"assets/Homebg.theatre-project-state.json":[function(require,module,exports) {
module.exports = {
  "sheetsById": {
    "Scene1": {
      "staticOverrides": {
        "byObject": {}
      },
      "sequence": {
        "subUnitsPerUnit": 30,
        "length": 10,
        "type": "PositionalSequence",
        "tracksByObject": {
          "Distortion": {
            "trackData": {
              "ejTH5UBrGF": {
                "type": "BasicKeyframedTrack",
                "__debugName": "Distortion:[\"progress\"]",
                "keyframes": [{
                  "id": "I6QwVrd3wn",
                  "position": 0,
                  "connectedRight": true,
                  "handles": [0.5, 1, 0.15265724587287804, 0.9854195693292835],
                  "type": "bezier",
                  "value": 0.7911392405063291
                }, {
                  "id": "Y1w5_yHGqt",
                  "position": 2.467,
                  "connectedRight": true,
                  "handles": [0.5, 1, 0.5, 0],
                  "type": "bezier",
                  "value": 0
                }]
              }
            },
            "trackIdByPropPath": {
              "[\"progress\"]": "ejTH5UBrGF"
            }
          }
        }
      }
    }
  },
  "definitionVersion": "0.4.0",
  "revisionHistory": ["htckQ4mC08Zqcuap", "NSd0H8t1pYlfGjAZ"]
};
},{}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/base64-js/index.js","ieee754":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/ieee754/index.js","isarray":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/isarray/index.js","buffer":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/@theatre/studio/dist/index.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var define;
var Buffer = require("buffer").Buffer;
"use strict";

var wq = Object.create,
  xf = Object.freeze,
  L7 = Object.defineProperty,
  Bq = Object.defineProperties,
  yq = Object.getOwnPropertyDescriptor,
  Sq = Object.getOwnPropertyDescriptors,
  kq = Object.getOwnPropertyNames,
  ge = Object.getOwnPropertySymbols,
  Aq = Object.getPrototypeOf,
  hv = Object.prototype.hasOwnProperty,
  Cf = Object.prototype.propertyIsEnumerable;
var ov = (t, a) => {
    if (a = Symbol[t]) return a;
    throw Error("Symbol." + t + " is not defined");
  },
  vv = Math.pow,
  nv = (t, a, c) => a in t ? L7(t, a, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: c
  }) : t[a] = c,
  S = (t, a) => {
    for (var c in a || (a = {})) hv.call(a, c) && nv(t, c, a[c]);
    if (ge) for (var c of ge(a)) Cf.call(a, c) && nv(t, c, a[c]);
    return t;
  },
  D = (t, a) => Bq(t, Sq(a));
var m4 = (t, a) => {
  var c = {};
  for (var r in t) hv.call(t, r) && a.indexOf(r) < 0 && (c[r] = t[r]);
  if (t != null && ge) for (var r of ge(t)) a.indexOf(r) < 0 && Cf.call(t, r) && (c[r] = t[r]);
  return c;
};
var x = (t, a) => () => (t && (a = t(t = 0)), a);
var L1 = (t, a) => () => (a || t((a = {
    exports: {}
  }).exports, a), a.exports),
  Lf = (t, a) => {
    for (var c in a) L7(t, c, {
      get: a[c],
      enumerable: !0
    });
  },
  Hf = (t, a, c, r) => {
    if (a && typeof a == "object" || typeof a == "function") for (let e of kq(a)) !hv.call(t, e) && e !== c && L7(t, e, {
      get: () => a[e],
      enumerable: !(r = yq(a, e)) || r.enumerable
    });
    return t;
  };
var I = (t, a, c) => (c = t != null ? wq(Aq(t)) : {}, Hf(a || !t || !t.__esModule ? L7(c, "default", {
    value: t,
    enumerable: !0
  }) : c, t)),
  Rq = t => Hf(L7({}, "__esModule", {
    value: !0
  }), t);
var y1 = (t, a, c) => (nv(t, typeof a != "symbol" ? a + "" : a, c), c);
var V = (t, a) => xf(L7(t, "raw", {
    value: xf(a || t.slice())
  })),
  e2 = (t, a, c) => new Promise((r, e) => {
    var l = n => {
        try {
          o(c.next(n));
        } catch (h) {
          e(h);
        }
      },
      i = n => {
        try {
          o(c.throw(n));
        } catch (h) {
          e(h);
        }
      },
      o = n => n.done ? r(n.value) : Promise.resolve(n.value).then(l, i);
    o((c = c.apply(t, a)).next());
  }),
  bq = function (t, a) {
    this[0] = t, this[1] = a;
  };
var Vf = t => {
  var a = t[ov("asyncIterator")],
    c = !1,
    r,
    e = {};
  return a == null ? (a = t[ov("iterator")](), r = l => e[l] = i => a[l](i)) : (a = a.call(t), r = l => e[l] = i => {
    if (c) {
      if (c = !1, l === "throw") throw i;
      return i;
    }
    return c = !0, {
      done: !1,
      value: new bq(new Promise(o => {
        var n = a[l](i);
        if (!(n instanceof Object)) throw TypeError("Object expected");
        o(n);
      }), 1)
    };
  }), e[ov("iterator")] = () => e, r("next"), "throw" in a ? r("throw") : e.throw = l => {
    throw l;
  }, "return" in a && r("return"), e;
};
function Bf(t) {
  wf = t;
}
function T() {
  return wf;
}
var wf,
  f1 = x(() => {
    "use strict";
  });
function q5(t, a, c = []) {
  if (typeof t == "object" && t) {
    if (Fq(t) || Iq(t)) {
      a(t, c);
      return;
    }
    for (let [r, e] of Object.entries(t)) q5(e, a, [...c, r]);
  } else {
    if (t == null) return;
    a(t, c);
  }
}
var Fq,
  Iq,
  de = x(() => {
    "use strict";

    Fq = t => typeof t == "object" && t !== null && Object.hasOwnProperty.call(t, "type") && t.type === "image" && Object.hasOwnProperty.call(t, "id") && typeof t.id == "string" && t.id !== "", Iq = t => typeof t == "object" && t !== null && Object.hasOwnProperty.call(t, "r") && Object.hasOwnProperty.call(t, "g") && Object.hasOwnProperty.call(t, "b") && Object.hasOwnProperty.call(t, "a") && typeof t.r == "number" && typeof t.g == "number" && typeof t.b == "number" && typeof t.a == "number";
  });
function c5(t) {
  return a => typeof a == "object" && !!a && a.type === t;
}
var se,
  H7,
  yf,
  c0,
  Sf,
  kf,
  ul1,
  gv,
  dv,
  N5 = x(() => {
    "use strict";

    se = c5("Theatre_Project"), H7 = c5("Theatre_Sheet"), yf = c5("Theatre_SheetTemplate"), c0 = c5("Theatre_SheetObject"), Sf = c5("Theatre_Sequence"), kf = c5("Theatre_SheetObjectTemplate"), ul1 = c5("Theatre_Project_PublicAPI"), gv = c5("Theatre_Sheet_PublicAPI"), dv = c5("Theatre_SheetObject_PublicAPI");
  });
var Gq,
  ze,
  zv = x(() => {
    Gq = typeof global == "object" && global && global.Object === Object && global, ze = Gq;
  });
var Tq,
  Zq,
  g2,
  m3 = x(() => {
    zv();
    Tq = typeof self == "object" && self && self.Object === Object && self, Zq = ze || Tq || Function("return this")(), g2 = Zq;
  });
var Oq,
  p0,
  V7 = x(() => {
    m3();
    Oq = g2.Symbol, p0 = Oq;
  });
function Wq(t) {
  var a = Eq.call(t, ta),
    c = t[ta];
  try {
    t[ta] = void 0;
    var r = !0;
  } catch (l) {}
  var e = Dq.call(t);
  return r && (a ? t[ta] = c : delete t[ta]), e;
}
var Af,
  Eq,
  Dq,
  ta,
  Rf,
  bf = x(() => {
    V7();
    Af = Object.prototype, Eq = Af.hasOwnProperty, Dq = Af.toString, ta = p0 ? p0.toStringTag : void 0;
    Rf = Wq;
  });
function qq(t) {
  return jq.call(t);
}
var _q,
  jq,
  Ff,
  If = x(() => {
    _q = Object.prototype, jq = _q.toString;
    Ff = qq;
  });
function Kq(t) {
  return t == null ? t === void 0 ? Uq : Nq : Pf && Pf in Object(t) ? Rf(t) : Ff(t);
}
var Nq,
  Uq,
  Pf,
  q0,
  p8 = x(() => {
    V7();
    bf();
    If();
    Nq = "[object Null]", Uq = "[object Undefined]", Pf = p0 ? p0.toStringTag : void 0;
    q0 = Kq;
  });
function $q(t) {
  return t != null && typeof t == "object";
}
var N0,
  m8 = x(() => {
    N0 = $q;
  });
function Xq(t) {
  return typeof t == "symbol" || N0(t) && q0(t) == Qq;
}
var Qq,
  E3,
  w7 = x(() => {
    p8();
    m8();
    Qq = "[object Symbol]";
    E3 = Xq;
  });
function Yq(t, a) {
  for (var c = -1, r = t == null ? 0 : t.length, e = Array(r); ++c < r;) e[c] = a(t[c], c, t);
  return e;
}
var U5,
  ue = x(() => {
    U5 = Yq;
  });
var Jq,
  o2,
  f3 = x(() => {
    Jq = Array.isArray, o2 = Jq;
  });
function Zf(t) {
  if (typeof t == "string") return t;
  if (o2(t)) return U5(t, Zf) + "";
  if (E3(t)) return Tf ? Tf.call(t) : "";
  var a = t + "";
  return a == "0" && 1 / t == -tN ? "-0" : a;
}
var tN,
  Gf,
  Tf,
  Of,
  Ef = x(() => {
    V7();
    ue();
    f3();
    w7();
    tN = 1 / 0, Gf = p0 ? p0.prototype : void 0, Tf = Gf ? Gf.toString : void 0;
    Of = Zf;
  });
function cN(t) {
  for (var a = t.length; a-- && aN.test(t.charAt(a)););
  return a;
}
var aN,
  Df,
  Wf = x(() => {
    aN = /\s/;
    Df = cN;
  });
function eN(t) {
  return t && t.slice(0, Df(t) + 1).replace(rN, "");
}
var rN,
  _f,
  jf = x(() => {
    Wf();
    rN = /^\s+/;
    _f = eN;
  });
function lN(t) {
  var a = typeof t;
  return t != null && (a == "object" || a == "function");
}
var r0,
  K5 = x(() => {
    r0 = lN;
  });
function vN(t) {
  if (typeof t == "number") return t;
  if (E3(t)) return qf;
  if (r0(t)) {
    var a = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = r0(a) ? a + "" : a;
  }
  if (typeof t != "string") return t === 0 ? t : +t;
  t = _f(t);
  var c = oN.test(t);
  return c || nN.test(t) ? hN(t.slice(2), c ? 2 : 8) : iN.test(t) ? qf : +t;
}
var qf,
  iN,
  oN,
  nN,
  hN,
  U0,
  B7 = x(() => {
    jf();
    K5();
    w7();
    qf = 0 / 0, iN = /^[-+]0x[0-9a-f]+$/i, oN = /^0b[01]+$/i, nN = /^0o[0-7]+$/i, hN = parseInt;
    U0 = vN;
  });
function dN(t) {
  if (!t) return t === 0 ? t : 0;
  if (t = U0(t), t === Nf || t === -Nf) {
    var a = t < 0 ? -1 : 1;
    return a * gN;
  }
  return t === t ? t : 0;
}
var Nf,
  gN,
  aa,
  uv = x(() => {
    B7();
    Nf = 1 / 0, gN = 17976931348623157e292;
    aa = dN;
  });
function sN(t) {
  var a = aa(t),
    c = a % 1;
  return a === a ? c ? a - c : a : 0;
}
var $5,
  ca = x(() => {
    uv();
    $5 = sN;
  });
function zN(t) {
  return t;
}
var Q5,
  ra = x(() => {
    Q5 = zN;
  });
function MN(t) {
  if (!r0(t)) return !1;
  var a = q0(t);
  return a == pN || a == mN || a == uN || a == fN;
}
var uN,
  pN,
  mN,
  fN,
  pe,
  pv = x(() => {
    p8();
    K5();
    uN = "[object AsyncFunction]", pN = "[object Function]", mN = "[object GeneratorFunction]", fN = "[object Proxy]";
    pe = MN;
  });
var xN,
  me,
  Uf = x(() => {
    m3();
    xN = g2["__core-js_shared__"], me = xN;
  });
function CN(t) {
  return !!Kf && Kf in t;
}
var Kf,
  $f,
  Qf = x(() => {
    Uf();
    Kf = function () {
      var t = /[^.]+$/.exec(me && me.keys && me.keys.IE_PROTO || "");
      return t ? "Symbol(src)_1." + t : "";
    }();
    $f = CN;
  });
function VN(t) {
  if (t != null) {
    try {
      return HN.call(t);
    } catch (a) {}
    try {
      return t + "";
    } catch (a) {}
  }
  return "";
}
var LN,
  HN,
  r5,
  mv = x(() => {
    LN = Function.prototype, HN = LN.toString;
    r5 = VN;
  });
function bN(t) {
  if (!r0(t) || $f(t)) return !1;
  var a = pe(t) ? RN : BN;
  return a.test(r5(t));
}
var wN,
  BN,
  yN,
  SN,
  kN,
  AN,
  RN,
  Xf,
  Yf = x(() => {
    pv();
    Qf();
    K5();
    mv();
    wN = /[\\^$.*+?()[\]{}|]/g, BN = /^\[object .+?Constructor\]$/, yN = Function.prototype, SN = Object.prototype, kN = yN.toString, AN = SN.hasOwnProperty, RN = RegExp("^" + kN.call(AN).replace(wN, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    Xf = bN;
  });
function FN(t, a) {
  return t == null ? void 0 : t[a];
}
var Jf,
  tM = x(() => {
    Jf = FN;
  });
function IN(t, a) {
  var c = Jf(t, a);
  return Xf(c) ? c : void 0;
}
var w0,
  X5 = x(() => {
    Yf();
    tM();
    w0 = IN;
  });
var PN,
  fe,
  aM = x(() => {
    X5();
    m3();
    PN = w0(g2, "WeakMap"), fe = PN;
  });
function GN(t, a, c) {
  switch (c.length) {
    case 0:
      return t.call(a);
    case 1:
      return t.call(a, c[0]);
    case 2:
      return t.call(a, c[0], c[1]);
    case 3:
      return t.call(a, c[0], c[1], c[2]);
  }
  return t.apply(a, c);
}
var cM,
  rM = x(() => {
    cM = GN;
  });
function TN() {}
var eM,
  lM = x(() => {
    eM = TN;
  });
function ZN(t, a) {
  var c = -1,
    r = t.length;
  for (a || (a = Array(r)); ++c < r;) a[c] = t[c];
  return a;
}
var iM,
  oM = x(() => {
    iM = ZN;
  });
function WN(t) {
  var a = 0,
    c = 0;
  return function () {
    var r = DN(),
      e = EN - (r - c);
    if (c = r, e > 0) {
      if (++a >= ON) return arguments[0];
    } else a = 0;
    return t.apply(void 0, arguments);
  };
}
var ON,
  EN,
  DN,
  nM,
  hM = x(() => {
    ON = 800, EN = 16, DN = Date.now;
    nM = WN;
  });
function _N(t) {
  return function () {
    return t;
  };
}
var vM,
  gM = x(() => {
    vM = _N;
  });
var jN,
  y7,
  fv = x(() => {
    X5();
    jN = function () {
      try {
        var t = w0(Object, "defineProperty");
        return t({}, "", {}), t;
      } catch (a) {}
    }(), y7 = jN;
  });
var qN,
  dM,
  sM = x(() => {
    gM();
    fv();
    ra();
    qN = y7 ? function (t, a) {
      return y7(t, "toString", {
        configurable: !0,
        enumerable: !1,
        value: vM(a),
        writable: !0
      });
    } : Q5, dM = qN;
  });
var NN,
  zM,
  uM = x(() => {
    sM();
    hM();
    NN = nM(dM), zM = NN;
  });
function UN(t, a, c, r) {
  for (var e = t.length, l = c + (r ? 1 : -1); r ? l-- : ++l < e;) if (a(t[l], l, t)) return l;
  return -1;
}
var S7,
  Me = x(() => {
    S7 = UN;
  });
function KN(t) {
  return t !== t;
}
var pM,
  mM = x(() => {
    pM = KN;
  });
function $N(t, a, c) {
  for (var r = c - 1, e = t.length; ++r < e;) if (t[r] === a) return r;
  return -1;
}
var fM,
  MM = x(() => {
    fM = $N;
  });
function QN(t, a, c) {
  return a === a ? fM(t, a, c) : S7(t, pM, c);
}
var xe,
  Mv = x(() => {
    Me();
    mM();
    MM();
    xe = QN;
  });
function XN(t, a) {
  var c = t == null ? 0 : t.length;
  return !!c && xe(t, a, 0) > -1;
}
var xM,
  CM = x(() => {
    Mv();
    xM = XN;
  });
function tU(t, a) {
  var c = typeof t;
  return a = a == null ? YN : a, !!a && (c == "number" || c != "symbol" && JN.test(t)) && t > -1 && t % 1 == 0 && t < a;
}
var YN,
  JN,
  Y5,
  ea = x(() => {
    YN = 9007199254740991, JN = /^(?:0|[1-9]\d*)$/;
    Y5 = tU;
  });
function aU(t, a, c) {
  a == "__proto__" && y7 ? y7(t, a, {
    configurable: !0,
    enumerable: !0,
    value: c,
    writable: !0
  }) : t[a] = c;
}
var k7,
  Ce = x(() => {
    fv();
    k7 = aU;
  });
function cU(t, a) {
  return t === a || t !== t && a !== a;
}
var J5,
  la = x(() => {
    J5 = cU;
  });
function lU(t, a, c) {
  var r = t[a];
  (!(eU.call(t, a) && J5(r, c)) || c === void 0 && !(a in t)) && k7(t, a, c);
}
var rU,
  eU,
  LM,
  HM = x(() => {
    Ce();
    la();
    rU = Object.prototype, eU = rU.hasOwnProperty;
    LM = lU;
  });
function iU(t, a, c) {
  return a = VM(a === void 0 ? t.length - 1 : a, 0), function () {
    for (var r = arguments, e = -1, l = VM(r.length - a, 0), i = Array(l); ++e < l;) i[e] = r[a + e];
    e = -1;
    for (var o = Array(a + 1); ++e < a;) o[e] = r[e];
    return o[a] = c(i), cM(t, this, o);
  };
}
var VM,
  wM,
  BM = x(() => {
    rM();
    VM = Math.max;
    wM = iU;
  });
function oU(t, a) {
  return zM(wM(t, a, Q5), t + "");
}
var Le,
  xv = x(() => {
    ra();
    BM();
    uM();
    Le = oU;
  });
function hU(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= nU;
}
var nU,
  A7,
  He = x(() => {
    nU = 9007199254740991;
    A7 = hU;
  });
function vU(t) {
  return t != null && A7(t.length) && !pe(t);
}
var t6,
  ia = x(() => {
    pv();
    He();
    t6 = vU;
  });
function gU(t, a, c) {
  if (!r0(c)) return !1;
  var r = typeof a;
  return (r == "number" ? t6(c) && Y5(a, c.length) : r == "string" && a in c) ? J5(c[a], t) : !1;
}
var Cv,
  yM = x(() => {
    la();
    ia();
    ea();
    K5();
    Cv = gU;
  });
function sU(t) {
  var a = t && t.constructor,
    c = typeof a == "function" && a.prototype || dU;
  return t === c;
}
var dU,
  SM,
  kM = x(() => {
    dU = Object.prototype;
    SM = sU;
  });
function zU(t, a) {
  for (var c = -1, r = Array(t); ++c < t;) r[c] = a(c);
  return r;
}
var AM,
  RM = x(() => {
    AM = zU;
  });
function pU(t) {
  return N0(t) && q0(t) == uU;
}
var uU,
  Lv,
  bM = x(() => {
    p8();
    m8();
    uU = "[object Arguments]";
    Lv = pU;
  });
var FM,
  mU,
  fU,
  MU,
  R7,
  Ve = x(() => {
    bM();
    m8();
    FM = Object.prototype, mU = FM.hasOwnProperty, fU = FM.propertyIsEnumerable, MU = Lv(function () {
      return arguments;
    }()) ? Lv : function (t) {
      return N0(t) && mU.call(t, "callee") && !fU.call(t, "callee");
    }, R7 = MU;
  });
function xU() {
  return !1;
}
var IM,
  PM = x(() => {
    IM = xU;
  });
var ZM,
  GM,
  CU,
  TM,
  LU,
  HU,
  oa,
  Hv = x(() => {
    m3();
    PM();
    ZM = typeof exports == "object" && exports && !exports.nodeType && exports, GM = ZM && typeof module == "object" && module && !module.nodeType && module, CU = GM && GM.exports === ZM, TM = CU ? g2.Buffer : void 0, LU = TM ? TM.isBuffer : void 0, HU = LU || IM, oa = HU;
  });
function KU(t) {
  return N0(t) && A7(t.length) && !!J1[q0(t)];
}
var VU,
  wU,
  BU,
  yU,
  SU,
  kU,
  AU,
  RU,
  bU,
  FU,
  IU,
  PU,
  GU,
  TU,
  ZU,
  OU,
  EU,
  DU,
  WU,
  _U,
  jU,
  qU,
  NU,
  UU,
  J1,
  OM,
  EM = x(() => {
    p8();
    He();
    m8();
    VU = "[object Arguments]", wU = "[object Array]", BU = "[object Boolean]", yU = "[object Date]", SU = "[object Error]", kU = "[object Function]", AU = "[object Map]", RU = "[object Number]", bU = "[object Object]", FU = "[object RegExp]", IU = "[object Set]", PU = "[object String]", GU = "[object WeakMap]", TU = "[object ArrayBuffer]", ZU = "[object DataView]", OU = "[object Float32Array]", EU = "[object Float64Array]", DU = "[object Int8Array]", WU = "[object Int16Array]", _U = "[object Int32Array]", jU = "[object Uint8Array]", qU = "[object Uint8ClampedArray]", NU = "[object Uint16Array]", UU = "[object Uint32Array]", J1 = {};
    J1[OU] = J1[EU] = J1[DU] = J1[WU] = J1[_U] = J1[jU] = J1[qU] = J1[NU] = J1[UU] = !0;
    J1[VU] = J1[wU] = J1[TU] = J1[BU] = J1[ZU] = J1[yU] = J1[SU] = J1[kU] = J1[AU] = J1[RU] = J1[bU] = J1[FU] = J1[IU] = J1[PU] = J1[GU] = !1;
    OM = KU;
  });
function $U(t) {
  return function (a) {
    return t(a);
  };
}
var b7,
  we = x(() => {
    b7 = $U;
  });
var DM,
  na,
  QU,
  Vv,
  XU,
  wv,
  WM = x(() => {
    zv();
    DM = typeof exports == "object" && exports && !exports.nodeType && exports, na = DM && typeof module == "object" && module && !module.nodeType && module, QU = na && na.exports === DM, Vv = QU && ze.process, XU = function () {
      try {
        var t = na && na.require && na.require("util").types;
        return t || Vv && Vv.binding && Vv.binding("util");
      } catch (a) {}
    }(), wv = XU;
  });
var _M,
  YU,
  Be,
  Bv = x(() => {
    EM();
    we();
    WM();
    _M = wv && wv.isTypedArray, YU = _M ? b7(_M) : OM, Be = YU;
  });
function aK(t, a) {
  var c = o2(t),
    r = !c && R7(t),
    e = !c && !r && oa(t),
    l = !c && !r && !e && Be(t),
    i = c || r || e || l,
    o = i ? AM(t.length, String) : [],
    n = o.length;
  for (var h in t) (a || tK.call(t, h)) && !(i && (h == "length" || e && (h == "offset" || h == "parent") || l && (h == "buffer" || h == "byteLength" || h == "byteOffset") || Y5(h, n))) && o.push(h);
  return o;
}
var JU,
  tK,
  jM,
  qM = x(() => {
    RM();
    Ve();
    f3();
    Hv();
    ea();
    Bv();
    JU = Object.prototype, tK = JU.hasOwnProperty;
    jM = aK;
  });
function cK(t, a) {
  return function (c) {
    return t(a(c));
  };
}
var ye,
  yv = x(() => {
    ye = cK;
  });
var rK,
  NM,
  UM = x(() => {
    yv();
    rK = ye(Object.keys, Object), NM = rK;
  });
function iK(t) {
  if (!SM(t)) return NM(t);
  var a = [];
  for (var c in Object(t)) lK.call(t, c) && c != "constructor" && a.push(c);
  return a;
}
var eK,
  lK,
  KM,
  $M = x(() => {
    kM();
    UM();
    eK = Object.prototype, lK = eK.hasOwnProperty;
    KM = iK;
  });
function oK(t) {
  return t6(t) ? jM(t) : KM(t);
}
var F7,
  Se = x(() => {
    qM();
    $M();
    ia();
    F7 = oK;
  });
function vK(t, a) {
  if (o2(t)) return !1;
  var c = typeof t;
  return c == "number" || c == "symbol" || c == "boolean" || t == null || E3(t) ? !0 : hK.test(t) || !nK.test(t) || a != null && t in Object(a);
}
var nK,
  hK,
  I7,
  ke = x(() => {
    f3();
    w7();
    nK = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, hK = /^\w*$/;
    I7 = vK;
  });
var gK,
  e5,
  ha = x(() => {
    X5();
    gK = w0(Object, "create"), e5 = gK;
  });
function dK() {
  this.__data__ = e5 ? e5(null) : {}, this.size = 0;
}
var QM,
  XM = x(() => {
    ha();
    QM = dK;
  });
function sK(t) {
  var a = this.has(t) && delete this.__data__[t];
  return this.size -= a ? 1 : 0, a;
}
var YM,
  JM = x(() => {
    YM = sK;
  });
function mK(t) {
  var a = this.__data__;
  if (e5) {
    var c = a[t];
    return c === zK ? void 0 : c;
  }
  return pK.call(a, t) ? a[t] : void 0;
}
var zK,
  uK,
  pK,
  tx,
  ax = x(() => {
    ha();
    zK = "__lodash_hash_undefined__", uK = Object.prototype, pK = uK.hasOwnProperty;
    tx = mK;
  });
function xK(t) {
  var a = this.__data__;
  return e5 ? a[t] !== void 0 : MK.call(a, t);
}
var fK,
  MK,
  cx,
  rx = x(() => {
    ha();
    fK = Object.prototype, MK = fK.hasOwnProperty;
    cx = xK;
  });
function LK(t, a) {
  var c = this.__data__;
  return this.size += this.has(t) ? 0 : 1, c[t] = e5 && a === void 0 ? CK : a, this;
}
var CK,
  ex,
  lx = x(() => {
    ha();
    CK = "__lodash_hash_undefined__";
    ex = LK;
  });
function P7(t) {
  var a = -1,
    c = t == null ? 0 : t.length;
  for (this.clear(); ++a < c;) {
    var r = t[a];
    this.set(r[0], r[1]);
  }
}
var Sv,
  ix = x(() => {
    XM();
    JM();
    ax();
    rx();
    lx();
    P7.prototype.clear = QM;
    P7.prototype.delete = YM;
    P7.prototype.get = tx;
    P7.prototype.has = cx;
    P7.prototype.set = ex;
    Sv = P7;
  });
function HK() {
  this.__data__ = [], this.size = 0;
}
var ox,
  nx = x(() => {
    ox = HK;
  });
function VK(t, a) {
  for (var c = t.length; c--;) if (J5(t[c][0], a)) return c;
  return -1;
}
var a6,
  va = x(() => {
    la();
    a6 = VK;
  });
function yK(t) {
  var a = this.__data__,
    c = a6(a, t);
  if (c < 0) return !1;
  var r = a.length - 1;
  return c == r ? a.pop() : BK.call(a, c, 1), --this.size, !0;
}
var wK,
  BK,
  hx,
  vx = x(() => {
    va();
    wK = Array.prototype, BK = wK.splice;
    hx = yK;
  });
function SK(t) {
  var a = this.__data__,
    c = a6(a, t);
  return c < 0 ? void 0 : a[c][1];
}
var gx,
  dx = x(() => {
    va();
    gx = SK;
  });
function kK(t) {
  return a6(this.__data__, t) > -1;
}
var sx,
  zx = x(() => {
    va();
    sx = kK;
  });
function AK(t, a) {
  var c = this.__data__,
    r = a6(c, t);
  return r < 0 ? (++this.size, c.push([t, a])) : c[r][1] = a, this;
}
var ux,
  px = x(() => {
    va();
    ux = AK;
  });
function G7(t) {
  var a = -1,
    c = t == null ? 0 : t.length;
  for (this.clear(); ++a < c;) {
    var r = t[a];
    this.set(r[0], r[1]);
  }
}
var c6,
  ga = x(() => {
    nx();
    vx();
    dx();
    zx();
    px();
    G7.prototype.clear = ox;
    G7.prototype.delete = hx;
    G7.prototype.get = gx;
    G7.prototype.has = sx;
    G7.prototype.set = ux;
    c6 = G7;
  });
var RK,
  r6,
  Ae = x(() => {
    X5();
    m3();
    RK = w0(g2, "Map"), r6 = RK;
  });
function bK() {
  this.size = 0, this.__data__ = {
    hash: new Sv(),
    map: new (r6 || c6)(),
    string: new Sv()
  };
}
var mx,
  fx = x(() => {
    ix();
    ga();
    Ae();
    mx = bK;
  });
function FK(t) {
  var a = typeof t;
  return a == "string" || a == "number" || a == "symbol" || a == "boolean" ? t !== "__proto__" : t === null;
}
var Mx,
  xx = x(() => {
    Mx = FK;
  });
function IK(t, a) {
  var c = t.__data__;
  return Mx(a) ? c[typeof a == "string" ? "string" : "hash"] : c.map;
}
var e6,
  da = x(() => {
    xx();
    e6 = IK;
  });
function PK(t) {
  var a = e6(this, t).delete(t);
  return this.size -= a ? 1 : 0, a;
}
var Cx,
  Lx = x(() => {
    da();
    Cx = PK;
  });
function GK(t) {
  return e6(this, t).get(t);
}
var Hx,
  Vx = x(() => {
    da();
    Hx = GK;
  });
function TK(t) {
  return e6(this, t).has(t);
}
var wx,
  Bx = x(() => {
    da();
    wx = TK;
  });
function ZK(t, a) {
  var c = e6(this, t),
    r = c.size;
  return c.set(t, a), this.size += c.size == r ? 0 : 1, this;
}
var yx,
  Sx = x(() => {
    da();
    yx = ZK;
  });
function T7(t) {
  var a = -1,
    c = t == null ? 0 : t.length;
  for (this.clear(); ++a < c;) {
    var r = t[a];
    this.set(r[0], r[1]);
  }
}
var f8,
  Re = x(() => {
    fx();
    Lx();
    Vx();
    Bx();
    Sx();
    T7.prototype.clear = mx;
    T7.prototype.delete = Cx;
    T7.prototype.get = Hx;
    T7.prototype.has = wx;
    T7.prototype.set = yx;
    f8 = T7;
  });
function kv(t, a) {
  if (typeof t != "function" || a != null && typeof a != "function") throw new TypeError(OK);
  var c = function () {
    var r = arguments,
      e = a ? a.apply(this, r) : r[0],
      l = c.cache;
    if (l.has(e)) return l.get(e);
    var i = t.apply(this, r);
    return c.cache = l.set(e, i) || l, i;
  };
  return c.cache = new (kv.Cache || f8)(), c;
}
var OK,
  sa,
  Av = x(() => {
    Re();
    OK = "Expected a function";
    kv.Cache = f8;
    sa = kv;
  });
function DK(t) {
  var a = sa(t, function (r) {
      return c.size === EK && c.clear(), r;
    }),
    c = a.cache;
  return a;
}
var EK,
  kx,
  Ax = x(() => {
    Av();
    EK = 500;
    kx = DK;
  });
var WK,
  _K,
  jK,
  Rx,
  bx = x(() => {
    Ax();
    WK = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, _K = /\\(\\)?/g, jK = kx(function (t) {
      var a = [];
      return t.charCodeAt(0) === 46 && a.push(""), t.replace(WK, function (c, r, e, l) {
        a.push(e ? l.replace(_K, "$1") : r || c);
      }), a;
    }), Rx = jK;
  });
function qK(t) {
  return t == null ? "" : Of(t);
}
var za,
  Rv = x(() => {
    Ef();
    za = qK;
  });
function NK(t, a) {
  return o2(t) ? t : I7(t, a) ? [t] : Rx(za(t));
}
var Z7,
  be = x(() => {
    f3();
    ke();
    bx();
    Rv();
    Z7 = NK;
  });
function KK(t) {
  if (typeof t == "string" || E3(t)) return t;
  var a = t + "";
  return a == "0" && 1 / t == -UK ? "-0" : a;
}
var UK,
  f4,
  O7 = x(() => {
    w7();
    UK = 1 / 0;
    f4 = KK;
  });
function $K(t, a) {
  a = Z7(a, t);
  for (var c = 0, r = a.length; t != null && c < r;) t = t[f4(a[c++])];
  return c && c == r ? t : void 0;
}
var E7,
  Fe = x(() => {
    be();
    O7();
    E7 = $K;
  });
function QK(t, a, c) {
  var r = t == null ? void 0 : E7(t, a);
  return r === void 0 ? c : r;
}
var D3,
  D7 = x(() => {
    Fe();
    D3 = QK;
  });
function XK(t, a) {
  for (var c = -1, r = a.length, e = t.length; ++c < r;) t[e + c] = a[c];
  return t;
}
var Ie,
  bv = x(() => {
    Ie = XK;
  });
function YK(t) {
  return o2(t) || R7(t) || !!(Fx && t && t[Fx]);
}
var Fx,
  Ix,
  Px = x(() => {
    V7();
    Ve();
    f3();
    Fx = p0 ? p0.isConcatSpreadable : void 0;
    Ix = YK;
  });
function Gx(t, a, c, r, e) {
  var l = -1,
    i = t.length;
  for (c || (c = Ix), e || (e = []); ++l < i;) {
    var o = t[l];
    a > 0 && c(o) ? a > 1 ? Gx(o, a - 1, c, r, e) : Ie(e, o) : r || (e[e.length] = o);
  }
  return e;
}
var Tx,
  Zx = x(() => {
    bv();
    Px();
    Tx = Gx;
  });
var JK,
  Ox,
  Ex = x(() => {
    yv();
    JK = ye(Object.getPrototypeOf, Object), Ox = JK;
  });
function l$(t) {
  if (!N0(t) || q0(t) != t$) return !1;
  var a = Ox(t);
  if (a === null) return !0;
  var c = r$.call(a, "constructor") && a.constructor;
  return typeof c == "function" && c instanceof c && Dx.call(c) == e$;
}
var t$,
  a$,
  c$,
  Dx,
  r$,
  e$,
  M8,
  Fv = x(() => {
    p8();
    Ex();
    m8();
    t$ = "[object Object]", a$ = Function.prototype, c$ = Object.prototype, Dx = a$.toString, r$ = c$.hasOwnProperty, e$ = Dx.call(Object);
    M8 = l$;
  });
function n$(t) {
  var a = Math[t];
  return function (c, r) {
    if (c = U0(c), r = r == null ? 0 : o$($5(r), 292), r && i$(c)) {
      var e = (za(c) + "e").split("e"),
        l = a(e[0] + "e" + (+e[1] + r));
      return e = (za(l) + "e").split("e"), +(e[0] + "e" + (+e[1] - r));
    }
    return a(c);
  };
}
var i$,
  o$,
  Wx,
  _x = x(() => {
    m3();
    ca();
    B7();
    Rv();
    i$ = g2.isFinite, o$ = Math.min;
    Wx = n$;
  });
function h$(t, a, c) {
  return t === t && (c !== void 0 && (t = t <= c ? t : c), a !== void 0 && (t = t >= a ? t : a)), t;
}
var jx,
  qx = x(() => {
    jx = h$;
  });
function v$(t, a, c) {
  return c === void 0 && (c = a, a = void 0), c !== void 0 && (c = U0(c), c = c === c ? c : 0), a !== void 0 && (a = U0(a), a = a === a ? a : 0), jx(U0(t), a, c);
}
var b1,
  ua = x(() => {
    qx();
    B7();
    b1 = v$;
  });
function g$() {
  this.__data__ = new c6(), this.size = 0;
}
var Nx,
  Ux = x(() => {
    ga();
    Nx = g$;
  });
function d$(t) {
  var a = this.__data__,
    c = a.delete(t);
  return this.size = a.size, c;
}
var Kx,
  $x = x(() => {
    Kx = d$;
  });
function s$(t) {
  return this.__data__.get(t);
}
var Qx,
  Xx = x(() => {
    Qx = s$;
  });
function z$(t) {
  return this.__data__.has(t);
}
var Yx,
  Jx = x(() => {
    Yx = z$;
  });
function p$(t, a) {
  var c = this.__data__;
  if (c instanceof c6) {
    var r = c.__data__;
    if (!r6 || r.length < u$ - 1) return r.push([t, a]), this.size = ++c.size, this;
    c = this.__data__ = new f8(r);
  }
  return c.set(t, a), this.size = c.size, this;
}
var u$,
  tC,
  aC = x(() => {
    ga();
    Ae();
    Re();
    u$ = 200;
    tC = p$;
  });
function W7(t) {
  var a = this.__data__ = new c6(t);
  this.size = a.size;
}
var _7,
  Iv = x(() => {
    ga();
    Ux();
    $x();
    Xx();
    Jx();
    aC();
    W7.prototype.clear = Nx;
    W7.prototype.delete = Kx;
    W7.prototype.get = Qx;
    W7.prototype.has = Yx;
    W7.prototype.set = tC;
    _7 = W7;
  });
function m$(t, a) {
  for (var c = -1, r = t == null ? 0 : t.length, e = 0, l = []; ++c < r;) {
    var i = t[c];
    a(i, c, t) && (l[e++] = i);
  }
  return l;
}
var cC,
  rC = x(() => {
    cC = m$;
  });
function f$() {
  return [];
}
var eC,
  lC = x(() => {
    eC = f$;
  });
var M$,
  x$,
  iC,
  C$,
  oC,
  nC = x(() => {
    rC();
    lC();
    M$ = Object.prototype, x$ = M$.propertyIsEnumerable, iC = Object.getOwnPropertySymbols, C$ = iC ? function (t) {
      return t == null ? [] : (t = Object(t), cC(iC(t), function (a) {
        return x$.call(t, a);
      }));
    } : eC, oC = C$;
  });
function L$(t, a, c) {
  var r = a(t);
  return o2(t) ? r : Ie(r, c(t));
}
var hC,
  vC = x(() => {
    bv();
    f3();
    hC = L$;
  });
function H$(t) {
  return hC(t, F7, oC);
}
var Pv,
  gC = x(() => {
    vC();
    nC();
    Se();
    Pv = H$;
  });
var V$,
  Pe,
  dC = x(() => {
    X5();
    m3();
    V$ = w0(g2, "DataView"), Pe = V$;
  });
var w$,
  Ge,
  sC = x(() => {
    X5();
    m3();
    w$ = w0(g2, "Promise"), Ge = w$;
  });
var B$,
  l6,
  Gv = x(() => {
    X5();
    m3();
    B$ = w0(g2, "Set"), l6 = B$;
  });
var zC,
  y$,
  uC,
  pC,
  mC,
  fC,
  S$,
  k$,
  A$,
  R$,
  b$,
  x8,
  Tv,
  MC = x(() => {
    dC();
    Ae();
    sC();
    Gv();
    aM();
    p8();
    mv();
    zC = "[object Map]", y$ = "[object Object]", uC = "[object Promise]", pC = "[object Set]", mC = "[object WeakMap]", fC = "[object DataView]", S$ = r5(Pe), k$ = r5(r6), A$ = r5(Ge), R$ = r5(l6), b$ = r5(fe), x8 = q0;
    (Pe && x8(new Pe(new ArrayBuffer(1))) != fC || r6 && x8(new r6()) != zC || Ge && x8(Ge.resolve()) != uC || l6 && x8(new l6()) != pC || fe && x8(new fe()) != mC) && (x8 = function (t) {
      var a = q0(t),
        c = a == y$ ? t.constructor : void 0,
        r = c ? r5(c) : "";
      if (r) switch (r) {
        case S$:
          return fC;
        case k$:
          return zC;
        case A$:
          return uC;
        case R$:
          return pC;
        case b$:
          return mC;
      }
      return a;
    });
    Tv = x8;
  });
var F$,
  Zv,
  xC = x(() => {
    m3();
    F$ = g2.Uint8Array, Zv = F$;
  });
function P$(t) {
  return this.__data__.set(t, I$), this;
}
var I$,
  CC,
  LC = x(() => {
    I$ = "__lodash_hash_undefined__";
    CC = P$;
  });
function G$(t) {
  return this.__data__.has(t);
}
var HC,
  VC = x(() => {
    HC = G$;
  });
function Te(t) {
  var a = -1,
    c = t == null ? 0 : t.length;
  for (this.__data__ = new f8(); ++a < c;) this.add(t[a]);
}
var Ze,
  Ov = x(() => {
    Re();
    LC();
    VC();
    Te.prototype.add = Te.prototype.push = CC;
    Te.prototype.has = HC;
    Ze = Te;
  });
function T$(t, a) {
  for (var c = -1, r = t == null ? 0 : t.length; ++c < r;) if (a(t[c], c, t)) return !0;
  return !1;
}
var wC,
  BC = x(() => {
    wC = T$;
  });
function Z$(t, a) {
  return t.has(a);
}
var Oe,
  Ev = x(() => {
    Oe = Z$;
  });
function D$(t, a, c, r, e, l) {
  var i = c & O$,
    o = t.length,
    n = a.length;
  if (o != n && !(i && n > o)) return !1;
  var h = l.get(t),
    v = l.get(a);
  if (h && v) return h == a && v == t;
  var g = -1,
    s = !0,
    d = c & E$ ? new Ze() : void 0;
  for (l.set(t, a), l.set(a, t); ++g < o;) {
    var z = t[g],
      u = a[g];
    if (r) var f = i ? r(u, z, g, a, t, l) : r(z, u, g, t, a, l);
    if (f !== void 0) {
      if (f) continue;
      s = !1;
      break;
    }
    if (d) {
      if (!wC(a, function (p, m) {
        if (!Oe(d, m) && (z === p || e(z, p, c, r, l))) return d.push(m);
      })) {
        s = !1;
        break;
      }
    } else if (!(z === u || e(z, u, c, r, l))) {
      s = !1;
      break;
    }
  }
  return l.delete(t), l.delete(a), s;
}
var O$,
  E$,
  Ee,
  Dv = x(() => {
    Ov();
    BC();
    Ev();
    O$ = 1, E$ = 2;
    Ee = D$;
  });
function W$(t) {
  var a = -1,
    c = Array(t.size);
  return t.forEach(function (r, e) {
    c[++a] = [e, r];
  }), c;
}
var yC,
  SC = x(() => {
    yC = W$;
  });
function _$(t) {
  var a = -1,
    c = Array(t.size);
  return t.forEach(function (r) {
    c[++a] = r;
  }), c;
}
var j7,
  De = x(() => {
    j7 = _$;
  });
function rQ(t, a, c, r, e, l, i) {
  switch (c) {
    case cQ:
      if (t.byteLength != a.byteLength || t.byteOffset != a.byteOffset) return !1;
      t = t.buffer, a = a.buffer;
    case aQ:
      return !(t.byteLength != a.byteLength || !l(new Zv(t), new Zv(a)));
    case N$:
    case U$:
    case Q$:
      return J5(+t, +a);
    case K$:
      return t.name == a.name && t.message == a.message;
    case X$:
    case J$:
      return t == a + "";
    case $$:
      var o = yC;
    case Y$:
      var n = r & j$;
      if (o || (o = j7), t.size != a.size && !n) return !1;
      var h = i.get(t);
      if (h) return h == a;
      r |= q$, i.set(t, a);
      var v = Ee(o(t), o(a), r, e, l, i);
      return i.delete(t), v;
    case tQ:
      if (Wv) return Wv.call(t) == Wv.call(a);
  }
  return !1;
}
var j$,
  q$,
  N$,
  U$,
  K$,
  $$,
  Q$,
  X$,
  Y$,
  J$,
  tQ,
  aQ,
  cQ,
  kC,
  Wv,
  AC,
  RC = x(() => {
    V7();
    xC();
    la();
    Dv();
    SC();
    De();
    j$ = 1, q$ = 2, N$ = "[object Boolean]", U$ = "[object Date]", K$ = "[object Error]", $$ = "[object Map]", Q$ = "[object Number]", X$ = "[object RegExp]", Y$ = "[object Set]", J$ = "[object String]", tQ = "[object Symbol]", aQ = "[object ArrayBuffer]", cQ = "[object DataView]", kC = p0 ? p0.prototype : void 0, Wv = kC ? kC.valueOf : void 0;
    AC = rQ;
  });
function oQ(t, a, c, r, e, l) {
  var i = c & eQ,
    o = Pv(t),
    n = o.length,
    h = Pv(a),
    v = h.length;
  if (n != v && !i) return !1;
  for (var g = n; g--;) {
    var s = o[g];
    if (!(i ? s in a : iQ.call(a, s))) return !1;
  }
  var d = l.get(t),
    z = l.get(a);
  if (d && z) return d == a && z == t;
  var u = !0;
  l.set(t, a), l.set(a, t);
  for (var f = i; ++g < n;) {
    s = o[g];
    var p = t[s],
      m = a[s];
    if (r) var M = i ? r(m, p, s, a, t, l) : r(p, m, s, t, a, l);
    if (!(M === void 0 ? p === m || e(p, m, c, r, l) : M)) {
      u = !1;
      break;
    }
    f || (f = s == "constructor");
  }
  if (u && !f) {
    var w = t.constructor,
      H = a.constructor;
    w != H && "constructor" in t && "constructor" in a && !(typeof w == "function" && w instanceof w && typeof H == "function" && H instanceof H) && (u = !1);
  }
  return l.delete(t), l.delete(a), u;
}
var eQ,
  lQ,
  iQ,
  bC,
  FC = x(() => {
    gC();
    eQ = 1, lQ = Object.prototype, iQ = lQ.hasOwnProperty;
    bC = oQ;
  });
function vQ(t, a, c, r, e, l) {
  var i = o2(t),
    o = o2(a),
    n = i ? PC : Tv(t),
    h = o ? PC : Tv(a);
  n = n == IC ? We : n, h = h == IC ? We : h;
  var v = n == We,
    g = h == We,
    s = n == h;
  if (s && oa(t)) {
    if (!oa(a)) return !1;
    i = !0, v = !1;
  }
  if (s && !v) return l || (l = new _7()), i || Be(t) ? Ee(t, a, c, r, e, l) : AC(t, a, n, c, r, e, l);
  if (!(c & nQ)) {
    var d = v && GC.call(t, "__wrapped__"),
      z = g && GC.call(a, "__wrapped__");
    if (d || z) {
      var u = d ? t.value() : t,
        f = z ? a.value() : a;
      return l || (l = new _7()), e(u, f, c, r, l);
    }
  }
  return s ? (l || (l = new _7()), bC(t, a, c, r, e, l)) : !1;
}
var nQ,
  IC,
  PC,
  We,
  hQ,
  GC,
  TC,
  ZC = x(() => {
    Iv();
    Dv();
    RC();
    FC();
    MC();
    f3();
    Hv();
    Bv();
    nQ = 1, IC = "[object Arguments]", PC = "[object Array]", We = "[object Object]", hQ = Object.prototype, GC = hQ.hasOwnProperty;
    TC = vQ;
  });
function OC(t, a, c, r, e) {
  return t === a ? !0 : t == null || a == null || !N0(t) && !N0(a) ? t !== t && a !== a : TC(t, a, c, r, OC, e);
}
var _e,
  _v = x(() => {
    ZC();
    m8();
    _e = OC;
  });
function sQ(t, a, c, r) {
  var e = c.length,
    l = e,
    i = !r;
  if (t == null) return !l;
  for (t = Object(t); e--;) {
    var o = c[e];
    if (i && o[2] ? o[1] !== t[o[0]] : !(o[0] in t)) return !1;
  }
  for (; ++e < l;) {
    o = c[e];
    var n = o[0],
      h = t[n],
      v = o[1];
    if (i && o[2]) {
      if (h === void 0 && !(n in t)) return !1;
    } else {
      var g = new _7();
      if (r) var s = r(h, v, n, t, a, g);
      if (!(s === void 0 ? _e(v, h, gQ | dQ, r, g) : s)) return !1;
    }
  }
  return !0;
}
var gQ,
  dQ,
  EC,
  DC = x(() => {
    Iv();
    _v();
    gQ = 1, dQ = 2;
    EC = sQ;
  });
function zQ(t) {
  return t === t && !r0(t);
}
var je,
  jv = x(() => {
    K5();
    je = zQ;
  });
function uQ(t) {
  for (var a = F7(t), c = a.length; c--;) {
    var r = a[c],
      e = t[r];
    a[c] = [r, e, je(e)];
  }
  return a;
}
var WC,
  _C = x(() => {
    jv();
    Se();
    WC = uQ;
  });
function pQ(t, a) {
  return function (c) {
    return c == null ? !1 : c[t] === a && (a !== void 0 || t in Object(c));
  };
}
var qe,
  qv = x(() => {
    qe = pQ;
  });
function mQ(t) {
  var a = WC(t);
  return a.length == 1 && a[0][2] ? qe(a[0][0], a[0][1]) : function (c) {
    return c === t || EC(c, t, a);
  };
}
var jC,
  qC = x(() => {
    DC();
    _C();
    qv();
    jC = mQ;
  });
function fQ(t, a) {
  return t != null && a in Object(t);
}
var NC,
  UC = x(() => {
    NC = fQ;
  });
function MQ(t, a, c) {
  a = Z7(a, t);
  for (var r = -1, e = a.length, l = !1; ++r < e;) {
    var i = f4(a[r]);
    if (!(l = t != null && c(t, i))) break;
    t = t[i];
  }
  return l || ++r != e ? l : (e = t == null ? 0 : t.length, !!e && A7(e) && Y5(i, e) && (o2(t) || R7(t)));
}
var KC,
  $C = x(() => {
    be();
    Ve();
    f3();
    ea();
    He();
    O7();
    KC = MQ;
  });
function xQ(t, a) {
  return t != null && KC(t, a, NC);
}
var QC,
  XC = x(() => {
    UC();
    $C();
    QC = xQ;
  });
function HQ(t, a) {
  return I7(t) && je(a) ? qe(f4(t), a) : function (c) {
    var r = D3(c, t);
    return r === void 0 && r === a ? QC(c, t) : _e(a, r, CQ | LQ);
  };
}
var CQ,
  LQ,
  YC,
  JC = x(() => {
    _v();
    D7();
    XC();
    ke();
    jv();
    qv();
    O7();
    CQ = 1, LQ = 2;
    YC = HQ;
  });
function VQ(t) {
  return function (a) {
    return a == null ? void 0 : a[t];
  };
}
var tL,
  aL = x(() => {
    tL = VQ;
  });
function wQ(t) {
  return function (a) {
    return E7(a, t);
  };
}
var cL,
  rL = x(() => {
    Fe();
    cL = wQ;
  });
function BQ(t) {
  return I7(t) ? tL(f4(t)) : cL(t);
}
var eL,
  lL = x(() => {
    aL();
    rL();
    ke();
    O7();
    eL = BQ;
  });
function yQ(t) {
  return typeof t == "function" ? t : t == null ? Q5 : typeof t == "object" ? o2(t) ? YC(t[0], t[1]) : jC(t) : eL(t);
}
var M4,
  q7 = x(() => {
    qC();
    JC();
    ra();
    f3();
    lL();
    M4 = yQ;
  });
function SQ(t, a, c, r) {
  for (var e = -1, l = t == null ? 0 : t.length; ++e < l;) {
    var i = t[e];
    a(r, i, c(i), t);
  }
  return r;
}
var iL,
  oL = x(() => {
    iL = SQ;
  });
function kQ(t) {
  return function (a, c, r) {
    for (var e = -1, l = Object(a), i = r(a), o = i.length; o--;) {
      var n = i[t ? o : ++e];
      if (c(l[n], n, l) === !1) break;
    }
    return a;
  };
}
var nL,
  hL = x(() => {
    nL = kQ;
  });
var AQ,
  vL,
  gL = x(() => {
    hL();
    AQ = nL(), vL = AQ;
  });
function RQ(t, a) {
  return t && vL(t, a, F7);
}
var Ne,
  Nv = x(() => {
    gL();
    Se();
    Ne = RQ;
  });
function bQ(t, a) {
  return function (c, r) {
    if (c == null) return c;
    if (!t6(c)) return t(c, r);
    for (var e = c.length, l = a ? e : -1, i = Object(c); (a ? l-- : ++l < e) && r(i[l], l, i) !== !1;);
    return c;
  };
}
var dL,
  sL = x(() => {
    ia();
    dL = bQ;
  });
var FQ,
  Ue,
  Uv = x(() => {
    Nv();
    sL();
    FQ = dL(Ne), Ue = FQ;
  });
function IQ(t, a, c, r) {
  return Ue(t, function (e, l, i) {
    a(r, e, c(e), i);
  }), r;
}
var zL,
  uL = x(() => {
    Uv();
    zL = IQ;
  });
function PQ(t, a) {
  return function (c, r) {
    var e = o2(c) ? iL : zL,
      l = a ? a() : {};
    return e(c, t, M4(r, 2), l);
  };
}
var pL,
  mL = x(() => {
    oL();
    uL();
    q7();
    f3();
    pL = PQ;
  });
var GQ,
  Ke,
  fL = x(() => {
    m3();
    GQ = function () {
      return g2.Date.now();
    }, Ke = GQ;
  });
function EQ(t, a, c) {
  var r,
    e,
    l,
    i,
    o,
    n,
    h = 0,
    v = !1,
    g = !1,
    s = !0;
  if (typeof t != "function") throw new TypeError(TQ);
  a = U0(a) || 0, r0(c) && (v = !!c.leading, g = "maxWait" in c, l = g ? ZQ(U0(c.maxWait) || 0, a) : l, s = "trailing" in c ? !!c.trailing : s);
  function d(y) {
    var k = r,
      F = e;
    return r = e = void 0, h = y, i = t.apply(F, k), i;
  }
  function z(y) {
    return h = y, o = setTimeout(p, a), v ? d(y) : i;
  }
  function u(y) {
    var k = y - n,
      F = y - h,
      U = a - k;
    return g ? OQ(U, l - F) : U;
  }
  function f(y) {
    var k = y - n,
      F = y - h;
    return n === void 0 || k >= a || k < 0 || g && F >= l;
  }
  function p() {
    var y = Ke();
    if (f(y)) return m(y);
    o = setTimeout(p, u(y));
  }
  function m(y) {
    return o = void 0, s && r ? d(y) : (r = e = void 0, i);
  }
  function M() {
    o !== void 0 && clearTimeout(o), h = 0, r = n = e = o = void 0;
  }
  function w() {
    return o === void 0 ? i : m(Ke());
  }
  function H() {
    var y = Ke(),
      k = f(y);
    if (r = arguments, e = this, n = y, k) {
      if (o === void 0) return z(n);
      if (g) return clearTimeout(o), o = setTimeout(p, a), d(n);
    }
    return o === void 0 && (o = setTimeout(p, a)), i;
  }
  return H.cancel = M, H.flush = w, H;
}
var TQ,
  ZQ,
  OQ,
  pa,
  Kv = x(() => {
    K5();
    fL();
    B7();
    TQ = "Expected a function", ZQ = Math.max, OQ = Math.min;
    pa = EQ;
  });
function DQ(t, a, c) {
  for (var r = -1, e = t == null ? 0 : t.length; ++r < e;) if (c(a, t[r])) return !0;
  return !1;
}
var ML,
  xL = x(() => {
    ML = DQ;
  });
function WQ(t) {
  var a = t == null ? 0 : t.length;
  return a ? t[a - 1] : void 0;
}
var M3,
  ma = x(() => {
    M3 = WQ;
  });
function jQ(t, a, c) {
  var r = t == null ? 0 : t.length;
  if (!r) return -1;
  var e = c == null ? 0 : $5(c);
  return e < 0 && (e = _Q(r + e, 0)), S7(t, M4(a, 3), e);
}
var _Q,
  $e,
  CL = x(() => {
    Me();
    q7();
    ca();
    _Q = Math.max;
    $e = jQ;
  });
function UQ(t, a, c) {
  var r = t == null ? 0 : t.length;
  if (!r) return -1;
  var e = r - 1;
  return c !== void 0 && (e = $5(c), e = c < 0 ? qQ(r + e, 0) : NQ(e, r - 1)), S7(t, M4(a, 3), e, !0);
}
var qQ,
  NQ,
  LL,
  HL = x(() => {
    Me();
    q7();
    ca();
    qQ = Math.max, NQ = Math.min;
    LL = UQ;
  });
function KQ(t, a) {
  var c = -1,
    r = t6(t) ? Array(t.length) : [];
  return Ue(t, function (e, l, i) {
    r[++c] = a(e, l, i);
  }), r;
}
var VL,
  wL = x(() => {
    Uv();
    ia();
    VL = KQ;
  });
function XQ(t, a, c) {
  return t >= QQ(a, c) && t < $Q(a, c);
}
var $Q,
  QQ,
  BL,
  yL = x(() => {
    $Q = Math.max, QQ = Math.min;
    BL = XQ;
  });
function YQ(t, a, c) {
  return a = aa(a), c === void 0 ? (c = a, a = 0) : c = aa(c), t = U0(t), BL(t, a, c);
}
var Qe,
  SL = x(() => {
    yL();
    uv();
    B7();
    Qe = YQ;
  });
function JQ(t) {
  return typeof t == "number" && t == $5(t);
}
var fa,
  $v = x(() => {
    ca();
    fa = JQ;
  });
var tX,
  Ma,
  kL = x(() => {
    Ce();
    mL();
    tX = pL(function (t, a, c) {
      k7(t, c, a);
    }), Ma = tX;
  });
function aX(t, a) {
  var c = {};
  return a = M4(a, 3), Ne(t, function (r, e, l) {
    k7(c, e, a(r, e, l));
  }), c;
}
var l5,
  Qv = x(() => {
    Ce();
    Nv();
    q7();
    l5 = aX;
  });
function cX(t, a, c, r) {
  if (!r0(t)) return t;
  a = Z7(a, t);
  for (var e = -1, l = a.length, i = l - 1, o = t; o != null && ++e < l;) {
    var n = f4(a[e]),
      h = c;
    if (n === "__proto__" || n === "constructor" || n === "prototype") return t;
    if (e != i) {
      var v = o[n];
      h = r ? r(v, n, o) : void 0, h === void 0 && (h = r0(v) ? v : Y5(a[e + 1]) ? [] : {});
    }
    LM(o, n, h), o = o[n];
  }
  return t;
}
var AL,
  RL = x(() => {
    HM();
    be();
    ea();
    K5();
    O7();
    AL = cX;
  });
function rX(t, a) {
  var c = t.length;
  for (t.sort(a); c--;) t[c] = t[c].value;
  return t;
}
var bL,
  FL = x(() => {
    bL = rX;
  });
function eX(t, a) {
  if (t !== a) {
    var c = t !== void 0,
      r = t === null,
      e = t === t,
      l = E3(t),
      i = a !== void 0,
      o = a === null,
      n = a === a,
      h = E3(a);
    if (!o && !h && !l && t > a || l && i && n && !o && !h || r && i && n || !c && n || !e) return 1;
    if (!r && !l && !h && t < a || h && c && e && !r && !l || o && c && e || !i && e || !n) return -1;
  }
  return 0;
}
var IL,
  PL = x(() => {
    w7();
    IL = eX;
  });
function lX(t, a, c) {
  for (var r = -1, e = t.criteria, l = a.criteria, i = e.length, o = c.length; ++r < i;) {
    var n = IL(e[r], l[r]);
    if (n) {
      if (r >= o) return n;
      var h = c[r];
      return n * (h == "desc" ? -1 : 1);
    }
  }
  return t.index - a.index;
}
var GL,
  TL = x(() => {
    PL();
    GL = lX;
  });
function iX(t, a, c) {
  a.length ? a = U5(a, function (l) {
    return o2(l) ? function (i) {
      return E7(i, l.length === 1 ? l[0] : l);
    } : l;
  }) : a = [Q5];
  var r = -1;
  a = U5(a, b7(M4));
  var e = VL(t, function (l, i, o) {
    var n = U5(a, function (h) {
      return h(l);
    });
    return {
      criteria: n,
      index: ++r,
      value: l
    };
  });
  return bL(e, function (l, i) {
    return GL(l, i, c);
  });
}
var ZL,
  OL = x(() => {
    ue();
    Fe();
    q7();
    wL();
    FL();
    we();
    TL();
    ra();
    f3();
    ZL = iX;
  });
function oX(t, a, c, r) {
  for (var e = c - 1, l = t.length; ++e < l;) if (r(t[e], a)) return e;
  return -1;
}
var EL,
  DL = x(() => {
    EL = oX;
  });
function hX(t, a, c, r) {
  var e = r ? EL : xe,
    l = -1,
    i = a.length,
    o = t;
  for (t === a && (a = iM(a)), c && (o = U5(t, b7(c))); ++l < i;) for (var n = 0, h = a[l], v = c ? c(h) : h; (n = e(o, v, n, r)) > -1;) o !== t && WL.call(o, n, 1), WL.call(t, n, 1);
  return t;
}
var nX,
  WL,
  _L,
  jL = x(() => {
    ue();
    Mv();
    DL();
    we();
    oM();
    nX = Array.prototype, WL = nX.splice;
    _L = hX;
  });
function vX(t, a) {
  return t && t.length && a && a.length ? _L(t, a) : t;
}
var qL,
  NL = x(() => {
    jL();
    qL = vX;
  });
var gX,
  UL,
  KL = x(() => {
    xv();
    NL();
    gX = Le(qL), UL = gX;
  });
var dX,
  Xv,
  $L = x(() => {
    _x();
    dX = Wx("round"), Xv = dX;
  });
function sX(t, a, c) {
  return t == null ? t : AL(t, a, c);
}
var i6,
  Xe = x(() => {
    RL();
    i6 = sX;
  });
var zX,
  QL,
  XL = x(() => {
    Zx();
    OL();
    xv();
    yM();
    zX = Le(function (t, a) {
      if (t == null) return [];
      var c = a.length;
      return c > 1 && Cv(t, a[0], a[1]) ? a = [] : c > 2 && Cv(a[0], a[1], a[2]) && (a = [a[0]]), ZL(t, Tx(a, 1), []);
    }), QL = zX;
  });
var uX,
  pX,
  YL,
  JL = x(() => {
    Gv();
    lM();
    De();
    uX = 1 / 0, pX = l6 && 1 / j7(new l6([, -0]))[1] == uX ? function (t) {
      return new l6(t);
    } : eM, YL = pX;
  });
function fX(t, a, c) {
  var r = -1,
    e = xM,
    l = t.length,
    i = !0,
    o = [],
    n = o;
  if (c) i = !1, e = ML;else if (l >= mX) {
    var h = a ? null : YL(t);
    if (h) return j7(h);
    i = !1, e = Oe, n = new Ze();
  } else n = a ? [] : o;
  t: for (; ++r < l;) {
    var v = t[r],
      g = a ? a(v) : v;
    if (v = c || v !== 0 ? v : 0, i && g === g) {
      for (var s = n.length; s--;) if (n[s] === g) continue t;
      a && n.push(g), o.push(v);
    } else e(n, g, c) || (n !== o && n.push(g), o.push(v));
  }
  return o;
}
var mX,
  tH,
  aH = x(() => {
    Ov();
    CM();
    xL();
    Ev();
    JL();
    De();
    mX = 200;
    tH = fX;
  });
function MX(t) {
  return t && t.length ? tH(t) : [];
}
var x3,
  cH = x(() => {
    aH();
    x3 = MX;
  });
var H2 = x(() => {
  ua();
  Kv();
  CL();
  SL();
  $v();
  Fv();
  ma();
  Qv();
  Av();
  $L();
  cH();
});
var lH = L1((yz1, eH) => {
  var rH;
  eH.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window != "undefined" ? window : global) : t => (rH || (rH = Promise.resolve())).then(t).catch(a => setTimeout(() => {
    throw a;
  }, 0));
});
var pH = L1(F1 => {
  "use strict";

  var xa = Symbol.for("react.element"),
    xX = Symbol.for("react.portal"),
    CX = Symbol.for("react.fragment"),
    LX = Symbol.for("react.strict_mode"),
    HX = Symbol.for("react.profiler"),
    VX = Symbol.for("react.provider"),
    wX = Symbol.for("react.context"),
    BX = Symbol.for("react.forward_ref"),
    yX = Symbol.for("react.suspense"),
    SX = Symbol.for("react.memo"),
    kX = Symbol.for("react.lazy"),
    iH = Symbol.iterator;
  function AX(t) {
    return t === null || typeof t != "object" ? null : (t = iH && t[iH] || t["@@iterator"], typeof t == "function" ? t : null);
  }
  var hH = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {}
    },
    vH = Object.assign,
    gH = {};
  function N7(t, a, c) {
    this.props = t, this.context = a, this.refs = gH, this.updater = c || hH;
  }
  N7.prototype.isReactComponent = {};
  N7.prototype.setState = function (t, a) {
    if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, a, "setState");
  };
  N7.prototype.forceUpdate = function (t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate");
  };
  function dH() {}
  dH.prototype = N7.prototype;
  function Jv(t, a, c) {
    this.props = t, this.context = a, this.refs = gH, this.updater = c || hH;
  }
  var tg = Jv.prototype = new dH();
  tg.constructor = Jv;
  vH(tg, N7.prototype);
  tg.isPureReactComponent = !0;
  var oH = Array.isArray,
    sH = Object.prototype.hasOwnProperty,
    ag = {
      current: null
    },
    zH = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    };
  function uH(t, a, c) {
    var r,
      e = {},
      l = null,
      i = null;
    if (a != null) for (r in a.ref !== void 0 && (i = a.ref), a.key !== void 0 && (l = "" + a.key), a) sH.call(a, r) && !zH.hasOwnProperty(r) && (e[r] = a[r]);
    var o = arguments.length - 2;
    if (o === 1) e.children = c;else if (1 < o) {
      for (var n = Array(o), h = 0; h < o; h++) n[h] = arguments[h + 2];
      e.children = n;
    }
    if (t && t.defaultProps) for (r in o = t.defaultProps, o) e[r] === void 0 && (e[r] = o[r]);
    return {
      $$typeof: xa,
      type: t,
      key: l,
      ref: i,
      props: e,
      _owner: ag.current
    };
  }
  function RX(t, a) {
    return {
      $$typeof: xa,
      type: t.type,
      key: a,
      ref: t.ref,
      props: t.props,
      _owner: t._owner
    };
  }
  function cg(t) {
    return typeof t == "object" && t !== null && t.$$typeof === xa;
  }
  function bX(t) {
    var a = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function (c) {
      return a[c];
    });
  }
  var nH = /\/+/g;
  function Yv(t, a) {
    return typeof t == "object" && t !== null && t.key != null ? bX("" + t.key) : a.toString(36);
  }
  function Je(t, a, c, r, e) {
    var l = typeof t;
    (l === "undefined" || l === "boolean") && (t = null);
    var i = !1;
    if (t === null) i = !0;else switch (l) {
      case "string":
      case "number":
        i = !0;
        break;
      case "object":
        switch (t.$$typeof) {
          case xa:
          case xX:
            i = !0;
        }
    }
    if (i) return i = t, e = e(i), t = r === "" ? "." + Yv(i, 0) : r, oH(e) ? (c = "", t != null && (c = t.replace(nH, "$&/") + "/"), Je(e, a, c, "", function (h) {
      return h;
    })) : e != null && (cg(e) && (e = RX(e, c + (!e.key || i && i.key === e.key ? "" : ("" + e.key).replace(nH, "$&/") + "/") + t)), a.push(e)), 1;
    if (i = 0, r = r === "" ? "." : r + ":", oH(t)) for (var o = 0; o < t.length; o++) {
      l = t[o];
      var n = r + Yv(l, o);
      i += Je(l, a, c, n, e);
    } else if (n = AX(t), typeof n == "function") for (t = n.call(t), o = 0; !(l = t.next()).done;) l = l.value, n = r + Yv(l, o++), i += Je(l, a, c, n, e);else if (l === "object") throw a = String(t), Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
    return i;
  }
  function Ye(t, a, c) {
    if (t == null) return t;
    var r = [],
      e = 0;
    return Je(t, r, "", "", function (l) {
      return a.call(c, l, e++);
    }), r;
  }
  function FX(t) {
    if (t._status === -1) {
      var a = t._result;
      a = a(), a.then(function (c) {
        (t._status === 0 || t._status === -1) && (t._status = 1, t._result = c);
      }, function (c) {
        (t._status === 0 || t._status === -1) && (t._status = 2, t._result = c);
      }), t._status === -1 && (t._status = 0, t._result = a);
    }
    if (t._status === 1) return t._result.default;
    throw t._result;
  }
  var m0 = {
      current: null
    },
    tl = {
      transition: null
    },
    IX = {
      ReactCurrentDispatcher: m0,
      ReactCurrentBatchConfig: tl,
      ReactCurrentOwner: ag
    };
  F1.Children = {
    map: Ye,
    forEach: function (t, a, c) {
      Ye(t, function () {
        a.apply(this, arguments);
      }, c);
    },
    count: function (t) {
      var a = 0;
      return Ye(t, function () {
        a++;
      }), a;
    },
    toArray: function (t) {
      return Ye(t, function (a) {
        return a;
      }) || [];
    },
    only: function (t) {
      if (!cg(t)) throw Error("React.Children.only expected to receive a single React element child.");
      return t;
    }
  };
  F1.Component = N7;
  F1.Fragment = CX;
  F1.Profiler = HX;
  F1.PureComponent = Jv;
  F1.StrictMode = LX;
  F1.Suspense = yX;
  F1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = IX;
  F1.cloneElement = function (t, a, c) {
    if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var r = vH({}, t.props),
      e = t.key,
      l = t.ref,
      i = t._owner;
    if (a != null) {
      if (a.ref !== void 0 && (l = a.ref, i = ag.current), a.key !== void 0 && (e = "" + a.key), t.type && t.type.defaultProps) var o = t.type.defaultProps;
      for (n in a) sH.call(a, n) && !zH.hasOwnProperty(n) && (r[n] = a[n] === void 0 && o !== void 0 ? o[n] : a[n]);
    }
    var n = arguments.length - 2;
    if (n === 1) r.children = c;else if (1 < n) {
      o = Array(n);
      for (var h = 0; h < n; h++) o[h] = arguments[h + 2];
      r.children = o;
    }
    return {
      $$typeof: xa,
      type: t.type,
      key: e,
      ref: l,
      props: r,
      _owner: i
    };
  };
  F1.createContext = function (t) {
    return t = {
      $$typeof: wX,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
    }, t.Provider = {
      $$typeof: VX,
      _context: t
    }, t.Consumer = t;
  };
  F1.createElement = uH;
  F1.createFactory = function (t) {
    var a = uH.bind(null, t);
    return a.type = t, a;
  };
  F1.createRef = function () {
    return {
      current: null
    };
  };
  F1.forwardRef = function (t) {
    return {
      $$typeof: BX,
      render: t
    };
  };
  F1.isValidElement = cg;
  F1.lazy = function (t) {
    return {
      $$typeof: kX,
      _payload: {
        _status: -1,
        _result: t
      },
      _init: FX
    };
  };
  F1.memo = function (t, a) {
    return {
      $$typeof: SX,
      type: t,
      compare: a === void 0 ? null : a
    };
  };
  F1.startTransition = function (t) {
    var a = tl.transition;
    tl.transition = {};
    try {
      t();
    } finally {
      tl.transition = a;
    }
  };
  F1.unstable_act = function () {
    throw Error("act(...) is not supported in production builds of React.");
  };
  F1.useCallback = function (t, a) {
    return m0.current.useCallback(t, a);
  };
  F1.useContext = function (t) {
    return m0.current.useContext(t);
  };
  F1.useDebugValue = function () {};
  F1.useDeferredValue = function (t) {
    return m0.current.useDeferredValue(t);
  };
  F1.useEffect = function (t, a) {
    return m0.current.useEffect(t, a);
  };
  F1.useId = function () {
    return m0.current.useId();
  };
  F1.useImperativeHandle = function (t, a, c) {
    return m0.current.useImperativeHandle(t, a, c);
  };
  F1.useInsertionEffect = function (t, a) {
    return m0.current.useInsertionEffect(t, a);
  };
  F1.useLayoutEffect = function (t, a) {
    return m0.current.useLayoutEffect(t, a);
  };
  F1.useMemo = function (t, a) {
    return m0.current.useMemo(t, a);
  };
  F1.useReducer = function (t, a, c) {
    return m0.current.useReducer(t, a, c);
  };
  F1.useRef = function (t) {
    return m0.current.useRef(t);
  };
  F1.useState = function (t) {
    return m0.current.useState(t);
  };
  F1.useSyncExternalStore = function (t, a, c) {
    return m0.current.useSyncExternalStore(t, a, c);
  };
  F1.useTransition = function () {
    return m0.current.useTransition();
  };
  F1.version = "18.2.0";
});
var G = L1((kz1, mH) => {
  "use strict";

  mH.exports = pH();
});
var yH = L1(K1 => {
  "use strict";

  function ig(t, a) {
    var c = t.length;
    t.push(a);
    t: for (; 0 < c;) {
      var r = c - 1 >>> 1,
        e = t[r];
      if (0 < al(e, a)) t[r] = a, t[c] = e, c = r;else break t;
    }
  }
  function W3(t) {
    return t.length === 0 ? null : t[0];
  }
  function rl(t) {
    if (t.length === 0) return null;
    var a = t[0],
      c = t.pop();
    if (c !== a) {
      t[0] = c;
      t: for (var r = 0, e = t.length, l = e >>> 1; r < l;) {
        var i = 2 * (r + 1) - 1,
          o = t[i],
          n = i + 1,
          h = t[n];
        if (0 > al(o, c)) n < e && 0 > al(h, o) ? (t[r] = h, t[n] = c, r = n) : (t[r] = o, t[i] = c, r = i);else if (n < e && 0 > al(h, c)) t[r] = h, t[n] = c, r = n;else break t;
      }
    }
    return a;
  }
  function al(t, a) {
    var c = t.sortIndex - a.sortIndex;
    return c !== 0 ? c : t.id - a.id;
  }
  typeof performance == "object" && typeof performance.now == "function" ? (fH = performance, K1.unstable_now = function () {
    return fH.now();
  }) : (rg = Date, MH = rg.now(), K1.unstable_now = function () {
    return rg.now() - MH;
  });
  var fH,
    rg,
    MH,
    x4 = [],
    o6 = [],
    PX = 1,
    C3 = null,
    e0 = 3,
    el = !1,
    C8 = !1,
    La = !1,
    LH = typeof setTimeout == "function" ? setTimeout : null,
    HH = typeof clearTimeout == "function" ? clearTimeout : null,
    xH = typeof setImmediate != "undefined" ? setImmediate : null;
  typeof navigator != "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function og(t) {
    for (var a = W3(o6); a !== null;) {
      if (a.callback === null) rl(o6);else if (a.startTime <= t) rl(o6), a.sortIndex = a.expirationTime, ig(x4, a);else break;
      a = W3(o6);
    }
  }
  function ng(t) {
    if (La = !1, og(t), !C8) if (W3(x4) !== null) C8 = !0, vg(hg);else {
      var a = W3(o6);
      a !== null && gg(ng, a.startTime - t);
    }
  }
  function hg(t, a) {
    C8 = !1, La && (La = !1, HH(Ha), Ha = -1), el = !0;
    var c = e0;
    try {
      for (og(a), C3 = W3(x4); C3 !== null && (!(C3.expirationTime > a) || t && !BH());) {
        var r = C3.callback;
        if (typeof r == "function") {
          C3.callback = null, e0 = C3.priorityLevel;
          var e = r(C3.expirationTime <= a);
          a = K1.unstable_now(), typeof e == "function" ? C3.callback = e : C3 === W3(x4) && rl(x4), og(a);
        } else rl(x4);
        C3 = W3(x4);
      }
      if (C3 !== null) var l = !0;else {
        var i = W3(o6);
        i !== null && gg(ng, i.startTime - a), l = !1;
      }
      return l;
    } finally {
      C3 = null, e0 = c, el = !1;
    }
  }
  var ll = !1,
    cl = null,
    Ha = -1,
    VH = 5,
    wH = -1;
  function BH() {
    return !(K1.unstable_now() - wH < VH);
  }
  function eg() {
    if (cl !== null) {
      var t = K1.unstable_now();
      wH = t;
      var a = !0;
      try {
        a = cl(!0, t);
      } finally {
        a ? Ca() : (ll = !1, cl = null);
      }
    } else ll = !1;
  }
  var Ca;
  typeof xH == "function" ? Ca = function () {
    xH(eg);
  } : typeof MessageChannel != "undefined" ? (lg = new MessageChannel(), CH = lg.port2, lg.port1.onmessage = eg, Ca = function () {
    CH.postMessage(null);
  }) : Ca = function () {
    LH(eg, 0);
  };
  var lg, CH;
  function vg(t) {
    cl = t, ll || (ll = !0, Ca());
  }
  function gg(t, a) {
    Ha = LH(function () {
      t(K1.unstable_now());
    }, a);
  }
  K1.unstable_IdlePriority = 5;
  K1.unstable_ImmediatePriority = 1;
  K1.unstable_LowPriority = 4;
  K1.unstable_NormalPriority = 3;
  K1.unstable_Profiling = null;
  K1.unstable_UserBlockingPriority = 2;
  K1.unstable_cancelCallback = function (t) {
    t.callback = null;
  };
  K1.unstable_continueExecution = function () {
    C8 || el || (C8 = !0, vg(hg));
  };
  K1.unstable_forceFrameRate = function (t) {
    0 > t || 125 < t ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : VH = 0 < t ? Math.floor(1e3 / t) : 5;
  };
  K1.unstable_getCurrentPriorityLevel = function () {
    return e0;
  };
  K1.unstable_getFirstCallbackNode = function () {
    return W3(x4);
  };
  K1.unstable_next = function (t) {
    switch (e0) {
      case 1:
      case 2:
      case 3:
        var a = 3;
        break;
      default:
        a = e0;
    }
    var c = e0;
    e0 = a;
    try {
      return t();
    } finally {
      e0 = c;
    }
  };
  K1.unstable_pauseExecution = function () {};
  K1.unstable_requestPaint = function () {};
  K1.unstable_runWithPriority = function (t, a) {
    switch (t) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        t = 3;
    }
    var c = e0;
    e0 = t;
    try {
      return a();
    } finally {
      e0 = c;
    }
  };
  K1.unstable_scheduleCallback = function (t, a, c) {
    var r = K1.unstable_now();
    switch (typeof c == "object" && c !== null ? (c = c.delay, c = typeof c == "number" && 0 < c ? r + c : r) : c = r, t) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    return e = c + e, t = {
      id: PX++,
      callback: a,
      priorityLevel: t,
      startTime: c,
      expirationTime: e,
      sortIndex: -1
    }, c > r ? (t.sortIndex = c, ig(o6, t), W3(x4) === null && t === W3(o6) && (La ? (HH(Ha), Ha = -1) : La = !0, gg(ng, c - r))) : (t.sortIndex = e, ig(x4, t), C8 || el || (C8 = !0, vg(hg))), t;
  };
  K1.unstable_shouldYield = BH;
  K1.unstable_wrapCallback = function (t) {
    var a = e0;
    return function () {
      var c = e0;
      e0 = a;
      try {
        return t.apply(this, arguments);
      } finally {
        e0 = c;
      }
    };
  };
});
var kH = L1((Rz1, SH) => {
  "use strict";

  SH.exports = yH();
});
var PB = L1(J0 => {
  "use strict";

  var GV = G(),
    X0 = kH();
  function n1(t) {
    for (var a = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, c = 1; c < arguments.length; c++) a += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + t + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var TV = new Set(),
    qa = {};
  function I8(t, a) {
    s9(t, a), s9(t + "Capture", a);
  }
  function s9(t, a) {
    for (qa[t] = a, t = 0; t < a.length; t++) TV.add(a[t]);
  }
  var g5 = !(typeof window == "undefined" || typeof window.document == "undefined" || typeof window.document.createElement == "undefined"),
    Ig = Object.prototype.hasOwnProperty,
    GX = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    AH = {},
    RH = {};
  function TX(t) {
    return Ig.call(RH, t) ? !0 : Ig.call(AH, t) ? !1 : GX.test(t) ? RH[t] = !0 : (AH[t] = !0, !1);
  }
  function ZX(t, a, c, r) {
    if (c !== null && c.type === 0) return !1;
    switch (typeof a) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return r ? !1 : c !== null ? !c.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
      default:
        return !1;
    }
  }
  function OX(t, a, c, r) {
    if (a === null || typeof a == "undefined" || ZX(t, a, c, r)) return !0;
    if (r) return !1;
    if (c !== null) switch (c.type) {
      case 3:
        return !a;
      case 4:
        return a === !1;
      case 5:
        return isNaN(a);
      case 6:
        return isNaN(a) || 1 > a;
    }
    return !1;
  }
  function x0(t, a, c, r, e, l, i) {
    this.acceptsBooleans = a === 2 || a === 3 || a === 4, this.attributeName = r, this.attributeNamespace = e, this.mustUseProperty = c, this.propertyName = t, this.type = a, this.sanitizeURL = l, this.removeEmptyString = i;
  }
  var q2 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) {
    q2[t] = new x0(t, 0, !1, t, null, !1, !1);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) {
    var a = t[0];
    q2[a] = new x0(a, 1, !1, t[1], null, !1, !1);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
    q2[t] = new x0(t, 2, !1, t.toLowerCase(), null, !1, !1);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) {
    q2[t] = new x0(t, 2, !1, t, null, !1, !1);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) {
    q2[t] = new x0(t, 3, !1, t.toLowerCase(), null, !1, !1);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function (t) {
    q2[t] = new x0(t, 3, !0, t, null, !1, !1);
  });
  ["capture", "download"].forEach(function (t) {
    q2[t] = new x0(t, 4, !1, t, null, !1, !1);
  });
  ["cols", "rows", "size", "span"].forEach(function (t) {
    q2[t] = new x0(t, 6, !1, t, null, !1, !1);
  });
  ["rowSpan", "start"].forEach(function (t) {
    q2[t] = new x0(t, 5, !1, t.toLowerCase(), null, !1, !1);
  });
  var Bd = /[\-:]([a-z])/g;
  function yd(t) {
    return t[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) {
    var a = t.replace(Bd, yd);
    q2[a] = new x0(a, 1, !1, t, null, !1, !1);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) {
    var a = t.replace(Bd, yd);
    q2[a] = new x0(a, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
    var a = t.replace(Bd, yd);
    q2[a] = new x0(a, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
  });
  ["tabIndex", "crossOrigin"].forEach(function (t) {
    q2[t] = new x0(t, 1, !1, t.toLowerCase(), null, !1, !1);
  });
  q2.xlinkHref = new x0("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
  ["src", "href", "action", "formAction"].forEach(function (t) {
    q2[t] = new x0(t, 1, !1, t.toLowerCase(), null, !0, !0);
  });
  function Sd(t, a, c, r) {
    var e = q2.hasOwnProperty(a) ? q2[a] : null;
    (e !== null ? e.type !== 0 : r || !(2 < a.length) || a[0] !== "o" && a[0] !== "O" || a[1] !== "n" && a[1] !== "N") && (OX(a, c, e, r) && (c = null), r || e === null ? TX(a) && (c === null ? t.removeAttribute(a) : t.setAttribute(a, "" + c)) : e.mustUseProperty ? t[e.propertyName] = c === null ? e.type === 3 ? !1 : "" : c : (a = e.attributeName, r = e.attributeNamespace, c === null ? t.removeAttribute(a) : (e = e.type, c = e === 3 || e === 4 && c === !0 ? "" : "" + c, r ? t.setAttributeNS(r, a, c) : t.setAttribute(a, c))));
  }
  var u5 = GV.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    il = Symbol.for("react.element"),
    $7 = Symbol.for("react.portal"),
    Q7 = Symbol.for("react.fragment"),
    kd = Symbol.for("react.strict_mode"),
    Pg = Symbol.for("react.profiler"),
    ZV = Symbol.for("react.provider"),
    OV = Symbol.for("react.context"),
    Ad = Symbol.for("react.forward_ref"),
    Gg = Symbol.for("react.suspense"),
    Tg = Symbol.for("react.suspense_list"),
    Rd = Symbol.for("react.memo"),
    h6 = Symbol.for("react.lazy");
  Symbol.for("react.scope");
  Symbol.for("react.debug_trace_mode");
  var EV = Symbol.for("react.offscreen");
  Symbol.for("react.legacy_hidden");
  Symbol.for("react.cache");
  Symbol.for("react.tracing_marker");
  var bH = Symbol.iterator;
  function Va(t) {
    return t === null || typeof t != "object" ? null : (t = bH && t[bH] || t["@@iterator"], typeof t == "function" ? t : null);
  }
  var v2 = Object.assign,
    dg;
  function ba(t) {
    if (dg === void 0) try {
      throw Error();
    } catch (c) {
      var a = c.stack.trim().match(/\n( *(at )?)/);
      dg = a && a[1] || "";
    }
    return "\n" + dg + t;
  }
  var sg = !1;
  function zg(t, a) {
    if (!t || sg) return "";
    sg = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (a) {
        if (a = function () {
          throw Error();
        }, Object.defineProperty(a.prototype, "props", {
          set: function () {
            throw Error();
          }
        }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(a, []);
          } catch (h) {
            var r = h;
          }
          Reflect.construct(t, [], a);
        } else {
          try {
            a.call();
          } catch (h) {
            r = h;
          }
          t.call(a.prototype);
        }
      } else {
        try {
          throw Error();
        } catch (h) {
          r = h;
        }
        t();
      }
    } catch (h) {
      if (h && r && typeof h.stack == "string") {
        for (var e = h.stack.split("\n"), l = r.stack.split("\n"), i = e.length - 1, o = l.length - 1; 1 <= i && 0 <= o && e[i] !== l[o];) o--;
        for (; 1 <= i && 0 <= o; i--, o--) if (e[i] !== l[o]) {
          if (i !== 1 || o !== 1) do if (i--, o--, 0 > o || e[i] !== l[o]) {
            var n = "\n" + e[i].replace(" at new ", " at ");
            return t.displayName && n.includes("<anonymous>") && (n = n.replace("<anonymous>", t.displayName)), n;
          } while (1 <= i && 0 <= o);
          break;
        }
      }
    } finally {
      sg = !1, Error.prepareStackTrace = c;
    }
    return (t = t ? t.displayName || t.name : "") ? ba(t) : "";
  }
  function EX(t) {
    switch (t.tag) {
      case 5:
        return ba(t.type);
      case 16:
        return ba("Lazy");
      case 13:
        return ba("Suspense");
      case 19:
        return ba("SuspenseList");
      case 0:
      case 2:
      case 15:
        return t = zg(t.type, !1), t;
      case 11:
        return t = zg(t.type.render, !1), t;
      case 1:
        return t = zg(t.type, !0), t;
      default:
        return "";
    }
  }
  function Zg(t) {
    if (t == null) return null;
    if (typeof t == "function") return t.displayName || t.name || null;
    if (typeof t == "string") return t;
    switch (t) {
      case Q7:
        return "Fragment";
      case $7:
        return "Portal";
      case Pg:
        return "Profiler";
      case kd:
        return "StrictMode";
      case Gg:
        return "Suspense";
      case Tg:
        return "SuspenseList";
    }
    if (typeof t == "object") switch (t.$$typeof) {
      case OV:
        return (t.displayName || "Context") + ".Consumer";
      case ZV:
        return (t._context.displayName || "Context") + ".Provider";
      case Ad:
        var a = t.render;
        return t = t.displayName, t || (t = a.displayName || a.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
      case Rd:
        return a = t.displayName || null, a !== null ? a : Zg(t.type) || "Memo";
      case h6:
        a = t._payload, t = t._init;
        try {
          return Zg(t(a));
        } catch (c) {}
    }
    return null;
  }
  function DX(t) {
    var a = t.type;
    switch (t.tag) {
      case 24:
        return "Cache";
      case 9:
        return (a.displayName || "Context") + ".Consumer";
      case 10:
        return (a._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return t = a.render, t = t.displayName || t.name || "", a.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return a;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Zg(a);
      case 8:
        return a === kd ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof a == "function") return a.displayName || a.name || null;
        if (typeof a == "string") return a;
    }
    return null;
  }
  function H6(t) {
    switch (typeof t) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return t;
      case "object":
        return t;
      default:
        return "";
    }
  }
  function DV(t) {
    var a = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
  }
  function WX(t) {
    var a = DV(t) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(t.constructor.prototype, a),
      r = "" + t[a];
    if (!t.hasOwnProperty(a) && typeof c != "undefined" && typeof c.get == "function" && typeof c.set == "function") {
      var e = c.get,
        l = c.set;
      return Object.defineProperty(t, a, {
        configurable: !0,
        get: function () {
          return e.call(this);
        },
        set: function (i) {
          r = "" + i, l.call(this, i);
        }
      }), Object.defineProperty(t, a, {
        enumerable: c.enumerable
      }), {
        getValue: function () {
          return r;
        },
        setValue: function (i) {
          r = "" + i;
        },
        stopTracking: function () {
          t._valueTracker = null, delete t[a];
        }
      };
    }
  }
  function ol(t) {
    t._valueTracker || (t._valueTracker = WX(t));
  }
  function WV(t) {
    if (!t) return !1;
    var a = t._valueTracker;
    if (!a) return !0;
    var c = a.getValue(),
      r = "";
    return t && (r = DV(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== c ? (a.setValue(t), !0) : !1;
  }
  function Pl(t) {
    if (t = t || (typeof document != "undefined" ? document : void 0), typeof t == "undefined") return null;
    try {
      return t.activeElement || t.body;
    } catch (a) {
      return t.body;
    }
  }
  function Og(t, a) {
    var c = a.checked;
    return v2({}, a, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: c != null ? c : t._wrapperState.initialChecked
    });
  }
  function FH(t, a) {
    var c = a.defaultValue == null ? "" : a.defaultValue,
      r = a.checked != null ? a.checked : a.defaultChecked;
    c = H6(a.value != null ? a.value : c), t._wrapperState = {
      initialChecked: r,
      initialValue: c,
      controlled: a.type === "checkbox" || a.type === "radio" ? a.checked != null : a.value != null
    };
  }
  function _V(t, a) {
    a = a.checked, a != null && Sd(t, "checked", a, !1);
  }
  function Eg(t, a) {
    _V(t, a);
    var c = H6(a.value),
      r = a.type;
    if (c != null) r === "number" ? (c === 0 && t.value === "" || t.value != c) && (t.value = "" + c) : t.value !== "" + c && (t.value = "" + c);else if (r === "submit" || r === "reset") {
      t.removeAttribute("value");
      return;
    }
    a.hasOwnProperty("value") ? Dg(t, a.type, c) : a.hasOwnProperty("defaultValue") && Dg(t, a.type, H6(a.defaultValue)), a.checked == null && a.defaultChecked != null && (t.defaultChecked = !!a.defaultChecked);
  }
  function IH(t, a, c) {
    if (a.hasOwnProperty("value") || a.hasOwnProperty("defaultValue")) {
      var r = a.type;
      if (!(r !== "submit" && r !== "reset" || a.value !== void 0 && a.value !== null)) return;
      a = "" + t._wrapperState.initialValue, c || a === t.value || (t.value = a), t.defaultValue = a;
    }
    c = t.name, c !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, c !== "" && (t.name = c);
  }
  function Dg(t, a, c) {
    (a !== "number" || Pl(t.ownerDocument) !== t) && (c == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + c && (t.defaultValue = "" + c));
  }
  var Fa = Array.isArray;
  function o9(t, a, c, r) {
    if (t = t.options, a) {
      a = {};
      for (var e = 0; e < c.length; e++) a["$" + c[e]] = !0;
      for (c = 0; c < t.length; c++) e = a.hasOwnProperty("$" + t[c].value), t[c].selected !== e && (t[c].selected = e), e && r && (t[c].defaultSelected = !0);
    } else {
      for (c = "" + H6(c), a = null, e = 0; e < t.length; e++) {
        if (t[e].value === c) {
          t[e].selected = !0, r && (t[e].defaultSelected = !0);
          return;
        }
        a !== null || t[e].disabled || (a = t[e]);
      }
      a !== null && (a.selected = !0);
    }
  }
  function Wg(t, a) {
    if (a.dangerouslySetInnerHTML != null) throw Error(n1(91));
    return v2({}, a, {
      value: void 0,
      defaultValue: void 0,
      children: "" + t._wrapperState.initialValue
    });
  }
  function PH(t, a) {
    var c = a.value;
    if (c == null) {
      if (c = a.children, a = a.defaultValue, c != null) {
        if (a != null) throw Error(n1(92));
        if (Fa(c)) {
          if (1 < c.length) throw Error(n1(93));
          c = c[0];
        }
        a = c;
      }
      a == null && (a = ""), c = a;
    }
    t._wrapperState = {
      initialValue: H6(c)
    };
  }
  function jV(t, a) {
    var c = H6(a.value),
      r = H6(a.defaultValue);
    c != null && (c = "" + c, c !== t.value && (t.value = c), a.defaultValue == null && t.defaultValue !== c && (t.defaultValue = c)), r != null && (t.defaultValue = "" + r);
  }
  function GH(t) {
    var a = t.textContent;
    a === t._wrapperState.initialValue && a !== "" && a !== null && (t.value = a);
  }
  function qV(t) {
    switch (t) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function _g(t, a) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? qV(a) : t === "http://www.w3.org/2000/svg" && a === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t;
  }
  var nl,
    NV = function (t) {
      return typeof MSApp != "undefined" && MSApp.execUnsafeLocalFunction ? function (a, c, r, e) {
        MSApp.execUnsafeLocalFunction(function () {
          return t(a, c, r, e);
        });
      } : t;
    }(function (t, a) {
      if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = a;else {
        for (nl = nl || document.createElement("div"), nl.innerHTML = "<svg>" + a.valueOf().toString() + "</svg>", a = nl.firstChild; t.firstChild;) t.removeChild(t.firstChild);
        for (; a.firstChild;) t.appendChild(a.firstChild);
      }
    });
  function Na(t, a) {
    if (a) {
      var c = t.firstChild;
      if (c && c === t.lastChild && c.nodeType === 3) {
        c.nodeValue = a;
        return;
      }
    }
    t.textContent = a;
  }
  var Ga = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    },
    _X = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Ga).forEach(function (t) {
    _X.forEach(function (a) {
      a = a + t.charAt(0).toUpperCase() + t.substring(1), Ga[a] = Ga[t];
    });
  });
  function UV(t, a, c) {
    return a == null || typeof a == "boolean" || a === "" ? "" : c || typeof a != "number" || a === 0 || Ga.hasOwnProperty(t) && Ga[t] ? ("" + a).trim() : a + "px";
  }
  function KV(t, a) {
    t = t.style;
    for (var c in a) if (a.hasOwnProperty(c)) {
      var r = c.indexOf("--") === 0,
        e = UV(c, a[c], r);
      c === "float" && (c = "cssFloat"), r ? t.setProperty(c, e) : t[c] = e;
    }
  }
  var jX = v2({
    menuitem: !0
  }, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  });
  function jg(t, a) {
    if (a) {
      if (jX[t] && (a.children != null || a.dangerouslySetInnerHTML != null)) throw Error(n1(137, t));
      if (a.dangerouslySetInnerHTML != null) {
        if (a.children != null) throw Error(n1(60));
        if (typeof a.dangerouslySetInnerHTML != "object" || !("__html" in a.dangerouslySetInnerHTML)) throw Error(n1(61));
      }
      if (a.style != null && typeof a.style != "object") throw Error(n1(62));
    }
  }
  function qg(t, a) {
    if (t.indexOf("-") === -1) return typeof a.is == "string";
    switch (t) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Ng = null;
  function bd(t) {
    return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
  }
  var Ug = null,
    n9 = null,
    h9 = null;
  function TH(t) {
    if (t = vc(t)) {
      if (typeof Ug != "function") throw Error(n1(280));
      var a = t.stateNode;
      a && (a = hi(a), Ug(t.stateNode, t.type, a));
    }
  }
  function $V(t) {
    n9 ? h9 ? h9.push(t) : h9 = [t] : n9 = t;
  }
  function QV() {
    if (n9) {
      var t = n9,
        a = h9;
      if (h9 = n9 = null, TH(t), a) for (t = 0; t < a.length; t++) TH(a[t]);
    }
  }
  function XV(t, a) {
    return t(a);
  }
  function YV() {}
  var ug = !1;
  function JV(t, a, c) {
    if (ug) return t(a, c);
    ug = !0;
    try {
      return XV(t, a, c);
    } finally {
      ug = !1, (n9 !== null || h9 !== null) && (YV(), QV());
    }
  }
  function Ua(t, a) {
    var c = t.stateNode;
    if (c === null) return null;
    var r = hi(c);
    if (r === null) return null;
    c = r[a];
    t: switch (a) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r;
        break t;
      default:
        t = !1;
    }
    if (t) return null;
    if (c && typeof c != "function") throw Error(n1(231, a, typeof c));
    return c;
  }
  var Kg = !1;
  if (g5) try {
    U7 = {}, Object.defineProperty(U7, "passive", {
      get: function () {
        Kg = !0;
      }
    }), window.addEventListener("test", U7, U7), window.removeEventListener("test", U7, U7);
  } catch (t) {
    Kg = !1;
  }
  var U7;
  function qX(t, a, c, r, e, l, i, o, n) {
    var h = Array.prototype.slice.call(arguments, 3);
    try {
      a.apply(c, h);
    } catch (v) {
      this.onError(v);
    }
  }
  var Ta = !1,
    Gl = null,
    Tl = !1,
    $g = null,
    NX = {
      onError: function (t) {
        Ta = !0, Gl = t;
      }
    };
  function UX(t, a, c, r, e, l, i, o, n) {
    Ta = !1, Gl = null, qX.apply(NX, arguments);
  }
  function KX(t, a, c, r, e, l, i, o, n) {
    if (UX.apply(this, arguments), Ta) {
      if (Ta) {
        var h = Gl;
        Ta = !1, Gl = null;
      } else throw Error(n1(198));
      Tl || (Tl = !0, $g = h);
    }
  }
  function P8(t) {
    var a = t,
      c = t;
    if (t.alternate) for (; a.return;) a = a.return;else {
      t = a;
      do a = t, a.flags & 4098 && (c = a.return), t = a.return; while (t);
    }
    return a.tag === 3 ? c : null;
  }
  function tw(t) {
    if (t.tag === 13) {
      var a = t.memoizedState;
      if (a === null && (t = t.alternate, t !== null && (a = t.memoizedState)), a !== null) return a.dehydrated;
    }
    return null;
  }
  function ZH(t) {
    if (P8(t) !== t) throw Error(n1(188));
  }
  function $X(t) {
    var a = t.alternate;
    if (!a) {
      if (a = P8(t), a === null) throw Error(n1(188));
      return a !== t ? null : t;
    }
    for (var c = t, r = a;;) {
      var e = c.return;
      if (e === null) break;
      var l = e.alternate;
      if (l === null) {
        if (r = e.return, r !== null) {
          c = r;
          continue;
        }
        break;
      }
      if (e.child === l.child) {
        for (l = e.child; l;) {
          if (l === c) return ZH(e), t;
          if (l === r) return ZH(e), a;
          l = l.sibling;
        }
        throw Error(n1(188));
      }
      if (c.return !== r.return) c = e, r = l;else {
        for (var i = !1, o = e.child; o;) {
          if (o === c) {
            i = !0, c = e, r = l;
            break;
          }
          if (o === r) {
            i = !0, r = e, c = l;
            break;
          }
          o = o.sibling;
        }
        if (!i) {
          for (o = l.child; o;) {
            if (o === c) {
              i = !0, c = l, r = e;
              break;
            }
            if (o === r) {
              i = !0, r = l, c = e;
              break;
            }
            o = o.sibling;
          }
          if (!i) throw Error(n1(189));
        }
      }
      if (c.alternate !== r) throw Error(n1(190));
    }
    if (c.tag !== 3) throw Error(n1(188));
    return c.stateNode.current === c ? t : a;
  }
  function aw(t) {
    return t = $X(t), t !== null ? cw(t) : null;
  }
  function cw(t) {
    if (t.tag === 5 || t.tag === 6) return t;
    for (t = t.child; t !== null;) {
      var a = cw(t);
      if (a !== null) return a;
      t = t.sibling;
    }
    return null;
  }
  var rw = X0.unstable_scheduleCallback,
    OH = X0.unstable_cancelCallback,
    QX = X0.unstable_shouldYield,
    XX = X0.unstable_requestPaint,
    m2 = X0.unstable_now,
    YX = X0.unstable_getCurrentPriorityLevel,
    Fd = X0.unstable_ImmediatePriority,
    ew = X0.unstable_UserBlockingPriority,
    Zl = X0.unstable_NormalPriority,
    JX = X0.unstable_LowPriority,
    lw = X0.unstable_IdlePriority,
    li = null,
    V4 = null;
  function tY(t) {
    if (V4 && typeof V4.onCommitFiberRoot == "function") try {
      V4.onCommitFiberRoot(li, t, void 0, (t.current.flags & 128) === 128);
    } catch (a) {}
  }
  var U3 = Math.clz32 ? Math.clz32 : rY,
    aY = Math.log,
    cY = Math.LN2;
  function rY(t) {
    return t >>>= 0, t === 0 ? 32 : 31 - (aY(t) / cY | 0) | 0;
  }
  var hl = 64,
    vl = 4194304;
  function Ia(t) {
    switch (t & -t) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return t & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return t & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return t;
    }
  }
  function Ol(t, a) {
    var c = t.pendingLanes;
    if (c === 0) return 0;
    var r = 0,
      e = t.suspendedLanes,
      l = t.pingedLanes,
      i = c & 268435455;
    if (i !== 0) {
      var o = i & ~e;
      o !== 0 ? r = Ia(o) : (l &= i, l !== 0 && (r = Ia(l)));
    } else i = c & ~e, i !== 0 ? r = Ia(i) : l !== 0 && (r = Ia(l));
    if (r === 0) return 0;
    if (a !== 0 && a !== r && !(a & e) && (e = r & -r, l = a & -a, e >= l || e === 16 && (l & 4194240) !== 0)) return a;
    if (r & 4 && (r |= c & 16), a = t.entangledLanes, a !== 0) for (t = t.entanglements, a &= r; 0 < a;) c = 31 - U3(a), e = 1 << c, r |= t[c], a &= ~e;
    return r;
  }
  function eY(t, a) {
    switch (t) {
      case 1:
      case 2:
      case 4:
        return a + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function lY(t, a) {
    for (var c = t.suspendedLanes, r = t.pingedLanes, e = t.expirationTimes, l = t.pendingLanes; 0 < l;) {
      var i = 31 - U3(l),
        o = 1 << i,
        n = e[i];
      n === -1 ? (!(o & c) || o & r) && (e[i] = eY(o, a)) : n <= a && (t.expiredLanes |= o), l &= ~o;
    }
  }
  function Qg(t) {
    return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0;
  }
  function iw() {
    var t = hl;
    return hl <<= 1, !(hl & 4194240) && (hl = 64), t;
  }
  function pg(t) {
    for (var a = [], c = 0; 31 > c; c++) a.push(t);
    return a;
  }
  function nc(t, a, c) {
    t.pendingLanes |= a, a !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, a = 31 - U3(a), t[a] = c;
  }
  function iY(t, a) {
    var c = t.pendingLanes & ~a;
    t.pendingLanes = a, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= a, t.mutableReadLanes &= a, t.entangledLanes &= a, a = t.entanglements;
    var r = t.eventTimes;
    for (t = t.expirationTimes; 0 < c;) {
      var e = 31 - U3(c),
        l = 1 << e;
      a[e] = 0, r[e] = -1, t[e] = -1, c &= ~l;
    }
  }
  function Id(t, a) {
    var c = t.entangledLanes |= a;
    for (t = t.entanglements; c;) {
      var r = 31 - U3(c),
        e = 1 << r;
      e & a | t[r] & a && (t[r] |= a), c &= ~e;
    }
  }
  var W1 = 0;
  function ow(t) {
    return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var nw,
    Pd,
    hw,
    vw,
    gw,
    Xg = !1,
    gl = [],
    u6 = null,
    p6 = null,
    m6 = null,
    Ka = new Map(),
    $a = new Map(),
    g6 = [],
    oY = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function EH(t, a) {
    switch (t) {
      case "focusin":
      case "focusout":
        u6 = null;
        break;
      case "dragenter":
      case "dragleave":
        p6 = null;
        break;
      case "mouseover":
      case "mouseout":
        m6 = null;
        break;
      case "pointerover":
      case "pointerout":
        Ka.delete(a.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        $a.delete(a.pointerId);
    }
  }
  function wa(t, a, c, r, e, l) {
    return t === null || t.nativeEvent !== l ? (t = {
      blockedOn: a,
      domEventName: c,
      eventSystemFlags: r,
      nativeEvent: l,
      targetContainers: [e]
    }, a !== null && (a = vc(a), a !== null && Pd(a)), t) : (t.eventSystemFlags |= r, a = t.targetContainers, e !== null && a.indexOf(e) === -1 && a.push(e), t);
  }
  function nY(t, a, c, r, e) {
    switch (a) {
      case "focusin":
        return u6 = wa(u6, t, a, c, r, e), !0;
      case "dragenter":
        return p6 = wa(p6, t, a, c, r, e), !0;
      case "mouseover":
        return m6 = wa(m6, t, a, c, r, e), !0;
      case "pointerover":
        var l = e.pointerId;
        return Ka.set(l, wa(Ka.get(l) || null, t, a, c, r, e)), !0;
      case "gotpointercapture":
        return l = e.pointerId, $a.set(l, wa($a.get(l) || null, t, a, c, r, e)), !0;
    }
    return !1;
  }
  function dw(t) {
    var a = V8(t.target);
    if (a !== null) {
      var c = P8(a);
      if (c !== null) {
        if (a = c.tag, a === 13) {
          if (a = tw(c), a !== null) {
            t.blockedOn = a, gw(t.priority, function () {
              hw(c);
            });
            return;
          }
        } else if (a === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          t.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    t.blockedOn = null;
  }
  function wl(t) {
    if (t.blockedOn !== null) return !1;
    for (var a = t.targetContainers; 0 < a.length;) {
      var c = Yg(t.domEventName, t.eventSystemFlags, a[0], t.nativeEvent);
      if (c === null) {
        c = t.nativeEvent;
        var r = new c.constructor(c.type, c);
        Ng = r, c.target.dispatchEvent(r), Ng = null;
      } else return a = vc(c), a !== null && Pd(a), t.blockedOn = c, !1;
      a.shift();
    }
    return !0;
  }
  function DH(t, a, c) {
    wl(t) && c.delete(a);
  }
  function hY() {
    Xg = !1, u6 !== null && wl(u6) && (u6 = null), p6 !== null && wl(p6) && (p6 = null), m6 !== null && wl(m6) && (m6 = null), Ka.forEach(DH), $a.forEach(DH);
  }
  function Ba(t, a) {
    t.blockedOn === a && (t.blockedOn = null, Xg || (Xg = !0, X0.unstable_scheduleCallback(X0.unstable_NormalPriority, hY)));
  }
  function Qa(t) {
    function a(e) {
      return Ba(e, t);
    }
    if (0 < gl.length) {
      Ba(gl[0], t);
      for (var c = 1; c < gl.length; c++) {
        var r = gl[c];
        r.blockedOn === t && (r.blockedOn = null);
      }
    }
    for (u6 !== null && Ba(u6, t), p6 !== null && Ba(p6, t), m6 !== null && Ba(m6, t), Ka.forEach(a), $a.forEach(a), c = 0; c < g6.length; c++) r = g6[c], r.blockedOn === t && (r.blockedOn = null);
    for (; 0 < g6.length && (c = g6[0], c.blockedOn === null);) dw(c), c.blockedOn === null && g6.shift();
  }
  var v9 = u5.ReactCurrentBatchConfig,
    El = !0;
  function vY(t, a, c, r) {
    var e = W1,
      l = v9.transition;
    v9.transition = null;
    try {
      W1 = 1, Gd(t, a, c, r);
    } finally {
      W1 = e, v9.transition = l;
    }
  }
  function gY(t, a, c, r) {
    var e = W1,
      l = v9.transition;
    v9.transition = null;
    try {
      W1 = 4, Gd(t, a, c, r);
    } finally {
      W1 = e, v9.transition = l;
    }
  }
  function Gd(t, a, c, r) {
    if (El) {
      var e = Yg(t, a, c, r);
      if (e === null) Hg(t, a, r, Dl, c), EH(t, r);else if (nY(e, t, a, c, r)) r.stopPropagation();else if (EH(t, r), a & 4 && -1 < oY.indexOf(t)) {
        for (; e !== null;) {
          var l = vc(e);
          if (l !== null && nw(l), l = Yg(t, a, c, r), l === null && Hg(t, a, r, Dl, c), l === e) break;
          e = l;
        }
        e !== null && r.stopPropagation();
      } else Hg(t, a, r, null, c);
    }
  }
  var Dl = null;
  function Yg(t, a, c, r) {
    if (Dl = null, t = bd(r), t = V8(t), t !== null) if (a = P8(t), a === null) t = null;else if (c = a.tag, c === 13) {
      if (t = tw(a), t !== null) return t;
      t = null;
    } else if (c === 3) {
      if (a.stateNode.current.memoizedState.isDehydrated) return a.tag === 3 ? a.stateNode.containerInfo : null;
      t = null;
    } else a !== t && (t = null);
    return Dl = t, null;
  }
  function sw(t) {
    switch (t) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (YX()) {
          case Fd:
            return 1;
          case ew:
            return 4;
          case Zl:
          case JX:
            return 16;
          case lw:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var s6 = null,
    Td = null,
    Bl = null;
  function zw() {
    if (Bl) return Bl;
    var t,
      a = Td,
      c = a.length,
      r,
      e = "value" in s6 ? s6.value : s6.textContent,
      l = e.length;
    for (t = 0; t < c && a[t] === e[t]; t++);
    var i = c - t;
    for (r = 1; r <= i && a[c - r] === e[l - r]; r++);
    return Bl = e.slice(t, 1 < r ? 1 - r : void 0);
  }
  function yl(t) {
    var a = t.keyCode;
    return "charCode" in t ? (t = t.charCode, t === 0 && a === 13 && (t = 13)) : t = a, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
  }
  function dl() {
    return !0;
  }
  function WH() {
    return !1;
  }
  function Y0(t) {
    function a(c, r, e, l, i) {
      this._reactName = c, this._targetInst = e, this.type = r, this.nativeEvent = l, this.target = i, this.currentTarget = null;
      for (var o in t) t.hasOwnProperty(o) && (c = t[o], this[o] = c ? c(l) : l[o]);
      return this.isDefaultPrevented = (l.defaultPrevented != null ? l.defaultPrevented : l.returnValue === !1) ? dl : WH, this.isPropagationStopped = WH, this;
    }
    return v2(a.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var c = this.nativeEvent;
        c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = dl);
      },
      stopPropagation: function () {
        var c = this.nativeEvent;
        c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = dl);
      },
      persist: function () {},
      isPersistent: dl
    }), a;
  }
  var x9 = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (t) {
        return t.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    },
    Zd = Y0(x9),
    hc = v2({}, x9, {
      view: 0,
      detail: 0
    }),
    dY = Y0(hc),
    mg,
    fg,
    ya,
    ii = v2({}, hc, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Od,
      button: 0,
      buttons: 0,
      relatedTarget: function (t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
      },
      movementX: function (t) {
        return "movementX" in t ? t.movementX : (t !== ya && (ya && t.type === "mousemove" ? (mg = t.screenX - ya.screenX, fg = t.screenY - ya.screenY) : fg = mg = 0, ya = t), mg);
      },
      movementY: function (t) {
        return "movementY" in t ? t.movementY : fg;
      }
    }),
    _H = Y0(ii),
    sY = v2({}, ii, {
      dataTransfer: 0
    }),
    zY = Y0(sY),
    uY = v2({}, hc, {
      relatedTarget: 0
    }),
    Mg = Y0(uY),
    pY = v2({}, x9, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }),
    mY = Y0(pY),
    fY = v2({}, x9, {
      clipboardData: function (t) {
        return "clipboardData" in t ? t.clipboardData : window.clipboardData;
      }
    }),
    MY = Y0(fY),
    xY = v2({}, x9, {
      data: 0
    }),
    jH = Y0(xY),
    CY = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    },
    LY = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    },
    HY = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
  function VY(t) {
    var a = this.nativeEvent;
    return a.getModifierState ? a.getModifierState(t) : (t = HY[t]) ? !!a[t] : !1;
  }
  function Od() {
    return VY;
  }
  var wY = v2({}, hc, {
      key: function (t) {
        if (t.key) {
          var a = CY[t.key] || t.key;
          if (a !== "Unidentified") return a;
        }
        return t.type === "keypress" ? (t = yl(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? LY[t.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Od,
      charCode: function (t) {
        return t.type === "keypress" ? yl(t) : 0;
      },
      keyCode: function (t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      },
      which: function (t) {
        return t.type === "keypress" ? yl(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      }
    }),
    BY = Y0(wY),
    yY = v2({}, ii, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }),
    qH = Y0(yY),
    SY = v2({}, hc, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Od
    }),
    kY = Y0(SY),
    AY = v2({}, x9, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }),
    RY = Y0(AY),
    bY = v2({}, ii, {
      deltaX: function (t) {
        return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
      },
      deltaY: function (t) {
        return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }),
    FY = Y0(bY),
    IY = [9, 13, 27, 32],
    Ed = g5 && "CompositionEvent" in window,
    Za = null;
  g5 && "documentMode" in document && (Za = document.documentMode);
  var PY = g5 && "TextEvent" in window && !Za,
    uw = g5 && (!Ed || Za && 8 < Za && 11 >= Za),
    NH = String.fromCharCode(32),
    UH = !1;
  function pw(t, a) {
    switch (t) {
      case "keyup":
        return IY.indexOf(a.keyCode) !== -1;
      case "keydown":
        return a.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function mw(t) {
    return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
  }
  var X7 = !1;
  function GY(t, a) {
    switch (t) {
      case "compositionend":
        return mw(a);
      case "keypress":
        return a.which !== 32 ? null : (UH = !0, NH);
      case "textInput":
        return t = a.data, t === NH && UH ? null : t;
      default:
        return null;
    }
  }
  function TY(t, a) {
    if (X7) return t === "compositionend" || !Ed && pw(t, a) ? (t = zw(), Bl = Td = s6 = null, X7 = !1, t) : null;
    switch (t) {
      case "paste":
        return null;
      case "keypress":
        if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) {
          if (a.char && 1 < a.char.length) return a.char;
          if (a.which) return String.fromCharCode(a.which);
        }
        return null;
      case "compositionend":
        return uw && a.locale !== "ko" ? null : a.data;
      default:
        return null;
    }
  }
  var ZY = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function KH(t) {
    var a = t && t.nodeName && t.nodeName.toLowerCase();
    return a === "input" ? !!ZY[t.type] : a === "textarea";
  }
  function fw(t, a, c, r) {
    $V(r), a = Wl(a, "onChange"), 0 < a.length && (c = new Zd("onChange", "change", null, c, r), t.push({
      event: c,
      listeners: a
    }));
  }
  var Oa = null,
    Xa = null;
  function OY(t) {
    kw(t, 0);
  }
  function oi(t) {
    var a = t9(t);
    if (WV(a)) return t;
  }
  function EY(t, a) {
    if (t === "change") return a;
  }
  var Mw = !1;
  g5 && (g5 ? (zl = "oninput" in document, zl || (xg = document.createElement("div"), xg.setAttribute("oninput", "return;"), zl = typeof xg.oninput == "function"), sl = zl) : sl = !1, Mw = sl && (!document.documentMode || 9 < document.documentMode));
  var sl, zl, xg;
  function $H() {
    Oa && (Oa.detachEvent("onpropertychange", xw), Xa = Oa = null);
  }
  function xw(t) {
    if (t.propertyName === "value" && oi(Xa)) {
      var a = [];
      fw(a, Xa, t, bd(t)), JV(OY, a);
    }
  }
  function DY(t, a, c) {
    t === "focusin" ? ($H(), Oa = a, Xa = c, Oa.attachEvent("onpropertychange", xw)) : t === "focusout" && $H();
  }
  function WY(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown") return oi(Xa);
  }
  function _Y(t, a) {
    if (t === "click") return oi(a);
  }
  function jY(t, a) {
    if (t === "input" || t === "change") return oi(a);
  }
  function qY(t, a) {
    return t === a && (t !== 0 || 1 / t === 1 / a) || t !== t && a !== a;
  }
  var $3 = typeof Object.is == "function" ? Object.is : qY;
  function Ya(t, a) {
    if ($3(t, a)) return !0;
    if (typeof t != "object" || t === null || typeof a != "object" || a === null) return !1;
    var c = Object.keys(t),
      r = Object.keys(a);
    if (c.length !== r.length) return !1;
    for (r = 0; r < c.length; r++) {
      var e = c[r];
      if (!Ig.call(a, e) || !$3(t[e], a[e])) return !1;
    }
    return !0;
  }
  function QH(t) {
    for (; t && t.firstChild;) t = t.firstChild;
    return t;
  }
  function XH(t, a) {
    var c = QH(t);
    t = 0;
    for (var r; c;) {
      if (c.nodeType === 3) {
        if (r = t + c.textContent.length, t <= a && r >= a) return {
          node: c,
          offset: a - t
        };
        t = r;
      }
      t: {
        for (; c;) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break t;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = QH(c);
    }
  }
  function Cw(t, a) {
    return t && a ? t === a ? !0 : t && t.nodeType === 3 ? !1 : a && a.nodeType === 3 ? Cw(t, a.parentNode) : "contains" in t ? t.contains(a) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(a) & 16) : !1 : !1;
  }
  function Lw() {
    for (var t = window, a = Pl(); a instanceof t.HTMLIFrameElement;) {
      try {
        var c = typeof a.contentWindow.location.href == "string";
      } catch (r) {
        c = !1;
      }
      if (c) t = a.contentWindow;else break;
      a = Pl(t.document);
    }
    return a;
  }
  function Dd(t) {
    var a = t && t.nodeName && t.nodeName.toLowerCase();
    return a && (a === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || a === "textarea" || t.contentEditable === "true");
  }
  function NY(t) {
    var a = Lw(),
      c = t.focusedElem,
      r = t.selectionRange;
    if (a !== c && c && c.ownerDocument && Cw(c.ownerDocument.documentElement, c)) {
      if (r !== null && Dd(c)) {
        if (a = r.start, t = r.end, t === void 0 && (t = a), "selectionStart" in c) c.selectionStart = a, c.selectionEnd = Math.min(t, c.value.length);else if (t = (a = c.ownerDocument || document) && a.defaultView || window, t.getSelection) {
          t = t.getSelection();
          var e = c.textContent.length,
            l = Math.min(r.start, e);
          r = r.end === void 0 ? l : Math.min(r.end, e), !t.extend && l > r && (e = r, r = l, l = e), e = XH(c, l);
          var i = XH(c, r);
          e && i && (t.rangeCount !== 1 || t.anchorNode !== e.node || t.anchorOffset !== e.offset || t.focusNode !== i.node || t.focusOffset !== i.offset) && (a = a.createRange(), a.setStart(e.node, e.offset), t.removeAllRanges(), l > r ? (t.addRange(a), t.extend(i.node, i.offset)) : (a.setEnd(i.node, i.offset), t.addRange(a)));
        }
      }
      for (a = [], t = c; t = t.parentNode;) t.nodeType === 1 && a.push({
        element: t,
        left: t.scrollLeft,
        top: t.scrollTop
      });
      for (typeof c.focus == "function" && c.focus(), c = 0; c < a.length; c++) t = a[c], t.element.scrollLeft = t.left, t.element.scrollTop = t.top;
    }
  }
  var UY = g5 && "documentMode" in document && 11 >= document.documentMode,
    Y7 = null,
    Jg = null,
    Ea = null,
    td = !1;
  function YH(t, a, c) {
    var r = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    td || Y7 == null || Y7 !== Pl(r) || (r = Y7, "selectionStart" in r && Dd(r) ? r = {
      start: r.selectionStart,
      end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
      anchorNode: r.anchorNode,
      anchorOffset: r.anchorOffset,
      focusNode: r.focusNode,
      focusOffset: r.focusOffset
    }), Ea && Ya(Ea, r) || (Ea = r, r = Wl(Jg, "onSelect"), 0 < r.length && (a = new Zd("onSelect", "select", null, a, c), t.push({
      event: a,
      listeners: r
    }), a.target = Y7)));
  }
  function ul(t, a) {
    var c = {};
    return c[t.toLowerCase()] = a.toLowerCase(), c["Webkit" + t] = "webkit" + a, c["Moz" + t] = "moz" + a, c;
  }
  var J7 = {
      animationend: ul("Animation", "AnimationEnd"),
      animationiteration: ul("Animation", "AnimationIteration"),
      animationstart: ul("Animation", "AnimationStart"),
      transitionend: ul("Transition", "TransitionEnd")
    },
    Cg = {},
    Hw = {};
  g5 && (Hw = document.createElement("div").style, "AnimationEvent" in window || (delete J7.animationend.animation, delete J7.animationiteration.animation, delete J7.animationstart.animation), "TransitionEvent" in window || delete J7.transitionend.transition);
  function ni(t) {
    if (Cg[t]) return Cg[t];
    if (!J7[t]) return t;
    var a = J7[t],
      c;
    for (c in a) if (a.hasOwnProperty(c) && c in Hw) return Cg[t] = a[c];
    return t;
  }
  var Vw = ni("animationend"),
    ww = ni("animationiteration"),
    Bw = ni("animationstart"),
    yw = ni("transitionend"),
    Sw = new Map(),
    JH = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function w6(t, a) {
    Sw.set(t, a), I8(a, [t]);
  }
  for (pl = 0; pl < JH.length; pl++) ml = JH[pl], tV = ml.toLowerCase(), aV = ml[0].toUpperCase() + ml.slice(1), w6(tV, "on" + aV);
  var ml, tV, aV, pl;
  w6(Vw, "onAnimationEnd");
  w6(ww, "onAnimationIteration");
  w6(Bw, "onAnimationStart");
  w6("dblclick", "onDoubleClick");
  w6("focusin", "onFocus");
  w6("focusout", "onBlur");
  w6(yw, "onTransitionEnd");
  s9("onMouseEnter", ["mouseout", "mouseover"]);
  s9("onMouseLeave", ["mouseout", "mouseover"]);
  s9("onPointerEnter", ["pointerout", "pointerover"]);
  s9("onPointerLeave", ["pointerout", "pointerover"]);
  I8("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  I8("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  I8("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  I8("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  I8("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  I8("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Pa = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    KY = new Set("cancel close invalid load scroll toggle".split(" ").concat(Pa));
  function cV(t, a, c) {
    var r = t.type || "unknown-event";
    t.currentTarget = c, KX(r, a, void 0, t), t.currentTarget = null;
  }
  function kw(t, a) {
    a = (a & 4) !== 0;
    for (var c = 0; c < t.length; c++) {
      var r = t[c],
        e = r.event;
      r = r.listeners;
      t: {
        var l = void 0;
        if (a) for (var i = r.length - 1; 0 <= i; i--) {
          var o = r[i],
            n = o.instance,
            h = o.currentTarget;
          if (o = o.listener, n !== l && e.isPropagationStopped()) break t;
          cV(e, o, h), l = n;
        } else for (i = 0; i < r.length; i++) {
          if (o = r[i], n = o.instance, h = o.currentTarget, o = o.listener, n !== l && e.isPropagationStopped()) break t;
          cV(e, o, h), l = n;
        }
      }
    }
    if (Tl) throw t = $g, Tl = !1, $g = null, t;
  }
  function t2(t, a) {
    var c = a[ld];
    c === void 0 && (c = a[ld] = new Set());
    var r = t + "__bubble";
    c.has(r) || (Aw(a, t, 2, !1), c.add(r));
  }
  function Lg(t, a, c) {
    var r = 0;
    a && (r |= 4), Aw(c, t, r, a);
  }
  var fl = "_reactListening" + Math.random().toString(36).slice(2);
  function Ja(t) {
    if (!t[fl]) {
      t[fl] = !0, TV.forEach(function (c) {
        c !== "selectionchange" && (KY.has(c) || Lg(c, !1, t), Lg(c, !0, t));
      });
      var a = t.nodeType === 9 ? t : t.ownerDocument;
      a === null || a[fl] || (a[fl] = !0, Lg("selectionchange", !1, a));
    }
  }
  function Aw(t, a, c, r) {
    switch (sw(a)) {
      case 1:
        var e = vY;
        break;
      case 4:
        e = gY;
        break;
      default:
        e = Gd;
    }
    c = e.bind(null, a, c, t), e = void 0, !Kg || a !== "touchstart" && a !== "touchmove" && a !== "wheel" || (e = !0), r ? e !== void 0 ? t.addEventListener(a, c, {
      capture: !0,
      passive: e
    }) : t.addEventListener(a, c, !0) : e !== void 0 ? t.addEventListener(a, c, {
      passive: e
    }) : t.addEventListener(a, c, !1);
  }
  function Hg(t, a, c, r, e) {
    var l = r;
    if (!(a & 1) && !(a & 2) && r !== null) t: for (;;) {
      if (r === null) return;
      var i = r.tag;
      if (i === 3 || i === 4) {
        var o = r.stateNode.containerInfo;
        if (o === e || o.nodeType === 8 && o.parentNode === e) break;
        if (i === 4) for (i = r.return; i !== null;) {
          var n = i.tag;
          if ((n === 3 || n === 4) && (n = i.stateNode.containerInfo, n === e || n.nodeType === 8 && n.parentNode === e)) return;
          i = i.return;
        }
        for (; o !== null;) {
          if (i = V8(o), i === null) return;
          if (n = i.tag, n === 5 || n === 6) {
            r = l = i;
            continue t;
          }
          o = o.parentNode;
        }
      }
      r = r.return;
    }
    JV(function () {
      var h = l,
        v = bd(c),
        g = [];
      t: {
        var s = Sw.get(t);
        if (s !== void 0) {
          var d = Zd,
            z = t;
          switch (t) {
            case "keypress":
              if (yl(c) === 0) break t;
            case "keydown":
            case "keyup":
              d = BY;
              break;
            case "focusin":
              z = "focus", d = Mg;
              break;
            case "focusout":
              z = "blur", d = Mg;
              break;
            case "beforeblur":
            case "afterblur":
              d = Mg;
              break;
            case "click":
              if (c.button === 2) break t;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              d = _H;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              d = zY;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              d = kY;
              break;
            case Vw:
            case ww:
            case Bw:
              d = mY;
              break;
            case yw:
              d = RY;
              break;
            case "scroll":
              d = dY;
              break;
            case "wheel":
              d = FY;
              break;
            case "copy":
            case "cut":
            case "paste":
              d = MY;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              d = qH;
          }
          var u = (a & 4) !== 0,
            f = !u && t === "scroll",
            p = u ? s !== null ? s + "Capture" : null : s;
          u = [];
          for (var m = h, M; m !== null;) {
            M = m;
            var w = M.stateNode;
            if (M.tag === 5 && w !== null && (M = w, p !== null && (w = Ua(m, p), w != null && u.push(tc(m, w, M)))), f) break;
            m = m.return;
          }
          0 < u.length && (s = new d(s, z, null, c, v), g.push({
            event: s,
            listeners: u
          }));
        }
      }
      if (!(a & 7)) {
        t: {
          if (s = t === "mouseover" || t === "pointerover", d = t === "mouseout" || t === "pointerout", s && c !== Ng && (z = c.relatedTarget || c.fromElement) && (V8(z) || z[d5])) break t;
          if ((d || s) && (s = v.window === v ? v : (s = v.ownerDocument) ? s.defaultView || s.parentWindow : window, d ? (z = c.relatedTarget || c.toElement, d = h, z = z ? V8(z) : null, z !== null && (f = P8(z), z !== f || z.tag !== 5 && z.tag !== 6) && (z = null)) : (d = null, z = h), d !== z)) {
            if (u = _H, w = "onMouseLeave", p = "onMouseEnter", m = "mouse", (t === "pointerout" || t === "pointerover") && (u = qH, w = "onPointerLeave", p = "onPointerEnter", m = "pointer"), f = d == null ? s : t9(d), M = z == null ? s : t9(z), s = new u(w, m + "leave", d, c, v), s.target = f, s.relatedTarget = M, w = null, V8(v) === h && (u = new u(p, m + "enter", z, c, v), u.target = M, u.relatedTarget = f, w = u), f = w, d && z) a: {
              for (u = d, p = z, m = 0, M = u; M; M = K7(M)) m++;
              for (M = 0, w = p; w; w = K7(w)) M++;
              for (; 0 < m - M;) u = K7(u), m--;
              for (; 0 < M - m;) p = K7(p), M--;
              for (; m--;) {
                if (u === p || p !== null && u === p.alternate) break a;
                u = K7(u), p = K7(p);
              }
              u = null;
            } else u = null;
            d !== null && rV(g, s, d, u, !1), z !== null && f !== null && rV(g, f, z, u, !0);
          }
        }
        t: {
          if (s = h ? t9(h) : window, d = s.nodeName && s.nodeName.toLowerCase(), d === "select" || d === "input" && s.type === "file") var H = EY;else if (KH(s)) {
            if (Mw) H = jY;else {
              H = WY;
              var y = DY;
            }
          } else (d = s.nodeName) && d.toLowerCase() === "input" && (s.type === "checkbox" || s.type === "radio") && (H = _Y);
          if (H && (H = H(t, h))) {
            fw(g, H, c, v);
            break t;
          }
          y && y(t, s, h), t === "focusout" && (y = s._wrapperState) && y.controlled && s.type === "number" && Dg(s, "number", s.value);
        }
        switch (y = h ? t9(h) : window, t) {
          case "focusin":
            (KH(y) || y.contentEditable === "true") && (Y7 = y, Jg = h, Ea = null);
            break;
          case "focusout":
            Ea = Jg = Y7 = null;
            break;
          case "mousedown":
            td = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            td = !1, YH(g, c, v);
            break;
          case "selectionchange":
            if (UY) break;
          case "keydown":
          case "keyup":
            YH(g, c, v);
        }
        var k;
        if (Ed) t: {
          switch (t) {
            case "compositionstart":
              var F = "onCompositionStart";
              break t;
            case "compositionend":
              F = "onCompositionEnd";
              break t;
            case "compositionupdate":
              F = "onCompositionUpdate";
              break t;
          }
          F = void 0;
        } else X7 ? pw(t, c) && (F = "onCompositionEnd") : t === "keydown" && c.keyCode === 229 && (F = "onCompositionStart");
        F && (uw && c.locale !== "ko" && (X7 || F !== "onCompositionStart" ? F === "onCompositionEnd" && X7 && (k = zw()) : (s6 = v, Td = "value" in s6 ? s6.value : s6.textContent, X7 = !0)), y = Wl(h, F), 0 < y.length && (F = new jH(F, t, null, c, v), g.push({
          event: F,
          listeners: y
        }), k ? F.data = k : (k = mw(c), k !== null && (F.data = k)))), (k = PY ? GY(t, c) : TY(t, c)) && (h = Wl(h, "onBeforeInput"), 0 < h.length && (v = new jH("onBeforeInput", "beforeinput", null, c, v), g.push({
          event: v,
          listeners: h
        }), v.data = k));
      }
      kw(g, a);
    });
  }
  function tc(t, a, c) {
    return {
      instance: t,
      listener: a,
      currentTarget: c
    };
  }
  function Wl(t, a) {
    for (var c = a + "Capture", r = []; t !== null;) {
      var e = t,
        l = e.stateNode;
      e.tag === 5 && l !== null && (e = l, l = Ua(t, c), l != null && r.unshift(tc(t, l, e)), l = Ua(t, a), l != null && r.push(tc(t, l, e))), t = t.return;
    }
    return r;
  }
  function K7(t) {
    if (t === null) return null;
    do t = t.return; while (t && t.tag !== 5);
    return t || null;
  }
  function rV(t, a, c, r, e) {
    for (var l = a._reactName, i = []; c !== null && c !== r;) {
      var o = c,
        n = o.alternate,
        h = o.stateNode;
      if (n !== null && n === r) break;
      o.tag === 5 && h !== null && (o = h, e ? (n = Ua(c, l), n != null && i.unshift(tc(c, n, o))) : e || (n = Ua(c, l), n != null && i.push(tc(c, n, o)))), c = c.return;
    }
    i.length !== 0 && t.push({
      event: a,
      listeners: i
    });
  }
  var $Y = /\r\n?/g,
    QY = /\u0000|\uFFFD/g;
  function eV(t) {
    return (typeof t == "string" ? t : "" + t).replace($Y, "\n").replace(QY, "");
  }
  function Ml(t, a, c) {
    if (a = eV(a), eV(t) !== a && c) throw Error(n1(425));
  }
  function _l() {}
  var ad = null,
    cd = null;
  function rd(t, a) {
    return t === "textarea" || t === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
  }
  var ed = typeof setTimeout == "function" ? setTimeout : void 0,
    XY = typeof clearTimeout == "function" ? clearTimeout : void 0,
    lV = typeof Promise == "function" ? Promise : void 0,
    YY = typeof queueMicrotask == "function" ? queueMicrotask : typeof lV != "undefined" ? function (t) {
      return lV.resolve(null).then(t).catch(JY);
    } : ed;
  function JY(t) {
    setTimeout(function () {
      throw t;
    });
  }
  function Vg(t, a) {
    var c = a,
      r = 0;
    do {
      var e = c.nextSibling;
      if (t.removeChild(c), e && e.nodeType === 8) if (c = e.data, c === "/$") {
        if (r === 0) {
          t.removeChild(e), Qa(a);
          return;
        }
        r--;
      } else c !== "$" && c !== "$?" && c !== "$!" || r++;
      c = e;
    } while (c);
    Qa(a);
  }
  function f6(t) {
    for (; t != null; t = t.nextSibling) {
      var a = t.nodeType;
      if (a === 1 || a === 3) break;
      if (a === 8) {
        if (a = t.data, a === "$" || a === "$!" || a === "$?") break;
        if (a === "/$") return null;
      }
    }
    return t;
  }
  function iV(t) {
    t = t.previousSibling;
    for (var a = 0; t;) {
      if (t.nodeType === 8) {
        var c = t.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (a === 0) return t;
          a--;
        } else c === "/$" && a++;
      }
      t = t.previousSibling;
    }
    return null;
  }
  var C9 = Math.random().toString(36).slice(2),
    H4 = "__reactFiber$" + C9,
    ac = "__reactProps$" + C9,
    d5 = "__reactContainer$" + C9,
    ld = "__reactEvents$" + C9,
    tJ = "__reactListeners$" + C9,
    aJ = "__reactHandles$" + C9;
  function V8(t) {
    var a = t[H4];
    if (a) return a;
    for (var c = t.parentNode; c;) {
      if (a = c[d5] || c[H4]) {
        if (c = a.alternate, a.child !== null || c !== null && c.child !== null) for (t = iV(t); t !== null;) {
          if (c = t[H4]) return c;
          t = iV(t);
        }
        return a;
      }
      t = c, c = t.parentNode;
    }
    return null;
  }
  function vc(t) {
    return t = t[H4] || t[d5], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t;
  }
  function t9(t) {
    if (t.tag === 5 || t.tag === 6) return t.stateNode;
    throw Error(n1(33));
  }
  function hi(t) {
    return t[ac] || null;
  }
  var id = [],
    a9 = -1;
  function B6(t) {
    return {
      current: t
    };
  }
  function a2(t) {
    0 > a9 || (t.current = id[a9], id[a9] = null, a9--);
  }
  function $1(t, a) {
    a9++, id[a9] = t.current, t.current = a;
  }
  var V6 = {},
    n0 = B6(V6),
    S0 = B6(!1),
    k8 = V6;
  function z9(t, a) {
    var c = t.type.contextTypes;
    if (!c) return V6;
    var r = t.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === a) return r.__reactInternalMemoizedMaskedChildContext;
    var e = {},
      l;
    for (l in c) e[l] = a[l];
    return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = a, t.__reactInternalMemoizedMaskedChildContext = e), e;
  }
  function k0(t) {
    return t = t.childContextTypes, t != null;
  }
  function jl() {
    a2(S0), a2(n0);
  }
  function oV(t, a, c) {
    if (n0.current !== V6) throw Error(n1(168));
    $1(n0, a), $1(S0, c);
  }
  function Rw(t, a, c) {
    var r = t.stateNode;
    if (a = a.childContextTypes, typeof r.getChildContext != "function") return c;
    r = r.getChildContext();
    for (var e in r) if (!(e in a)) throw Error(n1(108, DX(t) || "Unknown", e));
    return v2({}, c, r);
  }
  function ql(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || V6, k8 = n0.current, $1(n0, t), $1(S0, S0.current), !0;
  }
  function nV(t, a, c) {
    var r = t.stateNode;
    if (!r) throw Error(n1(169));
    c ? (t = Rw(t, a, k8), r.__reactInternalMemoizedMergedChildContext = t, a2(S0), a2(n0), $1(n0, t)) : a2(S0), $1(S0, c);
  }
  var o5 = null,
    vi = !1,
    wg = !1;
  function bw(t) {
    o5 === null ? o5 = [t] : o5.push(t);
  }
  function cJ(t) {
    vi = !0, bw(t);
  }
  function y6() {
    if (!wg && o5 !== null) {
      wg = !0;
      var t = 0,
        a = W1;
      try {
        var c = o5;
        for (W1 = 1; t < c.length; t++) {
          var r = c[t];
          do r = r(!0); while (r !== null);
        }
        o5 = null, vi = !1;
      } catch (e) {
        throw o5 !== null && (o5 = o5.slice(t + 1)), rw(Fd, y6), e;
      } finally {
        W1 = a, wg = !1;
      }
    }
    return null;
  }
  var c9 = [],
    r9 = 0,
    Nl = null,
    Ul = 0,
    L3 = [],
    H3 = 0,
    A8 = null,
    n5 = 1,
    h5 = "";
  function L8(t, a) {
    c9[r9++] = Ul, c9[r9++] = Nl, Nl = t, Ul = a;
  }
  function Fw(t, a, c) {
    L3[H3++] = n5, L3[H3++] = h5, L3[H3++] = A8, A8 = t;
    var r = n5;
    t = h5;
    var e = 32 - U3(r) - 1;
    r &= ~(1 << e), c += 1;
    var l = 32 - U3(a) + e;
    if (30 < l) {
      var i = e - e % 5;
      l = (r & (1 << i) - 1).toString(32), r >>= i, e -= i, n5 = 1 << 32 - U3(a) + e | c << e | r, h5 = l + t;
    } else n5 = 1 << l | c << e | r, h5 = t;
  }
  function Wd(t) {
    t.return !== null && (L8(t, 1), Fw(t, 1, 0));
  }
  function _d(t) {
    for (; t === Nl;) Nl = c9[--r9], c9[r9] = null, Ul = c9[--r9], c9[r9] = null;
    for (; t === A8;) A8 = L3[--H3], L3[H3] = null, h5 = L3[--H3], L3[H3] = null, n5 = L3[--H3], L3[H3] = null;
  }
  var Q0 = null,
    $0 = null,
    l2 = !1,
    N3 = null;
  function Iw(t, a) {
    var c = V3(5, null, null, 0);
    c.elementType = "DELETED", c.stateNode = a, c.return = t, a = t.deletions, a === null ? (t.deletions = [c], t.flags |= 16) : a.push(c);
  }
  function hV(t, a) {
    switch (t.tag) {
      case 5:
        var c = t.type;
        return a = a.nodeType !== 1 || c.toLowerCase() !== a.nodeName.toLowerCase() ? null : a, a !== null ? (t.stateNode = a, Q0 = t, $0 = f6(a.firstChild), !0) : !1;
      case 6:
        return a = t.pendingProps === "" || a.nodeType !== 3 ? null : a, a !== null ? (t.stateNode = a, Q0 = t, $0 = null, !0) : !1;
      case 13:
        return a = a.nodeType !== 8 ? null : a, a !== null ? (c = A8 !== null ? {
          id: n5,
          overflow: h5
        } : null, t.memoizedState = {
          dehydrated: a,
          treeContext: c,
          retryLane: 1073741824
        }, c = V3(18, null, null, 0), c.stateNode = a, c.return = t, t.child = c, Q0 = t, $0 = null, !0) : !1;
      default:
        return !1;
    }
  }
  function od(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
  }
  function nd(t) {
    if (l2) {
      var a = $0;
      if (a) {
        var c = a;
        if (!hV(t, a)) {
          if (od(t)) throw Error(n1(418));
          a = f6(c.nextSibling);
          var r = Q0;
          a && hV(t, a) ? Iw(r, c) : (t.flags = t.flags & -4097 | 2, l2 = !1, Q0 = t);
        }
      } else {
        if (od(t)) throw Error(n1(418));
        t.flags = t.flags & -4097 | 2, l2 = !1, Q0 = t;
      }
    }
  }
  function vV(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;) t = t.return;
    Q0 = t;
  }
  function xl(t) {
    if (t !== Q0) return !1;
    if (!l2) return vV(t), l2 = !0, !1;
    var a;
    if ((a = t.tag !== 3) && !(a = t.tag !== 5) && (a = t.type, a = a !== "head" && a !== "body" && !rd(t.type, t.memoizedProps)), a && (a = $0)) {
      if (od(t)) throw Pw(), Error(n1(418));
      for (; a;) Iw(t, a), a = f6(a.nextSibling);
    }
    if (vV(t), t.tag === 13) {
      if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(n1(317));
      t: {
        for (t = t.nextSibling, a = 0; t;) {
          if (t.nodeType === 8) {
            var c = t.data;
            if (c === "/$") {
              if (a === 0) {
                $0 = f6(t.nextSibling);
                break t;
              }
              a--;
            } else c !== "$" && c !== "$!" && c !== "$?" || a++;
          }
          t = t.nextSibling;
        }
        $0 = null;
      }
    } else $0 = Q0 ? f6(t.stateNode.nextSibling) : null;
    return !0;
  }
  function Pw() {
    for (var t = $0; t;) t = f6(t.nextSibling);
  }
  function u9() {
    $0 = Q0 = null, l2 = !1;
  }
  function jd(t) {
    N3 === null ? N3 = [t] : N3.push(t);
  }
  var rJ = u5.ReactCurrentBatchConfig;
  function j3(t, a) {
    if (t && t.defaultProps) {
      a = v2({}, a), t = t.defaultProps;
      for (var c in t) a[c] === void 0 && (a[c] = t[c]);
      return a;
    }
    return a;
  }
  var Kl = B6(null),
    $l = null,
    e9 = null,
    qd = null;
  function Nd() {
    qd = e9 = $l = null;
  }
  function Ud(t) {
    var a = Kl.current;
    a2(Kl), t._currentValue = a;
  }
  function hd(t, a, c) {
    for (; t !== null;) {
      var r = t.alternate;
      if ((t.childLanes & a) !== a ? (t.childLanes |= a, r !== null && (r.childLanes |= a)) : r !== null && (r.childLanes & a) !== a && (r.childLanes |= a), t === c) break;
      t = t.return;
    }
  }
  function g9(t, a) {
    $l = t, qd = e9 = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & a && (y0 = !0), t.firstContext = null);
  }
  function B3(t) {
    var a = t._currentValue;
    if (qd !== t) if (t = {
      context: t,
      memoizedValue: a,
      next: null
    }, e9 === null) {
      if ($l === null) throw Error(n1(308));
      e9 = t, $l.dependencies = {
        lanes: 0,
        firstContext: t
      };
    } else e9 = e9.next = t;
    return a;
  }
  var w8 = null;
  function Kd(t) {
    w8 === null ? w8 = [t] : w8.push(t);
  }
  function Gw(t, a, c, r) {
    var e = a.interleaved;
    return e === null ? (c.next = c, Kd(a)) : (c.next = e.next, e.next = c), a.interleaved = c, s5(t, r);
  }
  function s5(t, a) {
    t.lanes |= a;
    var c = t.alternate;
    for (c !== null && (c.lanes |= a), c = t, t = t.return; t !== null;) t.childLanes |= a, c = t.alternate, c !== null && (c.childLanes |= a), c = t, t = t.return;
    return c.tag === 3 ? c.stateNode : null;
  }
  var v6 = !1;
  function $d(t) {
    t.updateQueue = {
      baseState: t.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
        interleaved: null,
        lanes: 0
      },
      effects: null
    };
  }
  function Tw(t, a) {
    t = t.updateQueue, a.updateQueue === t && (a.updateQueue = {
      baseState: t.baseState,
      firstBaseUpdate: t.firstBaseUpdate,
      lastBaseUpdate: t.lastBaseUpdate,
      shared: t.shared,
      effects: t.effects
    });
  }
  function v5(t, a) {
    return {
      eventTime: t,
      lane: a,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
  }
  function M6(t, a, c) {
    var r = t.updateQueue;
    if (r === null) return null;
    if (r = r.shared, T1 & 2) {
      var e = r.pending;
      return e === null ? a.next = a : (a.next = e.next, e.next = a), r.pending = a, s5(t, c);
    }
    return e = r.interleaved, e === null ? (a.next = a, Kd(r)) : (a.next = e.next, e.next = a), r.interleaved = a, s5(t, c);
  }
  function Sl(t, a, c) {
    if (a = a.updateQueue, a !== null && (a = a.shared, (c & 4194240) !== 0)) {
      var r = a.lanes;
      r &= t.pendingLanes, c |= r, a.lanes = c, Id(t, c);
    }
  }
  function gV(t, a) {
    var c = t.updateQueue,
      r = t.alternate;
    if (r !== null && (r = r.updateQueue, c === r)) {
      var e = null,
        l = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var i = {
            eventTime: c.eventTime,
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: c.callback,
            next: null
          };
          l === null ? e = l = i : l = l.next = i, c = c.next;
        } while (c !== null);
        l === null ? e = l = a : l = l.next = a;
      } else e = l = a;
      c = {
        baseState: r.baseState,
        firstBaseUpdate: e,
        lastBaseUpdate: l,
        shared: r.shared,
        effects: r.effects
      }, t.updateQueue = c;
      return;
    }
    t = c.lastBaseUpdate, t === null ? c.firstBaseUpdate = a : t.next = a, c.lastBaseUpdate = a;
  }
  function Ql(t, a, c, r) {
    var e = t.updateQueue;
    v6 = !1;
    var l = e.firstBaseUpdate,
      i = e.lastBaseUpdate,
      o = e.shared.pending;
    if (o !== null) {
      e.shared.pending = null;
      var n = o,
        h = n.next;
      n.next = null, i === null ? l = h : i.next = h, i = n;
      var v = t.alternate;
      v !== null && (v = v.updateQueue, o = v.lastBaseUpdate, o !== i && (o === null ? v.firstBaseUpdate = h : o.next = h, v.lastBaseUpdate = n));
    }
    if (l !== null) {
      var g = e.baseState;
      i = 0, v = h = n = null, o = l;
      do {
        var s = o.lane,
          d = o.eventTime;
        if ((r & s) === s) {
          v !== null && (v = v.next = {
            eventTime: d,
            lane: 0,
            tag: o.tag,
            payload: o.payload,
            callback: o.callback,
            next: null
          });
          t: {
            var z = t,
              u = o;
            switch (s = a, d = c, u.tag) {
              case 1:
                if (z = u.payload, typeof z == "function") {
                  g = z.call(d, g, s);
                  break t;
                }
                g = z;
                break t;
              case 3:
                z.flags = z.flags & -65537 | 128;
              case 0:
                if (z = u.payload, s = typeof z == "function" ? z.call(d, g, s) : z, s == null) break t;
                g = v2({}, g, s);
                break t;
              case 2:
                v6 = !0;
            }
          }
          o.callback !== null && o.lane !== 0 && (t.flags |= 64, s = e.effects, s === null ? e.effects = [o] : s.push(o));
        } else d = {
          eventTime: d,
          lane: s,
          tag: o.tag,
          payload: o.payload,
          callback: o.callback,
          next: null
        }, v === null ? (h = v = d, n = g) : v = v.next = d, i |= s;
        if (o = o.next, o === null) {
          if (o = e.shared.pending, o === null) break;
          s = o, o = s.next, s.next = null, e.lastBaseUpdate = s, e.shared.pending = null;
        }
      } while (1);
      if (v === null && (n = g), e.baseState = n, e.firstBaseUpdate = h, e.lastBaseUpdate = v, a = e.shared.interleaved, a !== null) {
        e = a;
        do i |= e.lane, e = e.next; while (e !== a);
      } else l === null && (e.shared.lanes = 0);
      b8 |= i, t.lanes = i, t.memoizedState = g;
    }
  }
  function dV(t, a, c) {
    if (t = a.effects, a.effects = null, t !== null) for (a = 0; a < t.length; a++) {
      var r = t[a],
        e = r.callback;
      if (e !== null) {
        if (r.callback = null, r = c, typeof e != "function") throw Error(n1(191, e));
        e.call(r);
      }
    }
  }
  var Zw = new GV.Component().refs;
  function vd(t, a, c, r) {
    a = t.memoizedState, c = c(r, a), c = c == null ? a : v2({}, a, c), t.memoizedState = c, t.lanes === 0 && (t.updateQueue.baseState = c);
  }
  var gi = {
    isMounted: function (t) {
      return (t = t._reactInternals) ? P8(t) === t : !1;
    },
    enqueueSetState: function (t, a, c) {
      t = t._reactInternals;
      var r = M0(),
        e = C6(t),
        l = v5(r, e);
      l.payload = a, c != null && (l.callback = c), a = M6(t, l, e), a !== null && (K3(a, t, e, r), Sl(a, t, e));
    },
    enqueueReplaceState: function (t, a, c) {
      t = t._reactInternals;
      var r = M0(),
        e = C6(t),
        l = v5(r, e);
      l.tag = 1, l.payload = a, c != null && (l.callback = c), a = M6(t, l, e), a !== null && (K3(a, t, e, r), Sl(a, t, e));
    },
    enqueueForceUpdate: function (t, a) {
      t = t._reactInternals;
      var c = M0(),
        r = C6(t),
        e = v5(c, r);
      e.tag = 2, a != null && (e.callback = a), a = M6(t, e, r), a !== null && (K3(a, t, r, c), Sl(a, t, r));
    }
  };
  function sV(t, a, c, r, e, l, i) {
    return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, l, i) : a.prototype && a.prototype.isPureReactComponent ? !Ya(c, r) || !Ya(e, l) : !0;
  }
  function Ow(t, a, c) {
    var r = !1,
      e = V6,
      l = a.contextType;
    return typeof l == "object" && l !== null ? l = B3(l) : (e = k0(a) ? k8 : n0.current, r = a.contextTypes, l = (r = r != null) ? z9(t, e) : V6), a = new a(c, l), t.memoizedState = a.state !== null && a.state !== void 0 ? a.state : null, a.updater = gi, t.stateNode = a, a._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = l), a;
  }
  function zV(t, a, c, r) {
    t = a.state, typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(c, r), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(c, r), a.state !== t && gi.enqueueReplaceState(a, a.state, null);
  }
  function gd(t, a, c, r) {
    var e = t.stateNode;
    e.props = c, e.state = t.memoizedState, e.refs = Zw, $d(t);
    var l = a.contextType;
    typeof l == "object" && l !== null ? e.context = B3(l) : (l = k0(a) ? k8 : n0.current, e.context = z9(t, l)), e.state = t.memoizedState, l = a.getDerivedStateFromProps, typeof l == "function" && (vd(t, a, l, c), e.state = t.memoizedState), typeof a.getDerivedStateFromProps == "function" || typeof e.getSnapshotBeforeUpdate == "function" || typeof e.UNSAFE_componentWillMount != "function" && typeof e.componentWillMount != "function" || (a = e.state, typeof e.componentWillMount == "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount == "function" && e.UNSAFE_componentWillMount(), a !== e.state && gi.enqueueReplaceState(e, e.state, null), Ql(t, c, e, r), e.state = t.memoizedState), typeof e.componentDidMount == "function" && (t.flags |= 4194308);
  }
  function Sa(t, a, c) {
    if (t = c.ref, t !== null && typeof t != "function" && typeof t != "object") {
      if (c._owner) {
        if (c = c._owner, c) {
          if (c.tag !== 1) throw Error(n1(309));
          var r = c.stateNode;
        }
        if (!r) throw Error(n1(147, t));
        var e = r,
          l = "" + t;
        return a !== null && a.ref !== null && typeof a.ref == "function" && a.ref._stringRef === l ? a.ref : (a = function (i) {
          var o = e.refs;
          o === Zw && (o = e.refs = {}), i === null ? delete o[l] : o[l] = i;
        }, a._stringRef = l, a);
      }
      if (typeof t != "string") throw Error(n1(284));
      if (!c._owner) throw Error(n1(290, t));
    }
    return t;
  }
  function Cl(t, a) {
    throw t = Object.prototype.toString.call(a), Error(n1(31, t === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : t));
  }
  function uV(t) {
    var a = t._init;
    return a(t._payload);
  }
  function Ew(t) {
    function a(p, m) {
      if (t) {
        var M = p.deletions;
        M === null ? (p.deletions = [m], p.flags |= 16) : M.push(m);
      }
    }
    function c(p, m) {
      if (!t) return null;
      for (; m !== null;) a(p, m), m = m.sibling;
      return null;
    }
    function r(p, m) {
      for (p = new Map(); m !== null;) m.key !== null ? p.set(m.key, m) : p.set(m.index, m), m = m.sibling;
      return p;
    }
    function e(p, m) {
      return p = L6(p, m), p.index = 0, p.sibling = null, p;
    }
    function l(p, m, M) {
      return p.index = M, t ? (M = p.alternate, M !== null ? (M = M.index, M < m ? (p.flags |= 2, m) : M) : (p.flags |= 2, m)) : (p.flags |= 1048576, m);
    }
    function i(p) {
      return t && p.alternate === null && (p.flags |= 2), p;
    }
    function o(p, m, M, w) {
      return m === null || m.tag !== 6 ? (m = bg(M, p.mode, w), m.return = p, m) : (m = e(m, M), m.return = p, m);
    }
    function n(p, m, M, w) {
      var H = M.type;
      return H === Q7 ? v(p, m, M.props.children, w, M.key) : m !== null && (m.elementType === H || typeof H == "object" && H !== null && H.$$typeof === h6 && uV(H) === m.type) ? (w = e(m, M.props), w.ref = Sa(p, m, M), w.return = p, w) : (w = Il(M.type, M.key, M.props, null, p.mode, w), w.ref = Sa(p, m, M), w.return = p, w);
    }
    function h(p, m, M, w) {
      return m === null || m.tag !== 4 || m.stateNode.containerInfo !== M.containerInfo || m.stateNode.implementation !== M.implementation ? (m = Fg(M, p.mode, w), m.return = p, m) : (m = e(m, M.children || []), m.return = p, m);
    }
    function v(p, m, M, w, H) {
      return m === null || m.tag !== 7 ? (m = S8(M, p.mode, w, H), m.return = p, m) : (m = e(m, M), m.return = p, m);
    }
    function g(p, m, M) {
      if (typeof m == "string" && m !== "" || typeof m == "number") return m = bg("" + m, p.mode, M), m.return = p, m;
      if (typeof m == "object" && m !== null) {
        switch (m.$$typeof) {
          case il:
            return M = Il(m.type, m.key, m.props, null, p.mode, M), M.ref = Sa(p, null, m), M.return = p, M;
          case $7:
            return m = Fg(m, p.mode, M), m.return = p, m;
          case h6:
            var w = m._init;
            return g(p, w(m._payload), M);
        }
        if (Fa(m) || Va(m)) return m = S8(m, p.mode, M, null), m.return = p, m;
        Cl(p, m);
      }
      return null;
    }
    function s(p, m, M, w) {
      var H = m !== null ? m.key : null;
      if (typeof M == "string" && M !== "" || typeof M == "number") return H !== null ? null : o(p, m, "" + M, w);
      if (typeof M == "object" && M !== null) {
        switch (M.$$typeof) {
          case il:
            return M.key === H ? n(p, m, M, w) : null;
          case $7:
            return M.key === H ? h(p, m, M, w) : null;
          case h6:
            return H = M._init, s(p, m, H(M._payload), w);
        }
        if (Fa(M) || Va(M)) return H !== null ? null : v(p, m, M, w, null);
        Cl(p, M);
      }
      return null;
    }
    function d(p, m, M, w, H) {
      if (typeof w == "string" && w !== "" || typeof w == "number") return p = p.get(M) || null, o(m, p, "" + w, H);
      if (typeof w == "object" && w !== null) {
        switch (w.$$typeof) {
          case il:
            return p = p.get(w.key === null ? M : w.key) || null, n(m, p, w, H);
          case $7:
            return p = p.get(w.key === null ? M : w.key) || null, h(m, p, w, H);
          case h6:
            var y = w._init;
            return d(p, m, M, y(w._payload), H);
        }
        if (Fa(w) || Va(w)) return p = p.get(M) || null, v(m, p, w, H, null);
        Cl(m, w);
      }
      return null;
    }
    function z(p, m, M, w) {
      for (var H = null, y = null, k = m, F = m = 0, U = null; k !== null && F < M.length; F++) {
        k.index > F ? (U = k, k = null) : U = k.sibling;
        var A = s(p, k, M[F], w);
        if (A === null) {
          k === null && (k = U);
          break;
        }
        t && k && A.alternate === null && a(p, k), m = l(A, m, F), y === null ? H = A : y.sibling = A, y = A, k = U;
      }
      if (F === M.length) return c(p, k), l2 && L8(p, F), H;
      if (k === null) {
        for (; F < M.length; F++) k = g(p, M[F], w), k !== null && (m = l(k, m, F), y === null ? H = k : y.sibling = k, y = k);
        return l2 && L8(p, F), H;
      }
      for (k = r(p, k); F < M.length; F++) U = d(k, p, F, M[F], w), U !== null && (t && U.alternate !== null && k.delete(U.key === null ? F : U.key), m = l(U, m, F), y === null ? H = U : y.sibling = U, y = U);
      return t && k.forEach(function (P) {
        return a(p, P);
      }), l2 && L8(p, F), H;
    }
    function u(p, m, M, w) {
      var H = Va(M);
      if (typeof H != "function") throw Error(n1(150));
      if (M = H.call(M), M == null) throw Error(n1(151));
      for (var y = H = null, k = m, F = m = 0, U = null, A = M.next(); k !== null && !A.done; F++, A = M.next()) {
        k.index > F ? (U = k, k = null) : U = k.sibling;
        var P = s(p, k, A.value, w);
        if (P === null) {
          k === null && (k = U);
          break;
        }
        t && k && P.alternate === null && a(p, k), m = l(P, m, F), y === null ? H = P : y.sibling = P, y = P, k = U;
      }
      if (A.done) return c(p, k), l2 && L8(p, F), H;
      if (k === null) {
        for (; !A.done; F++, A = M.next()) A = g(p, A.value, w), A !== null && (m = l(A, m, F), y === null ? H = A : y.sibling = A, y = A);
        return l2 && L8(p, F), H;
      }
      for (k = r(p, k); !A.done; F++, A = M.next()) A = d(k, p, F, A.value, w), A !== null && (t && A.alternate !== null && k.delete(A.key === null ? F : A.key), m = l(A, m, F), y === null ? H = A : y.sibling = A, y = A);
      return t && k.forEach(function (C) {
        return a(p, C);
      }), l2 && L8(p, F), H;
    }
    function f(p, m, M, w) {
      if (typeof M == "object" && M !== null && M.type === Q7 && M.key === null && (M = M.props.children), typeof M == "object" && M !== null) {
        switch (M.$$typeof) {
          case il:
            t: {
              for (var H = M.key, y = m; y !== null;) {
                if (y.key === H) {
                  if (H = M.type, H === Q7) {
                    if (y.tag === 7) {
                      c(p, y.sibling), m = e(y, M.props.children), m.return = p, p = m;
                      break t;
                    }
                  } else if (y.elementType === H || typeof H == "object" && H !== null && H.$$typeof === h6 && uV(H) === y.type) {
                    c(p, y.sibling), m = e(y, M.props), m.ref = Sa(p, y, M), m.return = p, p = m;
                    break t;
                  }
                  c(p, y);
                  break;
                } else a(p, y);
                y = y.sibling;
              }
              M.type === Q7 ? (m = S8(M.props.children, p.mode, w, M.key), m.return = p, p = m) : (w = Il(M.type, M.key, M.props, null, p.mode, w), w.ref = Sa(p, m, M), w.return = p, p = w);
            }
            return i(p);
          case $7:
            t: {
              for (y = M.key; m !== null;) {
                if (m.key === y) {
                  if (m.tag === 4 && m.stateNode.containerInfo === M.containerInfo && m.stateNode.implementation === M.implementation) {
                    c(p, m.sibling), m = e(m, M.children || []), m.return = p, p = m;
                    break t;
                  } else {
                    c(p, m);
                    break;
                  }
                } else a(p, m);
                m = m.sibling;
              }
              m = Fg(M, p.mode, w), m.return = p, p = m;
            }
            return i(p);
          case h6:
            return y = M._init, f(p, m, y(M._payload), w);
        }
        if (Fa(M)) return z(p, m, M, w);
        if (Va(M)) return u(p, m, M, w);
        Cl(p, M);
      }
      return typeof M == "string" && M !== "" || typeof M == "number" ? (M = "" + M, m !== null && m.tag === 6 ? (c(p, m.sibling), m = e(m, M), m.return = p, p = m) : (c(p, m), m = bg(M, p.mode, w), m.return = p, p = m), i(p)) : c(p, m);
    }
    return f;
  }
  var p9 = Ew(!0),
    Dw = Ew(!1),
    gc = {},
    w4 = B6(gc),
    cc = B6(gc),
    rc = B6(gc);
  function B8(t) {
    if (t === gc) throw Error(n1(174));
    return t;
  }
  function Qd(t, a) {
    switch ($1(rc, a), $1(cc, t), $1(w4, gc), t = a.nodeType, t) {
      case 9:
      case 11:
        a = (a = a.documentElement) ? a.namespaceURI : _g(null, "");
        break;
      default:
        t = t === 8 ? a.parentNode : a, a = t.namespaceURI || null, t = t.tagName, a = _g(a, t);
    }
    a2(w4), $1(w4, a);
  }
  function m9() {
    a2(w4), a2(cc), a2(rc);
  }
  function Ww(t) {
    B8(rc.current);
    var a = B8(w4.current),
      c = _g(a, t.type);
    a !== c && ($1(cc, t), $1(w4, c));
  }
  function Xd(t) {
    cc.current === t && (a2(w4), a2(cc));
  }
  var n2 = B6(0);
  function Xl(t) {
    for (var a = t; a !== null;) {
      if (a.tag === 13) {
        var c = a.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!")) return a;
      } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
        if (a.flags & 128) return a;
      } else if (a.child !== null) {
        a.child.return = a, a = a.child;
        continue;
      }
      if (a === t) break;
      for (; a.sibling === null;) {
        if (a.return === null || a.return === t) return null;
        a = a.return;
      }
      a.sibling.return = a.return, a = a.sibling;
    }
    return null;
  }
  var Bg = [];
  function Yd() {
    for (var t = 0; t < Bg.length; t++) Bg[t]._workInProgressVersionPrimary = null;
    Bg.length = 0;
  }
  var kl = u5.ReactCurrentDispatcher,
    yg = u5.ReactCurrentBatchConfig,
    R8 = 0,
    h2 = null,
    S2 = null,
    b2 = null,
    Yl = !1,
    Da = !1,
    ec = 0,
    eJ = 0;
  function l0() {
    throw Error(n1(321));
  }
  function Jd(t, a) {
    if (a === null) return !1;
    for (var c = 0; c < a.length && c < t.length; c++) if (!$3(t[c], a[c])) return !1;
    return !0;
  }
  function ts(t, a, c, r, e, l) {
    if (R8 = l, h2 = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, kl.current = t === null || t.memoizedState === null ? nJ : hJ, t = c(r, e), Da) {
      l = 0;
      do {
        if (Da = !1, ec = 0, 25 <= l) throw Error(n1(301));
        l += 1, b2 = S2 = null, a.updateQueue = null, kl.current = vJ, t = c(r, e);
      } while (Da);
    }
    if (kl.current = Jl, a = S2 !== null && S2.next !== null, R8 = 0, b2 = S2 = h2 = null, Yl = !1, a) throw Error(n1(300));
    return t;
  }
  function as() {
    var t = ec !== 0;
    return ec = 0, t;
  }
  function L4() {
    var t = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return b2 === null ? h2.memoizedState = b2 = t : b2 = b2.next = t, b2;
  }
  function y3() {
    if (S2 === null) {
      var t = h2.alternate;
      t = t !== null ? t.memoizedState : null;
    } else t = S2.next;
    var a = b2 === null ? h2.memoizedState : b2.next;
    if (a !== null) b2 = a, S2 = t;else {
      if (t === null) throw Error(n1(310));
      S2 = t, t = {
        memoizedState: S2.memoizedState,
        baseState: S2.baseState,
        baseQueue: S2.baseQueue,
        queue: S2.queue,
        next: null
      }, b2 === null ? h2.memoizedState = b2 = t : b2 = b2.next = t;
    }
    return b2;
  }
  function lc(t, a) {
    return typeof a == "function" ? a(t) : a;
  }
  function Sg(t) {
    var a = y3(),
      c = a.queue;
    if (c === null) throw Error(n1(311));
    c.lastRenderedReducer = t;
    var r = S2,
      e = r.baseQueue,
      l = c.pending;
    if (l !== null) {
      if (e !== null) {
        var i = e.next;
        e.next = l.next, l.next = i;
      }
      r.baseQueue = e = l, c.pending = null;
    }
    if (e !== null) {
      l = e.next, r = r.baseState;
      var o = i = null,
        n = null,
        h = l;
      do {
        var v = h.lane;
        if ((R8 & v) === v) n !== null && (n = n.next = {
          lane: 0,
          action: h.action,
          hasEagerState: h.hasEagerState,
          eagerState: h.eagerState,
          next: null
        }), r = h.hasEagerState ? h.eagerState : t(r, h.action);else {
          var g = {
            lane: v,
            action: h.action,
            hasEagerState: h.hasEagerState,
            eagerState: h.eagerState,
            next: null
          };
          n === null ? (o = n = g, i = r) : n = n.next = g, h2.lanes |= v, b8 |= v;
        }
        h = h.next;
      } while (h !== null && h !== l);
      n === null ? i = r : n.next = o, $3(r, a.memoizedState) || (y0 = !0), a.memoizedState = r, a.baseState = i, a.baseQueue = n, c.lastRenderedState = r;
    }
    if (t = c.interleaved, t !== null) {
      e = t;
      do l = e.lane, h2.lanes |= l, b8 |= l, e = e.next; while (e !== t);
    } else e === null && (c.lanes = 0);
    return [a.memoizedState, c.dispatch];
  }
  function kg(t) {
    var a = y3(),
      c = a.queue;
    if (c === null) throw Error(n1(311));
    c.lastRenderedReducer = t;
    var r = c.dispatch,
      e = c.pending,
      l = a.memoizedState;
    if (e !== null) {
      c.pending = null;
      var i = e = e.next;
      do l = t(l, i.action), i = i.next; while (i !== e);
      $3(l, a.memoizedState) || (y0 = !0), a.memoizedState = l, a.baseQueue === null && (a.baseState = l), c.lastRenderedState = l;
    }
    return [l, r];
  }
  function _w() {}
  function jw(t, a) {
    var c = h2,
      r = y3(),
      e = a(),
      l = !$3(r.memoizedState, e);
    if (l && (r.memoizedState = e, y0 = !0), r = r.queue, cs(Uw.bind(null, c, r, t), [t]), r.getSnapshot !== a || l || b2 !== null && b2.memoizedState.tag & 1) {
      if (c.flags |= 2048, ic(9, Nw.bind(null, c, r, e, a), void 0, null), F2 === null) throw Error(n1(349));
      R8 & 30 || qw(c, a, e);
    }
    return e;
  }
  function qw(t, a, c) {
    t.flags |= 16384, t = {
      getSnapshot: a,
      value: c
    }, a = h2.updateQueue, a === null ? (a = {
      lastEffect: null,
      stores: null
    }, h2.updateQueue = a, a.stores = [t]) : (c = a.stores, c === null ? a.stores = [t] : c.push(t));
  }
  function Nw(t, a, c, r) {
    a.value = c, a.getSnapshot = r, Kw(a) && $w(t);
  }
  function Uw(t, a, c) {
    return c(function () {
      Kw(a) && $w(t);
    });
  }
  function Kw(t) {
    var a = t.getSnapshot;
    t = t.value;
    try {
      var c = a();
      return !$3(t, c);
    } catch (r) {
      return !0;
    }
  }
  function $w(t) {
    var a = s5(t, 1);
    a !== null && K3(a, t, 1, -1);
  }
  function pV(t) {
    var a = L4();
    return typeof t == "function" && (t = t()), a.memoizedState = a.baseState = t, t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: lc,
      lastRenderedState: t
    }, a.queue = t, t = t.dispatch = oJ.bind(null, h2, t), [a.memoizedState, t];
  }
  function ic(t, a, c, r) {
    return t = {
      tag: t,
      create: a,
      destroy: c,
      deps: r,
      next: null
    }, a = h2.updateQueue, a === null ? (a = {
      lastEffect: null,
      stores: null
    }, h2.updateQueue = a, a.lastEffect = t.next = t) : (c = a.lastEffect, c === null ? a.lastEffect = t.next = t : (r = c.next, c.next = t, t.next = r, a.lastEffect = t)), t;
  }
  function Qw() {
    return y3().memoizedState;
  }
  function Al(t, a, c, r) {
    var e = L4();
    h2.flags |= t, e.memoizedState = ic(1 | a, c, void 0, r === void 0 ? null : r);
  }
  function di(t, a, c, r) {
    var e = y3();
    r = r === void 0 ? null : r;
    var l = void 0;
    if (S2 !== null) {
      var i = S2.memoizedState;
      if (l = i.destroy, r !== null && Jd(r, i.deps)) {
        e.memoizedState = ic(a, c, l, r);
        return;
      }
    }
    h2.flags |= t, e.memoizedState = ic(1 | a, c, l, r);
  }
  function mV(t, a) {
    return Al(8390656, 8, t, a);
  }
  function cs(t, a) {
    return di(2048, 8, t, a);
  }
  function Xw(t, a) {
    return di(4, 2, t, a);
  }
  function Yw(t, a) {
    return di(4, 4, t, a);
  }
  function Jw(t, a) {
    if (typeof a == "function") return t = t(), a(t), function () {
      a(null);
    };
    if (a != null) return t = t(), a.current = t, function () {
      a.current = null;
    };
  }
  function tB(t, a, c) {
    return c = c != null ? c.concat([t]) : null, di(4, 4, Jw.bind(null, a, t), c);
  }
  function rs() {}
  function aB(t, a) {
    var c = y3();
    a = a === void 0 ? null : a;
    var r = c.memoizedState;
    return r !== null && a !== null && Jd(a, r[1]) ? r[0] : (c.memoizedState = [t, a], t);
  }
  function cB(t, a) {
    var c = y3();
    a = a === void 0 ? null : a;
    var r = c.memoizedState;
    return r !== null && a !== null && Jd(a, r[1]) ? r[0] : (t = t(), c.memoizedState = [t, a], t);
  }
  function rB(t, a, c) {
    return R8 & 21 ? ($3(c, a) || (c = iw(), h2.lanes |= c, b8 |= c, t.baseState = !0), a) : (t.baseState && (t.baseState = !1, y0 = !0), t.memoizedState = c);
  }
  function lJ(t, a) {
    var c = W1;
    W1 = c !== 0 && 4 > c ? c : 4, t(!0);
    var r = yg.transition;
    yg.transition = {};
    try {
      t(!1), a();
    } finally {
      W1 = c, yg.transition = r;
    }
  }
  function eB() {
    return y3().memoizedState;
  }
  function iJ(t, a, c) {
    var r = C6(t);
    if (c = {
      lane: r,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, lB(t)) iB(a, c);else if (c = Gw(t, a, c, r), c !== null) {
      var e = M0();
      K3(c, t, r, e), oB(c, a, r);
    }
  }
  function oJ(t, a, c) {
    var r = C6(t),
      e = {
        lane: r,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
    if (lB(t)) iB(a, e);else {
      var l = t.alternate;
      if (t.lanes === 0 && (l === null || l.lanes === 0) && (l = a.lastRenderedReducer, l !== null)) try {
        var i = a.lastRenderedState,
          o = l(i, c);
        if (e.hasEagerState = !0, e.eagerState = o, $3(o, i)) {
          var n = a.interleaved;
          n === null ? (e.next = e, Kd(a)) : (e.next = n.next, n.next = e), a.interleaved = e;
          return;
        }
      } catch (h) {} finally {}
      c = Gw(t, a, e, r), c !== null && (e = M0(), K3(c, t, r, e), oB(c, a, r));
    }
  }
  function lB(t) {
    var a = t.alternate;
    return t === h2 || a !== null && a === h2;
  }
  function iB(t, a) {
    Da = Yl = !0;
    var c = t.pending;
    c === null ? a.next = a : (a.next = c.next, c.next = a), t.pending = a;
  }
  function oB(t, a, c) {
    if (c & 4194240) {
      var r = a.lanes;
      r &= t.pendingLanes, c |= r, a.lanes = c, Id(t, c);
    }
  }
  var Jl = {
      readContext: B3,
      useCallback: l0,
      useContext: l0,
      useEffect: l0,
      useImperativeHandle: l0,
      useInsertionEffect: l0,
      useLayoutEffect: l0,
      useMemo: l0,
      useReducer: l0,
      useRef: l0,
      useState: l0,
      useDebugValue: l0,
      useDeferredValue: l0,
      useTransition: l0,
      useMutableSource: l0,
      useSyncExternalStore: l0,
      useId: l0,
      unstable_isNewReconciler: !1
    },
    nJ = {
      readContext: B3,
      useCallback: function (t, a) {
        return L4().memoizedState = [t, a === void 0 ? null : a], t;
      },
      useContext: B3,
      useEffect: mV,
      useImperativeHandle: function (t, a, c) {
        return c = c != null ? c.concat([t]) : null, Al(4194308, 4, Jw.bind(null, a, t), c);
      },
      useLayoutEffect: function (t, a) {
        return Al(4194308, 4, t, a);
      },
      useInsertionEffect: function (t, a) {
        return Al(4, 2, t, a);
      },
      useMemo: function (t, a) {
        var c = L4();
        return a = a === void 0 ? null : a, t = t(), c.memoizedState = [t, a], t;
      },
      useReducer: function (t, a, c) {
        var r = L4();
        return a = c !== void 0 ? c(a) : a, r.memoizedState = r.baseState = a, t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: a
        }, r.queue = t, t = t.dispatch = iJ.bind(null, h2, t), [r.memoizedState, t];
      },
      useRef: function (t) {
        var a = L4();
        return t = {
          current: t
        }, a.memoizedState = t;
      },
      useState: pV,
      useDebugValue: rs,
      useDeferredValue: function (t) {
        return L4().memoizedState = t;
      },
      useTransition: function () {
        var t = pV(!1),
          a = t[0];
        return t = lJ.bind(null, t[1]), L4().memoizedState = t, [a, t];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (t, a, c) {
        var r = h2,
          e = L4();
        if (l2) {
          if (c === void 0) throw Error(n1(407));
          c = c();
        } else {
          if (c = a(), F2 === null) throw Error(n1(349));
          R8 & 30 || qw(r, a, c);
        }
        e.memoizedState = c;
        var l = {
          value: c,
          getSnapshot: a
        };
        return e.queue = l, mV(Uw.bind(null, r, l, t), [t]), r.flags |= 2048, ic(9, Nw.bind(null, r, l, c, a), void 0, null), c;
      },
      useId: function () {
        var t = L4(),
          a = F2.identifierPrefix;
        if (l2) {
          var c = h5,
            r = n5;
          c = (r & ~(1 << 32 - U3(r) - 1)).toString(32) + c, a = ":" + a + "R" + c, c = ec++, 0 < c && (a += "H" + c.toString(32)), a += ":";
        } else c = eJ++, a = ":" + a + "r" + c.toString(32) + ":";
        return t.memoizedState = a;
      },
      unstable_isNewReconciler: !1
    },
    hJ = {
      readContext: B3,
      useCallback: aB,
      useContext: B3,
      useEffect: cs,
      useImperativeHandle: tB,
      useInsertionEffect: Xw,
      useLayoutEffect: Yw,
      useMemo: cB,
      useReducer: Sg,
      useRef: Qw,
      useState: function () {
        return Sg(lc);
      },
      useDebugValue: rs,
      useDeferredValue: function (t) {
        var a = y3();
        return rB(a, S2.memoizedState, t);
      },
      useTransition: function () {
        var t = Sg(lc)[0],
          a = y3().memoizedState;
        return [t, a];
      },
      useMutableSource: _w,
      useSyncExternalStore: jw,
      useId: eB,
      unstable_isNewReconciler: !1
    },
    vJ = {
      readContext: B3,
      useCallback: aB,
      useContext: B3,
      useEffect: cs,
      useImperativeHandle: tB,
      useInsertionEffect: Xw,
      useLayoutEffect: Yw,
      useMemo: cB,
      useReducer: kg,
      useRef: Qw,
      useState: function () {
        return kg(lc);
      },
      useDebugValue: rs,
      useDeferredValue: function (t) {
        var a = y3();
        return S2 === null ? a.memoizedState = t : rB(a, S2.memoizedState, t);
      },
      useTransition: function () {
        var t = kg(lc)[0],
          a = y3().memoizedState;
        return [t, a];
      },
      useMutableSource: _w,
      useSyncExternalStore: jw,
      useId: eB,
      unstable_isNewReconciler: !1
    };
  function f9(t, a) {
    try {
      var c = "",
        r = a;
      do c += EX(r), r = r.return; while (r);
      var e = c;
    } catch (l) {
      e = "\nError generating stack: " + l.message + "\n" + l.stack;
    }
    return {
      value: t,
      source: a,
      stack: e,
      digest: null
    };
  }
  function Ag(t, a, c) {
    return {
      value: t,
      source: null,
      stack: c != null ? c : null,
      digest: a != null ? a : null
    };
  }
  function dd(t, a) {
    try {
      console.error(a.value);
    } catch (c) {
      setTimeout(function () {
        throw c;
      });
    }
  }
  var gJ = typeof WeakMap == "function" ? WeakMap : Map;
  function nB(t, a, c) {
    c = v5(-1, c), c.tag = 3, c.payload = {
      element: null
    };
    var r = a.value;
    return c.callback = function () {
      ai || (ai = !0, Ld = r), dd(t, a);
    }, c;
  }
  function hB(t, a, c) {
    c = v5(-1, c), c.tag = 3;
    var r = t.type.getDerivedStateFromError;
    if (typeof r == "function") {
      var e = a.value;
      c.payload = function () {
        return r(e);
      }, c.callback = function () {
        dd(t, a);
      };
    }
    var l = t.stateNode;
    return l !== null && typeof l.componentDidCatch == "function" && (c.callback = function () {
      dd(t, a), typeof r != "function" && (x6 === null ? x6 = new Set([this]) : x6.add(this));
      var i = a.stack;
      this.componentDidCatch(a.value, {
        componentStack: i !== null ? i : ""
      });
    }), c;
  }
  function fV(t, a, c) {
    var r = t.pingCache;
    if (r === null) {
      r = t.pingCache = new gJ();
      var e = new Set();
      r.set(a, e);
    } else e = r.get(a), e === void 0 && (e = new Set(), r.set(a, e));
    e.has(c) || (e.add(c), t = wJ.bind(null, t, a, c), a.then(t, t));
  }
  function MV(t) {
    do {
      var a;
      if ((a = t.tag === 13) && (a = t.memoizedState, a = a !== null ? a.dehydrated !== null : !0), a) return t;
      t = t.return;
    } while (t !== null);
    return null;
  }
  function xV(t, a, c, r, e) {
    return t.mode & 1 ? (t.flags |= 65536, t.lanes = e, t) : (t === a ? t.flags |= 65536 : (t.flags |= 128, c.flags |= 131072, c.flags &= -52805, c.tag === 1 && (c.alternate === null ? c.tag = 17 : (a = v5(-1, 1), a.tag = 2, M6(c, a, 1))), c.lanes |= 1), t);
  }
  var dJ = u5.ReactCurrentOwner,
    y0 = !1;
  function f0(t, a, c, r) {
    a.child = t === null ? Dw(a, null, c, r) : p9(a, t.child, c, r);
  }
  function CV(t, a, c, r, e) {
    c = c.render;
    var l = a.ref;
    return g9(a, e), r = ts(t, a, c, r, l, e), c = as(), t !== null && !y0 ? (a.updateQueue = t.updateQueue, a.flags &= -2053, t.lanes &= ~e, z5(t, a, e)) : (l2 && c && Wd(a), a.flags |= 1, f0(t, a, r, e), a.child);
  }
  function LV(t, a, c, r, e) {
    if (t === null) {
      var l = c.type;
      return typeof l == "function" && !gs(l) && l.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0 ? (a.tag = 15, a.type = l, vB(t, a, l, r, e)) : (t = Il(c.type, null, r, a, a.mode, e), t.ref = a.ref, t.return = a, a.child = t);
    }
    if (l = t.child, !(t.lanes & e)) {
      var i = l.memoizedProps;
      if (c = c.compare, c = c !== null ? c : Ya, c(i, r) && t.ref === a.ref) return z5(t, a, e);
    }
    return a.flags |= 1, t = L6(l, r), t.ref = a.ref, t.return = a, a.child = t;
  }
  function vB(t, a, c, r, e) {
    if (t !== null) {
      var l = t.memoizedProps;
      if (Ya(l, r) && t.ref === a.ref) if (y0 = !1, a.pendingProps = r = l, (t.lanes & e) !== 0) t.flags & 131072 && (y0 = !0);else return a.lanes = t.lanes, z5(t, a, e);
    }
    return sd(t, a, c, r, e);
  }
  function gB(t, a, c) {
    var r = a.pendingProps,
      e = r.children,
      l = t !== null ? t.memoizedState : null;
    if (r.mode === "hidden") {
      if (!(a.mode & 1)) a.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
      }, $1(i9, K0), K0 |= c;else {
        if (!(c & 1073741824)) return t = l !== null ? l.baseLanes | c : c, a.lanes = a.childLanes = 1073741824, a.memoizedState = {
          baseLanes: t,
          cachePool: null,
          transitions: null
        }, a.updateQueue = null, $1(i9, K0), K0 |= t, null;
        a.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null
        }, r = l !== null ? l.baseLanes : c, $1(i9, K0), K0 |= r;
      }
    } else l !== null ? (r = l.baseLanes | c, a.memoizedState = null) : r = c, $1(i9, K0), K0 |= r;
    return f0(t, a, e, c), a.child;
  }
  function dB(t, a) {
    var c = a.ref;
    (t === null && c !== null || t !== null && t.ref !== c) && (a.flags |= 512, a.flags |= 2097152);
  }
  function sd(t, a, c, r, e) {
    var l = k0(c) ? k8 : n0.current;
    return l = z9(a, l), g9(a, e), c = ts(t, a, c, r, l, e), r = as(), t !== null && !y0 ? (a.updateQueue = t.updateQueue, a.flags &= -2053, t.lanes &= ~e, z5(t, a, e)) : (l2 && r && Wd(a), a.flags |= 1, f0(t, a, c, e), a.child);
  }
  function HV(t, a, c, r, e) {
    if (k0(c)) {
      var l = !0;
      ql(a);
    } else l = !1;
    if (g9(a, e), a.stateNode === null) Rl(t, a), Ow(a, c, r), gd(a, c, r, e), r = !0;else if (t === null) {
      var i = a.stateNode,
        o = a.memoizedProps;
      i.props = o;
      var n = i.context,
        h = c.contextType;
      typeof h == "object" && h !== null ? h = B3(h) : (h = k0(c) ? k8 : n0.current, h = z9(a, h));
      var v = c.getDerivedStateFromProps,
        g = typeof v == "function" || typeof i.getSnapshotBeforeUpdate == "function";
      g || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (o !== r || n !== h) && zV(a, i, r, h), v6 = !1;
      var s = a.memoizedState;
      i.state = s, Ql(a, r, i, e), n = a.memoizedState, o !== r || s !== n || S0.current || v6 ? (typeof v == "function" && (vd(a, c, v, r), n = a.memoizedState), (o = v6 || sV(a, c, o, r, s, n, h)) ? (g || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount()), typeof i.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof i.componentDidMount == "function" && (a.flags |= 4194308), a.memoizedProps = r, a.memoizedState = n), i.props = r, i.state = n, i.context = h, r = o) : (typeof i.componentDidMount == "function" && (a.flags |= 4194308), r = !1);
    } else {
      i = a.stateNode, Tw(t, a), o = a.memoizedProps, h = a.type === a.elementType ? o : j3(a.type, o), i.props = h, g = a.pendingProps, s = i.context, n = c.contextType, typeof n == "object" && n !== null ? n = B3(n) : (n = k0(c) ? k8 : n0.current, n = z9(a, n));
      var d = c.getDerivedStateFromProps;
      (v = typeof d == "function" || typeof i.getSnapshotBeforeUpdate == "function") || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (o !== g || s !== n) && zV(a, i, r, n), v6 = !1, s = a.memoizedState, i.state = s, Ql(a, r, i, e);
      var z = a.memoizedState;
      o !== g || s !== z || S0.current || v6 ? (typeof d == "function" && (vd(a, c, d, r), z = a.memoizedState), (h = v6 || sV(a, c, h, r, s, z, n) || !1) ? (v || typeof i.UNSAFE_componentWillUpdate != "function" && typeof i.componentWillUpdate != "function" || (typeof i.componentWillUpdate == "function" && i.componentWillUpdate(r, z, n), typeof i.UNSAFE_componentWillUpdate == "function" && i.UNSAFE_componentWillUpdate(r, z, n)), typeof i.componentDidUpdate == "function" && (a.flags |= 4), typeof i.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof i.componentDidUpdate != "function" || o === t.memoizedProps && s === t.memoizedState || (a.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || o === t.memoizedProps && s === t.memoizedState || (a.flags |= 1024), a.memoizedProps = r, a.memoizedState = z), i.props = r, i.state = z, i.context = n, r = h) : (typeof i.componentDidUpdate != "function" || o === t.memoizedProps && s === t.memoizedState || (a.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || o === t.memoizedProps && s === t.memoizedState || (a.flags |= 1024), r = !1);
    }
    return zd(t, a, c, r, l, e);
  }
  function zd(t, a, c, r, e, l) {
    dB(t, a);
    var i = (a.flags & 128) !== 0;
    if (!r && !i) return e && nV(a, c, !1), z5(t, a, l);
    r = a.stateNode, dJ.current = a;
    var o = i && typeof c.getDerivedStateFromError != "function" ? null : r.render();
    return a.flags |= 1, t !== null && i ? (a.child = p9(a, t.child, null, l), a.child = p9(a, null, o, l)) : f0(t, a, o, l), a.memoizedState = r.state, e && nV(a, c, !0), a.child;
  }
  function sB(t) {
    var a = t.stateNode;
    a.pendingContext ? oV(t, a.pendingContext, a.pendingContext !== a.context) : a.context && oV(t, a.context, !1), Qd(t, a.containerInfo);
  }
  function VV(t, a, c, r, e) {
    return u9(), jd(e), a.flags |= 256, f0(t, a, c, r), a.child;
  }
  var ud = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
  };
  function pd(t) {
    return {
      baseLanes: t,
      cachePool: null,
      transitions: null
    };
  }
  function zB(t, a, c) {
    var r = a.pendingProps,
      e = n2.current,
      l = !1,
      i = (a.flags & 128) !== 0,
      o;
    if ((o = i) || (o = t !== null && t.memoizedState === null ? !1 : (e & 2) !== 0), o ? (l = !0, a.flags &= -129) : (t === null || t.memoizedState !== null) && (e |= 1), $1(n2, e & 1), t === null) return nd(a), t = a.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (a.mode & 1 ? t.data === "$!" ? a.lanes = 8 : a.lanes = 1073741824 : a.lanes = 1, null) : (i = r.children, t = r.fallback, l ? (r = a.mode, l = a.child, i = {
      mode: "hidden",
      children: i
    }, !(r & 1) && l !== null ? (l.childLanes = 0, l.pendingProps = i) : l = ui(i, r, 0, null), t = S8(t, r, c, null), l.return = a, t.return = a, l.sibling = t, a.child = l, a.child.memoizedState = pd(c), a.memoizedState = ud, t) : es(a, i));
    if (e = t.memoizedState, e !== null && (o = e.dehydrated, o !== null)) return sJ(t, a, i, r, o, e, c);
    if (l) {
      l = r.fallback, i = a.mode, e = t.child, o = e.sibling;
      var n = {
        mode: "hidden",
        children: r.children
      };
      return !(i & 1) && a.child !== e ? (r = a.child, r.childLanes = 0, r.pendingProps = n, a.deletions = null) : (r = L6(e, n), r.subtreeFlags = e.subtreeFlags & 14680064), o !== null ? l = L6(o, l) : (l = S8(l, i, c, null), l.flags |= 2), l.return = a, r.return = a, r.sibling = l, a.child = r, r = l, l = a.child, i = t.child.memoizedState, i = i === null ? pd(c) : {
        baseLanes: i.baseLanes | c,
        cachePool: null,
        transitions: i.transitions
      }, l.memoizedState = i, l.childLanes = t.childLanes & ~c, a.memoizedState = ud, r;
    }
    return l = t.child, t = l.sibling, r = L6(l, {
      mode: "visible",
      children: r.children
    }), !(a.mode & 1) && (r.lanes = c), r.return = a, r.sibling = null, t !== null && (c = a.deletions, c === null ? (a.deletions = [t], a.flags |= 16) : c.push(t)), a.child = r, a.memoizedState = null, r;
  }
  function es(t, a) {
    return a = ui({
      mode: "visible",
      children: a
    }, t.mode, 0, null), a.return = t, t.child = a;
  }
  function Ll(t, a, c, r) {
    return r !== null && jd(r), p9(a, t.child, null, c), t = es(a, a.pendingProps.children), t.flags |= 2, a.memoizedState = null, t;
  }
  function sJ(t, a, c, r, e, l, i) {
    if (c) return a.flags & 256 ? (a.flags &= -257, r = Ag(Error(n1(422))), Ll(t, a, i, r)) : a.memoizedState !== null ? (a.child = t.child, a.flags |= 128, null) : (l = r.fallback, e = a.mode, r = ui({
      mode: "visible",
      children: r.children
    }, e, 0, null), l = S8(l, e, i, null), l.flags |= 2, r.return = a, l.return = a, r.sibling = l, a.child = r, a.mode & 1 && p9(a, t.child, null, i), a.child.memoizedState = pd(i), a.memoizedState = ud, l);
    if (!(a.mode & 1)) return Ll(t, a, i, null);
    if (e.data === "$!") {
      if (r = e.nextSibling && e.nextSibling.dataset, r) var o = r.dgst;
      return r = o, l = Error(n1(419)), r = Ag(l, r, void 0), Ll(t, a, i, r);
    }
    if (o = (i & t.childLanes) !== 0, y0 || o) {
      if (r = F2, r !== null) {
        switch (i & -i) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = e & (r.suspendedLanes | i) ? 0 : e, e !== 0 && e !== l.retryLane && (l.retryLane = e, s5(t, e), K3(r, t, e, -1));
      }
      return vs(), r = Ag(Error(n1(421))), Ll(t, a, i, r);
    }
    return e.data === "$?" ? (a.flags |= 128, a.child = t.child, a = BJ.bind(null, t), e._reactRetry = a, null) : (t = l.treeContext, $0 = f6(e.nextSibling), Q0 = a, l2 = !0, N3 = null, t !== null && (L3[H3++] = n5, L3[H3++] = h5, L3[H3++] = A8, n5 = t.id, h5 = t.overflow, A8 = a), a = es(a, r.children), a.flags |= 4096, a);
  }
  function wV(t, a, c) {
    t.lanes |= a;
    var r = t.alternate;
    r !== null && (r.lanes |= a), hd(t.return, a, c);
  }
  function Rg(t, a, c, r, e) {
    var l = t.memoizedState;
    l === null ? t.memoizedState = {
      isBackwards: a,
      rendering: null,
      renderingStartTime: 0,
      last: r,
      tail: c,
      tailMode: e
    } : (l.isBackwards = a, l.rendering = null, l.renderingStartTime = 0, l.last = r, l.tail = c, l.tailMode = e);
  }
  function uB(t, a, c) {
    var r = a.pendingProps,
      e = r.revealOrder,
      l = r.tail;
    if (f0(t, a, r.children, c), r = n2.current, r & 2) r = r & 1 | 2, a.flags |= 128;else {
      if (t !== null && t.flags & 128) t: for (t = a.child; t !== null;) {
        if (t.tag === 13) t.memoizedState !== null && wV(t, c, a);else if (t.tag === 19) wV(t, c, a);else if (t.child !== null) {
          t.child.return = t, t = t.child;
          continue;
        }
        if (t === a) break t;
        for (; t.sibling === null;) {
          if (t.return === null || t.return === a) break t;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      r &= 1;
    }
    if ($1(n2, r), !(a.mode & 1)) a.memoizedState = null;else switch (e) {
      case "forwards":
        for (c = a.child, e = null; c !== null;) t = c.alternate, t !== null && Xl(t) === null && (e = c), c = c.sibling;
        c = e, c === null ? (e = a.child, a.child = null) : (e = c.sibling, c.sibling = null), Rg(a, !1, e, c, l);
        break;
      case "backwards":
        for (c = null, e = a.child, a.child = null; e !== null;) {
          if (t = e.alternate, t !== null && Xl(t) === null) {
            a.child = e;
            break;
          }
          t = e.sibling, e.sibling = c, c = e, e = t;
        }
        Rg(a, !0, c, null, l);
        break;
      case "together":
        Rg(a, !1, null, null, void 0);
        break;
      default:
        a.memoizedState = null;
    }
    return a.child;
  }
  function Rl(t, a) {
    !(a.mode & 1) && t !== null && (t.alternate = null, a.alternate = null, a.flags |= 2);
  }
  function z5(t, a, c) {
    if (t !== null && (a.dependencies = t.dependencies), b8 |= a.lanes, !(c & a.childLanes)) return null;
    if (t !== null && a.child !== t.child) throw Error(n1(153));
    if (a.child !== null) {
      for (t = a.child, c = L6(t, t.pendingProps), a.child = c, c.return = a; t.sibling !== null;) t = t.sibling, c = c.sibling = L6(t, t.pendingProps), c.return = a;
      c.sibling = null;
    }
    return a.child;
  }
  function zJ(t, a, c) {
    switch (a.tag) {
      case 3:
        sB(a), u9();
        break;
      case 5:
        Ww(a);
        break;
      case 1:
        k0(a.type) && ql(a);
        break;
      case 4:
        Qd(a, a.stateNode.containerInfo);
        break;
      case 10:
        var r = a.type._context,
          e = a.memoizedProps.value;
        $1(Kl, r._currentValue), r._currentValue = e;
        break;
      case 13:
        if (r = a.memoizedState, r !== null) return r.dehydrated !== null ? ($1(n2, n2.current & 1), a.flags |= 128, null) : c & a.child.childLanes ? zB(t, a, c) : ($1(n2, n2.current & 1), t = z5(t, a, c), t !== null ? t.sibling : null);
        $1(n2, n2.current & 1);
        break;
      case 19:
        if (r = (c & a.childLanes) !== 0, t.flags & 128) {
          if (r) return uB(t, a, c);
          a.flags |= 128;
        }
        if (e = a.memoizedState, e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null), $1(n2, n2.current), r) break;
        return null;
      case 22:
      case 23:
        return a.lanes = 0, gB(t, a, c);
    }
    return z5(t, a, c);
  }
  var pB, md, mB, fB;
  pB = function (t, a) {
    for (var c = a.child; c !== null;) {
      if (c.tag === 5 || c.tag === 6) t.appendChild(c.stateNode);else if (c.tag !== 4 && c.child !== null) {
        c.child.return = c, c = c.child;
        continue;
      }
      if (c === a) break;
      for (; c.sibling === null;) {
        if (c.return === null || c.return === a) return;
        c = c.return;
      }
      c.sibling.return = c.return, c = c.sibling;
    }
  };
  md = function () {};
  mB = function (t, a, c, r) {
    var e = t.memoizedProps;
    if (e !== r) {
      t = a.stateNode, B8(w4.current);
      var l = null;
      switch (c) {
        case "input":
          e = Og(t, e), r = Og(t, r), l = [];
          break;
        case "select":
          e = v2({}, e, {
            value: void 0
          }), r = v2({}, r, {
            value: void 0
          }), l = [];
          break;
        case "textarea":
          e = Wg(t, e), r = Wg(t, r), l = [];
          break;
        default:
          typeof e.onClick != "function" && typeof r.onClick == "function" && (t.onclick = _l);
      }
      jg(c, r);
      var i;
      c = null;
      for (h in e) if (!r.hasOwnProperty(h) && e.hasOwnProperty(h) && e[h] != null) if (h === "style") {
        var o = e[h];
        for (i in o) o.hasOwnProperty(i) && (c || (c = {}), c[i] = "");
      } else h !== "dangerouslySetInnerHTML" && h !== "children" && h !== "suppressContentEditableWarning" && h !== "suppressHydrationWarning" && h !== "autoFocus" && (qa.hasOwnProperty(h) ? l || (l = []) : (l = l || []).push(h, null));
      for (h in r) {
        var n = r[h];
        if (o = e != null ? e[h] : void 0, r.hasOwnProperty(h) && n !== o && (n != null || o != null)) if (h === "style") {
          if (o) {
            for (i in o) !o.hasOwnProperty(i) || n && n.hasOwnProperty(i) || (c || (c = {}), c[i] = "");
            for (i in n) n.hasOwnProperty(i) && o[i] !== n[i] && (c || (c = {}), c[i] = n[i]);
          } else c || (l || (l = []), l.push(h, c)), c = n;
        } else h === "dangerouslySetInnerHTML" ? (n = n ? n.__html : void 0, o = o ? o.__html : void 0, n != null && o !== n && (l = l || []).push(h, n)) : h === "children" ? typeof n != "string" && typeof n != "number" || (l = l || []).push(h, "" + n) : h !== "suppressContentEditableWarning" && h !== "suppressHydrationWarning" && (qa.hasOwnProperty(h) ? (n != null && h === "onScroll" && t2("scroll", t), l || o === n || (l = [])) : (l = l || []).push(h, n));
      }
      c && (l = l || []).push("style", c);
      var h = l;
      (a.updateQueue = h) && (a.flags |= 4);
    }
  };
  fB = function (t, a, c, r) {
    c !== r && (a.flags |= 4);
  };
  function ka(t, a) {
    if (!l2) switch (t.tailMode) {
      case "hidden":
        a = t.tail;
        for (var c = null; a !== null;) a.alternate !== null && (c = a), a = a.sibling;
        c === null ? t.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = t.tail;
        for (var r = null; c !== null;) c.alternate !== null && (r = c), c = c.sibling;
        r === null ? a || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null;
    }
  }
  function i0(t) {
    var a = t.alternate !== null && t.alternate.child === t.child,
      c = 0,
      r = 0;
    if (a) for (var e = t.child; e !== null;) c |= e.lanes | e.childLanes, r |= e.subtreeFlags & 14680064, r |= e.flags & 14680064, e.return = t, e = e.sibling;else for (e = t.child; e !== null;) c |= e.lanes | e.childLanes, r |= e.subtreeFlags, r |= e.flags, e.return = t, e = e.sibling;
    return t.subtreeFlags |= r, t.childLanes = c, a;
  }
  function uJ(t, a, c) {
    var r = a.pendingProps;
    switch (_d(a), a.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return i0(a), null;
      case 1:
        return k0(a.type) && jl(), i0(a), null;
      case 3:
        return r = a.stateNode, m9(), a2(S0), a2(n0), Yd(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (xl(a) ? a.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(a.flags & 256) || (a.flags |= 1024, N3 !== null && (wd(N3), N3 = null))), md(t, a), i0(a), null;
      case 5:
        Xd(a);
        var e = B8(rc.current);
        if (c = a.type, t !== null && a.stateNode != null) mB(t, a, c, r, e), t.ref !== a.ref && (a.flags |= 512, a.flags |= 2097152);else {
          if (!r) {
            if (a.stateNode === null) throw Error(n1(166));
            return i0(a), null;
          }
          if (t = B8(w4.current), xl(a)) {
            r = a.stateNode, c = a.type;
            var l = a.memoizedProps;
            switch (r[H4] = a, r[ac] = l, t = (a.mode & 1) !== 0, c) {
              case "dialog":
                t2("cancel", r), t2("close", r);
                break;
              case "iframe":
              case "object":
              case "embed":
                t2("load", r);
                break;
              case "video":
              case "audio":
                for (e = 0; e < Pa.length; e++) t2(Pa[e], r);
                break;
              case "source":
                t2("error", r);
                break;
              case "img":
              case "image":
              case "link":
                t2("error", r), t2("load", r);
                break;
              case "details":
                t2("toggle", r);
                break;
              case "input":
                FH(r, l), t2("invalid", r);
                break;
              case "select":
                r._wrapperState = {
                  wasMultiple: !!l.multiple
                }, t2("invalid", r);
                break;
              case "textarea":
                PH(r, l), t2("invalid", r);
            }
            jg(c, l), e = null;
            for (var i in l) if (l.hasOwnProperty(i)) {
              var o = l[i];
              i === "children" ? typeof o == "string" ? r.textContent !== o && (l.suppressHydrationWarning !== !0 && Ml(r.textContent, o, t), e = ["children", o]) : typeof o == "number" && r.textContent !== "" + o && (l.suppressHydrationWarning !== !0 && Ml(r.textContent, o, t), e = ["children", "" + o]) : qa.hasOwnProperty(i) && o != null && i === "onScroll" && t2("scroll", r);
            }
            switch (c) {
              case "input":
                ol(r), IH(r, l, !0);
                break;
              case "textarea":
                ol(r), GH(r);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof l.onClick == "function" && (r.onclick = _l);
            }
            r = e, a.updateQueue = r, r !== null && (a.flags |= 4);
          } else {
            i = e.nodeType === 9 ? e : e.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = qV(c)), t === "http://www.w3.org/1999/xhtml" ? c === "script" ? (t = i.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = i.createElement(c, {
              is: r.is
            }) : (t = i.createElement(c), c === "select" && (i = t, r.multiple ? i.multiple = !0 : r.size && (i.size = r.size))) : t = i.createElementNS(t, c), t[H4] = a, t[ac] = r, pB(t, a, !1, !1), a.stateNode = t;
            t: {
              switch (i = qg(c, r), c) {
                case "dialog":
                  t2("cancel", t), t2("close", t), e = r;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  t2("load", t), e = r;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < Pa.length; e++) t2(Pa[e], t);
                  e = r;
                  break;
                case "source":
                  t2("error", t), e = r;
                  break;
                case "img":
                case "image":
                case "link":
                  t2("error", t), t2("load", t), e = r;
                  break;
                case "details":
                  t2("toggle", t), e = r;
                  break;
                case "input":
                  FH(t, r), e = Og(t, r), t2("invalid", t);
                  break;
                case "option":
                  e = r;
                  break;
                case "select":
                  t._wrapperState = {
                    wasMultiple: !!r.multiple
                  }, e = v2({}, r, {
                    value: void 0
                  }), t2("invalid", t);
                  break;
                case "textarea":
                  PH(t, r), e = Wg(t, r), t2("invalid", t);
                  break;
                default:
                  e = r;
              }
              jg(c, e), o = e;
              for (l in o) if (o.hasOwnProperty(l)) {
                var n = o[l];
                l === "style" ? KV(t, n) : l === "dangerouslySetInnerHTML" ? (n = n ? n.__html : void 0, n != null && NV(t, n)) : l === "children" ? typeof n == "string" ? (c !== "textarea" || n !== "") && Na(t, n) : typeof n == "number" && Na(t, "" + n) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (qa.hasOwnProperty(l) ? n != null && l === "onScroll" && t2("scroll", t) : n != null && Sd(t, l, n, i));
              }
              switch (c) {
                case "input":
                  ol(t), IH(t, r, !1);
                  break;
                case "textarea":
                  ol(t), GH(t);
                  break;
                case "option":
                  r.value != null && t.setAttribute("value", "" + H6(r.value));
                  break;
                case "select":
                  t.multiple = !!r.multiple, l = r.value, l != null ? o9(t, !!r.multiple, l, !1) : r.defaultValue != null && o9(t, !!r.multiple, r.defaultValue, !0);
                  break;
                default:
                  typeof e.onClick == "function" && (t.onclick = _l);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  r = !!r.autoFocus;
                  break t;
                case "img":
                  r = !0;
                  break t;
                default:
                  r = !1;
              }
            }
            r && (a.flags |= 4);
          }
          a.ref !== null && (a.flags |= 512, a.flags |= 2097152);
        }
        return i0(a), null;
      case 6:
        if (t && a.stateNode != null) fB(t, a, t.memoizedProps, r);else {
          if (typeof r != "string" && a.stateNode === null) throw Error(n1(166));
          if (c = B8(rc.current), B8(w4.current), xl(a)) {
            if (r = a.stateNode, c = a.memoizedProps, r[H4] = a, (l = r.nodeValue !== c) && (t = Q0, t !== null)) switch (t.tag) {
              case 3:
                Ml(r.nodeValue, c, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 && Ml(r.nodeValue, c, (t.mode & 1) !== 0);
            }
            l && (a.flags |= 4);
          } else r = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(r), r[H4] = a, a.stateNode = r;
        }
        return i0(a), null;
      case 13:
        if (a2(n2), r = a.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
          if (l2 && $0 !== null && a.mode & 1 && !(a.flags & 128)) Pw(), u9(), a.flags |= 98560, l = !1;else if (l = xl(a), r !== null && r.dehydrated !== null) {
            if (t === null) {
              if (!l) throw Error(n1(318));
              if (l = a.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(n1(317));
              l[H4] = a;
            } else u9(), !(a.flags & 128) && (a.memoizedState = null), a.flags |= 4;
            i0(a), l = !1;
          } else N3 !== null && (wd(N3), N3 = null), l = !0;
          if (!l) return a.flags & 65536 ? a : null;
        }
        return a.flags & 128 ? (a.lanes = c, a) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (a.child.flags |= 8192, a.mode & 1 && (t === null || n2.current & 1 ? k2 === 0 && (k2 = 3) : vs())), a.updateQueue !== null && (a.flags |= 4), i0(a), null);
      case 4:
        return m9(), md(t, a), t === null && Ja(a.stateNode.containerInfo), i0(a), null;
      case 10:
        return Ud(a.type._context), i0(a), null;
      case 17:
        return k0(a.type) && jl(), i0(a), null;
      case 19:
        if (a2(n2), l = a.memoizedState, l === null) return i0(a), null;
        if (r = (a.flags & 128) !== 0, i = l.rendering, i === null) {
          if (r) ka(l, !1);else {
            if (k2 !== 0 || t !== null && t.flags & 128) for (t = a.child; t !== null;) {
              if (i = Xl(t), i !== null) {
                for (a.flags |= 128, ka(l, !1), r = i.updateQueue, r !== null && (a.updateQueue = r, a.flags |= 4), a.subtreeFlags = 0, r = c, c = a.child; c !== null;) l = c, t = r, l.flags &= 14680066, i = l.alternate, i === null ? (l.childLanes = 0, l.lanes = t, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null) : (l.childLanes = i.childLanes, l.lanes = i.lanes, l.child = i.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = i.memoizedProps, l.memoizedState = i.memoizedState, l.updateQueue = i.updateQueue, l.type = i.type, t = i.dependencies, l.dependencies = t === null ? null : {
                  lanes: t.lanes,
                  firstContext: t.firstContext
                }), c = c.sibling;
                return $1(n2, n2.current & 1 | 2), a.child;
              }
              t = t.sibling;
            }
            l.tail !== null && m2() > M9 && (a.flags |= 128, r = !0, ka(l, !1), a.lanes = 4194304);
          }
        } else {
          if (!r) if (t = Xl(i), t !== null) {
            if (a.flags |= 128, r = !0, c = t.updateQueue, c !== null && (a.updateQueue = c, a.flags |= 4), ka(l, !0), l.tail === null && l.tailMode === "hidden" && !i.alternate && !l2) return i0(a), null;
          } else 2 * m2() - l.renderingStartTime > M9 && c !== 1073741824 && (a.flags |= 128, r = !0, ka(l, !1), a.lanes = 4194304);
          l.isBackwards ? (i.sibling = a.child, a.child = i) : (c = l.last, c !== null ? c.sibling = i : a.child = i, l.last = i);
        }
        return l.tail !== null ? (a = l.tail, l.rendering = a, l.tail = a.sibling, l.renderingStartTime = m2(), a.sibling = null, c = n2.current, $1(n2, r ? c & 1 | 2 : c & 1), a) : (i0(a), null);
      case 22:
      case 23:
        return hs(), r = a.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (a.flags |= 8192), r && a.mode & 1 ? K0 & 1073741824 && (i0(a), a.subtreeFlags & 6 && (a.flags |= 8192)) : i0(a), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n1(156, a.tag));
  }
  function pJ(t, a) {
    switch (_d(a), a.tag) {
      case 1:
        return k0(a.type) && jl(), t = a.flags, t & 65536 ? (a.flags = t & -65537 | 128, a) : null;
      case 3:
        return m9(), a2(S0), a2(n0), Yd(), t = a.flags, t & 65536 && !(t & 128) ? (a.flags = t & -65537 | 128, a) : null;
      case 5:
        return Xd(a), null;
      case 13:
        if (a2(n2), t = a.memoizedState, t !== null && t.dehydrated !== null) {
          if (a.alternate === null) throw Error(n1(340));
          u9();
        }
        return t = a.flags, t & 65536 ? (a.flags = t & -65537 | 128, a) : null;
      case 19:
        return a2(n2), null;
      case 4:
        return m9(), null;
      case 10:
        return Ud(a.type._context), null;
      case 22:
      case 23:
        return hs(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Hl = !1,
    o0 = !1,
    mJ = typeof WeakSet == "function" ? WeakSet : Set,
    p1 = null;
  function l9(t, a) {
    var c = t.ref;
    if (c !== null) if (typeof c == "function") try {
      c(null);
    } catch (r) {
      d2(t, a, r);
    } else c.current = null;
  }
  function fd(t, a, c) {
    try {
      c();
    } catch (r) {
      d2(t, a, r);
    }
  }
  var BV = !1;
  function fJ(t, a) {
    if (ad = El, t = Lw(), Dd(t)) {
      if ("selectionStart" in t) var c = {
        start: t.selectionStart,
        end: t.selectionEnd
      };else t: {
        c = (c = t.ownerDocument) && c.defaultView || window;
        var r = c.getSelection && c.getSelection();
        if (r && r.rangeCount !== 0) {
          c = r.anchorNode;
          var e = r.anchorOffset,
            l = r.focusNode;
          r = r.focusOffset;
          try {
            c.nodeType, l.nodeType;
          } catch (w) {
            c = null;
            break t;
          }
          var i = 0,
            o = -1,
            n = -1,
            h = 0,
            v = 0,
            g = t,
            s = null;
          a: for (;;) {
            for (var d; g !== c || e !== 0 && g.nodeType !== 3 || (o = i + e), g !== l || r !== 0 && g.nodeType !== 3 || (n = i + r), g.nodeType === 3 && (i += g.nodeValue.length), (d = g.firstChild) !== null;) s = g, g = d;
            for (;;) {
              if (g === t) break a;
              if (s === c && ++h === e && (o = i), s === l && ++v === r && (n = i), (d = g.nextSibling) !== null) break;
              g = s, s = g.parentNode;
            }
            g = d;
          }
          c = o === -1 || n === -1 ? null : {
            start: o,
            end: n
          };
        } else c = null;
      }
      c = c || {
        start: 0,
        end: 0
      };
    } else c = null;
    for (cd = {
      focusedElem: t,
      selectionRange: c
    }, El = !1, p1 = a; p1 !== null;) if (a = p1, t = a.child, (a.subtreeFlags & 1028) !== 0 && t !== null) t.return = a, p1 = t;else for (; p1 !== null;) {
      a = p1;
      try {
        var z = a.alternate;
        if (a.flags & 1024) switch (a.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (z !== null) {
              var u = z.memoizedProps,
                f = z.memoizedState,
                p = a.stateNode,
                m = p.getSnapshotBeforeUpdate(a.elementType === a.type ? u : j3(a.type, u), f);
              p.__reactInternalSnapshotBeforeUpdate = m;
            }
            break;
          case 3:
            var M = a.stateNode.containerInfo;
            M.nodeType === 1 ? M.textContent = "" : M.nodeType === 9 && M.documentElement && M.removeChild(M.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(n1(163));
        }
      } catch (w) {
        d2(a, a.return, w);
      }
      if (t = a.sibling, t !== null) {
        t.return = a.return, p1 = t;
        break;
      }
      p1 = a.return;
    }
    return z = BV, BV = !1, z;
  }
  function Wa(t, a, c) {
    var r = a.updateQueue;
    if (r = r !== null ? r.lastEffect : null, r !== null) {
      var e = r = r.next;
      do {
        if ((e.tag & t) === t) {
          var l = e.destroy;
          e.destroy = void 0, l !== void 0 && fd(a, c, l);
        }
        e = e.next;
      } while (e !== r);
    }
  }
  function si(t, a) {
    if (a = a.updateQueue, a = a !== null ? a.lastEffect : null, a !== null) {
      var c = a = a.next;
      do {
        if ((c.tag & t) === t) {
          var r = c.create;
          c.destroy = r();
        }
        c = c.next;
      } while (c !== a);
    }
  }
  function Md(t) {
    var a = t.ref;
    if (a !== null) {
      var c = t.stateNode;
      switch (t.tag) {
        case 5:
          t = c;
          break;
        default:
          t = c;
      }
      typeof a == "function" ? a(t) : a.current = t;
    }
  }
  function MB(t) {
    var a = t.alternate;
    a !== null && (t.alternate = null, MB(a)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (a = t.stateNode, a !== null && (delete a[H4], delete a[ac], delete a[ld], delete a[tJ], delete a[aJ])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
  }
  function xB(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4;
  }
  function yV(t) {
    t: for (;;) {
      for (; t.sibling === null;) {
        if (t.return === null || xB(t.return)) return null;
        t = t.return;
      }
      for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) {
        if (t.flags & 2 || t.child === null || t.tag === 4) continue t;
        t.child.return = t, t = t.child;
      }
      if (!(t.flags & 2)) return t.stateNode;
    }
  }
  function xd(t, a, c) {
    var r = t.tag;
    if (r === 5 || r === 6) t = t.stateNode, a ? c.nodeType === 8 ? c.parentNode.insertBefore(t, a) : c.insertBefore(t, a) : (c.nodeType === 8 ? (a = c.parentNode, a.insertBefore(t, c)) : (a = c, a.appendChild(t)), c = c._reactRootContainer, c != null || a.onclick !== null || (a.onclick = _l));else if (r !== 4 && (t = t.child, t !== null)) for (xd(t, a, c), t = t.sibling; t !== null;) xd(t, a, c), t = t.sibling;
  }
  function Cd(t, a, c) {
    var r = t.tag;
    if (r === 5 || r === 6) t = t.stateNode, a ? c.insertBefore(t, a) : c.appendChild(t);else if (r !== 4 && (t = t.child, t !== null)) for (Cd(t, a, c), t = t.sibling; t !== null;) Cd(t, a, c), t = t.sibling;
  }
  var _2 = null,
    q3 = !1;
  function n6(t, a, c) {
    for (c = c.child; c !== null;) CB(t, a, c), c = c.sibling;
  }
  function CB(t, a, c) {
    if (V4 && typeof V4.onCommitFiberUnmount == "function") try {
      V4.onCommitFiberUnmount(li, c);
    } catch (o) {}
    switch (c.tag) {
      case 5:
        o0 || l9(c, a);
      case 6:
        var r = _2,
          e = q3;
        _2 = null, n6(t, a, c), _2 = r, q3 = e, _2 !== null && (q3 ? (t = _2, c = c.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(c) : t.removeChild(c)) : _2.removeChild(c.stateNode));
        break;
      case 18:
        _2 !== null && (q3 ? (t = _2, c = c.stateNode, t.nodeType === 8 ? Vg(t.parentNode, c) : t.nodeType === 1 && Vg(t, c), Qa(t)) : Vg(_2, c.stateNode));
        break;
      case 4:
        r = _2, e = q3, _2 = c.stateNode.containerInfo, q3 = !0, n6(t, a, c), _2 = r, q3 = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!o0 && (r = c.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
          e = r = r.next;
          do {
            var l = e,
              i = l.destroy;
            l = l.tag, i !== void 0 && (l & 2 || l & 4) && fd(c, a, i), e = e.next;
          } while (e !== r);
        }
        n6(t, a, c);
        break;
      case 1:
        if (!o0 && (l9(c, a), r = c.stateNode, typeof r.componentWillUnmount == "function")) try {
          r.props = c.memoizedProps, r.state = c.memoizedState, r.componentWillUnmount();
        } catch (o) {
          d2(c, a, o);
        }
        n6(t, a, c);
        break;
      case 21:
        n6(t, a, c);
        break;
      case 22:
        c.mode & 1 ? (o0 = (r = o0) || c.memoizedState !== null, n6(t, a, c), o0 = r) : n6(t, a, c);
        break;
      default:
        n6(t, a, c);
    }
  }
  function SV(t) {
    var a = t.updateQueue;
    if (a !== null) {
      t.updateQueue = null;
      var c = t.stateNode;
      c === null && (c = t.stateNode = new mJ()), a.forEach(function (r) {
        var e = yJ.bind(null, t, r);
        c.has(r) || (c.add(r), r.then(e, e));
      });
    }
  }
  function _3(t, a) {
    var c = a.deletions;
    if (c !== null) for (var r = 0; r < c.length; r++) {
      var e = c[r];
      try {
        var l = t,
          i = a,
          o = i;
        t: for (; o !== null;) {
          switch (o.tag) {
            case 5:
              _2 = o.stateNode, q3 = !1;
              break t;
            case 3:
              _2 = o.stateNode.containerInfo, q3 = !0;
              break t;
            case 4:
              _2 = o.stateNode.containerInfo, q3 = !0;
              break t;
          }
          o = o.return;
        }
        if (_2 === null) throw Error(n1(160));
        CB(l, i, e), _2 = null, q3 = !1;
        var n = e.alternate;
        n !== null && (n.return = null), e.return = null;
      } catch (h) {
        d2(e, a, h);
      }
    }
    if (a.subtreeFlags & 12854) for (a = a.child; a !== null;) LB(a, t), a = a.sibling;
  }
  function LB(t, a) {
    var c = t.alternate,
      r = t.flags;
    switch (t.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (_3(a, t), C4(t), r & 4) {
          try {
            Wa(3, t, t.return), si(3, t);
          } catch (u) {
            d2(t, t.return, u);
          }
          try {
            Wa(5, t, t.return);
          } catch (u) {
            d2(t, t.return, u);
          }
        }
        break;
      case 1:
        _3(a, t), C4(t), r & 512 && c !== null && l9(c, c.return);
        break;
      case 5:
        if (_3(a, t), C4(t), r & 512 && c !== null && l9(c, c.return), t.flags & 32) {
          var e = t.stateNode;
          try {
            Na(e, "");
          } catch (u) {
            d2(t, t.return, u);
          }
        }
        if (r & 4 && (e = t.stateNode, e != null)) {
          var l = t.memoizedProps,
            i = c !== null ? c.memoizedProps : l,
            o = t.type,
            n = t.updateQueue;
          if (t.updateQueue = null, n !== null) try {
            o === "input" && l.type === "radio" && l.name != null && _V(e, l), qg(o, i);
            var h = qg(o, l);
            for (i = 0; i < n.length; i += 2) {
              var v = n[i],
                g = n[i + 1];
              v === "style" ? KV(e, g) : v === "dangerouslySetInnerHTML" ? NV(e, g) : v === "children" ? Na(e, g) : Sd(e, v, g, h);
            }
            switch (o) {
              case "input":
                Eg(e, l);
                break;
              case "textarea":
                jV(e, l);
                break;
              case "select":
                var s = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!l.multiple;
                var d = l.value;
                d != null ? o9(e, !!l.multiple, d, !1) : s !== !!l.multiple && (l.defaultValue != null ? o9(e, !!l.multiple, l.defaultValue, !0) : o9(e, !!l.multiple, l.multiple ? [] : "", !1));
            }
            e[ac] = l;
          } catch (u) {
            d2(t, t.return, u);
          }
        }
        break;
      case 6:
        if (_3(a, t), C4(t), r & 4) {
          if (t.stateNode === null) throw Error(n1(162));
          e = t.stateNode, l = t.memoizedProps;
          try {
            e.nodeValue = l;
          } catch (u) {
            d2(t, t.return, u);
          }
        }
        break;
      case 3:
        if (_3(a, t), C4(t), r & 4 && c !== null && c.memoizedState.isDehydrated) try {
          Qa(a.containerInfo);
        } catch (u) {
          d2(t, t.return, u);
        }
        break;
      case 4:
        _3(a, t), C4(t);
        break;
      case 13:
        _3(a, t), C4(t), e = t.child, e.flags & 8192 && (l = e.memoizedState !== null, e.stateNode.isHidden = l, !l || e.alternate !== null && e.alternate.memoizedState !== null || (os = m2())), r & 4 && SV(t);
        break;
      case 22:
        if (v = c !== null && c.memoizedState !== null, t.mode & 1 ? (o0 = (h = o0) || v, _3(a, t), o0 = h) : _3(a, t), C4(t), r & 8192) {
          if (h = t.memoizedState !== null, (t.stateNode.isHidden = h) && !v && t.mode & 1) for (p1 = t, v = t.child; v !== null;) {
            for (g = p1 = v; p1 !== null;) {
              switch (s = p1, d = s.child, s.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Wa(4, s, s.return);
                  break;
                case 1:
                  l9(s, s.return);
                  var z = s.stateNode;
                  if (typeof z.componentWillUnmount == "function") {
                    r = s, c = s.return;
                    try {
                      a = r, z.props = a.memoizedProps, z.state = a.memoizedState, z.componentWillUnmount();
                    } catch (u) {
                      d2(r, c, u);
                    }
                  }
                  break;
                case 5:
                  l9(s, s.return);
                  break;
                case 22:
                  if (s.memoizedState !== null) {
                    AV(g);
                    continue;
                  }
              }
              d !== null ? (d.return = s, p1 = d) : AV(g);
            }
            v = v.sibling;
          }
          t: for (v = null, g = t;;) {
            if (g.tag === 5) {
              if (v === null) {
                v = g;
                try {
                  e = g.stateNode, h ? (l = e.style, typeof l.setProperty == "function" ? l.setProperty("display", "none", "important") : l.display = "none") : (o = g.stateNode, n = g.memoizedProps.style, i = n != null && n.hasOwnProperty("display") ? n.display : null, o.style.display = UV("display", i));
                } catch (u) {
                  d2(t, t.return, u);
                }
              }
            } else if (g.tag === 6) {
              if (v === null) try {
                g.stateNode.nodeValue = h ? "" : g.memoizedProps;
              } catch (u) {
                d2(t, t.return, u);
              }
            } else if ((g.tag !== 22 && g.tag !== 23 || g.memoizedState === null || g === t) && g.child !== null) {
              g.child.return = g, g = g.child;
              continue;
            }
            if (g === t) break t;
            for (; g.sibling === null;) {
              if (g.return === null || g.return === t) break t;
              v === g && (v = null), g = g.return;
            }
            v === g && (v = null), g.sibling.return = g.return, g = g.sibling;
          }
        }
        break;
      case 19:
        _3(a, t), C4(t), r & 4 && SV(t);
        break;
      case 21:
        break;
      default:
        _3(a, t), C4(t);
    }
  }
  function C4(t) {
    var a = t.flags;
    if (a & 2) {
      try {
        t: {
          for (var c = t.return; c !== null;) {
            if (xB(c)) {
              var r = c;
              break t;
            }
            c = c.return;
          }
          throw Error(n1(160));
        }
        switch (r.tag) {
          case 5:
            var e = r.stateNode;
            r.flags & 32 && (Na(e, ""), r.flags &= -33);
            var l = yV(t);
            Cd(t, l, e);
            break;
          case 3:
          case 4:
            var i = r.stateNode.containerInfo,
              o = yV(t);
            xd(t, o, i);
            break;
          default:
            throw Error(n1(161));
        }
      } catch (n) {
        d2(t, t.return, n);
      }
      t.flags &= -3;
    }
    a & 4096 && (t.flags &= -4097);
  }
  function MJ(t, a, c) {
    p1 = t, HB(t, a, c);
  }
  function HB(t, a, c) {
    for (var r = (t.mode & 1) !== 0; p1 !== null;) {
      var e = p1,
        l = e.child;
      if (e.tag === 22 && r) {
        var i = e.memoizedState !== null || Hl;
        if (!i) {
          var o = e.alternate,
            n = o !== null && o.memoizedState !== null || o0;
          o = Hl;
          var h = o0;
          if (Hl = i, (o0 = n) && !h) for (p1 = e; p1 !== null;) i = p1, n = i.child, i.tag === 22 && i.memoizedState !== null ? RV(e) : n !== null ? (n.return = i, p1 = n) : RV(e);
          for (; l !== null;) p1 = l, HB(l, a, c), l = l.sibling;
          p1 = e, Hl = o, o0 = h;
        }
        kV(t, a, c);
      } else e.subtreeFlags & 8772 && l !== null ? (l.return = e, p1 = l) : kV(t, a, c);
    }
  }
  function kV(t) {
    for (; p1 !== null;) {
      var a = p1;
      if (a.flags & 8772) {
        var c = a.alternate;
        try {
          if (a.flags & 8772) switch (a.tag) {
            case 0:
            case 11:
            case 15:
              o0 || si(5, a);
              break;
            case 1:
              var r = a.stateNode;
              if (a.flags & 4 && !o0) if (c === null) r.componentDidMount();else {
                var e = a.elementType === a.type ? c.memoizedProps : j3(a.type, c.memoizedProps);
                r.componentDidUpdate(e, c.memoizedState, r.__reactInternalSnapshotBeforeUpdate);
              }
              var l = a.updateQueue;
              l !== null && dV(a, l, r);
              break;
            case 3:
              var i = a.updateQueue;
              if (i !== null) {
                if (c = null, a.child !== null) switch (a.child.tag) {
                  case 5:
                    c = a.child.stateNode;
                    break;
                  case 1:
                    c = a.child.stateNode;
                }
                dV(a, i, c);
              }
              break;
            case 5:
              var o = a.stateNode;
              if (c === null && a.flags & 4) {
                c = o;
                var n = a.memoizedProps;
                switch (a.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    n.autoFocus && c.focus();
                    break;
                  case "img":
                    n.src && (c.src = n.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (a.memoizedState === null) {
                var h = a.alternate;
                if (h !== null) {
                  var v = h.memoizedState;
                  if (v !== null) {
                    var g = v.dehydrated;
                    g !== null && Qa(g);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(n1(163));
          }
          o0 || a.flags & 512 && Md(a);
        } catch (s) {
          d2(a, a.return, s);
        }
      }
      if (a === t) {
        p1 = null;
        break;
      }
      if (c = a.sibling, c !== null) {
        c.return = a.return, p1 = c;
        break;
      }
      p1 = a.return;
    }
  }
  function AV(t) {
    for (; p1 !== null;) {
      var a = p1;
      if (a === t) {
        p1 = null;
        break;
      }
      var c = a.sibling;
      if (c !== null) {
        c.return = a.return, p1 = c;
        break;
      }
      p1 = a.return;
    }
  }
  function RV(t) {
    for (; p1 !== null;) {
      var a = p1;
      try {
        switch (a.tag) {
          case 0:
          case 11:
          case 15:
            var c = a.return;
            try {
              si(4, a);
            } catch (n) {
              d2(a, c, n);
            }
            break;
          case 1:
            var r = a.stateNode;
            if (typeof r.componentDidMount == "function") {
              var e = a.return;
              try {
                r.componentDidMount();
              } catch (n) {
                d2(a, e, n);
              }
            }
            var l = a.return;
            try {
              Md(a);
            } catch (n) {
              d2(a, l, n);
            }
            break;
          case 5:
            var i = a.return;
            try {
              Md(a);
            } catch (n) {
              d2(a, i, n);
            }
        }
      } catch (n) {
        d2(a, a.return, n);
      }
      if (a === t) {
        p1 = null;
        break;
      }
      var o = a.sibling;
      if (o !== null) {
        o.return = a.return, p1 = o;
        break;
      }
      p1 = a.return;
    }
  }
  var xJ = Math.ceil,
    ti = u5.ReactCurrentDispatcher,
    ls = u5.ReactCurrentOwner,
    w3 = u5.ReactCurrentBatchConfig,
    T1 = 0,
    F2 = null,
    V2 = null,
    j2 = 0,
    K0 = 0,
    i9 = B6(0),
    k2 = 0,
    oc = null,
    b8 = 0,
    zi = 0,
    is = 0,
    _a = null,
    B0 = null,
    os = 0,
    M9 = 1 / 0,
    i5 = null,
    ai = !1,
    Ld = null,
    x6 = null,
    Vl = !1,
    z6 = null,
    ci = 0,
    ja = 0,
    Hd = null,
    bl = -1,
    Fl = 0;
  function M0() {
    return T1 & 6 ? m2() : bl !== -1 ? bl : bl = m2();
  }
  function C6(t) {
    return t.mode & 1 ? T1 & 2 && j2 !== 0 ? j2 & -j2 : rJ.transition !== null ? (Fl === 0 && (Fl = iw()), Fl) : (t = W1, t !== 0 || (t = window.event, t = t === void 0 ? 16 : sw(t.type)), t) : 1;
  }
  function K3(t, a, c, r) {
    if (50 < ja) throw ja = 0, Hd = null, Error(n1(185));
    nc(t, c, r), (!(T1 & 2) || t !== F2) && (t === F2 && (!(T1 & 2) && (zi |= c), k2 === 4 && d6(t, j2)), A0(t, r), c === 1 && T1 === 0 && !(a.mode & 1) && (M9 = m2() + 500, vi && y6()));
  }
  function A0(t, a) {
    var c = t.callbackNode;
    lY(t, a);
    var r = Ol(t, t === F2 ? j2 : 0);
    if (r === 0) c !== null && OH(c), t.callbackNode = null, t.callbackPriority = 0;else if (a = r & -r, t.callbackPriority !== a) {
      if (c != null && OH(c), a === 1) t.tag === 0 ? cJ(bV.bind(null, t)) : bw(bV.bind(null, t)), YY(function () {
        !(T1 & 6) && y6();
      }), c = null;else {
        switch (ow(r)) {
          case 1:
            c = Fd;
            break;
          case 4:
            c = ew;
            break;
          case 16:
            c = Zl;
            break;
          case 536870912:
            c = lw;
            break;
          default:
            c = Zl;
        }
        c = RB(c, VB.bind(null, t));
      }
      t.callbackPriority = a, t.callbackNode = c;
    }
  }
  function VB(t, a) {
    if (bl = -1, Fl = 0, T1 & 6) throw Error(n1(327));
    var c = t.callbackNode;
    if (d9() && t.callbackNode !== c) return null;
    var r = Ol(t, t === F2 ? j2 : 0);
    if (r === 0) return null;
    if (r & 30 || r & t.expiredLanes || a) a = ri(t, r);else {
      a = r;
      var e = T1;
      T1 |= 2;
      var l = BB();
      (F2 !== t || j2 !== a) && (i5 = null, M9 = m2() + 500, y8(t, a));
      do try {
        HJ();
        break;
      } catch (o) {
        wB(t, o);
      } while (1);
      Nd(), ti.current = l, T1 = e, V2 !== null ? a = 0 : (F2 = null, j2 = 0, a = k2);
    }
    if (a !== 0) {
      if (a === 2 && (e = Qg(t), e !== 0 && (r = e, a = Vd(t, e))), a === 1) throw c = oc, y8(t, 0), d6(t, r), A0(t, m2()), c;
      if (a === 6) d6(t, r);else {
        if (e = t.current.alternate, !(r & 30) && !CJ(e) && (a = ri(t, r), a === 2 && (l = Qg(t), l !== 0 && (r = l, a = Vd(t, l))), a === 1)) throw c = oc, y8(t, 0), d6(t, r), A0(t, m2()), c;
        switch (t.finishedWork = e, t.finishedLanes = r, a) {
          case 0:
          case 1:
            throw Error(n1(345));
          case 2:
            H8(t, B0, i5);
            break;
          case 3:
            if (d6(t, r), (r & 130023424) === r && (a = os + 500 - m2(), 10 < a)) {
              if (Ol(t, 0) !== 0) break;
              if (e = t.suspendedLanes, (e & r) !== r) {
                M0(), t.pingedLanes |= t.suspendedLanes & e;
                break;
              }
              t.timeoutHandle = ed(H8.bind(null, t, B0, i5), a);
              break;
            }
            H8(t, B0, i5);
            break;
          case 4:
            if (d6(t, r), (r & 4194240) === r) break;
            for (a = t.eventTimes, e = -1; 0 < r;) {
              var i = 31 - U3(r);
              l = 1 << i, i = a[i], i > e && (e = i), r &= ~l;
            }
            if (r = e, r = m2() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * xJ(r / 1960)) - r, 10 < r) {
              t.timeoutHandle = ed(H8.bind(null, t, B0, i5), r);
              break;
            }
            H8(t, B0, i5);
            break;
          case 5:
            H8(t, B0, i5);
            break;
          default:
            throw Error(n1(329));
        }
      }
    }
    return A0(t, m2()), t.callbackNode === c ? VB.bind(null, t) : null;
  }
  function Vd(t, a) {
    var c = _a;
    return t.current.memoizedState.isDehydrated && (y8(t, a).flags |= 256), t = ri(t, a), t !== 2 && (a = B0, B0 = c, a !== null && wd(a)), t;
  }
  function wd(t) {
    B0 === null ? B0 = t : B0.push.apply(B0, t);
  }
  function CJ(t) {
    for (var a = t;;) {
      if (a.flags & 16384) {
        var c = a.updateQueue;
        if (c !== null && (c = c.stores, c !== null)) for (var r = 0; r < c.length; r++) {
          var e = c[r],
            l = e.getSnapshot;
          e = e.value;
          try {
            if (!$3(l(), e)) return !1;
          } catch (i) {
            return !1;
          }
        }
      }
      if (c = a.child, a.subtreeFlags & 16384 && c !== null) c.return = a, a = c;else {
        if (a === t) break;
        for (; a.sibling === null;) {
          if (a.return === null || a.return === t) return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
    }
    return !0;
  }
  function d6(t, a) {
    for (a &= ~is, a &= ~zi, t.suspendedLanes |= a, t.pingedLanes &= ~a, t = t.expirationTimes; 0 < a;) {
      var c = 31 - U3(a),
        r = 1 << c;
      t[c] = -1, a &= ~r;
    }
  }
  function bV(t) {
    if (T1 & 6) throw Error(n1(327));
    d9();
    var a = Ol(t, 0);
    if (!(a & 1)) return A0(t, m2()), null;
    var c = ri(t, a);
    if (t.tag !== 0 && c === 2) {
      var r = Qg(t);
      r !== 0 && (a = r, c = Vd(t, r));
    }
    if (c === 1) throw c = oc, y8(t, 0), d6(t, a), A0(t, m2()), c;
    if (c === 6) throw Error(n1(345));
    return t.finishedWork = t.current.alternate, t.finishedLanes = a, H8(t, B0, i5), A0(t, m2()), null;
  }
  function ns(t, a) {
    var c = T1;
    T1 |= 1;
    try {
      return t(a);
    } finally {
      T1 = c, T1 === 0 && (M9 = m2() + 500, vi && y6());
    }
  }
  function F8(t) {
    z6 !== null && z6.tag === 0 && !(T1 & 6) && d9();
    var a = T1;
    T1 |= 1;
    var c = w3.transition,
      r = W1;
    try {
      if (w3.transition = null, W1 = 1, t) return t();
    } finally {
      W1 = r, w3.transition = c, T1 = a, !(T1 & 6) && y6();
    }
  }
  function hs() {
    K0 = i9.current, a2(i9);
  }
  function y8(t, a) {
    t.finishedWork = null, t.finishedLanes = 0;
    var c = t.timeoutHandle;
    if (c !== -1 && (t.timeoutHandle = -1, XY(c)), V2 !== null) for (c = V2.return; c !== null;) {
      var r = c;
      switch (_d(r), r.tag) {
        case 1:
          r = r.type.childContextTypes, r != null && jl();
          break;
        case 3:
          m9(), a2(S0), a2(n0), Yd();
          break;
        case 5:
          Xd(r);
          break;
        case 4:
          m9();
          break;
        case 13:
          a2(n2);
          break;
        case 19:
          a2(n2);
          break;
        case 10:
          Ud(r.type._context);
          break;
        case 22:
        case 23:
          hs();
      }
      c = c.return;
    }
    if (F2 = t, V2 = t = L6(t.current, null), j2 = K0 = a, k2 = 0, oc = null, is = zi = b8 = 0, B0 = _a = null, w8 !== null) {
      for (a = 0; a < w8.length; a++) if (c = w8[a], r = c.interleaved, r !== null) {
        c.interleaved = null;
        var e = r.next,
          l = c.pending;
        if (l !== null) {
          var i = l.next;
          l.next = e, r.next = i;
        }
        c.pending = r;
      }
      w8 = null;
    }
    return t;
  }
  function wB(t, a) {
    do {
      var c = V2;
      try {
        if (Nd(), kl.current = Jl, Yl) {
          for (var r = h2.memoizedState; r !== null;) {
            var e = r.queue;
            e !== null && (e.pending = null), r = r.next;
          }
          Yl = !1;
        }
        if (R8 = 0, b2 = S2 = h2 = null, Da = !1, ec = 0, ls.current = null, c === null || c.return === null) {
          k2 = 1, oc = a, V2 = null;
          break;
        }
        t: {
          var l = t,
            i = c.return,
            o = c,
            n = a;
          if (a = j2, o.flags |= 32768, n !== null && typeof n == "object" && typeof n.then == "function") {
            var h = n,
              v = o,
              g = v.tag;
            if (!(v.mode & 1) && (g === 0 || g === 11 || g === 15)) {
              var s = v.alternate;
              s ? (v.updateQueue = s.updateQueue, v.memoizedState = s.memoizedState, v.lanes = s.lanes) : (v.updateQueue = null, v.memoizedState = null);
            }
            var d = MV(i);
            if (d !== null) {
              d.flags &= -257, xV(d, i, o, l, a), d.mode & 1 && fV(l, h, a), a = d, n = h;
              var z = a.updateQueue;
              if (z === null) {
                var u = new Set();
                u.add(n), a.updateQueue = u;
              } else z.add(n);
              break t;
            } else {
              if (!(a & 1)) {
                fV(l, h, a), vs();
                break t;
              }
              n = Error(n1(426));
            }
          } else if (l2 && o.mode & 1) {
            var f = MV(i);
            if (f !== null) {
              !(f.flags & 65536) && (f.flags |= 256), xV(f, i, o, l, a), jd(f9(n, o));
              break t;
            }
          }
          l = n = f9(n, o), k2 !== 4 && (k2 = 2), _a === null ? _a = [l] : _a.push(l), l = i;
          do {
            switch (l.tag) {
              case 3:
                l.flags |= 65536, a &= -a, l.lanes |= a;
                var p = nB(l, n, a);
                gV(l, p);
                break t;
              case 1:
                o = n;
                var m = l.type,
                  M = l.stateNode;
                if (!(l.flags & 128) && (typeof m.getDerivedStateFromError == "function" || M !== null && typeof M.componentDidCatch == "function" && (x6 === null || !x6.has(M)))) {
                  l.flags |= 65536, a &= -a, l.lanes |= a;
                  var w = hB(l, o, a);
                  gV(l, w);
                  break t;
                }
            }
            l = l.return;
          } while (l !== null);
        }
        SB(c);
      } catch (H) {
        a = H, V2 === c && c !== null && (V2 = c = c.return);
        continue;
      }
      break;
    } while (1);
  }
  function BB() {
    var t = ti.current;
    return ti.current = Jl, t === null ? Jl : t;
  }
  function vs() {
    (k2 === 0 || k2 === 3 || k2 === 2) && (k2 = 4), F2 === null || !(b8 & 268435455) && !(zi & 268435455) || d6(F2, j2);
  }
  function ri(t, a) {
    var c = T1;
    T1 |= 2;
    var r = BB();
    (F2 !== t || j2 !== a) && (i5 = null, y8(t, a));
    do try {
      LJ();
      break;
    } catch (e) {
      wB(t, e);
    } while (1);
    if (Nd(), T1 = c, ti.current = r, V2 !== null) throw Error(n1(261));
    return F2 = null, j2 = 0, k2;
  }
  function LJ() {
    for (; V2 !== null;) yB(V2);
  }
  function HJ() {
    for (; V2 !== null && !QX();) yB(V2);
  }
  function yB(t) {
    var a = AB(t.alternate, t, K0);
    t.memoizedProps = t.pendingProps, a === null ? SB(t) : V2 = a, ls.current = null;
  }
  function SB(t) {
    var a = t;
    do {
      var c = a.alternate;
      if (t = a.return, a.flags & 32768) {
        if (c = pJ(c, a), c !== null) {
          c.flags &= 32767, V2 = c;
          return;
        }
        if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;else {
          k2 = 6, V2 = null;
          return;
        }
      } else if (c = uJ(c, a, K0), c !== null) {
        V2 = c;
        return;
      }
      if (a = a.sibling, a !== null) {
        V2 = a;
        return;
      }
      V2 = a = t;
    } while (a !== null);
    k2 === 0 && (k2 = 5);
  }
  function H8(t, a, c) {
    var r = W1,
      e = w3.transition;
    try {
      w3.transition = null, W1 = 1, VJ(t, a, c, r);
    } finally {
      w3.transition = e, W1 = r;
    }
    return null;
  }
  function VJ(t, a, c, r) {
    do d9(); while (z6 !== null);
    if (T1 & 6) throw Error(n1(327));
    c = t.finishedWork;
    var e = t.finishedLanes;
    if (c === null) return null;
    if (t.finishedWork = null, t.finishedLanes = 0, c === t.current) throw Error(n1(177));
    t.callbackNode = null, t.callbackPriority = 0;
    var l = c.lanes | c.childLanes;
    if (iY(t, l), t === F2 && (V2 = F2 = null, j2 = 0), !(c.subtreeFlags & 2064) && !(c.flags & 2064) || Vl || (Vl = !0, RB(Zl, function () {
      return d9(), null;
    })), l = (c.flags & 15990) !== 0, c.subtreeFlags & 15990 || l) {
      l = w3.transition, w3.transition = null;
      var i = W1;
      W1 = 1;
      var o = T1;
      T1 |= 4, ls.current = null, fJ(t, c), LB(c, t), NY(cd), El = !!ad, cd = ad = null, t.current = c, MJ(c, t, e), XX(), T1 = o, W1 = i, w3.transition = l;
    } else t.current = c;
    if (Vl && (Vl = !1, z6 = t, ci = e), l = t.pendingLanes, l === 0 && (x6 = null), tY(c.stateNode, r), A0(t, m2()), a !== null) for (r = t.onRecoverableError, c = 0; c < a.length; c++) e = a[c], r(e.value, {
      componentStack: e.stack,
      digest: e.digest
    });
    if (ai) throw ai = !1, t = Ld, Ld = null, t;
    return ci & 1 && t.tag !== 0 && d9(), l = t.pendingLanes, l & 1 ? t === Hd ? ja++ : (ja = 0, Hd = t) : ja = 0, y6(), null;
  }
  function d9() {
    if (z6 !== null) {
      var t = ow(ci),
        a = w3.transition,
        c = W1;
      try {
        if (w3.transition = null, W1 = 16 > t ? 16 : t, z6 === null) var r = !1;else {
          if (t = z6, z6 = null, ci = 0, T1 & 6) throw Error(n1(331));
          var e = T1;
          for (T1 |= 4, p1 = t.current; p1 !== null;) {
            var l = p1,
              i = l.child;
            if (p1.flags & 16) {
              var o = l.deletions;
              if (o !== null) {
                for (var n = 0; n < o.length; n++) {
                  var h = o[n];
                  for (p1 = h; p1 !== null;) {
                    var v = p1;
                    switch (v.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Wa(8, v, l);
                    }
                    var g = v.child;
                    if (g !== null) g.return = v, p1 = g;else for (; p1 !== null;) {
                      v = p1;
                      var s = v.sibling,
                        d = v.return;
                      if (MB(v), v === h) {
                        p1 = null;
                        break;
                      }
                      if (s !== null) {
                        s.return = d, p1 = s;
                        break;
                      }
                      p1 = d;
                    }
                  }
                }
                var z = l.alternate;
                if (z !== null) {
                  var u = z.child;
                  if (u !== null) {
                    z.child = null;
                    do {
                      var f = u.sibling;
                      u.sibling = null, u = f;
                    } while (u !== null);
                  }
                }
                p1 = l;
              }
            }
            if (l.subtreeFlags & 2064 && i !== null) i.return = l, p1 = i;else t: for (; p1 !== null;) {
              if (l = p1, l.flags & 2048) switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  Wa(9, l, l.return);
              }
              var p = l.sibling;
              if (p !== null) {
                p.return = l.return, p1 = p;
                break t;
              }
              p1 = l.return;
            }
          }
          var m = t.current;
          for (p1 = m; p1 !== null;) {
            i = p1;
            var M = i.child;
            if (i.subtreeFlags & 2064 && M !== null) M.return = i, p1 = M;else t: for (i = m; p1 !== null;) {
              if (o = p1, o.flags & 2048) try {
                switch (o.tag) {
                  case 0:
                  case 11:
                  case 15:
                    si(9, o);
                }
              } catch (H) {
                d2(o, o.return, H);
              }
              if (o === i) {
                p1 = null;
                break t;
              }
              var w = o.sibling;
              if (w !== null) {
                w.return = o.return, p1 = w;
                break t;
              }
              p1 = o.return;
            }
          }
          if (T1 = e, y6(), V4 && typeof V4.onPostCommitFiberRoot == "function") try {
            V4.onPostCommitFiberRoot(li, t);
          } catch (H) {}
          r = !0;
        }
        return r;
      } finally {
        W1 = c, w3.transition = a;
      }
    }
    return !1;
  }
  function FV(t, a, c) {
    a = f9(c, a), a = nB(t, a, 1), t = M6(t, a, 1), a = M0(), t !== null && (nc(t, 1, a), A0(t, a));
  }
  function d2(t, a, c) {
    if (t.tag === 3) FV(t, t, c);else for (; a !== null;) {
      if (a.tag === 3) {
        FV(a, t, c);
        break;
      } else if (a.tag === 1) {
        var r = a.stateNode;
        if (typeof a.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (x6 === null || !x6.has(r))) {
          t = f9(c, t), t = hB(a, t, 1), a = M6(a, t, 1), t = M0(), a !== null && (nc(a, 1, t), A0(a, t));
          break;
        }
      }
      a = a.return;
    }
  }
  function wJ(t, a, c) {
    var r = t.pingCache;
    r !== null && r.delete(a), a = M0(), t.pingedLanes |= t.suspendedLanes & c, F2 === t && (j2 & c) === c && (k2 === 4 || k2 === 3 && (j2 & 130023424) === j2 && 500 > m2() - os ? y8(t, 0) : is |= c), A0(t, a);
  }
  function kB(t, a) {
    a === 0 && (t.mode & 1 ? (a = vl, vl <<= 1, !(vl & 130023424) && (vl = 4194304)) : a = 1);
    var c = M0();
    t = s5(t, a), t !== null && (nc(t, a, c), A0(t, c));
  }
  function BJ(t) {
    var a = t.memoizedState,
      c = 0;
    a !== null && (c = a.retryLane), kB(t, c);
  }
  function yJ(t, a) {
    var c = 0;
    switch (t.tag) {
      case 13:
        var r = t.stateNode,
          e = t.memoizedState;
        e !== null && (c = e.retryLane);
        break;
      case 19:
        r = t.stateNode;
        break;
      default:
        throw Error(n1(314));
    }
    r !== null && r.delete(a), kB(t, c);
  }
  var AB;
  AB = function (t, a, c) {
    if (t !== null) {
      if (t.memoizedProps !== a.pendingProps || S0.current) y0 = !0;else {
        if (!(t.lanes & c) && !(a.flags & 128)) return y0 = !1, zJ(t, a, c);
        y0 = !!(t.flags & 131072);
      }
    } else y0 = !1, l2 && a.flags & 1048576 && Fw(a, Ul, a.index);
    switch (a.lanes = 0, a.tag) {
      case 2:
        var r = a.type;
        Rl(t, a), t = a.pendingProps;
        var e = z9(a, n0.current);
        g9(a, c), e = ts(null, a, r, t, e, c);
        var l = as();
        return a.flags |= 1, typeof e == "object" && e !== null && typeof e.render == "function" && e.$$typeof === void 0 ? (a.tag = 1, a.memoizedState = null, a.updateQueue = null, k0(r) ? (l = !0, ql(a)) : l = !1, a.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, $d(a), e.updater = gi, a.stateNode = e, e._reactInternals = a, gd(a, r, t, c), a = zd(null, a, r, !0, l, c)) : (a.tag = 0, l2 && l && Wd(a), f0(null, a, e, c), a = a.child), a;
      case 16:
        r = a.elementType;
        t: {
          switch (Rl(t, a), t = a.pendingProps, e = r._init, r = e(r._payload), a.type = r, e = a.tag = kJ(r), t = j3(r, t), e) {
            case 0:
              a = sd(null, a, r, t, c);
              break t;
            case 1:
              a = HV(null, a, r, t, c);
              break t;
            case 11:
              a = CV(null, a, r, t, c);
              break t;
            case 14:
              a = LV(null, a, r, j3(r.type, t), c);
              break t;
          }
          throw Error(n1(306, r, ""));
        }
        return a;
      case 0:
        return r = a.type, e = a.pendingProps, e = a.elementType === r ? e : j3(r, e), sd(t, a, r, e, c);
      case 1:
        return r = a.type, e = a.pendingProps, e = a.elementType === r ? e : j3(r, e), HV(t, a, r, e, c);
      case 3:
        t: {
          if (sB(a), t === null) throw Error(n1(387));
          r = a.pendingProps, l = a.memoizedState, e = l.element, Tw(t, a), Ql(a, r, null, c);
          var i = a.memoizedState;
          if (r = i.element, l.isDehydrated) {
            if (l = {
              element: r,
              isDehydrated: !1,
              cache: i.cache,
              pendingSuspenseBoundaries: i.pendingSuspenseBoundaries,
              transitions: i.transitions
            }, a.updateQueue.baseState = l, a.memoizedState = l, a.flags & 256) {
              e = f9(Error(n1(423)), a), a = VV(t, a, r, c, e);
              break t;
            } else if (r !== e) {
              e = f9(Error(n1(424)), a), a = VV(t, a, r, c, e);
              break t;
            } else for ($0 = f6(a.stateNode.containerInfo.firstChild), Q0 = a, l2 = !0, N3 = null, c = Dw(a, null, r, c), a.child = c; c;) c.flags = c.flags & -3 | 4096, c = c.sibling;
          } else {
            if (u9(), r === e) {
              a = z5(t, a, c);
              break t;
            }
            f0(t, a, r, c);
          }
          a = a.child;
        }
        return a;
      case 5:
        return Ww(a), t === null && nd(a), r = a.type, e = a.pendingProps, l = t !== null ? t.memoizedProps : null, i = e.children, rd(r, e) ? i = null : l !== null && rd(r, l) && (a.flags |= 32), dB(t, a), f0(t, a, i, c), a.child;
      case 6:
        return t === null && nd(a), null;
      case 13:
        return zB(t, a, c);
      case 4:
        return Qd(a, a.stateNode.containerInfo), r = a.pendingProps, t === null ? a.child = p9(a, null, r, c) : f0(t, a, r, c), a.child;
      case 11:
        return r = a.type, e = a.pendingProps, e = a.elementType === r ? e : j3(r, e), CV(t, a, r, e, c);
      case 7:
        return f0(t, a, a.pendingProps, c), a.child;
      case 8:
        return f0(t, a, a.pendingProps.children, c), a.child;
      case 12:
        return f0(t, a, a.pendingProps.children, c), a.child;
      case 10:
        t: {
          if (r = a.type._context, e = a.pendingProps, l = a.memoizedProps, i = e.value, $1(Kl, r._currentValue), r._currentValue = i, l !== null) if ($3(l.value, i)) {
            if (l.children === e.children && !S0.current) {
              a = z5(t, a, c);
              break t;
            }
          } else for (l = a.child, l !== null && (l.return = a); l !== null;) {
            var o = l.dependencies;
            if (o !== null) {
              i = l.child;
              for (var n = o.firstContext; n !== null;) {
                if (n.context === r) {
                  if (l.tag === 1) {
                    n = v5(-1, c & -c), n.tag = 2;
                    var h = l.updateQueue;
                    if (h !== null) {
                      h = h.shared;
                      var v = h.pending;
                      v === null ? n.next = n : (n.next = v.next, v.next = n), h.pending = n;
                    }
                  }
                  l.lanes |= c, n = l.alternate, n !== null && (n.lanes |= c), hd(l.return, c, a), o.lanes |= c;
                  break;
                }
                n = n.next;
              }
            } else if (l.tag === 10) i = l.type === a.type ? null : l.child;else if (l.tag === 18) {
              if (i = l.return, i === null) throw Error(n1(341));
              i.lanes |= c, o = i.alternate, o !== null && (o.lanes |= c), hd(i, c, a), i = l.sibling;
            } else i = l.child;
            if (i !== null) i.return = l;else for (i = l; i !== null;) {
              if (i === a) {
                i = null;
                break;
              }
              if (l = i.sibling, l !== null) {
                l.return = i.return, i = l;
                break;
              }
              i = i.return;
            }
            l = i;
          }
          f0(t, a, e.children, c), a = a.child;
        }
        return a;
      case 9:
        return e = a.type, r = a.pendingProps.children, g9(a, c), e = B3(e), r = r(e), a.flags |= 1, f0(t, a, r, c), a.child;
      case 14:
        return r = a.type, e = j3(r, a.pendingProps), e = j3(r.type, e), LV(t, a, r, e, c);
      case 15:
        return vB(t, a, a.type, a.pendingProps, c);
      case 17:
        return r = a.type, e = a.pendingProps, e = a.elementType === r ? e : j3(r, e), Rl(t, a), a.tag = 1, k0(r) ? (t = !0, ql(a)) : t = !1, g9(a, c), Ow(a, r, e), gd(a, r, e, c), zd(null, a, r, !0, t, c);
      case 19:
        return uB(t, a, c);
      case 22:
        return gB(t, a, c);
    }
    throw Error(n1(156, a.tag));
  };
  function RB(t, a) {
    return rw(t, a);
  }
  function SJ(t, a, c, r) {
    this.tag = t, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function V3(t, a, c, r) {
    return new SJ(t, a, c, r);
  }
  function gs(t) {
    return t = t.prototype, !(!t || !t.isReactComponent);
  }
  function kJ(t) {
    if (typeof t == "function") return gs(t) ? 1 : 0;
    if (t != null) {
      if (t = t.$$typeof, t === Ad) return 11;
      if (t === Rd) return 14;
    }
    return 2;
  }
  function L6(t, a) {
    var c = t.alternate;
    return c === null ? (c = V3(t.tag, a, t.key, t.mode), c.elementType = t.elementType, c.type = t.type, c.stateNode = t.stateNode, c.alternate = t, t.alternate = c) : (c.pendingProps = a, c.type = t.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = t.flags & 14680064, c.childLanes = t.childLanes, c.lanes = t.lanes, c.child = t.child, c.memoizedProps = t.memoizedProps, c.memoizedState = t.memoizedState, c.updateQueue = t.updateQueue, a = t.dependencies, c.dependencies = a === null ? null : {
      lanes: a.lanes,
      firstContext: a.firstContext
    }, c.sibling = t.sibling, c.index = t.index, c.ref = t.ref, c;
  }
  function Il(t, a, c, r, e, l) {
    var i = 2;
    if (r = t, typeof t == "function") gs(t) && (i = 1);else if (typeof t == "string") i = 5;else t: switch (t) {
      case Q7:
        return S8(c.children, e, l, a);
      case kd:
        i = 8, e |= 8;
        break;
      case Pg:
        return t = V3(12, c, a, e | 2), t.elementType = Pg, t.lanes = l, t;
      case Gg:
        return t = V3(13, c, a, e), t.elementType = Gg, t.lanes = l, t;
      case Tg:
        return t = V3(19, c, a, e), t.elementType = Tg, t.lanes = l, t;
      case EV:
        return ui(c, e, l, a);
      default:
        if (typeof t == "object" && t !== null) switch (t.$$typeof) {
          case ZV:
            i = 10;
            break t;
          case OV:
            i = 9;
            break t;
          case Ad:
            i = 11;
            break t;
          case Rd:
            i = 14;
            break t;
          case h6:
            i = 16, r = null;
            break t;
        }
        throw Error(n1(130, t == null ? t : typeof t, ""));
    }
    return a = V3(i, c, a, e), a.elementType = t, a.type = r, a.lanes = l, a;
  }
  function S8(t, a, c, r) {
    return t = V3(7, t, r, a), t.lanes = c, t;
  }
  function ui(t, a, c, r) {
    return t = V3(22, t, r, a), t.elementType = EV, t.lanes = c, t.stateNode = {
      isHidden: !1
    }, t;
  }
  function bg(t, a, c) {
    return t = V3(6, t, null, a), t.lanes = c, t;
  }
  function Fg(t, a, c) {
    return a = V3(4, t.children !== null ? t.children : [], t.key, a), a.lanes = c, a.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation
    }, a;
  }
  function AJ(t, a, c, r, e) {
    this.tag = a, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = pg(0), this.expirationTimes = pg(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = pg(0), this.identifierPrefix = r, this.onRecoverableError = e, this.mutableSourceEagerHydrationData = null;
  }
  function ds(t, a, c, r, e, l, i, o, n) {
    return t = new AJ(t, a, c, o, n), a === 1 ? (a = 1, l === !0 && (a |= 8)) : a = 0, l = V3(3, null, null, a), t.current = l, l.stateNode = t, l.memoizedState = {
      element: r,
      isDehydrated: c,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null
    }, $d(l), t;
  }
  function RJ(t, a, c) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: $7,
      key: r == null ? null : "" + r,
      children: t,
      containerInfo: a,
      implementation: c
    };
  }
  function bB(t) {
    if (!t) return V6;
    t = t._reactInternals;
    t: {
      if (P8(t) !== t || t.tag !== 1) throw Error(n1(170));
      var a = t;
      do {
        switch (a.tag) {
          case 3:
            a = a.stateNode.context;
            break t;
          case 1:
            if (k0(a.type)) {
              a = a.stateNode.__reactInternalMemoizedMergedChildContext;
              break t;
            }
        }
        a = a.return;
      } while (a !== null);
      throw Error(n1(171));
    }
    if (t.tag === 1) {
      var c = t.type;
      if (k0(c)) return Rw(t, c, a);
    }
    return a;
  }
  function FB(t, a, c, r, e, l, i, o, n) {
    return t = ds(c, r, !0, t, e, l, i, o, n), t.context = bB(null), c = t.current, r = M0(), e = C6(c), l = v5(r, e), l.callback = a != null ? a : null, M6(c, l, e), t.current.lanes = e, nc(t, e, r), A0(t, r), t;
  }
  function pi(t, a, c, r) {
    var e = a.current,
      l = M0(),
      i = C6(e);
    return c = bB(c), a.context === null ? a.context = c : a.pendingContext = c, a = v5(l, i), a.payload = {
      element: t
    }, r = r === void 0 ? null : r, r !== null && (a.callback = r), t = M6(e, a, i), t !== null && (K3(t, e, i, l), Sl(t, e, i)), i;
  }
  function ei(t) {
    if (t = t.current, !t.child) return null;
    switch (t.child.tag) {
      case 5:
        return t.child.stateNode;
      default:
        return t.child.stateNode;
    }
  }
  function IV(t, a) {
    if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
      var c = t.retryLane;
      t.retryLane = c !== 0 && c < a ? c : a;
    }
  }
  function ss(t, a) {
    IV(t, a), (t = t.alternate) && IV(t, a);
  }
  function bJ() {
    return null;
  }
  var IB = typeof reportError == "function" ? reportError : function (t) {
    console.error(t);
  };
  function zs(t) {
    this._internalRoot = t;
  }
  mi.prototype.render = zs.prototype.render = function (t) {
    var a = this._internalRoot;
    if (a === null) throw Error(n1(409));
    pi(t, a, null, null);
  };
  mi.prototype.unmount = zs.prototype.unmount = function () {
    var t = this._internalRoot;
    if (t !== null) {
      this._internalRoot = null;
      var a = t.containerInfo;
      F8(function () {
        pi(null, t, null, null);
      }), a[d5] = null;
    }
  };
  function mi(t) {
    this._internalRoot = t;
  }
  mi.prototype.unstable_scheduleHydration = function (t) {
    if (t) {
      var a = vw();
      t = {
        blockedOn: null,
        target: t,
        priority: a
      };
      for (var c = 0; c < g6.length && a !== 0 && a < g6[c].priority; c++);
      g6.splice(c, 0, t), c === 0 && dw(t);
    }
  };
  function us(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
  }
  function fi(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "));
  }
  function PV() {}
  function FJ(t, a, c, r, e) {
    if (e) {
      if (typeof r == "function") {
        var l = r;
        r = function () {
          var h = ei(i);
          l.call(h);
        };
      }
      var i = FB(a, r, t, 0, null, !1, !1, "", PV);
      return t._reactRootContainer = i, t[d5] = i.current, Ja(t.nodeType === 8 ? t.parentNode : t), F8(), i;
    }
    for (; e = t.lastChild;) t.removeChild(e);
    if (typeof r == "function") {
      var o = r;
      r = function () {
        var h = ei(n);
        o.call(h);
      };
    }
    var n = ds(t, 0, !1, null, null, !1, !1, "", PV);
    return t._reactRootContainer = n, t[d5] = n.current, Ja(t.nodeType === 8 ? t.parentNode : t), F8(function () {
      pi(a, n, c, r);
    }), n;
  }
  function Mi(t, a, c, r, e) {
    var l = c._reactRootContainer;
    if (l) {
      var i = l;
      if (typeof e == "function") {
        var o = e;
        e = function () {
          var n = ei(i);
          o.call(n);
        };
      }
      pi(a, i, t, e);
    } else i = FJ(c, a, t, e, r);
    return ei(i);
  }
  nw = function (t) {
    switch (t.tag) {
      case 3:
        var a = t.stateNode;
        if (a.current.memoizedState.isDehydrated) {
          var c = Ia(a.pendingLanes);
          c !== 0 && (Id(a, c | 1), A0(a, m2()), !(T1 & 6) && (M9 = m2() + 500, y6()));
        }
        break;
      case 13:
        F8(function () {
          var r = s5(t, 1);
          if (r !== null) {
            var e = M0();
            K3(r, t, 1, e);
          }
        }), ss(t, 1);
    }
  };
  Pd = function (t) {
    if (t.tag === 13) {
      var a = s5(t, 134217728);
      if (a !== null) {
        var c = M0();
        K3(a, t, 134217728, c);
      }
      ss(t, 134217728);
    }
  };
  hw = function (t) {
    if (t.tag === 13) {
      var a = C6(t),
        c = s5(t, a);
      if (c !== null) {
        var r = M0();
        K3(c, t, a, r);
      }
      ss(t, a);
    }
  };
  vw = function () {
    return W1;
  };
  gw = function (t, a) {
    var c = W1;
    try {
      return W1 = t, a();
    } finally {
      W1 = c;
    }
  };
  Ug = function (t, a, c) {
    switch (a) {
      case "input":
        if (Eg(t, c), a = c.name, c.type === "radio" && a != null) {
          for (c = t; c.parentNode;) c = c.parentNode;
          for (c = c.querySelectorAll("input[name=" + JSON.stringify("" + a) + '][type="radio"]'), a = 0; a < c.length; a++) {
            var r = c[a];
            if (r !== t && r.form === t.form) {
              var e = hi(r);
              if (!e) throw Error(n1(90));
              WV(r), Eg(r, e);
            }
          }
        }
        break;
      case "textarea":
        jV(t, c);
        break;
      case "select":
        a = c.value, a != null && o9(t, !!c.multiple, a, !1);
    }
  };
  XV = ns;
  YV = F8;
  var IJ = {
      usingClientEntryPoint: !1,
      Events: [vc, t9, hi, $V, QV, ns]
    },
    Aa = {
      findFiberByHostInstance: V8,
      bundleType: 0,
      version: "18.2.0",
      rendererPackageName: "react-dom"
    },
    PJ = {
      bundleType: Aa.bundleType,
      version: Aa.version,
      rendererPackageName: Aa.rendererPackageName,
      rendererConfig: Aa.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: u5.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (t) {
        return t = aw(t), t === null ? null : t.stateNode;
      },
      findFiberByHostInstance: Aa.findFiberByHostInstance || bJ,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined" && (Ra = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Ra.isDisabled && Ra.supportsFiber)) try {
    li = Ra.inject(PJ), V4 = Ra;
  } catch (t) {}
  var Ra;
  J0.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = IJ;
  J0.createPortal = function (t, a) {
    var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!us(a)) throw Error(n1(200));
    return RJ(t, a, null, c);
  };
  J0.createRoot = function (t, a) {
    if (!us(t)) throw Error(n1(299));
    var c = !1,
      r = "",
      e = IB;
    return a != null && (a.unstable_strictMode === !0 && (c = !0), a.identifierPrefix !== void 0 && (r = a.identifierPrefix), a.onRecoverableError !== void 0 && (e = a.onRecoverableError)), a = ds(t, 1, !1, null, null, c, !1, r, e), t[d5] = a.current, Ja(t.nodeType === 8 ? t.parentNode : t), new zs(a);
  };
  J0.findDOMNode = function (t) {
    if (t == null) return null;
    if (t.nodeType === 1) return t;
    var a = t._reactInternals;
    if (a === void 0) throw typeof t.render == "function" ? Error(n1(188)) : (t = Object.keys(t).join(","), Error(n1(268, t)));
    return t = aw(a), t = t === null ? null : t.stateNode, t;
  };
  J0.flushSync = function (t) {
    return F8(t);
  };
  J0.hydrate = function (t, a, c) {
    if (!fi(a)) throw Error(n1(200));
    return Mi(null, t, a, !0, c);
  };
  J0.hydrateRoot = function (t, a, c) {
    if (!us(t)) throw Error(n1(405));
    var r = c != null && c.hydratedSources || null,
      e = !1,
      l = "",
      i = IB;
    if (c != null && (c.unstable_strictMode === !0 && (e = !0), c.identifierPrefix !== void 0 && (l = c.identifierPrefix), c.onRecoverableError !== void 0 && (i = c.onRecoverableError)), a = FB(a, null, t, 1, c != null ? c : null, e, !1, l, i), t[d5] = a.current, Ja(t), r) for (t = 0; t < r.length; t++) c = r[t], e = c._getVersion, e = e(c._source), a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [c, e] : a.mutableSourceEagerHydrationData.push(c, e);
    return new mi(a);
  };
  J0.render = function (t, a, c) {
    if (!fi(a)) throw Error(n1(200));
    return Mi(null, t, a, !1, c);
  };
  J0.unmountComponentAtNode = function (t) {
    if (!fi(t)) throw Error(n1(40));
    return t._reactRootContainer ? (F8(function () {
      Mi(null, null, t, !1, function () {
        t._reactRootContainer = null, t[d5] = null;
      });
    }), !0) : !1;
  };
  J0.unstable_batchedUpdates = ns;
  J0.unstable_renderSubtreeIntoContainer = function (t, a, c, r) {
    if (!fi(c)) throw Error(n1(200));
    if (t == null || t._reactInternals === void 0) throw Error(n1(38));
    return Mi(t, a, c, !1, r);
  };
  J0.version = "18.2.0-next-9e3b772b8-20220608";
});
var B4 = L1((Fz1, TB) => {
  "use strict";

  function GB() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(GB);
    } catch (t) {
      console.error(t);
    }
  }
  GB(), TB.exports = PB();
});
function GJ(t) {
  let [, a] = (0, Q3.useState)(0);
  return (0, Q3.useCallback)(() => {
    a(r => r + 1);
  }, []);
}
function v1(t, a, c) {
  let r = (0, Q3.useCallback)(t, a),
    e = (0, Q3.useRef)(null);
  e.current ? e.current.set(r) : e.current = new H9.Atom(r);
  let l = (0, Q3.useRef)(null);
  return l.current || (l.current = (0, H9.prism)(() => e.current.prism.getValue()())), G8(l.current, c);
}
function OJ() {
  ps || (ps = !0, (0, EB.default)(() => {
    (0, DB.unstable_batchedUpdates)(function () {
      var a, c;
      for (; y4.length > 0;) {
        let r = y4.shift();
        dc.delete(r);
        let e;
        L9 && ((a = r.debug) == null || a.history.push("queue reached"));
        try {
          e = r.der.getValue();
        } catch (l) {
          L9 && ((c = r.debug) == null || c.history.push("queue: der.getValue() errored")), console.error("A `der.getValue()` in `usePrismInstance(der)` threw an error. This may be a zombie child issue, so we're gonna try to get its value again in a normal react render phase.If you see the same error again, then you either have an error in your prism code, or the deps array in `usePrism(fn, deps)` is missing a dependency and causing the prism to read stale values."), console.error(l), r.runUpdate();
          continue;
        }
        e !== r.lastValue && (r.lastValue = e, r.runUpdate());
      }
      ps = !1;
    }, 1);
  }));
}
function G8(t, a) {
  var l;
  let c = GJ(a),
    r = (0, Q3.useRef)(void 0);
  r.current || (ZB++, r.current = {
    order: ZB,
    runUpdate: () => {
      r.current.unmounted || c();
    },
    der: t,
    lastValue: void 0,
    unmounted: !1,
    queueUpdate: () => {
      var i;
      L9 && ((i = r.current.debug) == null || i.history.push("queueUpdate()")), TJ(r.current);
    },
    untap: t.onStale(() => {
      L9 && r.current.debug.history.push("onStale(cb)"), r.current.queueUpdate();
    })
  }, L9 && (r.current.debug = {
    label: a,
    traceOfFirstTimeRender: new Error(),
    history: []
  })), (0, Q3.useLayoutEffect)(() => function () {
    r.current.unmounted = !0, r.current.untap(), OB(r.current);
  }, []), OB(r.current);
  let e = r.current.der.getValue();
  return r.current.lastValue = e, L9 && ((l = r.current.debug) == null || l.history.push("rendered")), e;
}
var H9,
  EB,
  Q3,
  DB,
  L9,
  s1,
  ZB,
  y4,
  dc,
  ps,
  TJ,
  ZJ,
  OB,
  M1 = x(() => {
    "use strict";

    H9 = require("@theatre/dataverse");
    H2();
    EB = I(lH()), Q3 = I(G()), DB = I(B4()), L9 = !1;
    s1 = (t, a) => v1(() => (0, H9.val)(t), [t], a), ZB = 0, y4 = [], dc = new Set(), ps = !1, TJ = t => {
      ZJ(t), OJ();
    }, ZJ = t => {
      if (!dc.has(t)) if (dc.add(t), y4.length === 0) y4.push(t);else {
        let a = $e(y4, c => c.order >= t.order);
        a === -1 ? y4.push(t) : y4[a].order > t.order && y4.splice(a, 0, t);
      }
    }, OB = t => {
      if (!dc.has(t)) return;
      dc.delete(t);
      let a = $e(y4, c => c === t);
      y4.splice(a, 1);
    };
  });
var UB = L1(q1 => {
  "use strict";

  var xi = 60103,
    Ci = 60106,
    sc = 60107,
    zc = 60108,
    uc = 60114,
    pc = 60109,
    mc = 60110,
    fc = 60112,
    Mc = 60113,
    ms = 60120,
    xc = 60115,
    Cc = 60116,
    WB = 60121,
    _B = 60122,
    jB = 60117,
    qB = 60129,
    NB = 60131;
  typeof Symbol == "function" && Symbol.for && (I2 = Symbol.for, xi = I2("react.element"), Ci = I2("react.portal"), sc = I2("react.fragment"), zc = I2("react.strict_mode"), uc = I2("react.profiler"), pc = I2("react.provider"), mc = I2("react.context"), fc = I2("react.forward_ref"), Mc = I2("react.suspense"), ms = I2("react.suspense_list"), xc = I2("react.memo"), Cc = I2("react.lazy"), WB = I2("react.block"), _B = I2("react.server.block"), jB = I2("react.fundamental"), qB = I2("react.debug_trace_mode"), NB = I2("react.legacy_hidden"));
  var I2;
  function X3(t) {
    if (typeof t == "object" && t !== null) {
      var a = t.$$typeof;
      switch (a) {
        case xi:
          switch (t = t.type, t) {
            case sc:
            case uc:
            case zc:
            case Mc:
            case ms:
              return t;
            default:
              switch (t = t && t.$$typeof, t) {
                case mc:
                case fc:
                case Cc:
                case xc:
                case pc:
                  return t;
                default:
                  return a;
              }
          }
        case Ci:
          return a;
      }
    }
  }
  var EJ = pc,
    DJ = xi,
    WJ = fc,
    _J = sc,
    jJ = Cc,
    qJ = xc,
    NJ = Ci,
    UJ = uc,
    KJ = zc,
    $J = Mc;
  q1.ContextConsumer = mc;
  q1.ContextProvider = EJ;
  q1.Element = DJ;
  q1.ForwardRef = WJ;
  q1.Fragment = _J;
  q1.Lazy = jJ;
  q1.Memo = qJ;
  q1.Portal = NJ;
  q1.Profiler = UJ;
  q1.StrictMode = KJ;
  q1.Suspense = $J;
  q1.isAsyncMode = function () {
    return !1;
  };
  q1.isConcurrentMode = function () {
    return !1;
  };
  q1.isContextConsumer = function (t) {
    return X3(t) === mc;
  };
  q1.isContextProvider = function (t) {
    return X3(t) === pc;
  };
  q1.isElement = function (t) {
    return typeof t == "object" && t !== null && t.$$typeof === xi;
  };
  q1.isForwardRef = function (t) {
    return X3(t) === fc;
  };
  q1.isFragment = function (t) {
    return X3(t) === sc;
  };
  q1.isLazy = function (t) {
    return X3(t) === Cc;
  };
  q1.isMemo = function (t) {
    return X3(t) === xc;
  };
  q1.isPortal = function (t) {
    return X3(t) === Ci;
  };
  q1.isProfiler = function (t) {
    return X3(t) === uc;
  };
  q1.isStrictMode = function (t) {
    return X3(t) === zc;
  };
  q1.isSuspense = function (t) {
    return X3(t) === Mc;
  };
  q1.isValidElementType = function (t) {
    return typeof t == "string" || typeof t == "function" || t === sc || t === uc || t === qB || t === zc || t === Mc || t === ms || t === NB || typeof t == "object" && t !== null && (t.$$typeof === Cc || t.$$typeof === xc || t.$$typeof === pc || t.$$typeof === mc || t.$$typeof === fc || t.$$typeof === jB || t.$$typeof === WB || t[0] === _B);
  };
  q1.typeOf = X3;
});
var $B = L1((Tz1, KB) => {
  "use strict";

  KB.exports = UB();
});
var fs = L1((Zz1, QB) => {
  QB.exports = function (a, c, r, e) {
    var l = r ? r.call(e, a, c) : void 0;
    if (l !== void 0) return !!l;
    if (a === c) return !0;
    if (typeof a != "object" || !a || typeof c != "object" || !c) return !1;
    var i = Object.keys(a),
      o = Object.keys(c);
    if (i.length !== o.length) return !1;
    for (var n = Object.prototype.hasOwnProperty.bind(c), h = 0; h < i.length; h++) {
      var v = i[h];
      if (!n(v)) return !1;
      var g = a[v],
        s = c[v];
      if (l = r ? r.call(e, g, s, v) : void 0, l === !1 || l === void 0 && g !== s) return !1;
    }
    return !0;
  };
});
function QJ(t) {
  function a(X, $, o1, u1, N) {
    for (var x1 = 0, i1 = 0, B1 = 0, k1 = 0, A1, L, Y = 0, Q = 0, b, R = b = A1 = 0, O = 0, t1 = 0, r1 = 0, q = 0, h1 = o1.length, d1 = h1 - 1, l1, e1 = "", w1 = "", R1 = "", a0 = "", V0; O < h1;) {
      if (L = o1.charCodeAt(O), O === d1 && i1 + k1 + B1 + x1 !== 0 && (i1 !== 0 && (L = i1 === 47 ? 10 : 47), k1 = B1 = x1 = 0, h1++, d1++), i1 + k1 + B1 + x1 === 0) {
        if (O === d1 && (0 < t1 && (e1 = e1.replace(s, "")), 0 < e1.trim().length)) {
          switch (L) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              e1 += o1.charAt(O);
          }
          L = 59;
        }
        switch (L) {
          case 123:
            for (e1 = e1.trim(), A1 = e1.charCodeAt(0), b = 1, q = ++O; O < h1;) {
              switch (L = o1.charCodeAt(O)) {
                case 123:
                  b++;
                  break;
                case 125:
                  b--;
                  break;
                case 47:
                  switch (L = o1.charCodeAt(O + 1)) {
                    case 42:
                    case 47:
                      t: {
                        for (R = O + 1; R < d1; ++R) switch (o1.charCodeAt(R)) {
                          case 47:
                            if (L === 42 && o1.charCodeAt(R - 1) === 42 && O + 2 !== R) {
                              O = R + 1;
                              break t;
                            }
                            break;
                          case 10:
                            if (L === 47) {
                              O = R + 1;
                              break t;
                            }
                        }
                        O = R;
                      }
                  }
                  break;
                case 91:
                  L++;
                case 40:
                  L++;
                case 34:
                case 39:
                  for (; O++ < d1 && o1.charCodeAt(O) !== L;);
              }
              if (b === 0) break;
              O++;
            }
            switch (b = o1.substring(q, O), A1 === 0 && (A1 = (e1 = e1.replace(g, "").trim()).charCodeAt(0)), A1) {
              case 64:
                switch (0 < t1 && (e1 = e1.replace(s, "")), L = e1.charCodeAt(1), L) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    t1 = $;
                    break;
                  default:
                    t1 = K;
                }
                if (b = a($, t1, b, L, N + 1), q = b.length, 0 < J && (t1 = c(K, e1, r1), V0 = o(3, b, t1, $, E, C, q, L, N, u1), e1 = t1.join(""), V0 !== void 0 && (q = (b = V0.trim()).length) === 0 && (L = 0, b = "")), 0 < q) switch (L) {
                  case 115:
                    e1 = e1.replace(y, i);
                  case 100:
                  case 109:
                  case 45:
                    b = e1 + "{" + b + "}";
                    break;
                  case 107:
                    e1 = e1.replace(m, "$1 $2"), b = e1 + "{" + b + "}", b = j === 1 || j === 2 && l("@" + b, 3) ? "@-webkit-" + b + "@" + b : "@" + b;
                    break;
                  default:
                    b = e1 + b, u1 === 112 && (b = (w1 += b, ""));
                } else b = "";
                break;
              default:
                b = a($, c($, e1, r1), b, u1, N + 1);
            }
            R1 += b, b = r1 = t1 = R = A1 = 0, e1 = "", L = o1.charCodeAt(++O);
            break;
          case 125:
          case 59:
            if (e1 = (0 < t1 ? e1.replace(s, "") : e1).trim(), 1 < (q = e1.length)) switch (R === 0 && (A1 = e1.charCodeAt(0), A1 === 45 || 96 < A1 && 123 > A1) && (q = (e1 = e1.replace(" ", ":")).length), 0 < J && (V0 = o(1, e1, $, X, E, C, w1.length, u1, N, u1)) !== void 0 && (q = (e1 = V0.trim()).length) === 0 && (e1 = "\0\0"), A1 = e1.charCodeAt(0), L = e1.charCodeAt(1), A1) {
              case 0:
                break;
              case 64:
                if (L === 105 || L === 99) {
                  a0 += e1 + o1.charAt(O);
                  break;
                }
              default:
                e1.charCodeAt(q - 1) !== 58 && (w1 += e(e1, A1, L, e1.charCodeAt(2)));
            }
            r1 = t1 = R = A1 = 0, e1 = "", L = o1.charCodeAt(++O);
        }
      }
      switch (L) {
        case 13:
        case 10:
          i1 === 47 ? i1 = 0 : 1 + A1 === 0 && u1 !== 107 && 0 < e1.length && (t1 = 1, e1 += "\0"), 0 < J * _ && o(0, e1, $, X, E, C, w1.length, u1, N, u1), C = 1, E++;
          break;
        case 59:
        case 125:
          if (i1 + k1 + B1 + x1 === 0) {
            C++;
            break;
          }
        default:
          switch (C++, l1 = o1.charAt(O), L) {
            case 9:
            case 32:
              if (k1 + x1 + i1 === 0) switch (Y) {
                case 44:
                case 58:
                case 9:
                case 32:
                  l1 = "";
                  break;
                default:
                  L !== 32 && (l1 = " ");
              }
              break;
            case 0:
              l1 = "\\0";
              break;
            case 12:
              l1 = "\\f";
              break;
            case 11:
              l1 = "\\v";
              break;
            case 38:
              k1 + i1 + x1 === 0 && (t1 = r1 = 1, l1 = "\f" + l1);
              break;
            case 108:
              if (k1 + i1 + x1 + a1 === 0 && 0 < R) switch (O - R) {
                case 2:
                  Y === 112 && o1.charCodeAt(O - 3) === 58 && (a1 = Y);
                case 8:
                  Q === 111 && (a1 = Q);
              }
              break;
            case 58:
              k1 + i1 + x1 === 0 && (R = O);
              break;
            case 44:
              i1 + B1 + k1 + x1 === 0 && (t1 = 1, l1 += "\r");
              break;
            case 34:
            case 39:
              i1 === 0 && (k1 = k1 === L ? 0 : k1 === 0 ? L : k1);
              break;
            case 91:
              k1 + i1 + B1 === 0 && x1++;
              break;
            case 93:
              k1 + i1 + B1 === 0 && x1--;
              break;
            case 41:
              k1 + i1 + x1 === 0 && B1--;
              break;
            case 40:
              if (k1 + i1 + x1 === 0) {
                if (A1 === 0) switch (2 * Y + 3 * Q) {
                  case 533:
                    break;
                  default:
                    A1 = 1;
                }
                B1++;
              }
              break;
            case 64:
              i1 + B1 + k1 + x1 + R + b === 0 && (b = 1);
              break;
            case 42:
            case 47:
              if (!(0 < k1 + x1 + B1)) switch (i1) {
                case 0:
                  switch (2 * L + 3 * o1.charCodeAt(O + 1)) {
                    case 235:
                      i1 = 47;
                      break;
                    case 220:
                      q = O, i1 = 42;
                  }
                  break;
                case 42:
                  L === 47 && Y === 42 && q + 2 !== O && (o1.charCodeAt(q + 2) === 33 && (w1 += o1.substring(q, O + 1)), l1 = "", i1 = 0);
              }
          }
          i1 === 0 && (e1 += l1);
      }
      Q = Y, Y = L, O++;
    }
    if (q = w1.length, 0 < q) {
      if (t1 = $, 0 < J && (V0 = o(2, w1, t1, X, E, C, q, u1, N, u1), V0 !== void 0 && (w1 = V0).length === 0)) return a0 + w1 + R1;
      if (w1 = t1.join(",") + "{" + w1 + "}", j * a1 !== 0) {
        switch (j !== 2 || l(w1, 2) || (a1 = 0), a1) {
          case 111:
            w1 = w1.replace(w, ":-moz-$1") + w1;
            break;
          case 112:
            w1 = w1.replace(M, "::-webkit-input-$1") + w1.replace(M, "::-moz-$1") + w1.replace(M, ":-ms-input-$1") + w1;
        }
        a1 = 0;
      }
    }
    return a0 + w1 + R1;
  }
  function c(X, $, o1) {
    var u1 = $.trim().split(f);
    $ = u1;
    var N = u1.length,
      x1 = X.length;
    switch (x1) {
      case 0:
      case 1:
        var i1 = 0;
        for (X = x1 === 0 ? "" : X[0] + " "; i1 < N; ++i1) $[i1] = r(X, $[i1], o1).trim();
        break;
      default:
        var B1 = i1 = 0;
        for ($ = []; i1 < N; ++i1) for (var k1 = 0; k1 < x1; ++k1) $[B1++] = r(X[k1] + " ", u1[i1], o1).trim();
    }
    return $;
  }
  function r(X, $, o1) {
    var u1 = $.charCodeAt(0);
    switch (33 > u1 && (u1 = ($ = $.trim()).charCodeAt(0)), u1) {
      case 38:
        return $.replace(p, "$1" + X.trim());
      case 58:
        return X.trim() + $.replace(p, "$1" + X.trim());
      default:
        if (0 < 1 * o1 && 0 < $.indexOf("\f")) return $.replace(p, (X.charCodeAt(0) === 58 ? "" : "$1") + X.trim());
    }
    return X + $;
  }
  function e(X, $, o1, u1) {
    var N = X + ";",
      x1 = 2 * $ + 3 * o1 + 4 * u1;
    if (x1 === 944) {
      X = N.indexOf(":", 9) + 1;
      var i1 = N.substring(X, N.length - 1).trim();
      return i1 = N.substring(0, X).trim() + i1 + ";", j === 1 || j === 2 && l(i1, 1) ? "-webkit-" + i1 + i1 : i1;
    }
    if (j === 0 || j === 2 && !l(N, 1)) return N;
    switch (x1) {
      case 1015:
        return N.charCodeAt(10) === 97 ? "-webkit-" + N + N : N;
      case 951:
        return N.charCodeAt(3) === 116 ? "-webkit-" + N + N : N;
      case 963:
        return N.charCodeAt(5) === 110 ? "-webkit-" + N + N : N;
      case 1009:
        if (N.charCodeAt(4) !== 100) break;
      case 969:
      case 942:
        return "-webkit-" + N + N;
      case 978:
        return "-webkit-" + N + "-moz-" + N + N;
      case 1019:
      case 983:
        return "-webkit-" + N + "-moz-" + N + "-ms-" + N + N;
      case 883:
        if (N.charCodeAt(8) === 45) return "-webkit-" + N + N;
        if (0 < N.indexOf("image-set(", 11)) return N.replace(P, "$1-webkit-$2") + N;
        break;
      case 932:
        if (N.charCodeAt(4) === 45) switch (N.charCodeAt(5)) {
          case 103:
            return "-webkit-box-" + N.replace("-grow", "") + "-webkit-" + N + "-ms-" + N.replace("grow", "positive") + N;
          case 115:
            return "-webkit-" + N + "-ms-" + N.replace("shrink", "negative") + N;
          case 98:
            return "-webkit-" + N + "-ms-" + N.replace("basis", "preferred-size") + N;
        }
        return "-webkit-" + N + "-ms-" + N + N;
      case 964:
        return "-webkit-" + N + "-ms-flex-" + N + N;
      case 1023:
        if (N.charCodeAt(8) !== 99) break;
        return i1 = N.substring(N.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), "-webkit-box-pack" + i1 + "-webkit-" + N + "-ms-flex-pack" + i1 + N;
      case 1005:
        return z.test(N) ? N.replace(d, ":-webkit-") + N.replace(d, ":-moz-") + N : N;
      case 1e3:
        switch (i1 = N.substring(13).trim(), $ = i1.indexOf("-") + 1, i1.charCodeAt(0) + i1.charCodeAt($)) {
          case 226:
            i1 = N.replace(H, "tb");
            break;
          case 232:
            i1 = N.replace(H, "tb-rl");
            break;
          case 220:
            i1 = N.replace(H, "lr");
            break;
          default:
            return N;
        }
        return "-webkit-" + N + "-ms-" + i1 + N;
      case 1017:
        if (N.indexOf("sticky", 9) === -1) break;
      case 975:
        switch ($ = (N = X).length - 10, i1 = (N.charCodeAt($) === 33 ? N.substring(0, $) : N).substring(X.indexOf(":", 7) + 1).trim(), x1 = i1.charCodeAt(0) + (i1.charCodeAt(7) | 0)) {
          case 203:
            if (111 > i1.charCodeAt(8)) break;
          case 115:
            N = N.replace(i1, "-webkit-" + i1) + ";" + N;
            break;
          case 207:
          case 102:
            N = N.replace(i1, "-webkit-" + (102 < x1 ? "inline-" : "") + "box") + ";" + N.replace(i1, "-webkit-" + i1) + ";" + N.replace(i1, "-ms-" + i1 + "box") + ";" + N;
        }
        return N + ";";
      case 938:
        if (N.charCodeAt(5) === 45) switch (N.charCodeAt(6)) {
          case 105:
            return i1 = N.replace("-items", ""), "-webkit-" + N + "-webkit-box-" + i1 + "-ms-flex-" + i1 + N;
          case 115:
            return "-webkit-" + N + "-ms-flex-item-" + N.replace(F, "") + N;
          default:
            return "-webkit-" + N + "-ms-flex-line-pack" + N.replace("align-content", "").replace(F, "") + N;
        }
        break;
      case 973:
      case 989:
        if (N.charCodeAt(3) !== 45 || N.charCodeAt(4) === 122) break;
      case 931:
      case 953:
        if (A.test(X) === !0) return (i1 = X.substring(X.indexOf(":") + 1)).charCodeAt(0) === 115 ? e(X.replace("stretch", "fill-available"), $, o1, u1).replace(":fill-available", ":stretch") : N.replace(i1, "-webkit-" + i1) + N.replace(i1, "-moz-" + i1.replace("fill-", "")) + N;
        break;
      case 962:
        if (N = "-webkit-" + N + (N.charCodeAt(5) === 102 ? "-ms-" + N : "") + N, o1 + u1 === 211 && N.charCodeAt(13) === 105 && 0 < N.indexOf("transform", 10)) return N.substring(0, N.indexOf(";", 27) + 1).replace(u, "$1-webkit-$2") + N;
    }
    return N;
  }
  function l(X, $) {
    var o1 = X.indexOf($ === 1 ? ":" : "{"),
      u1 = X.substring(0, $ !== 3 ? o1 : 10);
    return o1 = X.substring(o1 + 1, X.length - 1), W($ !== 2 ? u1 : u1.replace(U, "$1"), o1, $);
  }
  function i(X, $) {
    var o1 = e($, $.charCodeAt(0), $.charCodeAt(1), $.charCodeAt(2));
    return o1 !== $ + ";" ? o1.replace(k, " or ($1)").substring(4) : "(" + $ + ")";
  }
  function o(X, $, o1, u1, N, x1, i1, B1, k1, A1) {
    for (var L = 0, Y = $, Q; L < J; ++L) switch (Q = Z[L].call(v, X, Y, o1, u1, N, x1, i1, B1, k1, A1)) {
      case void 0:
      case !1:
      case !0:
      case null:
        break;
      default:
        Y = Q;
    }
    if (Y !== $) return Y;
  }
  function n(X) {
    switch (X) {
      case void 0:
      case null:
        J = Z.length = 0;
        break;
      default:
        if (typeof X == "function") Z[J++] = X;else if (typeof X == "object") for (var $ = 0, o1 = X.length; $ < o1; ++$) n(X[$]);else _ = !!X | 0;
    }
    return n;
  }
  function h(X) {
    return X = X.prefix, X !== void 0 && (W = null, X ? typeof X != "function" ? j = 1 : (j = 2, W = X) : j = 0), h;
  }
  function v(X, $) {
    var o1 = X;
    if (33 > o1.charCodeAt(0) && (o1 = o1.trim()), g1 = o1, o1 = [g1], 0 < J) {
      var u1 = o(-1, $, o1, o1, E, C, 0, 0, 0, 0);
      u1 !== void 0 && typeof u1 == "string" && ($ = u1);
    }
    var N = a(K, o1, $, 0, 0);
    return 0 < J && (u1 = o(-2, N, o1, o1, E, C, N.length, 0, 0, 0), u1 !== void 0 && (N = u1)), g1 = "", a1 = 0, C = E = 1, N;
  }
  var g = /^\0+/g,
    s = /[\0\r\f]/g,
    d = /: */g,
    z = /zoo|gra/,
    u = /([,: ])(transform)/g,
    f = /,\r+?/g,
    p = /([\t\r\n ])*\f?&/g,
    m = /@(k\w+)\s*(\S*)\s*/,
    M = /::(place)/g,
    w = /:(read-only)/g,
    H = /[svh]\w+-[tblr]{2}/,
    y = /\(\s*(.*)\s*\)/g,
    k = /([\s\S]*?);/g,
    F = /-self|flex-/g,
    U = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
    A = /stretch|:\s*\w+\-(?:conte|avail)/,
    P = /([^-])(image-set\()/,
    C = 1,
    E = 1,
    a1 = 0,
    j = 1,
    K = [],
    Z = [],
    J = 0,
    W = null,
    _ = 0,
    g1 = "";
  return v.use = n, v.set = h, t !== void 0 && h(t), v;
}
var XB,
  YB = x(() => {
    XB = QJ;
  });
var XJ,
  JB,
  ty = x(() => {
    XJ = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    }, JB = XJ;
  });
function YJ(t) {
  var a = Object.create(null);
  return function (c) {
    return a[c] === void 0 && (a[c] = t(c)), a[c];
  };
}
var ay,
  cy = x(() => {
    ay = YJ;
  });
var JJ,
  t11,
  Ms,
  ry = x(() => {
    cy();
    JJ = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, t11 = ay(function (t) {
      return JJ.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;
    }), Ms = t11;
  });
var ly = L1(_1 => {
  "use strict";

  var P2 = typeof Symbol == "function" && Symbol.for,
    xs = P2 ? Symbol.for("react.element") : 60103,
    Cs = P2 ? Symbol.for("react.portal") : 60106,
    Li = P2 ? Symbol.for("react.fragment") : 60107,
    Hi = P2 ? Symbol.for("react.strict_mode") : 60108,
    Vi = P2 ? Symbol.for("react.profiler") : 60114,
    wi = P2 ? Symbol.for("react.provider") : 60109,
    Bi = P2 ? Symbol.for("react.context") : 60110,
    Ls = P2 ? Symbol.for("react.async_mode") : 60111,
    yi = P2 ? Symbol.for("react.concurrent_mode") : 60111,
    Si = P2 ? Symbol.for("react.forward_ref") : 60112,
    ki = P2 ? Symbol.for("react.suspense") : 60113,
    a11 = P2 ? Symbol.for("react.suspense_list") : 60120,
    Ai = P2 ? Symbol.for("react.memo") : 60115,
    Ri = P2 ? Symbol.for("react.lazy") : 60116,
    c11 = P2 ? Symbol.for("react.block") : 60121,
    r11 = P2 ? Symbol.for("react.fundamental") : 60117,
    e11 = P2 ? Symbol.for("react.responder") : 60118,
    l11 = P2 ? Symbol.for("react.scope") : 60119;
  function t3(t) {
    if (typeof t == "object" && t !== null) {
      var a = t.$$typeof;
      switch (a) {
        case xs:
          switch (t = t.type, t) {
            case Ls:
            case yi:
            case Li:
            case Vi:
            case Hi:
            case ki:
              return t;
            default:
              switch (t = t && t.$$typeof, t) {
                case Bi:
                case Si:
                case Ri:
                case Ai:
                case wi:
                  return t;
                default:
                  return a;
              }
          }
        case Cs:
          return a;
      }
    }
  }
  function ey(t) {
    return t3(t) === yi;
  }
  _1.AsyncMode = Ls;
  _1.ConcurrentMode = yi;
  _1.ContextConsumer = Bi;
  _1.ContextProvider = wi;
  _1.Element = xs;
  _1.ForwardRef = Si;
  _1.Fragment = Li;
  _1.Lazy = Ri;
  _1.Memo = Ai;
  _1.Portal = Cs;
  _1.Profiler = Vi;
  _1.StrictMode = Hi;
  _1.Suspense = ki;
  _1.isAsyncMode = function (t) {
    return ey(t) || t3(t) === Ls;
  };
  _1.isConcurrentMode = ey;
  _1.isContextConsumer = function (t) {
    return t3(t) === Bi;
  };
  _1.isContextProvider = function (t) {
    return t3(t) === wi;
  };
  _1.isElement = function (t) {
    return typeof t == "object" && t !== null && t.$$typeof === xs;
  };
  _1.isForwardRef = function (t) {
    return t3(t) === Si;
  };
  _1.isFragment = function (t) {
    return t3(t) === Li;
  };
  _1.isLazy = function (t) {
    return t3(t) === Ri;
  };
  _1.isMemo = function (t) {
    return t3(t) === Ai;
  };
  _1.isPortal = function (t) {
    return t3(t) === Cs;
  };
  _1.isProfiler = function (t) {
    return t3(t) === Vi;
  };
  _1.isStrictMode = function (t) {
    return t3(t) === Hi;
  };
  _1.isSuspense = function (t) {
    return t3(t) === ki;
  };
  _1.isValidElementType = function (t) {
    return typeof t == "string" || typeof t == "function" || t === Li || t === yi || t === Vi || t === Hi || t === ki || t === a11 || typeof t == "object" && t !== null && (t.$$typeof === Ri || t.$$typeof === Ai || t.$$typeof === wi || t.$$typeof === Bi || t.$$typeof === Si || t.$$typeof === r11 || t.$$typeof === e11 || t.$$typeof === l11 || t.$$typeof === c11);
  };
  _1.typeOf = t3;
});
var oy = L1((qz1, iy) => {
  "use strict";

  iy.exports = ly();
});
var zy = L1((Nz1, sy) => {
  "use strict";

  var Hs = oy(),
    i11 = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0
    },
    o11 = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0
    },
    n11 = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0
    },
    gy = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0
    },
    Vs = {};
  Vs[Hs.ForwardRef] = n11;
  Vs[Hs.Memo] = gy;
  function ny(t) {
    return Hs.isMemo(t) ? gy : Vs[t.$$typeof] || i11;
  }
  var h11 = Object.defineProperty,
    v11 = Object.getOwnPropertyNames,
    hy = Object.getOwnPropertySymbols,
    g11 = Object.getOwnPropertyDescriptor,
    d11 = Object.getPrototypeOf,
    vy = Object.prototype;
  function dy(t, a, c) {
    if (typeof a != "string") {
      if (vy) {
        var r = d11(a);
        r && r !== vy && dy(t, r, c);
      }
      var e = v11(a);
      hy && (e = e.concat(hy(a)));
      for (var l = ny(t), i = ny(a), o = 0; o < e.length; ++o) {
        var n = e[o];
        if (!o11[n] && !(c && c[n]) && !(i && i[n]) && !(l && l[n])) {
          var h = g11(a, n);
          try {
            h11(t, n, h);
          } catch (v) {}
        }
      }
    }
    return t;
  }
  sy.exports = dy;
});
function Y3() {
  return (Y3 = Object.assign || function (t) {
    for (var a = 1; a < arguments.length; a++) {
      var c = arguments[a];
      for (var r in c) Object.prototype.hasOwnProperty.call(c, r) && (t[r] = c[r]);
    }
    return t;
  }).apply(this, arguments);
}
function Hc(t) {
  return typeof t == "function";
}
function py(t) {
  return t.displayName || t.name || "Component";
}
function Fs(t) {
  return t && typeof t.styledComponentId == "string";
}
function p5(t) {
  for (var a = arguments.length, c = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++) c[r - 1] = arguments[r];
  throw new Error("An error occurred. See https://git.io/JUIaE#" + t + " for more information." + (c.length > 0 ? " Args: " + c.join(", ") : ""));
}
function ks(t) {
  var a,
    c = "";
  for (a = Math.abs(t); a > 52; a = a / 52 | 0) c = fy(a % 52) + c;
  return (fy(a % 52) + c).replace(B11, "$1-$2");
}
function By(t) {
  for (var a = 0; a < t.length; a += 1) {
    var c = t[a];
    if (Hc(c) && !Fs(c)) return !1;
  }
  return !0;
}
function yy(t) {
  var a,
    c,
    r,
    e,
    l = t === void 0 ? S6 : t,
    i = l.options,
    o = i === void 0 ? S6 : i,
    n = l.plugins,
    h = n === void 0 ? Pi : n,
    v = new XB(o),
    g = [],
    s = function (u) {
      function f(p) {
        if (p) try {
          u(p + "}");
        } catch (m) {}
      }
      return function (p, m, M, w, H, y, k, F, U, A) {
        switch (p) {
          case 1:
            if (U === 0 && m.charCodeAt(0) === 64) return u(m + ";"), "";
            break;
          case 2:
            if (F === 0) return m + "/*|*/";
            break;
          case 3:
            switch (F) {
              case 102:
              case 112:
                return u(M[0] + m), "";
              default:
                return m + (A === 0 ? "/*|*/" : "");
            }
          case -2:
            m.split("/*|*/}").forEach(f);
        }
      };
    }(function (u) {
      g.push(u);
    }),
    d = function (u, f, p) {
      return f === 0 && A11.indexOf(p[c.length]) !== -1 || p.match(e) ? u : "." + a;
    };
  function z(u, f, p, m) {
    m === void 0 && (m = "&");
    var M = u.replace(k11, ""),
      w = f && p ? p + " " + f + " { " + M + " }" : M;
    return a = m, c = f, r = new RegExp("\\" + c + "\\b", "g"), e = new RegExp("(\\" + c + "\\b){2,}"), v(p || !f ? "" : f, w);
  }
  return v.use([].concat(h, [function (u, f, p) {
    u === 2 && p.length && p[0].lastIndexOf(c) > 0 && (p[0] = p[0].replace(r, d));
  }, s, function (u) {
    if (u === -2) {
      var f = g;
      return g = [], f;
    }
  }])), z.hash = h.length ? h.reduce(function (u, f) {
    return f.name || p5(15), V9(u, f.name);
  }, 5381).toString() : "", z;
}
function Ts() {
  return (0, j1.useContext)(Ps) || R11;
}
function Sy() {
  return (0, j1.useContext)(Gs) || As;
}
function Zs(t) {
  var a = (0, j1.useState)(t.stylisPlugins),
    c = a[0],
    r = a[1],
    e = Ts(),
    l = (0, j1.useMemo)(function () {
      var o = e;
      return t.sheet ? o = t.sheet : t.target && (o = o.reconstructWithOptions({
        target: t.target
      }, !1)), t.disableCSSOMInjection && (o = o.reconstructWithOptions({
        useCSSOMInjection: !1
      })), o;
    }, [t.disableCSSOMInjection, t.sheet, t.target]),
    i = (0, j1.useMemo)(function () {
      return yy({
        options: {
          prefix: !t.disableVendorPrefixes
        },
        plugins: c
      });
    }, [t.disableVendorPrefixes, c]);
  return (0, j1.useEffect)(function () {
    (0, Ly.default)(c, t.stylisPlugins) || r(t.stylisPlugins);
  }, [t.stylisPlugins]), j1.default.createElement(Ps.Provider, {
    value: l
  }, j1.default.createElement(Gs.Provider, {
    value: i
  }, t.children));
}
function My(t) {
  return F11.test(t) ? t.replace(I11, G11).replace(P11, "-ms-") : t;
}
function T8(t, a, c, r) {
  if (Array.isArray(t)) {
    for (var e, l = [], i = 0, o = t.length; i < o; i += 1) (e = T8(t[i], a, c, r)) !== "" && (Array.isArray(e) ? l.push.apply(l, e) : l.push(e));
    return l;
  }
  if (xy(t)) return "";
  if (Fs(t)) return "." + t.styledComponentId;
  if (Hc(t)) {
    if (typeof (h = t) != "function" || h.prototype && h.prototype.isReactComponent || !a) return t;
    var n = t(a);
    return T8(n, a, c, r);
  }
  var h;
  return t instanceof b11 ? c ? (t.inject(c, r), t.getName(r)) : t : ys(t) ? function v(g, s) {
    var d,
      z,
      u = [];
    for (var f in g) g.hasOwnProperty(f) && !xy(g[f]) && (Array.isArray(g[f]) && g[f].isCss || Hc(g[f]) ? u.push(My(f) + ":", g[f], ";") : ys(g[f]) ? u.push.apply(u, v(g[f], f)) : u.push(My(f) + ": " + (d = f, (z = g[f]) == null || typeof z == "boolean" || z === "" ? "" : typeof z != "number" || z === 0 || d in JB || d.startsWith("--") ? String(z).trim() : z + "px") + ";"));
    return s ? [s + " {"].concat(u, ["}"]) : u;
  }(t) : t.toString();
}
function f2(t) {
  for (var a = arguments.length, c = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++) c[r - 1] = arguments[r];
  return Hc(t) || ys(t) ? Cy(T8(uy(Pi, [t].concat(c)))) : c.length === 0 && t.length === 1 && typeof t[0] == "string" ? t : Cy(T8(uy(t, c)));
}
function ws(t) {
  return t.replace(T11, "-").replace(Z11, "");
}
function Fi(t) {
  return typeof t == "string" && !0;
}
function E11(t, a, c) {
  var r = t[c];
  Rs(a) && Rs(r) ? Ry(r, a) : t[c] = a;
}
function Ry(t) {
  for (var a = arguments.length, c = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++) c[r - 1] = arguments[r];
  for (var e = 0, l = c; e < l.length; e++) {
    var i = l[e];
    if (Rs(i)) for (var o in i) O11(o) && E11(t, i[o], o);
  }
  return t;
}
function by(t, a, c) {
  var r = Fs(t),
    e = !Fi(t),
    l = a.attrs,
    i = l === void 0 ? Pi : l,
    o = a.componentId,
    n = o === void 0 ? function (m, M) {
      var w = typeof m != "string" ? "sc" : ws(m);
      Bs[w] = (Bs[w] || 0) + 1;
      var H = w + "-" + Ay("5.3.11" + w + Bs[w]);
      return M ? M + "-" + H : H;
    }(a.displayName, a.parentComponentId) : o,
    h = a.displayName,
    v = h === void 0 ? function (m) {
      return Fi(m) ? "styled." + m : "Styled(" + py(m) + ")";
    }(t) : h,
    g = a.displayName && a.componentId ? ws(a.displayName) + "-" + a.componentId : a.componentId || n,
    s = r && t.attrs ? Array.prototype.concat(t.attrs, i).filter(Boolean) : i,
    d = a.shouldForwardProp;
  r && t.shouldForwardProp && (d = a.shouldForwardProp ? function (m, M, w) {
    return t.shouldForwardProp(m, M, w) && a.shouldForwardProp(m, M, w);
  } : t.shouldForwardProp);
  var z,
    u = new S11(c, g, r ? t.componentStyle : void 0),
    f = u.isStatic && i.length === 0,
    p = function (m, M) {
      return function (w, H, y, k) {
        var F = w.attrs,
          U = w.componentStyle,
          A = w.defaultProps,
          P = w.foldedComponentIds,
          C = w.shouldForwardProp,
          E = w.styledComponentId,
          a1 = w.target,
          j = function (u1, N, x1) {
            u1 === void 0 && (u1 = S6);
            var i1 = Y3({}, N, {
                theme: u1
              }),
              B1 = {};
            return x1.forEach(function (k1) {
              var A1,
                L,
                Y,
                Q = k1;
              for (A1 in Hc(Q) && (Q = Q(i1)), Q) i1[A1] = B1[A1] = A1 === "className" ? (L = B1[A1], Y = Q[A1], L && Y ? L + " " + Y : L || Y) : Q[A1];
            }), [i1, B1];
          }(ky(H, (0, j1.useContext)(Os), A) || S6, H, F),
          K = j[0],
          Z = j[1],
          J = function (u1, N, x1, i1) {
            var B1 = Ts(),
              k1 = Sy(),
              A1 = N ? u1.generateAndInjectStyles(S6, B1, k1) : u1.generateAndInjectStyles(x1, B1, k1);
            return A1;
          }(U, k, K, void 0),
          W = y,
          _ = Z.$as || H.$as || Z.as || H.as || a1,
          g1 = Fi(_),
          X = Z !== H ? Y3({}, H, {}, Z) : H,
          $ = {};
        for (var o1 in X) o1[0] !== "$" && o1 !== "as" && (o1 === "forwardedAs" ? $.as = X[o1] : (C ? C(o1, Ms, _) : !g1 || Ms(o1)) && ($[o1] = X[o1]));
        return H.style && Z.style !== H.style && ($.style = Y3({}, H.style, {}, Z.style)), $.className = Array.prototype.concat(P, E, J !== E ? J : null, H.className, Z.className).filter(Boolean).join(" "), $.ref = W, (0, j1.createElement)(_, $);
      }(z, m, M, f);
    };
  return p.displayName = v, (z = j1.default.forwardRef(p)).attrs = s, z.componentStyle = u, z.displayName = v, z.shouldForwardProp = d, z.foldedComponentIds = r ? Array.prototype.concat(t.foldedComponentIds, t.styledComponentId) : Pi, z.styledComponentId = g, z.target = r ? t.target : t, z.withComponent = function (m) {
    var M = a.componentId,
      w = function (y, k) {
        if (y == null) return {};
        var F,
          U,
          A = {},
          P = Object.keys(y);
        for (U = 0; U < P.length; U++) F = P[U], k.indexOf(F) >= 0 || (A[F] = y[F]);
        return A;
      }(a, ["componentId"]),
      H = M && M + "-" + (Fi(m) ? m : ws(py(m)));
    return by(m, Y3({}, w, {
      attrs: s,
      componentId: H
    }), c);
  }, Object.defineProperty(z, "defaultProps", {
    get: function () {
      return this._foldedDefaultProps;
    },
    set: function (m) {
      this._foldedDefaultProps = r ? Ry({}, t.defaultProps, m) : m;
    }
  }), Object.defineProperty(z, "toString", {
    value: function () {
      return "." + z.styledComponentId;
    }
  }), e && (0, Hy.default)(z, t, {
    attrs: !0,
    componentStyle: !0,
    displayName: !0,
    foldedComponentIds: !0,
    shouldForwardProp: !0,
    styledComponentId: !0,
    target: !0,
    withComponent: !0
  }), z;
}
function Zi(t) {
  for (var a = arguments.length, c = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++) c[r - 1] = arguments[r];
  var e = f2.apply(void 0, [t].concat(c)),
    l = "sc-global-" + Ay(JSON.stringify(e)),
    i = new D11(e, l);
  function o(h) {
    var v = Ts(),
      g = Sy(),
      s = (0, j1.useContext)(Os),
      d = (0, j1.useRef)(v.allocateGSInstance(l)).current;
    return v.server && n(d, h, v, s, g), (0, j1.useLayoutEffect)(function () {
      if (!v.server) return n(d, h, v, s, g), function () {
        return i.removeStyles(d, v);
      };
    }, [d, h, v, s, g]), null;
  }
  function n(h, v, g, s, d) {
    if (i.isStatic) i.renderStyles(h, z11, g, d);else {
      var z = Y3({}, v, {
        theme: ky(v, s, o.defaultProps)
      });
      i.renderStyles(h, z, g, d);
    }
  }
  return j1.default.memo(o);
}
var Ti,
  j1,
  Ly,
  Hy,
  uy,
  ys,
  Pi,
  S6,
  k6,
  Is,
  s11,
  z11,
  u11,
  Ii,
  Gi,
  Lc,
  bi,
  p11,
  m11,
  f11,
  M11,
  x11,
  C11,
  Ss,
  Vy,
  L11,
  H11,
  V11,
  my,
  w11,
  Vc,
  B11,
  fy,
  V9,
  wy,
  y11,
  S11,
  k11,
  A11,
  Ps,
  Xz1,
  Gs,
  R11,
  As,
  b11,
  F11,
  I11,
  P11,
  G11,
  xy,
  Cy,
  ky,
  T11,
  Z11,
  Ay,
  Rs,
  O11,
  Os,
  Yz1,
  Bs,
  bs,
  D11,
  Jz1,
  B,
  c1 = x(() => {
    Ti = I($B()), j1 = I(G()), Ly = I(fs());
    YB();
    ty();
    ry();
    Hy = I(zy());
    uy = function (t, a) {
      for (var c = [t[0]], r = 0, e = a.length; r < e; r += 1) c.push(a[r], t[r + 1]);
      return c;
    }, ys = function (t) {
      return t !== null && typeof t == "object" && (t.toString ? t.toString() : Object.prototype.toString.call(t)) === "[object Object]" && !(0, Ti.typeOf)(t);
    }, Pi = Object.freeze([]), S6 = Object.freeze({});
    k6 = typeof process != "undefined" && process.env !== void 0 && (undefined || undefined) || "data-styled", Is = typeof window != "undefined" && "HTMLElement" in window, s11 = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process != "undefined" && process.env !== void 0 && (undefined !== void 0 && undefined !== "" ? undefined !== "false" && undefined : undefined !== void 0 && undefined !== "" && undefined !== "false" && undefined)), z11 = {};
    u11 = function () {
      function t(c) {
        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = c;
      }
      var a = t.prototype;
      return a.indexOfGroup = function (c) {
        for (var r = 0, e = 0; e < c; e++) r += this.groupSizes[e];
        return r;
      }, a.insertRules = function (c, r) {
        if (c >= this.groupSizes.length) {
          for (var e = this.groupSizes, l = e.length, i = l; c >= i;) (i <<= 1) < 0 && p5(16, "" + c);
          this.groupSizes = new Uint32Array(i), this.groupSizes.set(e), this.length = i;
          for (var o = l; o < i; o++) this.groupSizes[o] = 0;
        }
        for (var n = this.indexOfGroup(c + 1), h = 0, v = r.length; h < v; h++) this.tag.insertRule(n, r[h]) && (this.groupSizes[c]++, n++);
      }, a.clearGroup = function (c) {
        if (c < this.length) {
          var r = this.groupSizes[c],
            e = this.indexOfGroup(c),
            l = e + r;
          this.groupSizes[c] = 0;
          for (var i = e; i < l; i++) this.tag.deleteRule(e);
        }
      }, a.getGroup = function (c) {
        var r = "";
        if (c >= this.length || this.groupSizes[c] === 0) return r;
        for (var e = this.groupSizes[c], l = this.indexOfGroup(c), i = l + e, o = l; o < i; o++) r += this.tag.getRule(o) + "/*!sc*/\n";
        return r;
      }, t;
    }(), Ii = new Map(), Gi = new Map(), Lc = 1, bi = function (t) {
      if (Ii.has(t)) return Ii.get(t);
      for (; Gi.has(Lc);) Lc++;
      var a = Lc++;
      return Ii.set(t, a), Gi.set(a, t), a;
    }, p11 = function (t) {
      return Gi.get(t);
    }, m11 = function (t, a) {
      a >= Lc && (Lc = a + 1), Ii.set(t, a), Gi.set(a, t);
    }, f11 = "style[" + k6 + '][data-styled-version="5.3.11"]', M11 = new RegExp("^" + k6 + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), x11 = function (t, a, c) {
      for (var r, e = c.split(","), l = 0, i = e.length; l < i; l++) (r = e[l]) && t.registerName(a, r);
    }, C11 = function (t, a) {
      for (var c = (a.textContent || "").split("/*!sc*/\n"), r = [], e = 0, l = c.length; e < l; e++) {
        var i = c[e].trim();
        if (i) {
          var o = i.match(M11);
          if (o) {
            var n = 0 | parseInt(o[1], 10),
              h = o[2];
            n !== 0 && (m11(h, n), x11(t, h, o[3]), t.getTag().insertRules(n, r)), r.length = 0;
          } else r.push(i);
        }
      }
    }, Ss = function () {
      return typeof __webpack_nonce__ != "undefined" ? __webpack_nonce__ : null;
    }, Vy = function (t) {
      var a = document.head,
        c = t || a,
        r = document.createElement("style"),
        e = function (o) {
          for (var n = o.childNodes, h = n.length; h >= 0; h--) {
            var v = n[h];
            if (v && v.nodeType === 1 && v.hasAttribute(k6)) return v;
          }
        }(c),
        l = e !== void 0 ? e.nextSibling : null;
      r.setAttribute(k6, "active"), r.setAttribute("data-styled-version", "5.3.11");
      var i = Ss();
      return i && r.setAttribute("nonce", i), c.insertBefore(r, l), r;
    }, L11 = function () {
      function t(c) {
        var r = this.element = Vy(c);
        r.appendChild(document.createTextNode("")), this.sheet = function (e) {
          if (e.sheet) return e.sheet;
          for (var l = document.styleSheets, i = 0, o = l.length; i < o; i++) {
            var n = l[i];
            if (n.ownerNode === e) return n;
          }
          p5(17);
        }(r), this.length = 0;
      }
      var a = t.prototype;
      return a.insertRule = function (c, r) {
        try {
          return this.sheet.insertRule(r, c), this.length++, !0;
        } catch (e) {
          return !1;
        }
      }, a.deleteRule = function (c) {
        this.sheet.deleteRule(c), this.length--;
      }, a.getRule = function (c) {
        var r = this.sheet.cssRules[c];
        return r !== void 0 && typeof r.cssText == "string" ? r.cssText : "";
      }, t;
    }(), H11 = function () {
      function t(c) {
        var r = this.element = Vy(c);
        this.nodes = r.childNodes, this.length = 0;
      }
      var a = t.prototype;
      return a.insertRule = function (c, r) {
        if (c <= this.length && c >= 0) {
          var e = document.createTextNode(r),
            l = this.nodes[c];
          return this.element.insertBefore(e, l || null), this.length++, !0;
        }
        return !1;
      }, a.deleteRule = function (c) {
        this.element.removeChild(this.nodes[c]), this.length--;
      }, a.getRule = function (c) {
        return c < this.length ? this.nodes[c].textContent : "";
      }, t;
    }(), V11 = function () {
      function t(c) {
        this.rules = [], this.length = 0;
      }
      var a = t.prototype;
      return a.insertRule = function (c, r) {
        return c <= this.length && (this.rules.splice(c, 0, r), this.length++, !0);
      }, a.deleteRule = function (c) {
        this.rules.splice(c, 1), this.length--;
      }, a.getRule = function (c) {
        return c < this.length ? this.rules[c] : "";
      }, t;
    }(), my = Is, w11 = {
      isServer: !Is,
      useCSSOMInjection: !s11
    }, Vc = function () {
      function t(c, r, e) {
        c === void 0 && (c = S6), r === void 0 && (r = {}), this.options = Y3({}, w11, {}, c), this.gs = r, this.names = new Map(e), this.server = !!c.isServer, !this.server && Is && my && (my = !1, function (l) {
          for (var i = document.querySelectorAll(f11), o = 0, n = i.length; o < n; o++) {
            var h = i[o];
            h && h.getAttribute(k6) !== "active" && (C11(l, h), h.parentNode && h.parentNode.removeChild(h));
          }
        }(this));
      }
      t.registerId = function (c) {
        return bi(c);
      };
      var a = t.prototype;
      return a.reconstructWithOptions = function (c, r) {
        return r === void 0 && (r = !0), new t(Y3({}, this.options, {}, c), this.gs, r && this.names || void 0);
      }, a.allocateGSInstance = function (c) {
        return this.gs[c] = (this.gs[c] || 0) + 1;
      }, a.getTag = function () {
        return this.tag || (this.tag = (e = (r = this.options).isServer, l = r.useCSSOMInjection, i = r.target, c = e ? new V11(i) : l ? new L11(i) : new H11(i), new u11(c)));
        var c, r, e, l, i;
      }, a.hasNameForId = function (c, r) {
        return this.names.has(c) && this.names.get(c).has(r);
      }, a.registerName = function (c, r) {
        if (bi(c), this.names.has(c)) this.names.get(c).add(r);else {
          var e = new Set();
          e.add(r), this.names.set(c, e);
        }
      }, a.insertRules = function (c, r, e) {
        this.registerName(c, r), this.getTag().insertRules(bi(c), e);
      }, a.clearNames = function (c) {
        this.names.has(c) && this.names.get(c).clear();
      }, a.clearRules = function (c) {
        this.getTag().clearGroup(bi(c)), this.clearNames(c);
      }, a.clearTag = function () {
        this.tag = void 0;
      }, a.toString = function () {
        return function (c) {
          for (var r = c.getTag(), e = r.length, l = "", i = 0; i < e; i++) {
            var o = p11(i);
            if (o !== void 0) {
              var n = c.names.get(o),
                h = r.getGroup(i);
              if (n && h && n.size) {
                var v = k6 + ".g" + i + '[id="' + o + '"]',
                  g = "";
                n !== void 0 && n.forEach(function (s) {
                  s.length > 0 && (g += s + ",");
                }), l += "" + h + v + '{content:"' + g + '"}/*!sc*/\n';
              }
            }
          }
          return l;
        }(this);
      }, t;
    }(), B11 = /(a)(d)/gi, fy = function (t) {
      return String.fromCharCode(t + (t > 25 ? 39 : 97));
    };
    V9 = function (t, a) {
      for (var c = a.length; c;) t = 33 * t ^ a.charCodeAt(--c);
      return t;
    }, wy = function (t) {
      return V9(5381, t);
    };
    y11 = wy("5.3.11"), S11 = function () {
      function t(a, c, r) {
        this.rules = a, this.staticRulesId = "", this.isStatic = (r === void 0 || r.isStatic) && By(a), this.componentId = c, this.baseHash = V9(y11, c), this.baseStyle = r, Vc.registerId(c);
      }
      return t.prototype.generateAndInjectStyles = function (a, c, r) {
        var e = this.componentId,
          l = [];
        if (this.baseStyle && l.push(this.baseStyle.generateAndInjectStyles(a, c, r)), this.isStatic && !r.hash) {
          if (this.staticRulesId && c.hasNameForId(e, this.staticRulesId)) l.push(this.staticRulesId);else {
            var i = T8(this.rules, a, c, r).join(""),
              o = ks(V9(this.baseHash, i) >>> 0);
            if (!c.hasNameForId(e, o)) {
              var n = r(i, "." + o, void 0, e);
              c.insertRules(e, o, n);
            }
            l.push(o), this.staticRulesId = o;
          }
        } else {
          for (var h = this.rules.length, v = V9(this.baseHash, r.hash), g = "", s = 0; s < h; s++) {
            var d = this.rules[s];
            if (typeof d == "string") g += d;else if (d) {
              var z = T8(d, a, c, r),
                u = Array.isArray(z) ? z.join("") : z;
              v = V9(v, u + s), g += u;
            }
          }
          if (g) {
            var f = ks(v >>> 0);
            if (!c.hasNameForId(e, f)) {
              var p = r(g, "." + f, void 0, e);
              c.insertRules(e, f, p);
            }
            l.push(f);
          }
        }
        return l.join(" ");
      }, t;
    }(), k11 = /^\s*\/\/.*$/gm, A11 = [":", "[", ".", "#"];
    Ps = j1.default.createContext(), Xz1 = Ps.Consumer, Gs = j1.default.createContext(), R11 = (Gs.Consumer, new Vc()), As = yy();
    b11 = function () {
      function t(a, c) {
        var r = this;
        this.inject = function (e, l) {
          l === void 0 && (l = As);
          var i = r.name + l.hash;
          e.hasNameForId(r.id, i) || e.insertRules(r.id, i, l(r.rules, i, "@keyframes"));
        }, this.toString = function () {
          return p5(12, String(r.name));
        }, this.name = a, this.id = "sc-keyframes-" + a, this.rules = c;
      }
      return t.prototype.getName = function (a) {
        return a === void 0 && (a = As), this.name + a.hash;
      }, t;
    }(), F11 = /([A-Z])/, I11 = /([A-Z])/g, P11 = /^ms-/, G11 = function (t) {
      return "-" + t.toLowerCase();
    };
    xy = function (t) {
      return t == null || t === !1 || t === "";
    };
    Cy = function (t) {
      return Array.isArray(t) && (t.isCss = !0), t;
    };
    ky = function (t, a, c) {
      return c === void 0 && (c = S6), t.theme !== c.theme && t.theme || a || c.theme;
    }, T11 = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, Z11 = /(^-|-$)/g;
    Ay = function (t) {
      return ks(wy(t) >>> 0);
    };
    Rs = function (t) {
      return typeof t == "function" || typeof t == "object" && t !== null && !Array.isArray(t);
    }, O11 = function (t) {
      return t !== "__proto__" && t !== "constructor" && t !== "prototype";
    };
    Os = j1.default.createContext(), Yz1 = Os.Consumer, Bs = {};
    bs = function (t) {
      return function a(c, r, e) {
        if (e === void 0 && (e = S6), !(0, Ti.isValidElementType)(r)) return p5(1, String(r));
        var l = function () {
          return c(r, e, f2.apply(void 0, arguments));
        };
        return l.withConfig = function (i) {
          return a(c, r, Y3({}, e, {}, i));
        }, l.attrs = function (i) {
          return a(c, r, Y3({}, e, {
            attrs: Array.prototype.concat(e.attrs, i).filter(Boolean)
          }));
        }, l;
      }(by, t);
    };
    ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function (t) {
      bs[t] = bs(t);
    });
    D11 = function () {
      function t(c, r) {
        this.rules = c, this.componentId = r, this.isStatic = By(c), Vc.registerId(this.componentId + 1);
      }
      var a = t.prototype;
      return a.createStyles = function (c, r, e, l) {
        var i = l(T8(this.rules, r, e, l).join(""), ""),
          o = this.componentId + c;
        e.insertRules(o, o, i);
      }, a.removeStyles = function (c, r) {
        r.clearRules(this.componentId + c);
      }, a.renderStyles = function (c, r, e, l) {
        c > 2 && Vc.registerId(this.componentId + c), this.removeStyles(c, e), this.createStyles(c, r, e, l);
      }, t;
    }();
    Jz1 = function () {
      function t() {
        var c = this;
        this._emitSheetCSS = function () {
          var r = c.instance.toString();
          if (!r) return "";
          var e = Ss();
          return "<style " + [e && 'nonce="' + e + '"', k6 + '="true"', 'data-styled-version="5.3.11"'].filter(Boolean).join(" ") + ">" + r + "</style>";
        }, this.getStyleTags = function () {
          return c.sealed ? p5(2) : c._emitSheetCSS();
        }, this.getStyleElement = function () {
          var r;
          if (c.sealed) return p5(2);
          var e = ((r = {})[k6] = "", r["data-styled-version"] = "5.3.11", r.dangerouslySetInnerHTML = {
              __html: c.instance.toString()
            }, r),
            l = Ss();
          return l && (e.nonce = l), [j1.default.createElement("style", Y3({}, e, {
            key: "sc-0-0"
          }))];
        }, this.seal = function () {
          c.sealed = !0;
        }, this.instance = new Vc({
          isServer: !0
        }), this.sealed = !1;
      }
      var a = t.prototype;
      return a.collectStyles = function (c) {
        return this.sealed ? p5(2) : j1.default.createElement(Zs, {
          sheet: this.instance
        }, c);
      }, a.interleaveWithNodeStream = function (c) {
        return p5(3);
      }, t;
    }(), B = bs;
  });
function m5() {
  return m5 = Object.assign || function (t) {
    for (var a = 1; a < arguments.length; a++) {
      var c = arguments[a];
      for (var r in c) Object.prototype.hasOwnProperty.call(c, r) && (t[r] = c[r]);
    }
    return t;
  }, m5.apply(this, arguments);
}
var Fy = x(() => {});
function Es(t) {
  if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
var Iy = x(() => {});
function f5(t, a) {
  return f5 = Object.setPrototypeOf || function (r, e) {
    return r.__proto__ = e, r;
  }, f5(t, a);
}
var Oi = x(() => {});
function Ds(t, a) {
  t.prototype = Object.create(a.prototype), t.prototype.constructor = t, f5(t, a);
}
var Py = x(() => {
  Oi();
});
function wc(t) {
  return wc = Object.setPrototypeOf ? Object.getPrototypeOf : function (c) {
    return c.__proto__ || Object.getPrototypeOf(c);
  }, wc(t);
}
var Gy = x(() => {});
function Ws(t) {
  return Function.toString.call(t).indexOf("[native code]") !== -1;
}
var Ty = x(() => {});
function _s() {
  if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
  } catch (t) {
    return !1;
  }
}
var Zy = x(() => {});
function w9(t, a, c) {
  return _s() ? w9 = Reflect.construct : w9 = function (e, l, i) {
    var o = [null];
    o.push.apply(o, l);
    var n = Function.bind.apply(e, o),
      h = new n();
    return i && f5(h, i.prototype), h;
  }, w9.apply(null, arguments);
}
var Oy = x(() => {
  Oi();
  Zy();
});
function Bc(t) {
  var a = typeof Map == "function" ? new Map() : void 0;
  return Bc = function (r) {
    if (r === null || !Ws(r)) return r;
    if (typeof r != "function") throw new TypeError("Super expression must either be null or a function");
    if (typeof a != "undefined") {
      if (a.has(r)) return a.get(r);
      a.set(r, e);
    }
    function e() {
      return w9(r, arguments, wc(this).constructor);
    }
    return e.prototype = Object.create(r.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), f5(e, r);
  }, Bc(t);
}
var Ey = x(() => {
  Gy();
  Oi();
  Ty();
  Oy();
});
var Dy = x(() => {});
function W11(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function j11(t, a) {
  if (!t) return a.toLowerCase();
  var c = t.split("-");
  if (c.length > 1) return c.splice(1, 0, a), c.reduce(function (e, l) {
    return "" + e + W11(l);
  });
  var r = t.replace(/([a-z])([A-Z])/g, "$1" + a + "$2");
  return t === r ? "" + t + a : r;
}
function q11(t, a) {
  for (var c = {}, r = 0; r < a.length; r += 1) (a[r] || a[r] === 0) && (c[j11(t, _11[r])] = a[r]);
  return c;
}
function Wy(t) {
  for (var a = arguments.length, c = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++) c[r - 1] = arguments[r];
  var e = c[0],
    l = c[1],
    i = l === void 0 ? e : l,
    o = c[2],
    n = o === void 0 ? e : o,
    h = c[3],
    v = h === void 0 ? i : h,
    g = [e, i, n, v];
  return q11(t, g);
}
function js(t) {
  return Math.round(t * 255);
}
function N11(t, a, c) {
  return js(t) + "," + js(a) + "," + js(c);
}
function yc(t, a, c, r) {
  if (r === void 0 && (r = N11), a === 0) return r(c, c, c);
  var e = (t % 360 + 360) % 360 / 60,
    l = (1 - Math.abs(2 * c - 1)) * a,
    i = l * (1 - Math.abs(e % 2 - 1)),
    o = 0,
    n = 0,
    h = 0;
  e >= 0 && e < 1 ? (o = l, n = i) : e >= 1 && e < 2 ? (o = i, n = l) : e >= 2 && e < 3 ? (n = l, h = i) : e >= 3 && e < 4 ? (n = i, h = l) : e >= 4 && e < 5 ? (o = i, h = l) : e >= 5 && e < 6 && (o = l, h = i);
  var v = c - l / 2,
    g = o + v,
    s = n + v,
    d = h + v;
  return r(g, s, d);
}
function U11(t) {
  if (typeof t != "string") return t;
  var a = t.toLowerCase();
  return _y[a] ? "#" + _y[a] : t;
}
function $s(t) {
  if (typeof t != "string") throw new S4(3);
  var a = U11(t);
  if (a.match(K11)) return {
    red: parseInt("" + a[1] + a[2], 16),
    green: parseInt("" + a[3] + a[4], 16),
    blue: parseInt("" + a[5] + a[6], 16)
  };
  if (a.match($11)) {
    var c = parseFloat((parseInt("" + a[7] + a[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + a[1] + a[2], 16),
      green: parseInt("" + a[3] + a[4], 16),
      blue: parseInt("" + a[5] + a[6], 16),
      alpha: c
    };
  }
  if (a.match(Q11)) return {
    red: parseInt("" + a[1] + a[1], 16),
    green: parseInt("" + a[2] + a[2], 16),
    blue: parseInt("" + a[3] + a[3], 16)
  };
  if (a.match(X11)) {
    var r = parseFloat((parseInt("" + a[4] + a[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + a[1] + a[1], 16),
      green: parseInt("" + a[2] + a[2], 16),
      blue: parseInt("" + a[3] + a[3], 16),
      alpha: r
    };
  }
  var e = qs.exec(a);
  if (e) return {
    red: parseInt("" + e[1], 10),
    green: parseInt("" + e[2], 10),
    blue: parseInt("" + e[3], 10)
  };
  var l = Y11.exec(a.substring(0, 50));
  if (l) return {
    red: parseInt("" + l[1], 10),
    green: parseInt("" + l[2], 10),
    blue: parseInt("" + l[3], 10),
    alpha: parseFloat("" + l[4])
  };
  var i = J11.exec(a);
  if (i) {
    var o = parseInt("" + i[1], 10),
      n = parseInt("" + i[2], 10) / 100,
      h = parseInt("" + i[3], 10) / 100,
      v = "rgb(" + yc(o, n, h) + ")",
      g = qs.exec(v);
    if (!g) throw new S4(4, a, v);
    return {
      red: parseInt("" + g[1], 10),
      green: parseInt("" + g[2], 10),
      blue: parseInt("" + g[3], 10)
    };
  }
  var s = t21.exec(a.substring(0, 50));
  if (s) {
    var d = parseInt("" + s[1], 10),
      z = parseInt("" + s[2], 10) / 100,
      u = parseInt("" + s[3], 10) / 100,
      f = "rgb(" + yc(d, z, u) + ")",
      p = qs.exec(f);
    if (!p) throw new S4(4, a, f);
    return {
      red: parseInt("" + p[1], 10),
      green: parseInt("" + p[2], 10),
      blue: parseInt("" + p[3], 10),
      alpha: parseFloat("" + s[4])
    };
  }
  throw new S4(5);
}
function a21(t) {
  var a = t.red / 255,
    c = t.green / 255,
    r = t.blue / 255,
    e = Math.max(a, c, r),
    l = Math.min(a, c, r),
    i = (e + l) / 2;
  if (e === l) return t.alpha !== void 0 ? {
    hue: 0,
    saturation: 0,
    lightness: i,
    alpha: t.alpha
  } : {
    hue: 0,
    saturation: 0,
    lightness: i
  };
  var o,
    n = e - l,
    h = i > .5 ? n / (2 - e - l) : n / (e + l);
  switch (e) {
    case a:
      o = (c - r) / n + (c < r ? 6 : 0);
      break;
    case c:
      o = (r - a) / n + 2;
      break;
    default:
      o = (a - c) / n + 4;
      break;
  }
  return o *= 60, t.alpha !== void 0 ? {
    hue: o,
    saturation: h,
    lightness: i,
    alpha: t.alpha
  } : {
    hue: o,
    saturation: h,
    lightness: i
  };
}
function Qs(t) {
  return a21($s(t));
}
function Z8(t) {
  var a = t.toString(16);
  return a.length === 1 ? "0" + a : a;
}
function Ns(t) {
  return Z8(Math.round(t * 255));
}
function c21(t, a, c) {
  return Us("#" + Ns(t) + Ns(a) + Ns(c));
}
function Ei(t, a, c) {
  return yc(t, a, c, c21);
}
function r21(t, a, c) {
  if (typeof t == "number" && typeof a == "number" && typeof c == "number") return Ei(t, a, c);
  if (typeof t == "object" && a === void 0 && c === void 0) return Ei(t.hue, t.saturation, t.lightness);
  throw new S4(1);
}
function e21(t, a, c, r) {
  if (typeof t == "number" && typeof a == "number" && typeof c == "number" && typeof r == "number") return r >= 1 ? Ei(t, a, c) : "rgba(" + yc(t, a, c) + "," + r + ")";
  if (typeof t == "object" && a === void 0 && c === void 0 && r === void 0) return t.alpha >= 1 ? Ei(t.hue, t.saturation, t.lightness) : "rgba(" + yc(t.hue, t.saturation, t.lightness) + "," + t.alpha + ")";
  throw new S4(2);
}
function Ks(t, a, c) {
  if (typeof t == "number" && typeof a == "number" && typeof c == "number") return Us("#" + Z8(t) + Z8(a) + Z8(c));
  if (typeof t == "object" && a === void 0 && c === void 0) return Us("#" + Z8(t.red) + Z8(t.green) + Z8(t.blue));
  throw new S4(6);
}
function jy(t, a, c, r) {
  if (typeof t == "string" && typeof a == "number") {
    var e = $s(t);
    return "rgba(" + e.red + "," + e.green + "," + e.blue + "," + a + ")";
  } else {
    if (typeof t == "number" && typeof a == "number" && typeof c == "number" && typeof r == "number") return r >= 1 ? Ks(t, a, c) : "rgba(" + t + "," + a + "," + c + "," + r + ")";
    if (typeof t == "object" && a === void 0 && c === void 0 && r === void 0) return t.alpha >= 1 ? Ks(t.red, t.green, t.blue) : "rgba(" + t.red + "," + t.green + "," + t.blue + "," + t.alpha + ")";
  }
  throw new S4(7);
}
function Xs(t) {
  if (typeof t != "object") throw new S4(8);
  if (i21(t)) return jy(t);
  if (l21(t)) return Ks(t);
  if (n21(t)) return e21(t);
  if (o21(t)) return r21(t);
  throw new S4(8);
}
function qy(t, a, c) {
  return function () {
    var e = c.concat(Array.prototype.slice.call(arguments));
    return e.length >= a ? t.apply(this, e) : qy(t, a, e);
  };
}
function Di(t) {
  return qy(t, t.length, []);
}
function Wi(t, a, c) {
  return Math.max(t, Math.min(a, c));
}
function h21(t, a) {
  if (a === "transparent") return a;
  var c = Qs(a);
  return Xs(m5({}, c, {
    lightness: Wi(0, 1, c.lightness - parseFloat(t))
  }));
}
function v21(t, a) {
  if (a === "transparent") return a;
  var c = Qs(a);
  return Xs(m5({}, c, {
    lightness: Wi(0, 1, c.lightness + parseFloat(t))
  }));
}
function g21(t, a) {
  if (a === "transparent") return a;
  var c = Qs(a);
  return Xs(m5({}, c, {
    saturation: Wi(0, 1, c.saturation + parseFloat(t))
  }));
}
function d21(t, a) {
  if (a === "transparent") return a;
  var c = $s(a),
    r = typeof c.alpha == "number" ? c.alpha : 1,
    e = m5({}, c, {
      alpha: Wi(0, 1, +(r * 100 - parseFloat(t) * 100).toFixed(2) / 100)
    });
  return jy(e);
}
function ji(t) {
  for (var a = arguments.length, c = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++) c[r - 1] = arguments[r];
  return s21.indexOf(t) >= 0 && t ? m5({}, Wy.apply(void 0, [""].concat(c)), {
    position: t
  }) : Wy.apply(void 0, ["", t].concat(c));
}
var S4,
  _11,
  _y,
  K11,
  $11,
  Q11,
  X11,
  qs,
  Y11,
  J11,
  t21,
  Us,
  l21,
  i21,
  o21,
  n21,
  A6,
  R6,
  _i,
  N2,
  s21,
  R0 = x(() => {
    Fy();
    Iy();
    Py();
    Ey();
    Dy();
    S4 = function (t) {
      Ds(a, t);
      function a(c) {
        var r;
        if (!0) r = t.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + c + " for more information.") || this;else for (var e, l, i; i < e; i++);
        return Es(r);
      }
      return a;
    }(Bc(Error));
    _11 = ["Top", "Right", "Bottom", "Left"];
    _y = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "639",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    K11 = /^#[a-fA-F0-9]{6}$/, $11 = /^#[a-fA-F0-9]{8}$/, Q11 = /^#[a-fA-F0-9]{3}$/, X11 = /^#[a-fA-F0-9]{4}$/, qs = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i, Y11 = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i, J11 = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, t21 = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
    Us = function (a) {
      return a.length === 7 && a[1] === a[2] && a[3] === a[4] && a[5] === a[6] ? "#" + a[1] + a[3] + a[5] : a;
    };
    l21 = function (a) {
      return typeof a.red == "number" && typeof a.green == "number" && typeof a.blue == "number" && (typeof a.alpha != "number" || typeof a.alpha == "undefined");
    }, i21 = function (a) {
      return typeof a.red == "number" && typeof a.green == "number" && typeof a.blue == "number" && typeof a.alpha == "number";
    }, o21 = function (a) {
      return typeof a.hue == "number" && typeof a.saturation == "number" && typeof a.lightness == "number" && (typeof a.alpha != "number" || typeof a.alpha == "undefined");
    }, n21 = function (a) {
      return typeof a.hue == "number" && typeof a.saturation == "number" && typeof a.lightness == "number" && typeof a.alpha == "number";
    };
    A6 = Di(h21);
    R6 = Di(v21);
    _i = Di(g21);
    N2 = Di(d21), s21 = ["absolute", "fixed", "relative", "static", "sticky"];
  });
function z21(t, a, c) {
  return a in t ? Object.defineProperty(t, a, {
    value: c,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[a] = c, t;
}
function Ny(t, a) {
  var c = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    a && (r = r.filter(function (e) {
      return Object.getOwnPropertyDescriptor(t, e).enumerable;
    })), c.push.apply(c, r);
  }
  return c;
}
function J3(t) {
  for (var a = 1; a < arguments.length; a++) {
    var c = arguments[a] != null ? arguments[a] : {};
    a % 2 ? Ny(Object(c), !0).forEach(function (r) {
      z21(t, r, c[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(c)) : Ny(Object(c)).forEach(function (r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(c, r));
    });
  }
  return t;
}
function k4(t, a) {
  if (t == null) return {};
  var c = {},
    r = Object.keys(t),
    e,
    l;
  for (l = 0; l < r.length; l++) e = r[l], !(a.indexOf(e) >= 0) && (c[e] = t[e]);
  return c;
}
var B9 = x(() => {});
var Uy,
  qi,
  Ys = x(() => {
    Uy = I(G()), qi = (0, Uy.createContext)({});
  });
function u21(t, a, c) {
  return a in t ? Object.defineProperty(t, a, {
    value: c,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[a] = c, t;
}
function Ky(t, a) {
  var c = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    a && (r = r.filter(function (e) {
      return Object.getOwnPropertyDescriptor(t, e).enumerable;
    })), c.push.apply(c, r);
  }
  return c;
}
function b6(t) {
  for (var a = 1; a < arguments.length; a++) {
    var c = arguments[a] != null ? arguments[a] : {};
    a % 2 ? Ky(Object(c), !0).forEach(function (r) {
      u21(t, r, c[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(c)) : Ky(Object(c)).forEach(function (r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(c, r));
    });
  }
  return t;
}
function Sc(t, a) {
  if (t == null) return {};
  var c = {},
    r = Object.keys(t),
    e,
    l;
  for (l = 0; l < r.length; l++) e = r[l], !(a.indexOf(e) >= 0) && (c[e] = t[e]);
  return c;
}
function p21(t, a) {
  if (t) {
    if (typeof t == "string") return $y(t, a);
    var c = Object.prototype.toString.call(t).slice(8, -1);
    if (c === "Object" && t.constructor && (c = t.constructor.name), c === "Map" || c === "Set") return Array.from(t);
    if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return $y(t, a);
  }
}
function $y(t, a) {
  (a == null || a > t.length) && (a = t.length);
  for (var c = 0, r = new Array(a); c < a; c++) r[c] = t[c];
  return r;
}
function Js(t, a) {
  var c;
  if (typeof Symbol == "undefined" || t[Symbol.iterator] == null) {
    if (Array.isArray(t) || (c = p21(t)) || a && t && typeof t.length == "number") {
      c && (t = c);
      var r = 0;
      return function () {
        return r >= t.length ? {
          done: !0
        } : {
          done: !1,
          value: t[r++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  return c = t[Symbol.iterator](), c.next.bind(c);
}
var kc = x(() => {});
function m21(t) {
  return typeof t == "function";
}
var Ni,
  Qy,
  Xy = x(() => {
    Ni = I(G());
    Ys();
    kc();
    Qy = function (a, c, r) {
      r === void 0 && (r = c.children);
      var e = (0, Ni.useContext)(qi);
      if (e.useCreateElement) return e.useCreateElement(a, c, r);
      if (typeof a == "string" && m21(r)) {
        var l = c.children,
          i = Sc(c, ["children"]);
        return r(i);
      }
      return (0, Ni.createElement)(a, c, r);
    };
  });
function f21(t, a, c) {
  return a in t ? Object.defineProperty(t, a, {
    value: c,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[a] = c, t;
}
function Yy(t, a) {
  var c = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    a && (r = r.filter(function (e) {
      return Object.getOwnPropertyDescriptor(t, e).enumerable;
    })), c.push.apply(c, r);
  }
  return c;
}
function F6(t) {
  for (var a = 1; a < arguments.length; a++) {
    var c = arguments[a] != null ? arguments[a] : {};
    a % 2 ? Yy(Object(c), !0).forEach(function (r) {
      f21(t, r, c[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(c)) : Yy(Object(c)).forEach(function (r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(c, r));
    });
  }
  return t;
}
function Jy(t, a) {
  if (t == null) return {};
  var c = {},
    r = Object.keys(t),
    e,
    l;
  for (l = 0; l < r.length; l++) e = r[l], !(a.indexOf(e) >= 0) && (c[e] = t[e]);
  return c;
}
var tz = x(() => {});
function tS(t) {
  return typeof t == "object" && t != null;
}
var aS = x(() => {});
function Ac(t) {
  var a;
  if (!tS(t)) return !1;
  var c = Object.getPrototypeOf(t);
  return c == null ? !0 : ((a = c.constructor) === null || a === void 0 ? void 0 : a.toString()) === Object.toString();
}
var az = x(() => {
  aS();
});
function cS(t, a) {
  for (var c = Object.keys(t), r = {}, e = {}, l = 0, i = c; l < i.length; l++) {
    var o = i[l];
    a.indexOf(o) >= 0 ? r[o] = t[o] : e[o] = t[o];
  }
  return [r, e];
}
function cz(t, a) {
  if (a === void 0 && (a = []), !Ac(t.state)) return cS(t, a);
  var c = cS(t, [].concat(a, ["state"])),
    r = c[0],
    e = c[1],
    l = r.state,
    i = Jy(r, ["state"]);
  return [F6(F6({}, l), i), e];
}
var rS = x(() => {
  tz();
  az();
});
function O8(t, a) {
  if (t === a) return !0;
  if (!t || !a || typeof t != "object" || typeof a != "object") return !1;
  var c = Object.keys(t),
    r = Object.keys(a),
    e = c.length;
  if (r.length !== e) return !1;
  for (var l = 0, i = c; l < i.length; l++) {
    var o = i[l];
    if (t[o] !== a[o]) return !1;
  }
  return !0;
}
var Ui = x(() => {});
function rz(t) {
  return t.name === "normalizePropsAreEqualInner" ? t : function (c, r) {
    return !Ac(c.state) || !Ac(r.state) ? t(c, r) : t(F6(F6({}, c.state), c), F6(F6({}, r.state), r));
  };
}
var eS = x(() => {
  tz();
  az();
});
function M21(t) {
  return (0, Ki.forwardRef)(t);
}
function x21(t, a) {
  return (0, Ki.memo)(t, a);
}
function A4(t) {
  var a = t.as,
    c = t.useHook,
    r = t.memo,
    e = t.propsAreEqual,
    l = e === void 0 ? c == null ? void 0 : c.unstable_propsAreEqual : e,
    i = t.keys,
    o = i === void 0 ? (c == null ? void 0 : c.__keys) || [] : i,
    n = t.useCreateElement,
    h = n === void 0 ? Qy : n,
    v = function (s, d) {
      var z = s.as,
        u = z === void 0 ? a : z,
        f = Sc(s, ["as"]);
      if (c) {
        var p,
          m = cz(f, o),
          M = m[0],
          w = m[1],
          H = c(M, b6({
            ref: d
          }, w)),
          y = H.wrapElement,
          k = Sc(H, ["wrapElement"]),
          F = ((p = u.render) === null || p === void 0 ? void 0 : p.__keys) || u.__keys,
          U = F && cz(f, F)[0],
          A = U ? b6(b6({}, k), U) : k,
          P = h(u, A);
        return y ? y(P) : P;
      }
      return h(u, b6({
        ref: d
      }, f));
    };
  return v = M21(v), r && (v = x21(v, l && rz(l))), v.__keys = o, v.unstable_propsAreEqual = rz(l || O8), v;
}
var Ki,
  y9 = x(() => {
    Ki = I(G());
    kc();
    Xy();
    rS();
    Ui();
    eS();
  });
function Qi(t, a) {
  (0, $i.useDebugValue)(t);
  var c = (0, $i.useContext)(qi);
  return c[t] != null ? c[t] : a;
}
var $i,
  ez = x(() => {
    $i = I(G());
    Ys();
  });
function iS(t, a, c) {
  a === void 0 && (a = {}), c === void 0 && (c = {});
  var r = "use" + t + "Props";
  (0, lS.useDebugValue)(r);
  var e = Qi(r);
  return e ? e(a, c) : c;
}
var lS,
  oS = x(() => {
    lS = I(G());
    ez();
  });
function hS(t, a, c) {
  a === void 0 && (a = {}), c === void 0 && (c = {});
  var r = "use" + t + "Options";
  (0, nS.useDebugValue)(r);
  var e = Qi(r);
  return e ? b6(b6({}, a), e(a, c)) : a;
}
var nS,
  vS = x(() => {
    nS = I(G());
    ez();
    kc();
  });
function gS(t) {
  return Array.isArray(t) ? t : typeof t != "undefined" ? [t] : [];
}
var dS = x(() => {});
function R4(t) {
  var a,
    c,
    r = gS(t.compose),
    e = function (n, h) {
      if (t.useOptions && (n = t.useOptions(n, h)), t.name && (n = hS(t.name, n, h)), t.compose) for (var v = Js(r), g; !(g = v()).done;) {
        var s = g.value;
        n = s.__useOptions(n, h);
      }
      return n;
    },
    l = function (n, h, v) {
      if (n === void 0 && (n = {}), h === void 0 && (h = {}), v === void 0 && (v = !1), v || (n = e(n, h)), t.useProps && (h = t.useProps(n, h)), t.name && (h = iS(t.name, n, h)), t.compose) if (t.useComposeOptions && (n = t.useComposeOptions(n, h)), t.useComposeProps) h = t.useComposeProps(n, h);else for (var g = Js(r), s; !(s = g()).done;) {
        var d = s.value;
        h = d(n, h, !0);
      }
      var z = {},
        u = h || {};
      for (var f in u) u[f] !== void 0 && (z[f] = u[f]);
      return z;
    };
  l.__useOptions = e;
  var i = r.reduce(function (o, n) {
    return o.push.apply(o, n.__keys || []), o;
  }, []);
  return l.__keys = [].concat(i, ((a = t.useState) === null || a === void 0 ? void 0 : a.__keys) || [], t.keys || []), l.unstable_propsAreEqual = t.propsAreEqual || ((c = r[0]) === null || c === void 0 ? void 0 : c.unstable_propsAreEqual) || O8, l;
}
var cp1,
  S9 = x(() => {
    cp1 = I(G());
    oS();
    kc();
    vS();
    Ui();
    dS();
  });
function sS(t, a) {
  a === void 0 && (a = null), t && (typeof t == "function" ? t(a) : t.current = a);
}
function Xi(t, a) {
  return (0, zS.useMemo)(function () {
    return t == null && a == null ? null : function (c) {
      sS(t, c), sS(a, c);
    };
  }, [t, a]);
}
var zS,
  lz = x(() => {
    zS = I(G());
  });
function k9(t) {
  if (t.tagName === "BUTTON") return !0;
  if (t.tagName === "INPUT") {
    var a = t;
    return C21.indexOf(a.type) !== -1;
  }
  return !1;
}
var C21,
  Yi = x(() => {
    C21 = ["button", "color", "file", "image", "reset", "submit"];
  });
var Ji = x(() => {});
var zp1,
  uS = x(() => {
    Ji();
    zp1 = I(G());
  });
var Mp1,
  Rc = x(() => {
    Ji();
    Mp1 = I(G());
    uS();
  });
function to(t) {
  return t ? t.ownerDocument || t : document;
}
var iz = x(() => {});
function pS(t) {
  return t && to(t).defaultView || oz;
}
var oz,
  mS = x(() => {
    iz();
    try {
      oz = window;
    } catch (t) {}
  });
function L21() {
  var t = pS();
  return !!(typeof t != "undefined" && t.document && t.document.createElement);
}
var E8,
  ao = x(() => {
    mS();
    E8 = L21();
  });
var co,
  A9,
  ro = x(() => {
    co = I(G());
    ao();
    A9 = E8 ? co.useLayoutEffect : co.useEffect;
  });
function I6(t) {
  var a = (0, fS.useRef)(t);
  return A9(function () {
    a.current = t;
  }), a;
}
var fS,
  nz = x(() => {
    fS = I(G());
    ro();
  });
function MS(t) {
  return t.target === t.currentTarget;
}
var xS = x(() => {});
function CS(t) {
  var a = to(t),
    c = a.activeElement;
  return c != null && c.nodeName ? c : null;
}
var LS = x(() => {
  iz();
});
function eo(t, a) {
  return t === a || t.contains(a);
}
var hz = x(() => {});
function HS(t) {
  var a = CS(t);
  if (!a) return !1;
  if (eo(t, a)) return !0;
  var c = a.getAttribute("aria-activedescendant");
  return c ? c === t.id ? !0 : !!t.querySelector("#" + c) : !1;
}
var VS = x(() => {
  LS();
  hz();
});
function wS(t) {
  return !eo(t.currentTarget, t.target);
}
var BS = x(() => {
  hz();
});
function bc(t) {
  return E8 ? window.navigator.userAgent.indexOf(t) !== -1 : !1;
}
var yS = x(() => {
  ao();
});
function SS(t, a) {
  return "matches" in t ? t.matches(a) : "msMatchesSelector" in t ? t.msMatchesSelector(a) : t.webkitMatchesSelector(a);
}
var kS = x(() => {});
function V21(t) {
  var a = t;
  return a.offsetWidth > 0 || a.offsetHeight > 0 || t.getClientRects().length > 0;
}
function AS(t) {
  return SS(t, H21) && V21(t);
}
var H21,
  RS = x(() => {
    kS();
    H21 = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false'])";
  });
var w21,
  Fc,
  Qp1,
  vz = x(() => {
    B9();
    y9();
    S9();
    Ui();
    w21 = ["unstable_system"], Fc = R4({
      name: "Role",
      keys: w21,
      propsAreEqual: function (a, c) {
        var r = a.unstable_system,
          e = k4(a, ["unstable_system"]),
          l = c.unstable_system,
          i = k4(c, ["unstable_system"]);
        return r !== l && !O8(r, l) ? !1 : O8(e, i);
      }
    }), Qp1 = A4({
      as: "div",
      useHook: Fc
    });
  });
function bS(t) {
  !HS(t) && AS(t) && t.focus();
}
function S21(t) {
  return t.tagName === "BUTTON" || t.tagName === "INPUT" || t.tagName === "SELECT" || t.tagName === "TEXTAREA" || t.tagName === "A";
}
function k21(t) {
  return t.tagName === "BUTTON" || t.tagName === "INPUT" || t.tagName === "SELECT" || t.tagName === "TEXTAREA";
}
function A21(t, a, c, r) {
  return t ? a && !c ? -1 : void 0 : a ? r : r || 0;
}
function gz(t, a) {
  return (0, P6.useCallback)(function (c) {
    var r;
    (r = t.current) === null || r === void 0 || r.call(t, c), !c.defaultPrevented && a && (c.stopPropagation(), c.preventDefault());
  }, [t, a]);
}
var P6,
  B21,
  y21,
  dz,
  dm1,
  FS = x(() => {
    B9();
    y9();
    S9();
    P6 = I(G());
    lz();
    Yi();
    Rc();
    nz();
    ro();
    VS();
    BS();
    yS();
    RS();
    vz();
    B21 = ["disabled", "focusable"], y21 = bc("Mac") && !bc("Chrome") && (bc("Safari") || bc("Firefox"));
    dz = R4({
      name: "Tabbable",
      compose: Fc,
      keys: B21,
      useOptions: function (a, c) {
        var r = c.disabled;
        return J3({
          disabled: r
        }, a);
      },
      useProps: function (a, c) {
        var r = c.ref,
          e = c.tabIndex,
          l = c.onClickCapture,
          i = c.onMouseDownCapture,
          o = c.onMouseDown,
          n = c.onKeyPressCapture,
          h = c.style,
          v = k4(c, ["ref", "tabIndex", "onClickCapture", "onMouseDownCapture", "onMouseDown", "onKeyPressCapture", "style"]),
          g = (0, P6.useRef)(null),
          s = I6(l),
          d = I6(i),
          z = I6(o),
          u = I6(n),
          f = !!a.disabled && !a.focusable,
          p = (0, P6.useState)(!0),
          m = p[0],
          M = p[1],
          w = (0, P6.useState)(!0),
          H = w[0],
          y = w[1],
          k = a.disabled ? J3({
            pointerEvents: "none"
          }, h) : h;
        A9(function () {
          var C = g.current;
          C && (S21(C) || M(!1), k21(C) || y(!1));
        }, []);
        var F = gz(s, a.disabled),
          U = gz(d, a.disabled),
          A = gz(u, a.disabled),
          P = (0, P6.useCallback)(function (C) {
            var E;
            (E = z.current) === null || E === void 0 || E.call(z, C);
            var a1 = C.currentTarget;
            if (!C.defaultPrevented && y21 && !wS(C) && k9(a1)) {
              var j = requestAnimationFrame(function () {
                  a1.removeEventListener("mouseup", K, !0), bS(a1);
                }),
                K = function () {
                  cancelAnimationFrame(j), bS(a1);
                };
              a1.addEventListener("mouseup", K, {
                once: !0,
                capture: !0
              });
            }
          }, []);
        return J3({
          ref: Xi(g, r),
          style: k,
          tabIndex: A21(f, m, H, e),
          disabled: f && H ? !0 : void 0,
          "aria-disabled": a.disabled ? !0 : void 0,
          onClickCapture: F,
          onMouseDownCapture: U,
          onMouseDown: P,
          onKeyPressCapture: A
        }, v);
      }
    }), dm1 = A4({
      as: "div",
      useHook: dz
    });
  });
function b21(t) {
  var a = t.currentTarget;
  return t.isTrusted ? k9(a) || a.tagName === "INPUT" || a.tagName === "TEXTAREA" || a.tagName === "A" || a.tagName === "SELECT" : !1;
}
var Ic,
  R21,
  sz,
  Lm1,
  IS = x(() => {
    B9();
    y9();
    S9();
    Ic = I(G());
    Yi();
    Rc();
    nz();
    xS();
    FS();
    R21 = ["unstable_clickOnEnter", "unstable_clickOnSpace"];
    sz = R4({
      name: "Clickable",
      compose: dz,
      keys: R21,
      useOptions: function (a) {
        var c = a.unstable_clickOnEnter,
          r = c === void 0 ? !0 : c,
          e = a.unstable_clickOnSpace,
          l = e === void 0 ? !0 : e,
          i = k4(a, ["unstable_clickOnEnter", "unstable_clickOnSpace"]);
        return J3({
          unstable_clickOnEnter: r,
          unstable_clickOnSpace: l
        }, i);
      },
      useProps: function (a, c) {
        var r = c.onKeyDown,
          e = c.onKeyUp,
          l = k4(c, ["onKeyDown", "onKeyUp"]),
          i = (0, Ic.useState)(!1),
          o = i[0],
          n = i[1],
          h = I6(r),
          v = I6(e),
          g = (0, Ic.useCallback)(function (d) {
            var z;
            if ((z = h.current) === null || z === void 0 || z.call(h, d), !d.defaultPrevented && !a.disabled && !d.metaKey && MS(d)) {
              var u = a.unstable_clickOnEnter && d.key === "Enter",
                f = a.unstable_clickOnSpace && d.key === " ";
              if (u || f) {
                if (b21(d)) return;
                d.preventDefault(), u ? d.currentTarget.click() : f && n(!0);
              }
            }
          }, [a.disabled, a.unstable_clickOnEnter, a.unstable_clickOnSpace]),
          s = (0, Ic.useCallback)(function (d) {
            var z;
            if ((z = v.current) === null || z === void 0 || z.call(v, d), !d.defaultPrevented && !a.disabled && !d.metaKey) {
              var u = a.unstable_clickOnSpace && d.key === " ";
              o && u && (n(!1), d.currentTarget.click());
            }
          }, [a.disabled, a.unstable_clickOnSpace, o]);
        return J3({
          "data-active": o || void 0,
          onKeyDown: g,
          onKeyUp: s
        }, l);
      }
    }), Lm1 = A4({
      as: "button",
      memo: !0,
      useHook: sz
    });
  });
var D8,
  F21,
  PS,
  zz,
  GS = x(() => {
    B9();
    y9();
    S9();
    D8 = I(G());
    lz();
    Yi();
    Rc();
    IS();
    F21 = [], PS = R4({
      name: "Button",
      compose: sz,
      keys: F21,
      useProps: function (a, c) {
        var r = c.ref,
          e = k4(c, ["ref"]),
          l = (0, D8.useRef)(null),
          i = (0, D8.useState)(void 0),
          o = i[0],
          n = i[1],
          h = (0, D8.useState)("button"),
          v = h[0],
          g = h[1];
        return (0, D8.useEffect)(function () {
          var s = l.current;
          s && (k9(s) || (s.tagName !== "A" && n("button"), g(void 0)));
        }, []), J3({
          ref: Xi(l, r),
          role: o,
          type: v
        }, e);
      }
    }), zz = A4({
      as: "button",
      memo: !0,
      useHook: PS
    });
  });
var I21,
  TS,
  uz,
  ZS = x(() => {
    B9();
    y9();
    S9();
    vz();
    I21 = [], TS = R4({
      name: "Group",
      compose: Fc,
      keys: I21,
      useProps: function (a, c) {
        return J3({
          role: "group"
        }, c);
      }
    }), uz = A4({
      as: "div",
      useHook: TS
    });
  });
function ES() {
  return E8 ? document.body : null;
}
function Pc(t) {
  var a = t.children,
    c = (0, G6.useContext)(a3) || ES(),
    r = (0, G6.useState)(function () {
      if (E8) {
        var l = document.createElement("div");
        return l.className = Pc.__className, l;
      }
      return null;
    }),
    e = r[0];
  return A9(function () {
    if (!(!e || !c)) return c.appendChild(e), function () {
      c.removeChild(e);
    };
  }, [e, c]), e ? (0, OS.createPortal)((0, G6.createElement)(a3.Provider, {
    value: e
  }, a), e) : null;
}
var G6,
  OS,
  a3,
  DS = x(() => {
    G6 = I(G());
    ro();
    ao();
    OS = I(B4());
    a3 = (0, G6.createContext)(ES());
    Pc.__className = "__reakit-portal";
    Pc.__selector = "." + Pc.__className;
  });
var P21,
  pz,
  Dm1,
  WS = x(() => {
    P21 = !1;
    typeof window != "undefined" && (pz = {
      get passive() {
        P21 = !0;
      }
    }, window.addEventListener("testPassive", null, pz), window.removeEventListener("testPassive", null, pz));
    Dm1 = typeof window != "undefined" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
  });
var _m1,
  qm1,
  T6 = x(() => {
    _m1 = I(G());
    Rc();
    GS();
    ZS();
    qm1 = I(B4());
    DS();
    WS();
    Ji();
  });
function z1(t) {
  let a = (0, lo.useMemo)(() => {
      let e = t;
      return {
        get current() {
          return e;
        },
        set current(l) {
          e = l, r(l);
        }
      };
    }, []),
    [c, r] = (0, lo.useState)(() => t);
  return [a, c];
}
var lo,
  P1 = x(() => {
    "use strict";

    lo = I(G());
  });
function US(t) {
  return a => G2.default.createElement(T21, null, G2.default.createElement(t, S({}, a)));
}
var G2,
  NS,
  _S,
  C1,
  Z6,
  jS,
  G21,
  qS,
  mz,
  fz,
  T21,
  G1 = x(() => {
    "use strict";

    R0();
    c1();
    c1();
    G2 = I(G()), NS = I(B4());
    T6();
    P1();
    C1 = f2(_S || (_S = V(["\n  #pointer-root & {\n    pointer-events: none;\n  }\n  #pointer-root.normal & {\n    pointer-events: auto;\n  }\n"]))), Z6 = {
      panel: {
        bg: "#282b2f",
        head: {
          title: {
            color: "#bbb"
          },
          punctuation: {
            color: "#808080"
          }
        },
        body: {
          compoudThing: {
            label: {
              get color() {
                return R6(.6, Z6.panel.bg);
              }
            }
          }
        }
      }
    }, G21 = typeof window != "undefined" ? Zi(jS || (jS = V(["\n  :host {\n    all: initial;\n    color: white;\n    font: 11px -apple-system, BlinkMacSystemFont, Segoe WPC, Segoe Editor,\n      HelveticaNeue-Light, Ubuntu, Droid Sans, sans-serif;\n  }\n\n  * {\n    padding: 0;\n    margin: 0;\n    font-size: 100%;\n    font: inherit;\n    vertical-align: baseline;\n    list-style: none;\n  }\n"]))) : {}, mz = B.div(qS || (qS = V(["\n  z-index: 51;\n  position: fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  pointer-events: none;\n"]))), fz = t => G2.default.createElement(Zs, {
      disableVendorPrefixes: !0,
      target: t.target
    }, G2.default.createElement(G2.default.Fragment, null, G2.default.createElement(G21, null), t.children));
    T21 = t => {
      let [a, c] = (0, G2.useState)(null),
        [r, e] = (0, G2.useState)(null);
      (0, G2.useLayoutEffect)(() => {
        if (!a) return;
        let {
          parentNode: o
        } = a;
        if (!o) return;
        let h = !!o.shadowRoot ? parent.shadowRoot : o.attachShadow({
          mode: "open"
        });
        e(h);
      }, [a]);
      let [l, i] = z1(void 0);
      return r ? NS.default.createPortal(G2.default.createElement(fz, {
        target: r
      }, G2.default.createElement(G2.default.Fragment, null, G2.default.createElement(mz, {
        ref: l
      }), G2.default.createElement(a3.Provider, {
        value: i
      }, t.children))), r) : G2.default.createElement("template", {
        ref: c,
        "shadow-root": "open"
      }, t.children);
    };
  });
var M5,
  Z21,
  KS,
  x5,
  $S,
  R9,
  QS,
  YS,
  io,
  XS,
  oo,
  S3,
  b4 = x(() => {
    "use strict";

    G1();
    c1();
    M5 = {
      get outlinePanel() {
        return 1;
      },
      get propsPanel() {
        return M5.outlinePanel;
      },
      get sequenceEditorPanel() {
        return this.outlinePanel - 1;
      },
      get toolbar() {
        return this.outlinePanel + 1;
      },
      get pluginPanes() {
        return this.sequenceEditorPanel - 1;
      }
    }, Z21 = Z6.panel.bg, x5 = B.span(KS || (KS = V(["\n  white-space: nowrap;\n"]))), R9 = B.span($S || ($S = V(["\n  white-space: nowrap;\n  color: ", ";\n"])), Z6.panel.head.punctuation.color), YS = B.div(QS || (QS = V(["\n  background: ", ";\n  flex-grow: 1;\n  overflow-y: scroll;\n  padding: 0;\n"])), Z21), io = 18, oo = B.div(XS || (XS = V(["\n  height: ", "px;\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n  padding: 0 10px;\n  position: relative;\n  color: #adadadb3;\n  border-bottom: 1px solid rgb(0 0 0 / 13%);\n  background-color: #25272b;\n  font-size: 10px;\n  font-weight: 500;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n"])), io), S3 = 100;
  });
var O21,
  h0,
  W8 = x(() => {
    "use strict";

    O21 = () => {}, h0 = O21;
  });
function E21(t) {
  return Mz.createElement("svg", S({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), Mz.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M1.775 2.781a.5.5 0 01.5.5v1.7H4.67c.108-.957.92-1.7 1.905-1.7h6.608a1.917 1.917 0 110 3.834H6.574c-.78 0-1.452-.466-1.751-1.135H2.275v5.03h2.39a2.032 2.032 0 012.023-1.854h6.38a2.031 2.031 0 110 4.063h-6.38c-.83 0-1.543-.497-1.858-1.21H1.775a.5.5 0 01-.5-.5V3.281a.5.5 0 01.5-.5zm4.799 1.5h6.608a.917.917 0 110 1.834H6.574a.917.917 0 110-1.834zm.114 5.875h6.38a1.031 1.031 0 110 2.063h-6.38a1.032 1.032 0 110-2.063z",
    fill: "currentColor"
  }));
}
var Mz,
  Gc,
  JS = x(() => {
    "use strict";

    Mz = I(G());
    Gc = E21;
  });
function D21(t) {
  return xz.createElement("svg", S({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), xz.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M8 10.5L4 6.654 5.2 5.5 8 8.385 10.8 5.5 12 6.654 8 10.5z",
    fill: "currentColor"
  }));
}
var xz,
  Cz,
  tk = x(() => {
    "use strict";

    xz = I(G());
    Cz = D21;
  });
function W21(t) {
  return Lz.createElement("svg", S({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), Lz.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3.5 3c-1.072 0-1.969.904-1.969 1.969 0 1 .929 1.968 1.969 1.968h9A1.969 1.969 0 1012.5 3h-9zm9 1H5.531v1.938H12.5A.969.969 0 0012.5 4zM3.5 9.14a1.969 1.969 0 000 3.938h9a1.969 1.969 0 100-3.937h-9zm9 1H8.406v1.938H12.5a.969.969 0 100-1.937z",
    fill: "currentColor"
  }));
}
var Lz,
  Hz,
  ak = x(() => {
    "use strict";

    Lz = I(G());
    Hz = W21;
  });
function _21(t) {
  return Vz.createElement("svg", S({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), Vz.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M.166 7.994a2.26 2.26 0 114.518 0 2.26 2.26 0 01-4.518 0zM2.425 6.91a1.085 1.085 0 100 2.17 1.085 1.085 0 000-2.17zM5.74 7.994a2.26 2.26 0 114.519 0 2.26 2.26 0 01-4.519 0zM8 6.91a1.085 1.085 0 100 2.17 1.085 1.085 0 000-2.17zM13.575 5.735a2.26 2.26 0 100 4.519 2.26 2.26 0 000-4.52zm-1.086 2.26a1.085 1.085 0 112.171 0 1.085 1.085 0 01-2.17 0z",
    fill: "currentColor"
  }));
}
var Vz,
  wz,
  ck = x(() => {
    "use strict";

    Vz = I(G());
    wz = _21;
  });
function j21(t) {
  return Bz.createElement("svg", S({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), Bz.createElement("path", {
    d: "M8.339 4.5l-2.055.644 4.451 1.393v2.748l-2.966.928-2.504-.783V6.738l2.42.758 2.055-.644-4.458-1.395L4 5.858v4.463L7.768 11.5 12 10.175V5.646L8.339 4.5z",
    fill: "currentColor"
  }));
}
var Bz,
  Tc,
  rk = x(() => {
    "use strict";

    Bz = I(G());
    Tc = j21;
  });
function q21(t) {
  return yz.createElement("svg", S({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), yz.createElement("path", {
    d: "M8 1.57c-.416 0-.752.36-.752.804v.482c-1.715.372-3.006 1.994-3.006 3.938v.473c0 1.18-.407 2.32-1.14 3.205l-.173.208a.85.85 0 00-.125.864.75.75 0 00.686.475h9.019a.752.752 0 00.686-.475.845.845 0 00-.125-.864l-.174-.208a5.026 5.026 0 01-1.139-3.205v-.473c0-1.944-1.291-3.566-3.006-3.938v-.482c0-.445-.336-.804-.752-.804zm1.063 12.39c.282-.301.44-.71.44-1.138H6.496c0 .428.158.837.44 1.138.281.302.664.47 1.063.47.4 0 .783-.168 1.064-.47z",
    fill: "currentColor"
  }));
}
var yz,
  Zc,
  ek = x(() => {
    "use strict";

    yz = I(G());
    Zc = q21;
  });
function N21(t) {
  return Sz.createElement("svg", S({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), Sz.createElement("path", {
    d: "M6.8 11.6a.6.6 0 00.6-.6V7.4a.6.6 0 00-1.2 0V11a.6.6 0 00.6.6zm6-7.2h-2.4v-.6A1.8 1.8 0 008.6 2H7.4a1.8 1.8 0 00-1.8 1.8v.6H3.2a.6.6 0 100 1.2h.6v6.6A1.8 1.8 0 005.6 14h4.8a1.8 1.8 0 001.8-1.8V5.6h.6a.6.6 0 100-1.2zm-6-.6a.6.6 0 01.6-.6h1.2a.6.6 0 01.6.6v.6H6.8v-.6zm4.2 8.4a.6.6 0 01-.6.6H5.6a.6.6 0 01-.6-.6V5.6h6v6.6zm-1.8-.6a.6.6 0 00.6-.6V7.4a.6.6 0 00-1.2 0V11a.6.6 0 00.6.6z",
    fill: "currentColor"
  }));
}
var Sz,
  Oc,
  lk = x(() => {
    "use strict";

    Sz = I(G());
    Oc = N21;
  });
var b9 = x(() => {
  "use strict";

  JS();
  tk();
  ak();
  ck();
  rk();
  ek();
  lk();
});
var F4,
  ik,
  kz,
  ok,
  U21,
  nk,
  K21,
  hk,
  $21,
  vk,
  Q21,
  gk,
  X21,
  dk,
  Y21,
  sk,
  J21,
  t01,
  O6,
  Ec = x(() => {
    "use strict";

    F4 = I(G());
    c1();
    W8();
    G1();
    b9();
    kz = B.li(ik || (ik = V(["\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  display: flex;\n  justify-content: flex-start;\n  flex-direction: column;\n  align-items: flex-start;\n"]))), U21 = B.div(ok || (ok = V([""]))), K21 = B(U21)(nk || (nk = V(["\n  position: relative;\n  margin-top: 2px;\n  margin-bottom: 2px;\n  margin-left: calc(4px + var(--depth) * 16px);\n  padding-left: 4px;\n  padding-right: 8px;\n  gap: 4px;\n  height: 21px;\n  line-height: 0;\n  box-sizing: border-box;\n  display: flex;\n  flex-wrap: nowrap;\n  align-items: center;\n  pointer-events: none;\n  white-space: nowrap;\n\n  border-radius: 2px;\n  box-shadow: 0 3px 4px -1px rgba(0, 0, 0, 0.48);\n\n  color: rgba(255, 255, 255, 0.9);\n  background: rgba(40, 43, 47, 0.65);\n  backdrop-filter: blur(14px);\n  border-bottom: 1px solid rgba(255, 255, 255, 0.08);\n\n  &.descendant-is-selected {\n    background: rgba(29, 53, 59, 0.7);\n  }\n\n  ", ";\n  &:not(.not-selectable):not(.selected):hover {\n    background: rgba(59, 63, 69, 0.9);\n\n    border-bottom: 1px solid rgba(255, 255, 255, 0.24);\n  }\n\n  &:not(.not-selectable):not(.selected):active {\n    background: rgba(82, 88, 96, 0.9);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.24);\n  }\n\n  &.selected {\n    background: rgba(30, 88, 102, 0.7);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.08);\n  }\n\n  @supports not (backdrop-filter: blur()) {\n    background: rgba(40, 43, 47, 0.95);\n  }\n"])), C1), $21 = f2(hk || (hk = V(["\n  font-weight: 500;\n  font-size: 11px;\n  & {\n  }\n"]))), Q21 = B.span(vk || (vk = V(["\n  ", ";\n\n  ", ";\n  position: relative;\n  // Compensate for border bottom\n  top: 0.5px;\n  display: flex;\n  height: 20px;\n  align-items: center;\n  box-sizing: border-box;\n"])), $21, C1), X21 = B.div(gk || (gk = V(["\n  font-weight: 500;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  opacity: 0.99;\n"]))), Y21 = B.span(dk || (dk = V(["\n  font-size: 9px;\n  position: relative;\n  display: block;\n  transition: transform 0.1s ease-out;\n\n  &:hover {\n    transform: rotate(-20deg);\n  }\n\n  ", ".collapsed & {\n    transform: rotate(-90deg);\n\n    &:hover {\n      transform: rotate(-70deg);\n    }\n  }\n"])), kz), J21 = B.ul(sk || (sk = V(["\n  margin: 0;\n  padding: 0;\n  list-style: none;\n\n  ", ".collapsed & {\n    display: none;\n  }\n"])), kz), t01 = ({
      label: t,
      children: a,
      depth: c,
      select: r,
      selectionStatus: e,
      labelDecoration: l,
      collapsed: i = !1,
      setIsCollapsed: o
    }) => {
      let n = a !== void 0;
      return F4.default.createElement(kz, {
        style: {
          "--depth": c
        },
        className: i ? "collapsed" : ""
      }, F4.default.createElement(K21, {
        className: e,
        onClick: r != null ? r : h0,
        "data-header": !0
      }, F4.default.createElement(X21, null, n ? F4.default.createElement(Y21, {
        onClick: h => {
          h.stopPropagation(), h.preventDefault(), o == null || o(!i);
        }
      }, F4.default.createElement(Cz, null)) : F4.default.createElement(Tc, null)), F4.default.createElement(Q21, null, F4.default.createElement("span", null, t)), l), n && F4.default.createElement(J21, null, a));
    }, O6 = t01;
  });
function c01(t) {
  return Object.keys(t);
}
function zk(t) {
  return Object.keys((0, I4.val)(t.sheetTemplatesP));
}
function uk() {
  let a = x3(c3().filter(c => H7(c) || c0(c)).map(c => c0(c) ? c.sheet : c))[0];
  if (a) return a.getSequence();
}
var I4,
  c3,
  a01,
  C5 = x(() => {
    "use strict";

    I4 = require("@theatre/dataverse");
    N5();
    H2();
    f1();
    c3 = () => {
      var c;
      let t = (0, I4.val)(T().projectsP),
        a = ((c = (0, I4.val)(T().atomP.historic.panels.outlinePanel.selection)) != null ? c : []).map(r => {
          let e = t[r.projectId];
          if (!e) return;
          if (r.type === "Project") return e;
          if (!(0, I4.val)(e.sheetTemplatesP[r.sheetId])) return;
          let i = a01(e, r.sheetId);
          if (!i) return;
          if (r.type === "Sheet") return i;
          let o = (0, I4.val)(i.objectsP[r.objectKey]);
          if (o) return o;
        });
      return x3(a.filter(r => typeof r != "undefined"));
    }, a01 = (t, a) => {
      let c = T().atomP.historic.projects.stateByProjectId[t.address.projectId],
        r = (0, I4.val)(c.stateBySheetId[a].selectedInstanceId),
        e = (0, I4.val)(t.sheetTemplatesP[a]);
      if (e) {
        if (r) return (0, I4.val)(e.instancesP[r]);
        {
          let l = (0, I4.val)(e.instancesP);
          return l[c01(l)[0]];
        }
      }
    };
  });
var pk,
  mk,
  fk = x(() => {
    "use strict";

    f1();
    pk = I(G());
    Ec();
    M1();
    C5();
    mk = ({
      sheetObject: t,
      depth: a,
      overrideLabel: c
    }) => {
      let r = () => {
          T().transaction(({
            stateEditors: l
          }) => {
            l.studio.historic.panels.outline.selection.set([t]);
          });
        },
        e = v1(() => c3(), []);
      return pk.default.createElement(O6, {
        select: r,
        label: c != null ? c : t.address.objectKey,
        depth: a,
        selectionStatus: e.includes(t) ? "selected" : "not-selected"
      });
    };
  });
function F9(t) {
  var l;
  let a = t.type === "namespace" ? "namespace:".concat(t.sheet.address.sheetId, ":").concat(t.path.join("/")) : t.type === "Theatre_Project" ? "project" : t.type === "Theatre_Sheet" ? "sheetInstance:".concat(t.address.sheetId, ":").concat(t.address.sheetInstanceId) : "unknown",
    c = t.type === "namespace" ? t.sheet.address.projectId : t.address.projectId,
    r = (l = s1(T().atomP.ahistoric.projects.stateByProjectId[c].collapsedItemsInOutline[a])) != null ? l : !1,
    e = (0, Mk.useCallback)(i => {
      T().transaction(({
        stateEditors: o
      }) => {
        o.studio.ahistoric.projects.stateByProjectId.collapsedItemsInOutline.set({
          projectId: c,
          isCollapsed: i,
          itemKey: a
        });
      });
    }, [a]);
  return {
    collapsed: r,
    setCollapsed: e
  };
}
var Mk,
  no = x(() => {
    "use strict";

    Mk = I(G());
    f1();
    M1();
  });
function Hk(t) {
  return P4.default.createElement(P4.default.Fragment, null, [...t.namespace.entries()].map(([a, {
    object: c,
    nested: r
  }]) => P4.default.createElement(e01, {
    key: a,
    label: a,
    object: c,
    nested: r,
    visualIndentation: t.visualIndentation,
    path: t.path,
    sheet: t.sheet
  })));
}
function e01(t) {
  let {
      nested: a,
      label: c,
      object: r,
      sheet: e
    } = t,
    {
      collapsed: l,
      setCollapsed: i
    } = F9({
      type: "namespace",
      sheet: e,
      path: [...t.path, c]
    }),
    o = a && P4.default.createElement(Hk, {
      namespace: a,
      path: [...t.path, c],
      key: "namespaceTree(" + c + ")",
      visualIndentation: t.visualIndentation + 1,
      sheet: e
    }),
    n = r && P4.default.createElement(mk, {
      depth: t.visualIndentation,
      key: "objectPath(" + r.address.objectKey + ")",
      sheetObject: r,
      overrideLabel: c
    });
  return P4.default.createElement(P4.default.Fragment, {
    key: "".concat(c, " - ").concat(t.visualIndentation)
  }, n, o && P4.default.createElement(O6, {
    selectionStatus: "not-selectable",
    label: c,
    key: "baseItem(".concat(c, ")"),
    depth: t.visualIndentation,
    children: o,
    collapsed: l,
    setIsCollapsed: i
  }));
}
function wk(t, a, c = l01(a)) {
  let [r, ...e] = c,
    l = t.get(r);
  l || (l = {
    nested: void 0,
    object: void 0,
    path: [...c]
  }, t.set(r, l)), e.length === 0 ? (console.assert(!l.object, "expect not to have existing object with same name", {
    existing: l,
    object: a
  }), l.object = a) : (l.nested || (l.nested = new Map()), wk(l.nested, a, e));
}
function l01(t) {
  let a = xk.get(t);
  return a || (a = t.address.objectKey.split(i01), console.assert(a.length > 0, "expected not empty"), xk.set(t, a)), a;
}
var Lk,
  P4,
  Ck,
  cM1,
  r01,
  Vk,
  i01,
  xk,
  Bk = x(() => {
    "use strict";

    M1();
    Lk = require("@theatre/dataverse"), P4 = I(G());
    c1();
    fk();
    Ec();
    no();
    cM1 = B.li(Ck || (Ck = V(["\n  color: ", ";\n"])), t => t.isSelected ? "white" : "hsl(1, 1%, 80%)"), r01 = ({
      sheet: t,
      depth: a
    }) => v1(() => {
      let c = (0, Lk.val)(t.objectsP),
        r = Object.values(c).filter(l => l != null),
        e = new Map();
      return r.forEach(l => {
        wk(e, l);
      }), P4.default.createElement(Hk, {
        namespace: e,
        visualIndentation: a,
        path: [],
        sheet: t
      });
    }, [t, a]);
    Vk = r01;
    i01 = /\s*\/\s*/g, xk = new WeakMap();
  });
var _8,
  yk,
  o01,
  Sk,
  dM1,
  kk,
  n01,
  Ak,
  Rk = x(() => {
    "use strict";

    f1();
    C5();
    M1();
    _8 = I(G());
    c1();
    Bk();
    Ec();
    no();
    o01 = B.div(yk || (yk = V(["\n  display: flex;\n"]))), dM1 = B.li(Sk || (Sk = V(["\n  color: ", ";\n"])), t => t.isSelected ? "white" : "hsl(1, 1%, 80%)"), n01 = B.div(kk || (kk = V([""]))), Ak = ({
      sheet: t,
      depth: a
    }) => {
      let {
          collapsed: c,
          setCollapsed: r
        } = F9(t),
        e = (0, _8.useCallback)(() => {
          T().transaction(({
            stateEditors: l
          }) => {
            l.studio.historic.panels.outline.selection.set([t]);
          });
        }, [t]);
      return v1(() => {
        let l = c3();
        return _8.default.createElement(O6, {
          depth: a,
          select: e,
          setIsCollapsed: r,
          collapsed: c,
          selectionStatus: l.some(i => i === t) ? "selected" : l.some(i => i.type === "Theatre_SheetObject" && i.sheet === t) ? "descendant-is-selected" : "not-selected",
          label: _8.default.createElement(o01, null, t.address.sheetId, ": ", t.address.sheetInstanceId)
        }, _8.default.createElement(n01, null, _8.default.createElement(Vk, {
          depth: a + 1,
          sheet: t,
          key: "objectList" + t.address.sheetInstanceId
        })));
      }, [a, c]);
    };
  });
var Az,
  I9,
  bk,
  fM1,
  Fk,
  MM1,
  Ik,
  xM1,
  Pk,
  Gk = x(() => {
    "use strict";

    M1();
    Az = require("@theatre/dataverse"), I9 = I(G());
    c1();
    Rk();
    fM1 = B.div(bk || (bk = V(["\n  display: flex;\n"]))), MM1 = B.li(Fk || (Fk = V(["\n  color: ", ";\n"])), t => t.isSelected ? "white" : "hsl(1, 1%, 80%)"), xM1 = B.div(Ik || (Ik = V([""]))), Pk = ({
      sheetId: t,
      depth: a,
      project: c
    }) => v1(() => {
      let r = (0, Az.val)(c.sheetTemplatesP[t]);
      if (!r) return I9.default.createElement(I9.default.Fragment, null);
      let e = (0, Az.val)(r.instancesP);
      return I9.default.createElement(I9.default.Fragment, null, Object.entries(e).map(([l, i]) => I9.default.createElement(Ak, {
        key: i.address.sheetInstanceId,
        sheet: i,
        depth: a
      })));
    }, [a, t, c]);
  });
var ho,
  h01,
  Tk,
  Zk = x(() => {
    "use strict";

    C5();
    M1();
    ho = I(G());
    Gk();
    h01 = ({
      project: t,
      depth: a
    }) => v1(() => {
      if (!t) return null;
      let c = zk(t);
      return ho.default.createElement(ho.default.Fragment, null, c.map(r => ho.default.createElement(Pk, {
        depth: a,
        sheetId: r,
        key: "sheet-".concat(r),
        project: t
      })));
    }, [t, a]), Tk = h01;
  });
var P9,
  Ek,
  Ok,
  v01,
  g01,
  Dk,
  Wk = x(() => {
    "use strict";

    P9 = I(G());
    Ec();
    Zk();
    f1();
    M1();
    C5();
    Ek = require("@theatre/dataverse");
    c1();
    no();
    v01 = B.div(Ok || (Ok = V(["\n  color: #ff6363;\n  margin-left: 11px;\n  background: #4c282d;\n  padding: 2px 8px;\n  border-radius: 2px;\n  font-size: 10px;\n  box-shadow: 0 2px 8px -4px black;\n"]))), g01 = ({
      depth: t,
      project: a
    }) => {
      let c = v1(() => c3(), []),
        r = v1(() => {
          let o = a.address.projectId,
            n = (0, Ek.val)(T().atomP.ephemeral.coreByProject[o].loadingState);
          return (n == null ? void 0 : n.type) === "browserStateIsNotBasedOnDiskState";
        }, [a]),
        e = (0, P9.useCallback)(() => {
          T().transaction(({
            stateEditors: o
          }) => {
            o.studio.historic.panels.outline.selection.set([a]);
          });
        }, [a]),
        {
          collapsed: l,
          setCollapsed: i
        } = F9(a);
      return P9.default.createElement(O6, {
        depth: t,
        label: a.address.projectId,
        setIsCollapsed: i,
        collapsed: l,
        labelDecoration: r ? P9.default.createElement(v01, null, "Has Conflicts") : null,
        children: P9.default.createElement(Tk, {
          project: a,
          depth: t + 1
        }),
        selectionStatus: c.includes(a) ? "selected" : c.some(o => o.address.projectId === a.address.projectId) ? "descendant-is-selected" : "not-selected",
        select: e
      });
    }, Dk = g01;
  });
var jk,
  Rz,
  _k,
  d01,
  s01,
  qk,
  Nk = x(() => {
    "use strict";

    jk = require("@theatre/dataverse");
    M1();
    f1();
    Rz = I(G());
    c1();
    Wk();
    d01 = B.ul(_k || (_k = V(["\n  list-style: none;\n  margin: 0;\n  padding: 0;\n  padding-right: 4px;\n"]))), s01 = t => v1(() => {
      let a = (0, jk.val)(T().projectsP);
      return Rz.default.createElement(d01, null, Object.keys(a).map(c => {
        let r = a[c];
        return Rz.default.createElement(Dk, {
          depth: 0,
          project: r,
          key: "projectListItem-".concat(c)
        });
      }));
    }, []), qk = s01;
  });
function Dc(t) {
  let [a, c] = (0, vo.useState)(!1);
  return (0, vo.useEffect)(() => {
    let r = l => {
      let i = a ? 200 : 50,
        o = 56,
        n = t === "left" ? l.x < i : l.x > window.innerWidth - i;
      n && (n = l.y > o), c(!!n);
    };
    document.addEventListener("mousemove", r);
    let e = () => {
      c(!1);
    };
    return document.addEventListener("mouseleave", e), () => {
      document.removeEventListener("mousemove", r), document.removeEventListener("mouseleave", e);
    };
  }, [a]), a;
}
var vo,
  bz = x(() => {
    "use strict";

    vo = I(G());
  });
var j8,
  E6,
  Uk,
  Kk,
  z01,
  u01,
  $k,
  Fz,
  go,
  p01,
  Qk = x(() => {
    "use strict";

    j8 = I(G());
    c1();
    b4();
    Nk();
    M1();
    f1();
    bz();
    E6 = require("@theatre/dataverse");
    G1();
    Uk = "44px", z01 = B.div(Kk || (Kk = V(["\n  ", ";\n  background-color: transparent;\n  position: absolute;\n  left: 8px;\n  z-index: ", ";\n\n  top: calc(", " + 8px);\n  height: fit-content;\n  max-height: calc(100% - ", ");\n  overflow-y: scroll;\n  overflow-x: hidden;\n  padding: 0;\n  user-select: none;\n\n  &::-webkit-scrollbar {\n    display: none;\n  }\n\n  scrollbar-width: none;\n\n  display: ", ";\n\n  &:hover {\n    display: block;\n  }\n\n  // Create a small buffer on the bottom to aid selecting the bottom item in a long, scrolling list\n  &::after {\n    content: '';\n    display: block;\n    height: 20px;\n  }\n"])), C1, M5.outlinePanel, Uk, Uk, ({
      pin: t
    }) => t ? "block" : "none"), u01 = () => {
      var r;
      let t = (r = s1(T().atomP.ahistoric.pinOutline)) != null ? r : !0,
        a = s1(p01),
        c = Dc("left");
      return (0, j8.useLayoutEffect)(() => {
        Fz.set(c);
      }, [c]), (0, j8.useEffect)(() => () => {
        go.set(!1), Fz.set(!1);
      }, []), j8.default.createElement(z01, {
        pin: t || a,
        onMouseEnter: () => {
          go.set(!0);
        },
        onMouseLeave: () => {
          go.set(!1);
        }
      }, j8.default.createElement(qk, null));
    }, $k = u01, Fz = new E6.Atom(!1), go = new E6.Atom(!1), p01 = (0, E6.prism)(() => {
      let t = (0, E6.val)(go.prism),
        a = (0, E6.val)(Fz.prism);
      return t || a;
    });
  });
var Xk,
  m01,
  Yk,
  Jk = x(() => {
    "use strict";

    c1();
    m01 = B.input.attrs({
      type: "checkbox"
    })(Xk || (Xk = V(["\n  outline: none;\n"]))), Yk = m01;
  });
function M01({
  propConfig: t,
  editingTools: a,
  value: c,
  autoFocus: r
}) {
  let e = (0, so.useCallback)(l => {
    a.permanentlySetValue(!!l.target.checked);
  }, [t, a]);
  return so.default.createElement(f01, {
    checked: c,
    onChange: e,
    autoFocus: r
  });
}
var so,
  tA,
  f01,
  aA,
  cA = x(() => {
    "use strict";

    so = I(G());
    c1();
    Jk();
    f01 = B(Yk)(tA || (tA = V(["\n  margin-left: 6px;\n\n  :focus {\n    outline: 1px solid #555;\n  }\n"])));
    aA = M01;
  });
function D6(t) {
  return a => {
    t.forEach(c => {
      typeof c == "function" ? c(a) : c != null && (c.current = a);
    });
  };
}
var Wc = x(() => {});
function q8(t, a, c) {
  (0, rA.useEffect)(() => {
    if (!t || c === !1) return;
    let r = Array.isArray(t) ? t.filter(l => l) : [t],
      e = l => {
        r.every(i => !l.composedPath().includes(i)) && a(l);
      };
    return window.addEventListener("mousedown", e, {
      capture: !0,
      passive: !1
    }), () => {
      window.removeEventListener("mousedown", e, {
        capture: !0,
        passive: !1
      });
    };
  }, [t, c]);
}
var rA,
  zo = x(() => {
    "use strict";

    rA = I(G());
  });
var b0,
  x01,
  F0,
  eA,
  C01,
  lA,
  L01,
  iA,
  H01,
  s2,
  oA,
  I0 = x(() => {
    "use strict";

    b0 = I(G());
    c1();
    x01 = "pointer-root", F0 = "--lockedCursor", C01 = B.div(eA || (eA = V(["\n  pointer-events: auto;\n  &.normal {\n    pointer-events: none;\n  }\n"]))), L01 = B.div(lA || (lA = V(["\n  position: absolute;\n  inset: 0;\n  pointer-events: none;\n\n  #pointer-root:not(.normal) > & {\n    pointer-events: auto;\n  }\n"]))), iA = (0, b0.createContext)({}), H01 = t => {
      var l, i, o, n;
      let [a, c] = (0, b0.useState)([]),
        r = (0, b0.useMemo)(() => ({
          getLock: (v, g) => {
            let s = {
              className: v,
              cursor: g
            };
            return c(z => [...z, s]), () => {
              c(z => z.filter(u => u !== s));
            };
          }
        }), []),
        e = (i = (l = a[0]) == null ? void 0 : l.cursor) != null ? i : "";
      return b0.default.createElement(iA.Provider, {
        value: r
      }, b0.default.createElement(C01, {
        id: x01,
        className: ((n = (o = a[0]) == null ? void 0 : o.className) != null ? n : "normal") + " " + t.className
      }, b0.default.createElement(L01, {
        style: {
          cursor: e,
          [F0]: e
        }
      }, t.children)));
    }, s2 = (t, a, c) => {
      let r = (0, b0.useContext)(iA);
      (0, b0.useLayoutEffect)(() => {
        if (t) return r.getLock(a, c);
      }, [t, a, c]);
    }, oA = H01;
  });
function uo(t) {
  return N8.default.createElement(nA.Provider, {
    value: t.logger
  }, t.children);
}
function C0(t, a) {
  let c = (0, N8.useContext)(nA);
  return (0, N8.useMemo)(() => t ? c.named(t, a) : c, [c, t, a]);
}
var N8,
  nA,
  L5 = x(() => {
    "use strict";

    N8 = I(G()), nA = N8.default.createContext(null);
  });
function V01() {
  let t = C0("PointerCapturing"),
    a = P0.default.useRef(null),
    c = () => a.current != null;
  return r => {
    let e,
      l = o => (e = o, a.current = o, o);
    return {
      capturing: {
        capturePointer(o) {
          if (t._debug("Capturing pointer", {
            forDebugName: r,
            reason: o
          }), a.current != null) throw new Error('"'.concat(r, '" attempted capturing pointer for "').concat(o, '" while already captured by "').concat(a.current.debugOwnerName, '" for "').concat(a.current.debugReason, '"'));
          let n = l({
            debugOwnerName: r,
            debugReason: o
          });
          return {
            isCapturing() {
              return n === a.current;
            },
            release() {
              return n === a.current ? (t._debug("Releasing pointer", {
                forDebugName: r,
                reason: o
              }), l(null), !0) : !1;
            }
          };
        },
        isPointerBeingCaptured: c
      },
      forceRelease() {
        e && a.current === e && (t._debug("Force releasing pointer", {
          localCapture: e
        }), l(null));
      }
    };
  };
}
function vA(t) {
  let a = V01();
  return P0.default.createElement(hA.Provider, {
    value: a
  }, P0.default.createElement(w01, {
    children: t.children
  }));
}
function po(t) {
  let a = (0, P0.useContext)(hA),
    c = (0, P0.useMemo)(() => a(t), [t, a]);
  return (0, P0.useEffect)(() => () => {
    c.forceRelease();
  }, [c]), c.capturing;
}
var P0,
  hA,
  w01,
  mo = x(() => {
    "use strict";

    P0 = I(G());
    L5();
    hA = P0.default.createContext(null), w01 = P0.default.memo(({
      children: t
    }) => P0.default.createElement(P0.default.Fragment, null, t));
  });
var Iz,
  gA = x(() => {
    "use strict";

    Iz = typeof window != "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  });
function S1(t, a) {
  let c = (0, U8.useRef)(a);
  c.current = a;
  let r = a.shouldPointerLock && !Iz,
    e = (0, U8.useRef)({
      domDragStarted: !1
    }),
    {
      capturePointer: l
    } = po("useDrag for ".concat(a.debugName)),
    i = (0, U8.useRef)({
      onDrag: h0,
      onDragEnd: h0,
      onClick: h0
    }),
    o = (0, U8.useRef)(),
    [n, h] = z1(!1);
  return (0, U8.useLayoutEffect)(() => {
    if (!t) return;
    let v = () => {
        let m = e.current.domDragStarted && e.current.detection.detected;
        n.current !== m && (n.current = m);
      },
      g = m => {
        if (!e.current.domDragStarted) return;
        let M = e.current;
        if (!y01(m, M) && (M.detection.detected || (M.detection.totalDistanceMoved += Math.abs(m.movementY) + Math.abs(m.movementX), M.detection.totalDistanceMoved > B01 && (r && t.requestPointerLock(), M.detection = {
          detected: !0,
          dragMovement: {
            x: 0,
            y: 0
          },
          dragEventCount: 0
        }, v())), M.detection.detected)) {
          M.detection.dragEventCount += 1;
          let {
            dragMovement: w
          } = M.detection;
          if (r) w.x += m.movementX, w.y += m.movementY;else {
            let {
              startPos: H
            } = M;
            w.x = m.screenX - H.x, w.y = m.screenY - H.y;
          }
          i.current.onDrag(w.x, w.y, m, m.movementX, m.movementY);
        }
      },
      s = m => {
        if (z(), !e.current.domDragStarted) return;
        let M = e.current.detection.detected;
        e.current = {
          domDragStarted: !1
        }, a.shouldPointerLock && !Iz && document.exitPointerLock(), i.current.onDragEnd(M), window.focus(), M || i.current.onClick(m), v();
      },
      d = () => {
        document.addEventListener("mousemove", g), document.addEventListener("mouseup", s);
      },
      z = () => {
        var m;
        (m = o.current) == null || m.release(), document.removeEventListener("mousemove", g), document.removeEventListener("mouseup", s);
      },
      u = m => {
        c.current.disabled || e.current.domDragStarted && e.current.detection.detected && (c.current.dontBlockMouseDown || (m.stopPropagation(), m.preventDefault()), e.current.detection = {
          detected: !1,
          totalDistanceMoved: 0
        }, v());
      },
      f = m => {
        var y, k, F, U;
        (y = o.current) == null || y.release();
        let M = c.current;
        if (M.disabled === !0 || !((k = M.buttons) != null ? k : [0]).includes(m.button)) return;
        let H = M.onDragStart(m);
        H !== !1 && (i.current.onDrag = H.onDrag, i.current.onDragEnd = (F = H.onDragEnd) != null ? F : h0, i.current.onClick = (U = H.onClick) != null ? U : h0, o.current = l("Drag start"), M.dontBlockMouseDown || (m.stopPropagation(), m.preventDefault()), e.current = {
          domDragStarted: !0,
          startPos: {
            x: m.screenX,
            y: m.screenY
          },
          detection: {
            detected: !1,
            totalDistanceMoved: 0
          }
        }, v(), d());
      },
      p = m => {
        f(m);
      };
    return t.addEventListener("mousedown", p), t.addEventListener("click", u), () => {
      var m, M;
      z(), t.removeEventListener("mousedown", p), t.removeEventListener("click", u), e.current.domDragStarted && ((M = (m = i.current).onDragEnd) == null || M.call(m, e.current.detection.detected)), e.current = {
        domDragStarted: !1
      }, v();
    };
  }, [t]), s2(h && !!a.lockCSSCursorTo, "dragging", a.lockCSSCursorTo), [h];
}
function y01(t, a) {
  return (!a.detection.detected || a.detection.detected && a.detection.dragEventCount < 3) && (Math.abs(t.movementX) > dA || Math.abs(t.movementY) > dA);
}
var U8,
  B01,
  dA,
  M2 = x(() => {
    "use strict";

    U8 = I(G());
    I0();
    mo();
    W8();
    gA();
    P1();
    B01 = 3, dA = 100;
  });
function F01(t) {
  return isNaN(t) ? "NaN" : fa(t) ? t.toFixed(0) : Xv(t, 3).toString();
}
var mA,
  fA,
  t4,
  sA,
  Pz,
  zA,
  S01,
  uA,
  k01,
  pA,
  A01,
  R01,
  b01,
  G9,
  fo = x(() => {
    "use strict";

    H2();
    mA = I(G()), fA = I(G()), t4 = I(G());
    c1();
    Wc();
    P1();
    zo();
    M2();
    Pz = B.div(sA || (sA = V(["\n  height: 100%;\n  width: 100%;\n  position: relative;\n  z-index: 0;\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n\n  &:after {\n    position: absolute;\n    inset: 1px 0 2px;\n    display: block;\n    content: ' ';\n    background-color: transparent;\n    border: 1px solid transparent;\n    z-index: -2;\n    box-sizing: border-box;\n    border-radius: 1px;\n  }\n\n  &:hover,\n  &.dragging,\n  &.editingViaKeyboard {\n    &:after {\n      background-color: #10101042;\n      border-color: #00000059;\n    }\n  }\n"]))), S01 = B.input(zA || (zA = V(["\n  background: transparent;\n  border: 1px solid transparent;\n  color: rgba(255, 255, 255, 0.9);\n  padding: 1px 6px;\n  font: inherit;\n  outline: none;\n  cursor: ew-resize;\n  text-align: left;\n  width: 100%;\n  height: calc(100% - 4px);\n  border-radius: 2px;\n\n  &:focus {\n    cursor: text;\n  }\n"]))), k01 = B.div(uA || (uA = V(["\n  position: absolute;\n  inset: 3px 2px 4px;\n  transform: scale(var(--percentage), 1);\n  transform-origin: top left;\n  background-color: #2d5561;\n  z-index: -1;\n  border-radius: 2px;\n  pointer-events: none;\n\n  ", ".dragging &, ", ".noFocus:hover & {\n    background-color: #338198;\n  }\n"])), Pz, Pz), A01 = B.div(pA || (pA = V(["\n  display: contents;\n"]))), R01 = t => !0, b01 = t => {
      var u;
      let [a] = z1({
          mode: "noFocus"
        }),
        c = (u = t.isValid) != null ? u : R01,
        r = (0, t4.useRef)(t);
      r.current = t;
      let e = (0, t4.useRef)(null);
      q8(e.current, () => {
        e.current.blur();
      }, a.current.mode === "editingViaKeyboard");
      let l = (0, t4.useRef)(null),
        i = (0, t4.useMemo)(() => {
          let f = U => {
              let A = U.target,
                {
                  value: P
                } = A,
                C = a.current;
              a.current = D(S({}, C), {
                currentEditedValueInString: P
              });
              let E = parseFloat(P);
              !isFinite(E) || !c(E) || r.current.temporarilySetValue(E);
            },
            p = () => {
              a.current.mode === "editingViaKeyboard" && (m(), a.current = {
                mode: "noFocus"
              }), t.onBlur && t.onBlur();
            },
            m = () => {
              let U = a.current,
                A = parseFloat(U.currentEditedValueInString);
              !isFinite(A) || !c(A) || U.valueBeforeEditing === A ? r.current.discardTemporaryValue() : r.current.permanentlySetValue(A);
            },
            M = U => {
              U.key === "Escape" ? (r.current.discardTemporaryValue(), a.current = {
                mode: "noFocus"
              }, e.current.blur()) : (U.key === "Enter" || U.key === "Tab") && (m(), e.current.blur());
            },
            w = U => {
              a.current.mode === "noFocus" && (e.current.focus(), U.preventDefault()), U.stopPropagation();
            },
            H = () => {
              a.current.mode === "noFocus" ? y() : a.current.mode;
            },
            y = () => {
              let U = r.current.value;
              a.current = {
                mode: "editingViaKeyboard",
                currentEditedValueInString: String(U),
                valueBeforeEditing: U
              }, setTimeout(() => {
                e.current.focus(), e.current.setSelectionRange(0, 100);
              });
            },
            k;
          return {
            inputChange: f,
            onBlur: p,
            transitionToDraggingMode: () => {
              var C;
              let U = r.current.value;
              k = (C = e.current) == null ? void 0 : C.getBoundingClientRect().width, a.current = {
                mode: "dragging"
              };
              let A = U,
                P = U;
              return l.current = document.body.style.cursor, {
                onDrag(E, a1, j, K) {
                  let Z = j.altKey ? K / 10 : K,
                    J = P + t.nudge({
                      deltaX: Z,
                      deltaFraction: Z / k,
                      magnitude: 1
                    });
                  P = t.range ? b1(J, t.range[0], t.range[1]) : J, r.current.temporarilySetValue(P);
                },
                onDragEnd(E) {
                  E ? (A === P ? r.current.discardTemporaryValue() : r.current.permanentlySetValue(P), a.current = {
                    mode: "noFocus"
                  }) : (r.current.discardTemporaryValue(), a.current = {
                    mode: "noFocus"
                  });
                },
                onClick() {
                  e.current.focus(), e.current.setSelectionRange(0, 100);
                }
              };
            },
            onInputKeyDown: M,
            onClick: w,
            onFocus: H
          };
        }, []);
      (0, mA.useEffect)(() => () => {
        i.onBlur();
      }, []);
      let o = a.current.mode !== "editingViaKeyboard" ? F01(t.value) : a.current.currentEditedValueInString;
      typeof o == "number" && isNaN(o) && (o = "NaN");
      let n = [e];
      t.inputRef && n.push(t.inputRef);
      let h = t4.default.createElement(S01, {
          key: "input",
          type: "text",
          onChange: i.inputChange,
          value: o,
          onBlur: i.onBlur,
          onKeyDown: i.onInputKeyDown,
          onClick: i.onClick,
          onFocus: i.onFocus,
          ref: D6(n),
          onMouseDown: f => {
            f.stopPropagation();
          },
          onDoubleClick: f => {
            f.preventDefault(), f.stopPropagation();
          },
          autoFocus: t.autoFocus
        }),
        {
          range: v
        } = t,
        g = parseFloat(o),
        s = v ? t4.default.createElement(k01, {
          style: {
            "--percentage": b1((g - v[0]) / (v[1] - v[0]), 0, 1)
          }
        }) : null,
        [d, z] = (0, fA.useState)(null);
      return S1(d, {
        debugName: "form/BasicNumberInput",
        onDragStart: i.transitionToDraggingMode,
        lockCSSCursorTo: "ew-resize",
        shouldPointerLock: !0,
        disabled: a.current.mode === "editingViaKeyboard"
      }), t4.default.createElement(Pz, {
        className: t.className + " " + a.current.mode
      }, t4.default.createElement(A01, {
        ref: z
      }, h), s);
    };
    G9 = b01;
  });
function I01({
  propConfig: t,
  editingTools: a,
  value: c,
  autoFocus: r
}) {
  let e = (0, Mo.useCallback)(l => t.nudgeFn(D(S({}, l), {
    config: t
  })), [t]);
  return Mo.default.createElement(G9, {
    value: c,
    temporarilySetValue: a.temporarilySetValue,
    discardTemporaryValue: a.discardTemporaryValue,
    permanentlySetValue: a.permanentlySetValue,
    range: t.range,
    nudge: e,
    autoFocus: r
  });
}
var Mo,
  xo,
  Gz = x(() => {
    "use strict";

    fo();
    Mo = I(G());
    xo = I01;
  });
function T01({
  value: t,
  onChange: a,
  options: c,
  autoFocus: r
}) {
  let e = (0, T9.useCallback)(l => {
    a(String(l.target.value));
  }, [a]);
  return T9.default.createElement(LA, {
    role: "radiogroup"
  }, Object.keys(c).map((l, i) => T9.default.createElement(P01, {
    key: "label-" + i,
    "data-checked": t === l
  }, c[l], T9.default.createElement(G01, {
    type: "radio",
    checked: t === l,
    value: l,
    onChange: e,
    name: "switchbox",
    autoFocus: r
  }))));
}
var T9,
  MA,
  LA,
  xA,
  P01,
  CA,
  G01,
  HA,
  VA = x(() => {
    "use strict";

    R0();
    T9 = I(G());
    c1();
    LA = B.form(MA || (MA = V(["\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n  vertical-align: middle;\n  justify-content: stretch;\n  height: 24px;\n  width: 100%;\n"]))), P01 = B.label(xA || (xA = V(["\n  padding: 0 0.5em;\n  background: transparent;\n  /* background: #373748; */\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-grow: 1;\n  color: #a7a7a7;\n  border: 1px solid transparent;\n  box-sizing: border-box;\n  border-right-width: 0px;\n\n  & + &:last-child {\n    border-right-width: 1px;\n  }\n\n  ", ":hover > & {\n    border-color: #1c2123;\n    /* background-color: #373748; */\n    /* color: ", "; */\n  }\n\n  &&:hover {\n    background-color: #464654;\n  }\n\n  &&[data-checked='true'] {\n    color: white;\n    background: #3f3f4c;\n  }\n"])), LA, A6(.1, "white")), G01 = B.input(CA || (CA = V(["\n  position: absolute;\n  opacity: 0;\n  pointer-events: none;\n  width: 0;\n  height: 0;\n"])));
    HA = T01;
  });
var wA = x(() => {});
var Tz,
  Zz,
  Oz,
  Ez = x(() => {
    Tz = I(G()), Zz = {
      color: void 0,
      size: void 0,
      className: void 0,
      style: void 0,
      attr: void 0
    }, Oz = Tz.default.createContext && Tz.default.createContext(Zz);
  });
function BA(t) {
  return t && t.map(function (a, c) {
    return Z9.default.createElement(a.tag, W6({
      key: c
    }, a.attr), BA(a.child));
  });
}
function N1(t) {
  return function (a) {
    return Z9.default.createElement(O01, W6({
      attr: W6({}, t.attr)
    }, a), BA(t.child));
  };
}
function O01(t) {
  var a = function (c) {
    var r = t.attr,
      e = t.size,
      l = t.title,
      i = Z01(t, ["attr", "size", "title"]),
      o = e || c.size || "1em",
      n;
    return c.className && (n = c.className), t.className && (n = (n ? n + " " : "") + t.className), Z9.default.createElement("svg", W6({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, c.attr, r, i, {
      className: n,
      style: W6(W6({
        color: t.color || c.color
      }, c.style), t.style),
      height: o,
      width: o,
      xmlns: "http://www.w3.org/2000/svg"
    }), l && Z9.default.createElement("title", null, l), t.children);
  };
  return Oz !== void 0 ? Z9.default.createElement(Oz.Consumer, null, function (c) {
    return a(c);
  }) : a(Zz);
}
var Z9,
  W6,
  Z01,
  yA = x(() => {
    Z9 = I(G());
    Ez();
    W6 = function () {
      return W6 = Object.assign || function (t) {
        for (var a, c = 1, r = arguments.length; c < r; c++) {
          a = arguments[c];
          for (var e in a) Object.prototype.hasOwnProperty.call(a, e) && (t[e] = a[e]);
        }
        return t;
      }, W6.apply(this, arguments);
    }, Z01 = function (t, a) {
      var c = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && a.indexOf(r) < 0 && (c[r] = t[r]);
      if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var e = 0, r = Object.getOwnPropertySymbols(t); e < r.length; e++) a.indexOf(r[e]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[e]) && (c[r[e]] = t[r[e]]);
      return c;
    };
  });
var z2 = x(() => {
  wA();
  yA();
  Ez();
});
var SA = x(() => {
  z2();
});
var kA = x(() => {
  z2();
});
function AA(t) {
  return N1({
    tag: "svg",
    attr: {
      viewBox: "0 0 512 512"
    },
    child: [{
      tag: "path",
      attr: {
        d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z"
      }
    }]
  })(t);
}
var RA = x(() => {
  z2();
});
var bA = x(() => {
  z2();
});
var FA = x(() => {
  z2();
});
function IA(t) {
  return N1({
    tag: "svg",
    attr: {
      viewBox: "0 0 8 16"
    },
    child: [{
      tag: "path",
      attr: {
        fillRule: "evenodd",
        d: "M5.5 3L7 4.5 3.25 8 7 11.5 5.5 13l-5-5 5-5z"
      }
    }]
  })(t);
}
function PA(t) {
  return N1({
    tag: "svg",
    attr: {
      viewBox: "0 0 8 16"
    },
    child: [{
      tag: "path",
      attr: {
        fillRule: "evenodd",
        d: "M7.5 8l-5 5L1 11.5 4.75 8 1 4.5 2.5 3l5 5z"
      }
    }]
  })(t);
}
var GA = x(() => {
  z2();
});
var TA = x(() => {
  z2();
});
var ZA = x(() => {
  z2();
});
var OA = x(() => {
  z2();
});
var EA = x(() => {
  z2();
});
var DA = x(() => {
  z2();
});
var WA = x(() => {
  z2();
});
var _A = x(() => {
  z2();
});
var jA = x(() => {
  z2();
});
var qA = x(() => {
  z2();
});
function Co(t) {
  return N1({
    tag: "svg",
    attr: {
      fill: "none",
      viewBox: "0 0 24 24",
      stroke: "currentColor"
    },
    child: [{
      tag: "path",
      attr: {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: "2",
        d: "M9 5l7 7-7 7"
      }
    }]
  })(t);
}
var NA = x(() => {
  z2();
});
var UA = x(() => {
  z2();
});
var KA = x(() => {
  z2();
});
var $A = x(() => {
  z2();
});
function QA(t) {
  return N1({
    tag: "svg",
    attr: {
      viewBox: "0 0 24 24",
      fill: "none"
    },
    child: [{
      tag: "path",
      attr: {
        d: "M6 9.65685L7.41421 11.0711L11.6569 6.82843L15.8995 11.0711L17.3137 9.65685L11.6569 4L6 9.65685Z",
        fill: "currentColor"
      }
    }, {
      tag: "path",
      attr: {
        d: "M6 14.4433L7.41421 13.0291L11.6569 17.2717L15.8995 13.0291L17.3137 14.4433L11.6569 20.1001L6 14.4433Z",
        fill: "currentColor"
      }
    }]
  })(t);
}
var XA = x(() => {
  z2();
});
function YA(t) {
  return N1({
    tag: "svg",
    attr: {
      viewBox: "0 0 16 16",
      fill: "currentColor"
    },
    child: [{
      tag: "path",
      attr: {
        d: "M14 10.44l-.413.56H2.393L2 10.46 7.627 5h.827L14 10.44z"
      }
    }]
  })(t);
}
var JA = x(() => {
  z2();
});
var K8 = x(() => {
  SA();
  kA();
  RA();
  bA();
  FA();
  GA();
  TA();
  ZA();
  OA();
  EA();
  DA();
  WA();
  _A();
  jA();
  qA();
  NA();
  UA();
  KA();
  $A();
  XA();
  JA();
});
function _01({
  value: t,
  onChange: a,
  options: c,
  className: r,
  autoFocus: e
}) {
  let l = (0, _6.useCallback)(i => {
    a(String(i.target.value));
  }, [a]);
  return _6.default.createElement(E01, null, _6.default.createElement(W01, {
    className: r,
    value: t,
    onChange: l,
    autoFocus: e
  }, Object.keys(c).map((i, o) => _6.default.createElement("option", {
    key: "option-" + o,
    value: i
  }, c[i]))), _6.default.createElement(D01, null, _6.default.createElement(QA, null)));
}
var _6,
  tR,
  E01,
  aR,
  D01,
  cR,
  W01,
  rR,
  eR = x(() => {
    "use strict";

    _6 = I(G());
    c1();
    K8();
    E01 = B.div(tR || (tR = V(["\n  width: 100%;\n  position: relative;\n"]))), D01 = B.div(aR || (aR = V(["\n  position: absolute;\n  right: 0px;\n  top: 0;\n  bottom: 0;\n  width: 1.5em;\n  font-size: 14px;\n  display: flex;\n  align-items: center;\n  color: #6b7280;\n  pointer-events: none;\n"]))), W01 = B.select(cR || (cR = V(["\n  appearance: none;\n  background-color: transparent;\n  box-sizing: border-box;\n  border: 1px solid transparent;\n  color: rgba(255, 255, 255, 0.85);\n  padding: 1px 6px;\n  font: inherit;\n  outline: none;\n  text-align: left;\n  width: 100%;\n  border-radius: 2px;\n  /*\n  looks like putting percentages in the height of a select box doesn't work in Firefox. Not sure why.\n  So we're hard-coding the height to 26px, unlike all other inputs that use a relative height.\n  */\n  height: 26px /* calc(100% - 4px); */;\n\n  @supports (-moz-appearance: none) {\n    /* Ugly hack to remove the extra left padding that shows up only in Firefox */\n    text-indent: -2px;\n  }\n\n  &:hover,\n  &:focus {\n    background-color: #10101042;\n    border-color: #00000059;\n  }\n"])));
    rR = _01;
  });
function j01({
  propConfig: t,
  editingTools: a,
  value: c,
  autoFocus: r
}) {
  let e = (0, _c.useCallback)(l => {
    a.permanentlySetValue(l);
  }, [t, a]);
  return t.as === "menu" ? _c.default.createElement(rR, {
    value: c,
    onChange: e,
    options: t.valuesAndLabels,
    autoFocus: r
  }) : _c.default.createElement(HA, {
    value: c,
    onChange: e,
    options: t.valuesAndLabels,
    autoFocus: r
  });
}
var _c,
  lR,
  iR = x(() => {
    "use strict";

    _c = I(G());
    VA();
    eR();
    lR = j01;
  });
var nR,
  $8,
  oR,
  q01,
  N01,
  U01,
  O9,
  Lo = x(() => {
    "use strict";

    c1();
    nR = I(G()), $8 = I(G());
    Wc();
    P1();
    zo();
    q01 = B.input.attrs({
      type: "text"
    })(oR || (oR = V(["\n  background: transparent;\n  border: 1px solid transparent;\n  color: rgba(255, 255, 255, 0.9);\n  padding: 1px 6px;\n  font: inherit;\n  outline: none;\n  cursor: text;\n  text-align: left;\n  width: 100%;\n  height: calc(100% - 4px);\n  border-radius: 2px;\n  border: 1px solid transparent;\n  box-sizing: border-box;\n\n  &:hover {\n    background-color: #10101042;\n    border-color: #00000059;\n  }\n\n  &:hover,\n  &:focus {\n    cursor: text;\n    background-color: #10101042;\n    border-color: #00000059;\n  }\n\n  &.invalid {\n    border-color: red;\n  }\n"]))), N01 = t => !0, U01 = t => {
      var h, v;
      let [a] = z1({
          mode: "noFocus"
        }),
        c = (h = t.isValid) != null ? h : N01,
        r = (0, $8.useRef)(t);
      r.current = t;
      let e = (0, $8.useRef)(null);
      q8(e.current, () => {
        e.current.blur();
      }, a.current.mode === "editingViaKeyboard");
      let l = (0, $8.useMemo)(() => {
        let g = m => {
            let M = m.target,
              {
                value: w
              } = M,
              H = a.current;
            a.current = D(S({}, H), {
              currentEditedValueInString: w
            }), c(w) && r.current.temporarilySetValue(w);
          },
          s = () => {
            var m, M;
            a.current.mode === "editingViaKeyboard" && (d(), a.current = {
              mode: "noFocus"
            }), (M = (m = r.current).onBlur) == null || M.call(m);
          },
          d = () => {
            let m = a.current,
              M = m.currentEditedValueInString;
            c(M) ? m.valueBeforeEditing === M ? r.current.discardTemporaryValue() : r.current.permanentlySetValue(M) : r.current.discardTemporaryValue();
          },
          z = m => {
            m.key === "Escape" ? (r.current.discardTemporaryValue(), a.current = {
              mode: "noFocus"
            }, e.current.blur()) : (m.key === "Enter" || m.key === "Tab") && (d(), e.current.blur());
          },
          u = m => {
            a.current.mode === "noFocus" && (e.current.focus(), m.preventDefault()), m.stopPropagation();
          },
          f = () => {
            a.current.mode === "noFocus" ? p() : a.current.mode;
          },
          p = () => {
            let m = r.current.value;
            a.current = {
              mode: "editingViaKeyboard",
              currentEditedValueInString: String(m),
              valueBeforeEditing: m
            }, setTimeout(() => {
              e.current.focus();
            });
          };
        return {
          inputChange: g,
          onBlur: s,
          onInputKeyDown: z,
          onClick: u,
          onFocus: f
        };
      }, []);
      (0, nR.useEffect)(() => () => {
        l.onBlur();
      }, []);
      let i = a.current.mode !== "editingViaKeyboard" ? t.value : a.current.currentEditedValueInString,
        o = [e];
      return t.inputRef && o.push(t.inputRef), $8.default.createElement(q01, {
        key: "input",
        type: "text",
        className: "".concat((v = t.className) != null ? v : "", " ").concat(c(i) ? "" : "invalid"),
        onChange: l.inputChange,
        value: i,
        onBlur: l.onBlur,
        onKeyDown: l.onInputKeyDown,
        onClick: l.onClick,
        onFocus: l.onFocus,
        ref: D6(o),
        onMouseDown: g => {
          g.stopPropagation();
        },
        onDoubleClick: g => {
          g.preventDefault(), g.stopPropagation();
        },
        autoFocus: t.autoFocus
      });
    }, O9 = U01;
  });
function K01({
  editingTools: t,
  value: a,
  autoFocus: c
}) {
  return hR.default.createElement(O9, {
    value: a,
    temporarilySetValue: t.temporarilySetValue,
    discardTemporaryValue: t.discardTemporaryValue,
    permanentlySetValue: t.permanentlySetValue,
    autoFocus: c
  });
}
var hR,
  vR,
  gR = x(() => {
    "use strict";

    hR = I(G());
    Lo();
    vR = K01;
  });
function dR(t) {
  t = t.trim().toLowerCase();
  let a = t.match(Dz);
  if (!a) return {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
  let c = $01(a[1]);
  return {
    r: parseInt(c.substr(0, 2), 16) / 255,
    g: parseInt(c.substr(2, 2), 16) / 255,
    b: parseInt(c.substr(4, 2), 16) / 255,
    a: parseInt(c.substr(6, 2), 16) / 255
  };
}
function Ho(t, {
  removeAlphaIfOpaque: a = !1
} = {}) {
  let c = (t.a * 255 | 256).toString(16).slice(1),
    r = (t.r * 255 | 256).toString(16).slice(1) + (t.g * 255 | 256).toString(16).slice(1) + (t.b * 255 | 256).toString(16).slice(1) + (a && c === "ff" ? "" : c);
  return "#".concat(r);
}
function Vo(t) {
  return D(S({}, t), {
    toString() {
      return Ho(this, {
        removeAlphaIfOpaque: !0
      });
    }
  });
}
function $01(t) {
  switch (t.length) {
    case 3:
      return "".concat(t.repeat(2), "ff");
    case 4:
      let a = t.substr(0, 3),
        c = t[3];
      return "".concat(a.repeat(2)).concat(c.repeat(2));
    case 6:
      return "".concat(t, "ff");
  }
  return t;
}
var Dz,
  Wz = x(() => {
    "use strict";

    Dz = /^#*([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
  });
function E9(t) {
  let a = (0, _z.useRef)(t),
    c = (0, _z.useRef)(r => {
      a.current && a.current(r);
    });
  return a.current = t, c.current;
}
var _z,
  jz = x(() => {
    "use strict";

    _z = I(G());
  });
var G4,
  jc = x(() => {
    "use strict";

    G4 = (t, a = 0, c = 1) => t > c ? c : t < a ? a : t;
  });
var j6,
  sR,
  zR,
  wo,
  Bo = x(() => {
    "use strict";

    j6 = I(G()), sR = (0, j6.createContext)(void 0), zR = ({
      children: t
    }) => {
      let [a, c] = (0, j6.useState)(!1);
      return j6.default.createElement(sR.Provider, {
        value: {
          editing: a,
          setEditing: c
        }
      }, t);
    }, wo = () => (0, j6.useContext)(sR);
  });
var a4,
  qc,
  Q01,
  qz,
  uR,
  pR,
  X01,
  mR,
  Y01,
  J01,
  q6,
  Nc = x(() => {
    "use strict";

    a4 = I(G());
    jz();
    jc();
    c1();
    Bo();
    qc = t => "touches" in t, Q01 = (t, a) => {
      for (let c = 0; c < t.length; c++) if (t[c].identifier === a) return t[c];
      return t[0];
    }, qz = t => t && t.ownerDocument.defaultView || self, uR = (t, a, c) => {
      let r = t.getBoundingClientRect(),
        e = qc(a) ? Q01(a.touches, c) : a;
      return {
        left: G4((e.pageX - (r.left + qz(t).pageXOffset)) / r.width),
        top: G4((e.pageY - (r.top + qz(t).pageYOffset)) / r.height)
      };
    }, pR = t => {
      !qc(t) && t.preventDefault();
    }, X01 = (t, a) => a && !qc(t), Y01 = B.div(mR || (mR = V(["\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  border-radius: inherit;\n  outline: none;\n  /* Don't trigger the default scrolling behavior when the event is originating from this element */\n  touch-action: none;\n"]))), J01 = r => {
      var e = r,
        {
          onMove: t,
          onKey: a
        } = e,
        c = m4(e, ["onMove", "onKey"]);
      let l = (0, a4.useRef)(null),
        i = E9(t),
        o = E9(a),
        n = (0, a4.useRef)(null),
        h = (0, a4.useRef)(!1),
        {
          setEditing: v
        } = wo(),
        [g, s, d] = (0, a4.useMemo)(() => {
          let z = ({
              nativeEvent: M
            }) => {
              let w = l.current;
              if (w && (pR(M), !(X01(M, h.current) || !w))) {
                if (qc(M)) {
                  h.current = !0;
                  let H = M.changedTouches || [];
                  H.length && (n.current = H[0].identifier);
                }
                w.focus(), v(!0), i(uR(w, M, n.current)), m(!0);
              }
            },
            u = M => {
              pR(M), (qc(M) ? M.touches.length > 0 : M.buttons > 0) && l.current ? i(uR(l.current, M, n.current)) : (v(!1), m(!1));
            },
            f = M => {
              v(!1), m(!1);
            },
            p = M => {
              let w = M.which || M.keyCode;
              w < 37 || w > 40 || (M.preventDefault(), o({
                left: w === 39 ? .05 : w === 37 ? -.05 : 0,
                top: w === 40 ? .05 : w === 38 ? -.05 : 0
              }));
            };
          function m(M) {
            let w = h.current,
              H = l.current,
              y = qz(H),
              k = M ? y.addEventListener : y.removeEventListener;
            k(w ? "touchmove" : "mousemove", u), k(w ? "touchend" : "mouseup", f);
          }
          return [z, p, m];
        }, [o, i]);
      return (0, a4.useEffect)(() => d, [d]), a4.default.createElement(Y01, D(S({}, c), {
        onTouchStart: g,
        onMouseDown: g,
        ref: l,
        onKeyDown: s,
        tabIndex: 0,
        role: "slider"
      }));
    }, q6 = a4.default.memo(J01);
  });
var Nz,
  fR,
  t31,
  MR,
  a31,
  xR,
  c31,
  D9,
  yo = x(() => {
    "use strict";

    Nz = I(G());
    c1();
    Nc();
    t31 = B(q6)(fR || (fR = V([""]))), a31 = B.div(MR || (MR = V(["\n  position: absolute;\n  z-index: 1;\n  box-sizing: border-box;\n  width: 16px;\n  height: 16px;\n  transform: translate(-50%, -50%);\n  background-color: #fff;\n  border: 1px solid #ffffff00;\n  border-radius: 2px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\n\n  ", ":focus & {\n    transform: translate(-50%, -50%) scale(1.1);\n  }\n"])), t31), c31 = B.div(xR || (xR = V(["\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n  border-radius: inherit;\n"]))), D9 = ({
      className: t,
      color: a,
      left: c,
      top: r = .5
    }) => {
      let e = {
        top: "".concat(r * 100, "%"),
        left: "".concat(c * 100, "%")
      };
      return Nz.default.createElement(a31, {
        style: e,
        className: t
      }, Nz.default.createElement(c31, {
        style: {
          backgroundColor: a
        }
      }));
    };
  });
var A2,
  Uc = x(() => {
    "use strict";

    A2 = (t, a = 0, c = Math.pow(10, a)) => Math.round(c * t) / c;
  });
var RL1,
  CR,
  Kc,
  So,
  LR,
  HR,
  $c = x(() => {
    "use strict";

    Uc();
    RL1 = {
      grad: 360 / 400,
      turn: 360,
      rad: 360 / (Math.PI * 2)
    }, CR = ({
      h: t,
      s: a,
      v: c,
      a: r
    }) => {
      let e = (200 - a) * c / 100;
      return {
        h: A2(t),
        s: A2(e > 0 && e < 200 ? a * c / 100 / (e <= 100 ? e : 200 - e) * 100 : 0),
        l: A2(e / 2),
        a: A2(r, 2)
      };
    }, Kc = t => {
      let {
        h: a,
        s: c,
        l: r
      } = CR(t);
      return "hsl(".concat(a, ", ").concat(c, "%, ").concat(r, "%)");
    }, So = t => {
      let {
        h: a,
        s: c,
        l: r,
        a: e
      } = CR(t);
      return "hsla(".concat(a, ", ").concat(c, "%, ").concat(r, "%, ").concat(e, ")");
    }, LR = ({
      h: t,
      s: a,
      v: c,
      a: r
    }) => {
      t = t / 360 * 6, a = a / 100, c = c / 100;
      let e = Math.floor(t),
        l = c * (1 - a),
        i = c * (1 - (t - e) * a),
        o = c * (1 - (1 - t + e) * a),
        n = e % 6;
      return {
        r: A2([c, i, l, l, o, c][n] * 255),
        g: A2([o, c, c, i, l, l][n] * 255),
        b: A2([l, l, o, c, c, i][n] * 255),
        a: A2(r, 2)
      };
    }, HR = ({
      r: t,
      g: a,
      b: c,
      a: r
    }) => {
      let e = Math.max(t, a, c),
        l = e - Math.min(t, a, c),
        i = l ? e === t ? (a - c) / l : e === a ? 2 + (c - t) / l : 4 + (t - a) / l : 0;
      return {
        h: A2(60 * (i < 0 ? i + 6 : i)),
        s: A2(e ? l / e * 100 : 0),
        v: A2(e / 255 * 100),
        a: r
      };
    };
  });
var Qc,
  VR,
  r31,
  wR,
  e31,
  l31,
  BR,
  yR = x(() => {
    "use strict";

    Qc = I(G());
    Nc();
    yo();
    $c();
    jc();
    Uc();
    c1();
    r31 = B.div(VR || (VR = V(["\n  position: relative;\n  height: 16px;\n  border-radius: 2px;\n\n  background: linear-gradient(\n    to right,\n    #f00 0%,\n    #ff0 17%,\n    #0f0 33%,\n    #0ff 50%,\n    #00f 67%,\n    #f0f 83%,\n    #f00 100%\n  );\n"]))), e31 = B(D9)(wR || (wR = V(["\n  z-index: 2;\n"]))), l31 = ({
      className: t,
      hue: a,
      onChange: c
    }) => Qc.default.createElement(r31, {
      className: t
    }, Qc.default.createElement(q6, {
      onMove: l => {
        c({
          h: 360 * l.left
        });
      },
      onKey: l => {
        c({
          h: G4(a + l.left * 360, 0, 360)
        });
      },
      "aria-label": "Hue",
      "aria-valuetext": A2(a)
    }, Qc.default.createElement(e31, {
      left: a / 360,
      color: Kc({
        h: a,
        s: 100,
        v: 100,
        a: 1
      })
    }))), BR = Qc.default.memo(l31);
  });
var Xc,
  SR,
  i31,
  kR,
  o31,
  n31,
  AR,
  RR = x(() => {
    "use strict";

    Xc = I(G());
    Nc();
    yo();
    $c();
    jc();
    Uc();
    c1();
    i31 = B.div(SR || (SR = V(["\n  position: relative;\n  flex-grow: 1;\n  border-color: transparent; /* Fixes https://github.com/omgovich/react-colorful/issues/139 */\n  border-bottom: 12px solid #000;\n  border-radius: 2px;\n  background-image: linear-gradient(to top, #000, rgba(0, 0, 0, 0)),\n    linear-gradient(to right, #fff, rgba(255, 255, 255, 0));\n\n  // Improve elements rendering on light backgrounds\n  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.05);\n"]))), o31 = B(D9)(kR || (kR = V(["\n  z-index: 3;\n"]))), n31 = ({
      hsva: t,
      onChange: a
    }) => {
      let c = l => {
          a({
            s: l.left * 100,
            v: 100 - l.top * 100
          });
        },
        r = l => {
          a({
            s: G4(t.s + l.left * 100, 0, 100),
            v: G4(t.v - l.top * 100, 0, 100)
          });
        },
        e = {
          backgroundColor: Kc({
            h: t.h,
            s: 100,
            v: 100,
            a: 1
          })
        };
      return Xc.default.createElement(i31, {
        style: e
      }, Xc.default.createElement(q6, {
        onMove: c,
        onKey: r,
        "aria-label": "Color",
        "aria-valuetext": "Saturation ".concat(A2(t.s), "%, Brightness ").concat(A2(t.v), "%")
      }, Xc.default.createElement(o31, {
        top: 1 - t.v / 100,
        left: t.s / 100,
        color: Kc(t)
      })));
    }, AR = Xc.default.memo(n31);
  });
var Yc,
  bR,
  h31,
  FR,
  v31,
  IR,
  g31,
  PR,
  GR = x(() => {
    "use strict";

    Yc = I(G());
    Nc();
    yo();
    $c();
    jc();
    Uc();
    c1();
    h31 = B.div(bR || (bR = V(['\n  position: relative;\n  height: 16px;\n  border-radius: 2px;\n  // Checkerboard\n  background-color: #fff;\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><rect x="8" width="8" height="8"/><rect y="8" width="8" height="8"/></svg>\');\n']))), v31 = B.div.attrs(({
      colorFrom: t,
      colorTo: a
    }) => ({
      style: {
        backgroundImage: "linear-gradient(90deg, ".concat(t, ", ").concat(a, ")")
      }
    }))(FR || (FR = V(["\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n  border-radius: inherit;\n\n  // Improve rendering on light backgrounds\n  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.05);\n"]))), g31 = B(D9)(IR || (IR = V(['\n  // Checkerboard\n  background-color: #fff;\n  background-image: url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><rect x="8" width="8" height="8"/><rect y="8" width="8" height="8"/></svg>\');\n']))), PR = ({
      className: t,
      hsva: a,
      onChange: c
    }) => {
      let r = o => {
          c({
            a: o.left
          });
        },
        e = o => {
          c({
            a: G4(a.a + o.left)
          });
        },
        l = So(Object.assign({}, a, {
          a: 0
        })),
        i = So(Object.assign({}, a, {
          a: 1
        }));
      return Yc.default.createElement(h31, {
        className: t
      }, Yc.default.createElement(v31, {
        colorFrom: l,
        colorTo: i
      }), Yc.default.createElement(q6, {
        onMove: r,
        onKey: e,
        "aria-label": "Alpha",
        "aria-valuetext": "".concat(A2(a.a * 100), "%")
      }, Yc.default.createElement(g31, {
        left: a.a,
        color: So(a)
      })));
    };
  });
var Jc,
  Uz = x(() => {
    "use strict";

    Jc = (t, a) => {
      if (t === a) return !0;
      for (let c in t) if (t[c] !== a[c]) return !1;
      return !0;
    };
  });
function TR(t, a, c, r) {
  let {
      editing: e
    } = wo(),
    [l, i] = (0, k3.useState)(a),
    o = E9(c),
    n = E9(r),
    h = e ? l : a,
    [v, g] = (0, k3.useState)(() => t.toHsva(h)),
    s = (0, k3.useRef)({
      color: h,
      hsva: v
    }),
    d = (0, k3.useRef)({
      color: h,
      hsva: v
    });
  (0, k3.useEffect)(() => {
    e && i(s.current.color);
  }, [e]), (0, k3.useEffect)(() => {
    let u = t.fromHsva(v);
    e ? !Jc(v, s.current.hsva) && !t.equal(u, s.current.color) && (s.current = {
      hsva: v,
      color: u
    }, i(u), o(u)) : !Jc(v, d.current.hsva) && !t.equal(u, d.current.color) && (d.current = {
      hsva: v,
      color: u
    }, s.current = {
      hsva: v,
      color: u
    }, n(u));
  }, [e, v, t, o, n]), (0, k3.useEffect)(() => {
    if (!e && !t.equal(h, d.current.color)) {
      let u = t.toHsva(h);
      d.current = {
        hsva: u,
        color: h
      }, g(u);
    }
  }, [e, h, t]);
  let z = (0, k3.useCallback)(u => {
    g(f => Object.assign({}, f, u));
  }, []);
  return [v, z];
}
var k3,
  ZR = x(() => {
    "use strict";

    k3 = I(G());
    Uz();
    jz();
    Bo();
  });
var Q8,
  OR,
  d31,
  ER,
  DR = x(() => {
    "use strict";

    Q8 = I(G());
    yR();
    RR();
    GR();
    ZR();
    c1();
    d31 = B.div(OR || (OR = V(["\n  position: relative;\n  display: flex;\n  gap: 4px;\n  flex-direction: column;\n  width: 200px;\n  height: 200px;\n  user-select: none;\n  cursor: default;\n"]))), ER = o => {
      var n = o,
        {
          className: t,
          colorModel: a,
          color: c = a.defaultColor,
          temporarilySetValue: r,
          permanentlySetValue: e,
          discardTemporaryValue: l
        } = n,
        i = m4(n, ["className", "colorModel", "color", "temporarilySetValue", "permanentlySetValue", "discardTemporaryValue"]);
      let [h, v] = TR(a, c, r, e);
      return (0, Q8.useEffect)(() => () => {
        l();
      }, []), Q8.default.createElement(d31, S({}, i), Q8.default.createElement(AR, {
        hsva: h,
        onChange: v
      }), Q8.default.createElement(BR, {
        hue: h.h,
        onChange: v
      }), Q8.default.createElement(PR, {
        hsva: h,
        onChange: v
      }));
    };
  });
var Kz,
  s31,
  z31,
  u31,
  $z,
  WR = x(() => {
    "use strict";

    Kz = I(G());
    DR();
    Uz();
    $c();
    Bo();
    s31 = t => ({
      r: t.r / 255,
      g: t.g / 255,
      b: t.b / 255,
      a: t.a
    }), z31 = t => ({
      r: t.r * 255,
      g: t.g * 255,
      b: t.b * 255,
      a: t.a
    }), u31 = {
      defaultColor: {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      },
      toHsva: t => HR(z31(t)),
      fromHsva: t => s31(LR(t)),
      equal: Jc
    }, $z = t => Kz.default.createElement(zR, null, Kz.default.createElement(ER, D(S({}, t), {
      permanentlySetValue: a => {
        t.permanentlySetValue(a);
      },
      colorModel: u31
    })));
  });
var _R = x(() => {
  "use strict";

  WR();
});
var jR,
  p31,
  qR,
  NR = x(() => {
    jR = I(G()), p31 = function (t) {
      (0, jR.useEffect)(t, []);
    }, qR = p31;
  });
var UR,
  m31,
  KR,
  $R = x(() => {
    UR = I(G());
    NR();
    m31 = function (t) {
      var a = (0, UR.useRef)(t);
      a.current = t, qR(function () {
        return function () {
          return a.current();
        };
      });
    }, KR = m31;
  });
var W9,
  f31,
  QR,
  XR = x(() => {
    W9 = I(G());
    $R();
    f31 = function (t) {
      var a = (0, W9.useRef)(0),
        c = (0, W9.useState)(t),
        r = c[0],
        e = c[1],
        l = (0, W9.useCallback)(function (i) {
          cancelAnimationFrame(a.current), a.current = requestAnimationFrame(function () {
            e(i);
          });
        }, []);
      return KR(function () {
        cancelAnimationFrame(a.current);
      }), [r, l];
    }, QR = f31;
  });
function YR(t) {
  for (var a = [], c = 1; c < arguments.length; c++) a[c - 1] = arguments[c];
  t && t.addEventListener && t.addEventListener.apply(t, a);
}
function JR(t) {
  for (var a = [], c = 1; c < arguments.length; c++) a[c - 1] = arguments[c];
  t && t.removeEventListener && t.removeEventListener.apply(t, a);
}
var ko,
  tb = x(() => {
    ko = typeof window != "undefined";
  });
var ab,
  M31,
  _9,
  Ao = x(() => {
    ab = I(G());
    XR();
    tb();
    M31 = function (t, a) {
      t === void 0 && (t = 1 / 0), a === void 0 && (a = 1 / 0);
      var c = QR({
          width: ko ? window.innerWidth : t,
          height: ko ? window.innerHeight : a
        }),
        r = c[0],
        e = c[1];
      return (0, ab.useEffect)(function () {
        if (ko) {
          var l = function () {
            e({
              width: window.innerWidth,
              height: window.innerHeight
            });
          };
          return YR(window, "resize", l), function () {
            JR(window, "resize", l);
          };
        }
      }, []), r;
    }, _9 = M31;
  });
function j9(t) {
  let [a, c] = (0, Ro.useState)(null);
  return (0, Ro.useLayoutEffect)(() => (t && c(t.getBoundingClientRect()), () => {
    c(null);
  }), [t]), a;
}
var Ro,
  Qz = x(() => {
    "use strict";

    Ro = I(G());
  });
var cb,
  x31,
  bo,
  Xz = x(() => {
    "use strict";

    cb = I(G()), x31 = (0, cb.createContext)({}), bo = x31;
  });
function Yz(t, a, c) {
  let r = t.getBoundingClientRect(),
    e = l => {
      (l.clientX < r.left - a || l.clientX > r.left + r.width + a || l.clientY < r.top - a || l.clientY > r.top + r.height + a) && c(l);
    };
  return window.addEventListener("mousemove", e), () => {
    window.removeEventListener("mousemove", e);
  };
}
var rb = x(() => {
  "use strict";
});
var lb,
  q9,
  eb,
  C31,
  Fo,
  Jz = x(() => {
    "use strict";

    lb = I(G()), q9 = I(G());
    Ao();
    Qz();
    Xz();
    P1();
    zo();
    rb();
    W8();
    H2();
    eb = 8, C31 = t => {
      var v, g;
      let a = t.children(),
        [c, r] = z1(null),
        e = a.props.style ? S({}, a.props.style) : {};
      e.position = "absolute";
      let l = j9(r),
        i = j9(t.target),
        o = _9(),
        [n, h] = (0, q9.useState)({});
      return (0, q9.useLayoutEffect)(() => {
        var k, F, U;
        if (!l || !r || !i) return;
        let s = (k = t.verticalGap) != null ? k : 8,
          d = {},
          z = (F = t.verticalPlacement) != null ? F : "bottom",
          u = 0,
          f = 0;
        z === "bottom" ? i.bottom + l.height + s < o.height ? (z = "bottom", u = i.bottom + s, d.top = "0px") : i.top > l.height + s ? (z = "top", u = i.top - (l.height + s), d.bottom = "0px", d.transform = "rotateZ(180deg)") : z = "overlay" : z === "top" && (i.top > l.height + s ? (z = "top", u = i.top - (l.height + s), d.bottom = "0px", d.transform = "rotateZ(180deg)") : i.bottom + l.height + s < o.height ? (z = "bottom", u = i.bottom + s, d.top = "0px") : z = "overlay");
        let p = 0;
        if (z !== "overlay") {
          let A = i.left + i.width / 2;
          A < l.width / 2 ? (f = s, p = Math.max(A - s, eb)) : A + l.width / 2 > o.width ? (f = o.width - (s + l.width), p = Math.min(A - f, l.width - eb)) : (f = A - l.width / 2, p = l.width / 2), d.left = p + "px";
        }
        let {
            minX: m = -1 / 0,
            maxX: M = 1 / 0,
            minY: w = -1 / 0,
            maxY: H = 1 / 0
          } = (U = t.constraints) != null ? U : {},
          y = {
            left: b1(f, m, M - l.width),
            top: b1(u, w, H + l.height)
          };
        if (r.style.left = y.left + "px", r.style.top = y.top + "px", h(d), t.onPointerOutside) return Yz(r, t.onPointerOutside.threshold, t.onPointerOutside.callback);
      }, [l, r, t.target, i, o, t.onPointerOutside]), q8([r, (v = t.target) != null ? v : null], (g = t.onClickOutside) != null ? g : h0), lb.default.createElement(bo.Provider, {
        value: n
      }, (0, q9.cloneElement)(a, {
        ref: c,
        style: e
      }));
    }, Fo = C31;
  });
function x2(t, a) {
  let c = (...z) => {},
    {
      isPointerBeingCaptured: r
    } = po("usePopover"),
    [e, l] = z1({
      isOpen: !1
    }),
    i = (0, w2.useRef)(t),
    o = (0, w2.useCallback)(z => {
      c('closing due to "'.concat(z, '"')), e.current = {
        isOpen: !1
      };
    }, []),
    n = (0, w2.useCallback)((z, u) => {
      var m;
      let f = typeof i.current == "function" ? i.current() : i.current;
      function p() {
        v.childHasFocusRef.current || f.closeOnClickOutside !== !1 && o("clicked outside popover");
      }
      e.current = {
        isOpen: !0,
        clickPoint: {
          clientX: z.clientX,
          clientY: z.clientY
        },
        target: u,
        opts: f,
        onClickOutside: p,
        onPointerOutside: f.closeWhenPointerIsDistant === !1 ? void 0 : {
          threshold: (m = f.pointerDistanceThreshold) != null ? m : 100,
          callback: () => {
            v.childHasFocusRef.current || r() || o("pointer outside");
          }
        }
      };
    }, []),
    h = (0, w2.useCallback)((...z) => {
      e.current.isOpen ? o("toggled") : n(...z);
    }, []),
    v = L31({
      _debug: c,
      state: l
    }),
    [, g] = (0, w2.useContext)(N9);
  (0, w2.useEffect)(() => {
    let z;
    return l.isOpen && (z = g()), () => z == null ? void 0 : z();
  }, [l.isOpen]);
  let s = (0, w2.useContext)(a3);
  return {
    node: l.isOpen ? (0, ib.createPortal)(w2.default.createElement(ob.Provider, {
      value: v.childPopoverLock
    }, w2.default.createElement(Fo, {
      children: a,
      target: l.target,
      onClickOutside: l.onClickOutside,
      onPointerOutside: l.onPointerOutside,
      constraints: l.opts.constraints,
      verticalGap: l.opts.verticalGap
    })), s) : w2.default.createElement(w2.default.Fragment, null),
    open: n,
    close: o,
    toggle: h,
    isOpen: l.isOpen
  };
}
function L31(t) {
  let a = (0, w2.useContext)(ob);
  (0, w2.useEffect)(() => {
    if (t.state.isOpen) {
      let r = a.takeFocus();
      return t._debug("take focus"), () => {
        t._debug("release focus"), r.releaseFocus();
      };
    }
  }, [t.state.isOpen]);
  let c = (0, w2.useRef)(!1);
  return {
    childHasFocusRef: c,
    childPopoverLock: {
      takeFocus() {
        return c.current = !0, {
          releaseFocus() {
            c.current = !1;
          }
        };
      }
    }
  };
}
var w2,
  ib,
  ob,
  c4 = x(() => {
    "use strict";

    mo();
    P1();
    w2 = I(G()), ib = I(B4());
    T6();
    Jz();
    Io();
    ob = w2.default.createContext({
      takeFocus() {
        return {
          releaseFocus() {}
        };
      }
    });
  });
var r4,
  nb,
  H31,
  hb,
  V31,
  vb,
  w31,
  gb,
  B31,
  db,
  y31,
  S31,
  sb,
  zb = x(() => {
    "use strict";

    r4 = I(G());
    c1();
    Xz();
    H31 = B.div(nb || (nb = V(["\n  position: absolute;\n  width: 0;\n  height: 0;\n  color: var(--popover-arrow-color);\n  pointer-events: none;\n"]))), V31 = B.div(hb || (hb = V(["\n  width: 12px;\n  height: 8px;\n  position: absolute;\n  left: -7px;\n  top: -8px;\n  text-align: center;\n  line-height: 0;\n"]))), w31 = B.path(vb || (vb = V(["\n  fill: var(--popover-bg);\n"]))), B31 = B.path(gb || (gb = V(["\n  fill: var(--popover-inner-stroke);\n"]))), y31 = B.path(db || (db = V(["\n  fill: var(--popover-outer-stroke);\n"]))), S31 = (0, r4.forwardRef)(({
      className: t
    }, a) => {
      let c = (0, r4.useContext)(bo);
      return r4.default.createElement(H31, {
        className: t,
        ref: a,
        style: S({}, c)
      }, r4.default.createElement(V31, null, r4.default.createElement("svg", {
        width: "12",
        height: "8",
        viewBox: "0 0 12 8",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, r4.default.createElement(y31, {
        d: "M6 0L0 6H12L6 0Z"
      }), r4.default.createElement(B31, {
        d: "M6 1.5L0 7.5H12L6 1.5Z"
      }), r4.default.createElement(w31, {
        d: "M6 3L0 9H12L6 3Z"
      }))));
    }), sb = S31;
  });
var Po,
  tu,
  ub,
  k31,
  A31,
  T2,
  e4 = x(() => {
    "use strict";

    G1();
    R0();
    Po = I(G());
    c1();
    zb();
    tu = N2(.05, "#2a2a31"), k31 = B.div(ub || (ub = V(["\n  position: absolute;\n  --popover-bg: ", ";\n  --popover-inner-stroke: #505159;\n  --popover-outer-stroke: #111;\n\n  background: var(--popover-bg);\n\n  color: white;\n  padding: 0;\n  margin: 0;\n  cursor: default;\n  ", ";\n  border-radius: 3px;\n  z-index: 10000;\n  border: 1px solid var(--popover-inner-stroke);\n  box-shadow: 0 0 0 1px var(--popover-outer-stroke), 0 6px 8px -4px black;\n  backdrop-filter: blur(8px);\n\n  & a {\n    color: inherit;\n  }\n"])), tu, C1), A31 = Po.default.forwardRef(({
      children: t,
      className: a,
      showPopoverEdgeTriangle: c = !0
    }, r) => Po.default.createElement(k31, {
      className: a,
      ref: r
    }, c ? Po.default.createElement(sb, null) : void 0, t)), T2 = A31;
  });
function P31({
  editingTools: t,
  value: a,
  autoFocus: c
}) {
  let r = (0, A3.useRef)(null),
    e = (0, A3.useCallback)(i => {
      let o = Vo(dR(i));
      t.permanentlySetValue(o);
    }, [t]),
    l = x2({
      debugName: "RgbaPropEditor"
    }, () => A3.default.createElement(I31, null, A3.default.createElement($z, {
      color: {
        r: a.r,
        g: a.g,
        b: a.b,
        a: a.a
      },
      temporarilySetValue: i => {
        let o = Vo(i);
        t.temporarilySetValue(o);
      },
      permanentlySetValue: i => {
        let o = Vo(i);
        t.permanentlySetValue(o);
      },
      discardTemporaryValue: t.discardTemporaryValue
    })));
  return A3.default.createElement(A3.default.Fragment, null, A3.default.createElement(R31, null, A3.default.createElement(b31, {
    rgbaColor: a,
    ref: r,
    onClick: i => {
      l.toggle(i, r.current);
    }
  }), A3.default.createElement(F31, {
    value: Ho(a, {
      removeAlphaIfOpaque: !0
    }),
    temporarilySetValue: pb,
    discardTemporaryValue: pb,
    permanentlySetValue: e,
    isValid: i => !!i.match(Dz),
    autoFocus: c
  })), l.node);
}
var A3,
  mb,
  R31,
  fb,
  b31,
  Mb,
  F31,
  pb,
  xb,
  I31,
  Cb,
  Lb = x(() => {
    "use strict";

    Wz();
    Wz();
    A3 = I(G());
    _R();
    c1();
    c4();
    Lo();
    e4();
    R31 = B.div(mb || (mb = V(["\n  display: flex;\n  align-items: center;\n  height: 100%;\n  gap: 4px;\n"]))), b31 = B.div.attrs(t => ({
      style: {
        background: Ho(t.rgbaColor)
      }
    }))(fb || (fb = V(["\n  height: 18px;\n  aspect-ratio: 1;\n  border-radius: 99999px;\n"]))), F31 = B(O9)(Mb || (Mb = V(["\n  flex: 1;\n"]))), pb = () => {}, I31 = B.div(xb || (xb = V(["\n  position: absolute;\n  background-color: ", ";\n  color: white;\n  margin: 0;\n  cursor: default;\n  border-radius: 3px;\n  z-index: 10000;\n  backdrop-filter: blur(8px);\n\n  padding: 4px;\n  pointer-events: all;\n\n  border: none;\n  box-shadow: none;\n"])), tu);
    Cb = P31;
  });
function D31({
  propConfig: t,
  editingTools: a,
  value: c,
  autoFocus: r
}) {
  let [e, l] = r3.default.useState();
  (0, r3.useEffect)(() => {
    l(c ? a.getAssetUrl(c) : void 0);
  }, [c]);
  let i = (0, r3.useCallback)(n => e2(this, null, function* () {
      let h = n.target.files[0];
      a.permanentlySetValue({
        type: "image",
        id: void 0
      });
      let v = yield a.createAsset(h);
      v ? a.permanentlySetValue({
        type: "image",
        id: v
      }) : a.permanentlySetValue(c), n.target.value = null;
    }), [a, c]),
    o = !(c != null && c.id);
  return r3.default.createElement(Rb, {
    empty: o
  }, r3.default.createElement(T31, {
    empty: o,
    title: o ? "Upload image" : '"'.concat(c.id, '" (Click to upload new image)')
  }, r3.default.createElement(Z31, {
    type: "file",
    onChange: i,
    accept: "image/*,.hdr",
    autoFocus: r
  }), e ? r3.default.createElement(O31, {
    src: e
  }) : r3.default.createElement(G31, null)), !o && r3.default.createElement(E31, {
    title: "Delete image",
    onClick: () => {
      a.permanentlySetValue({
        type: "image",
        id: void 0
      });
    }
  }, r3.default.createElement(Oc, null)));
}
var r3,
  Hb,
  Rb,
  Vb,
  G31,
  wb,
  Bb,
  yb,
  T31,
  Sb,
  Z31,
  kb,
  O31,
  Ab,
  E31,
  bb,
  Fb = x(() => {
    "use strict";

    b9();
    r3 = I(G());
    c1();
    Rb = B.div(Hb || (Hb = V(["\n  display: flex;\n  align-items: center;\n  height: 100%;\n  gap: 4px;\n"]))), G31 = B.div(Vb || (Vb = V(["\n  position: absolute;\n  inset: -5px;\n  // rotate 45deg\n  transform: rotate(45deg);\n  --checker-color: #ededed36;\n  &:hover {\n    --checker-color: #ededed77;\n  }\n  // checkerboard background with 4px squares\n  background-image: linear-gradient(\n      45deg,\n      var(--checker-color) 25%,\n      transparent 25%\n    ),\n    linear-gradient(-45deg, var(--checker-color) 25%, transparent 25%),\n    linear-gradient(45deg, transparent 75%, var(--checker-color) 75%),\n    linear-gradient(-45deg, transparent 75%, var(--checker-color) 75%);\n  background-size: 5px 5px;\n"]))), T31 = B.label(yb || (yb = V(["\n  position: relative;\n  cursor: default;\n  box-sizing: border-box;\n\n  height: 18px;\n  aspect-ratio: 1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 16px;\n\n  overflow: hidden;\n  color: #ccc;\n  &:hover {\n    color: white;\n  }\n\n  border-radius: 99999px;\n  border: 1px solid hwb(220deg 40% 52%);\n  &:hover {\n    border-color: hwb(220deg 45% 52%);\n  }\n\n  ", "\n"])), t => t.empty ? f2(wb || (wb = V([""]))) : f2(Bb || (Bb = V([""])))), Z31 = B.input.attrs({
      type: "file"
    })(Sb || (Sb = V(["\n  display: none;\n"]))), O31 = B.img(kb || (kb = V(["\n  position: absolute;\n  inset: 0;\n  height: 100%;\n  aspect-ratio: 1;\n\n  object-fit: cover;\n"]))), E31 = B.button(Ab || (Ab = V(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  outline: none;\n  background: transparent;\n  color: #a8a8a9;\n\n  border: none;\n  height: 100%;\n  aspect-ratio: 1/1;\n\n  opacity: 0;\n\n  ", ":hover & {\n    opacity: 0.8;\n  }\n\n  &:hover {\n    opacity: 1;\n    color: white;\n  }\n"])), Rb);
    bb = D31;
  });
function N31({
  propConfig: t,
  editingTools: a,
  value: c,
  autoFocus: r
}) {
  let [e, l] = e3.default.useState();
  (0, e3.useEffect)(() => {
    l(c ? a.getAssetUrl(c) : void 0);
  }, [c]);
  let i = (0, e3.useCallback)(n => e2(this, null, function* () {
      let h = n.target.files[0];
      a.permanentlySetValue({
        type: "file",
        id: void 0
      });
      let v = yield a.createAsset(h);
      v ? a.permanentlySetValue({
        type: "file",
        id: v
      }) : a.permanentlySetValue(c), n.target.value = null;
    }), [a, c]),
    o = !(c != null && c.id);
  return e3.default.createElement(Db, {
    empty: o
  }, e3.default.createElement(_31, {
    empty: o,
    title: o ? "Upload file" : '"'.concat(c.id, '" (Click to upload new file)')
  }, e3.default.createElement(j31, {
    type: "file",
    onChange: i,
    autoFocus: r
  }), e ? e3.default.createElement(Tc, null) : e3.default.createElement(W31, null)), !o && e3.default.createElement(q31, {
    title: "Delete file",
    onClick: () => {
      a.permanentlySetValue({
        type: "file",
        id: void 0
      });
    }
  }, e3.default.createElement(Oc, null)));
}
var e3,
  Ib,
  Db,
  Pb,
  W31,
  Gb,
  Tb,
  Zb,
  _31,
  Ob,
  j31,
  Eb,
  q31,
  Wb,
  _b = x(() => {
    "use strict";

    b9();
    e3 = I(G());
    c1();
    Db = B.div(Ib || (Ib = V(["\n  display: flex;\n  align-items: center;\n  height: 100%;\n  gap: 4px;\n"]))), W31 = B.div(Pb || (Pb = V(["\n  position: absolute;\n  inset: -5px;\n  // rotate 45deg\n  transform: rotate(45deg);\n  --checker-color: #ededed36;\n  &:hover {\n    --checker-color: #ededed77;\n  }\n  // checkerboard background with 4px squares\n  background-image: linear-gradient(\n      45deg,\n      var(--checker-color) 25%,\n      transparent 25%\n    ),\n    linear-gradient(-45deg, var(--checker-color) 25%, transparent 25%),\n    linear-gradient(45deg, transparent 75%, var(--checker-color) 75%),\n    linear-gradient(-45deg, transparent 75%, var(--checker-color) 75%);\n  background-size: 5px 5px;\n"]))), _31 = B.label(Zb || (Zb = V(["\n  position: relative;\n  cursor: default;\n  box-sizing: border-box;\n\n  height: 18px;\n  aspect-ratio: 1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 16px;\n\n  overflow: hidden;\n  color: #ccc;\n  &:hover {\n    color: white;\n  }\n\n  border-radius: 99999px;\n  border: 1px solid hwb(220deg 40% 52%);\n  &:hover {\n    border-color: hwb(220deg 45% 52%);\n  }\n\n  ", "\n"])), t => t.empty ? f2(Gb || (Gb = V([""]))) : f2(Tb || (Tb = V([""])))), j31 = B.input.attrs({
      type: "file"
    })(Ob || (Ob = V(["\n  display: none;\n"]))), q31 = B.button(Eb || (Eb = V(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  outline: none;\n  background: transparent;\n  color: #a8a8a9;\n\n  border: none;\n  height: 100%;\n  aspect-ratio: 1/1;\n\n  opacity: 0;\n\n  ", ":hover & {\n    opacity: 0.8;\n  }\n\n  &:hover {\n    opacity: 1;\n    color: white;\n  }\n"])), Db);
    Wb = N31;
  });
var Go,
  au = x(() => {
    "use strict";

    cA();
    Gz();
    iR();
    gR();
    Lb();
    Fb();
    _b();
    Go = {
      number: xo,
      string: vR,
      boolean: aA,
      stringLiteral: lR,
      rgba: Cb,
      image: bb,
      file: Wb
    };
  });
function T4(t) {
  let a = new WeakMap();
  return c => (a.has(c) || a.set(c, t(c)), a.get(c));
}
var tr = x(() => {
  "use strict";
});
function G0(t) {
  return t.type === "compound" || t.type === "enum";
}
function U9(t, a) {
  if (!t) return;
  let [c, ...r] = a;
  if (c === void 0) return t;
  if (!G0(t)) return;
  let e = t.type === "enum" ? t.cases[c] : t.props[c];
  return U9(e, r);
}
function X8(t, a) {
  let c = a.deserializeAndSanitize(t);
  return c === void 0 ? a.default : c;
}
function jb(t) {
  return !G0(t);
}
function* Y8(t, a) {
  if (t.type === "compound") for (let c in t.props) yield* Vf(Y8(t.props[c], [...a, c]));else {
    if (t.type === "enum") throw new Error("Not implemented yet");
    return yield {
      path: a,
      conf: t
    };
  }
}
var cu,
  H5 = x(() => {
    "use strict";

    tr();
    cu = T4(t => {
      if (t.type === "enum") throw new Error("Not implemented yet for enums");
      for (let a in t.props) {
        let c = t.props[a];
        if (G0(c)) {
          if (cu(c)) return !0;
        } else return !0;
      }
      return !1;
    });
  });
var To,
  ru = x(() => {
    "use strict";

    To = "calc(var(--left-pad) + var(--depth) * var(--step))";
  });
var qb,
  T0,
  N6 = x(() => {
    "use strict";

    c1();
    T0 = f2(qb || (qb = V(["\n  font-weight: 300;\n  font-size: 11px;\n  color: ", ";\n  text-shadow: 0.5px 0.5px 2px rgba(0, 0, 0, 0.3);\n"])), t => t.isHighlighted === "self" ? "#CCC" : "#919191");
  });
var ar,
  Zo,
  Nb,
  U31,
  Ub,
  K31,
  $31,
  Kb,
  eu = x(() => {
    "use strict";

    W8();
    ar = I(G());
    c1();
    Zo = 26, U31 = B.li(Nb || (Nb = V(["\n  height: ", "px;\n  padding: 0 12px;\n  margin: 0;\n  display: flex;\n  align-items: center;\n  font-size: 11px;\n  font-weight: 400;\n  position: relative;\n  color: ", ";\n  cursor: ", ";\n\n  &:after {\n    position: absolute;\n    inset: 2px 1px;\n    display: block;\n    content: ' ';\n    pointer-events: none;\n    z-index: -1;\n    border-radius: 3px;\n  }\n\n  &:hover:after {\n    background-color: ", ";\n  }\n"])), Zo, t => t.enabled ? "white" : "#8f8f8f", t => t.enabled ? "normal" : "not-allowed", t => t.enabled ? "rgba(63, 174, 191, 0.75)" : "initial"), K31 = B.span(Ub || (Ub = V([""]))), $31 = t => ar.default.createElement(U31, {
      onClick: t.enabled ? t.onClick : h0,
      enabled: t.enabled,
      title: t.enabled ? void 0 : "Disabled"
    }, ar.default.createElement(K31, null, ar.default.createElement(ar.default.Fragment, null, t.label))), Kb = $31;
  });
function lu(t) {
  let a = (0, Oo.useRef)(t);
  a.current = t, (0, Oo.useEffect)(() => {
    let c = r => a.current(r);
    return window.addEventListener("keydown", c), () => {
      window.removeEventListener("keydown", c);
    };
  }, []);
}
var Oo,
  $b = x(() => {
    "use strict";

    Oo = I(G());
  });
var cr,
  Q31,
  X31,
  Qb,
  Y31,
  Xb,
  J31,
  t41,
  Eo,
  iu = x(() => {
    "use strict";

    cr = I(G());
    eu();
    c1();
    R0();
    G1();
    Q31 = 190, X31 = !0, Y31 = B.ul(Qb || (Qb = V(["\n  position: absolute;\n  min-width: ", "px;\n  z-index: 10000;\n  background: ", ";\n  backdrop-filter: blur(2px);\n  color: white;\n  list-style-type: none;\n  padding: 2px 0;\n  margin: 0;\n  border-radius: 1px;\n  cursor: default;\n  ", ";\n  border-radius: 3px;\n"])), Q31, N2(.2, "#111"), C1), J31 = B.div(Xb || (Xb = V(["\n  padding: 4px 10px;\n  border-bottom: 1px solid #6262626d;\n  color: #adadadb3;\n  font-size: 11px;\n  font-weight: 500;\n"]))), t41 = cr.default.forwardRef((t, a) => cr.default.createElement(Y31, {
      ref: a
    }, X31 && t.displayName ? cr.default.createElement(J31, null, t.displayName) : null, t.items.map((c, r) => cr.default.createElement(Kb, {
      key: "item-".concat(r),
      label: c.label,
      enabled: c.enabled !== !1,
      onClick: e => {
        c.callback && c.callback(e), t.onRequestClose();
      }
    })))), Eo = t41;
  });
var Yb,
  Jb,
  K9,
  tF,
  Do,
  a41,
  aF,
  cF = x(() => {
    "use strict";

    Qz();
    Yb = I(G()), Jb = I(G()), K9 = I(G()), tF = I(B4());
    Ao();
    eu();
    T6();
    $b();
    iu();
    Do = 20, a41 = t => {
      let [a, c] = (0, K9.useState)(null),
        r = j9(a),
        e = _9();
      (0, K9.useLayoutEffect)(() => {
        if (!r || !a) return;
        let o = {
            left: r.width / 2,
            top: Zo / 2 + (t.displayName ? Zo : 0)
          },
          n = {
            left: t.clickPoint.clientX - o.left,
            top: t.clickPoint.clientY - o.top
          };
        n.left < 0 ? n.left = 0 : n.left + r.width > e.width && (n.left = e.width - r.width), n.top < 0 ? n.top = 0 : n.top + r.height > e.height && (n.top = e.height - r.height), a.style.left = n.left + "px", a.style.top = n.top + "px";
        let h = v => {
          (v.clientX < n.left - Do || v.clientX > n.left + r.width + Do || v.clientY < n.top - Do || v.clientY > n.top + r.height + Do) && t.onRequestClose();
        };
        return window.addEventListener("mousemove", h), () => {
          window.removeEventListener("mousemove", h);
        };
      }, [r, a, t.clickPoint, e, t.onRequestClose]);
      let l = (0, Jb.useContext)(a3);
      lu(o => {
        o.key === "Escape" && t.onRequestClose();
      });
      let i = (0, Yb.useMemo)(() => {
        let o = Array.isArray(t.items) ? t.items : t.items();
        return o.length > 0 ? o : [{
          label: t.displayName ? "No actions for ".concat(t.displayName) : "No actions found",
          enabled: !1
        }];
      }, [t.items]);
      return (0, tF.createPortal)(K9.default.createElement(Eo, {
        items: i,
        onRequestClose: t.onRequestClose,
        displayName: t.displayName,
        ref: c
      }), l);
    }, aF = a41;
  });
var $9,
  c41,
  rF,
  eF = x(() => {
    "use strict";

    $9 = I(G()), c41 = (t, a) => {
      let [c, r] = (0, $9.useState)({
          isOpen: !1
        }),
        e = (0, $9.useCallback)(() => r({
          isOpen: !1
        }), []);
      return (0, $9.useEffect)(() => {
        if (!t || a.disabled === !0) {
          r({
            isOpen: !1
          });
          return;
        }
        let l = i => {
          r({
            isOpen: !0,
            event: i
          }), i.preventDefault(), i.stopPropagation();
        };
        return t.addEventListener("contextmenu", l), () => {
          t.removeEventListener("contextmenu", l);
        };
      }, [t, a.disabled]), [c, e];
    }, rF = c41;
  });
function Z1(t, a) {
  let [c, r] = rF(t, a),
    [, e] = (0, U6.useContext)(N9);
  return (0, U6.useEffect)(() => {
    var o;
    let i;
    return c.isOpen && ((o = a.onOpen) == null || o.call(a), i = e()), () => i == null ? void 0 : i();
  }, [c.isOpen, a.onOpen]), [c.isOpen ? U6.default.createElement(aF, {
    items: a.menuItems,
    displayName: a.displayName,
    clickPoint: c.event,
    onRequestClose: r
  }) : r41, r, c.isOpen];
}
var U6,
  r41,
  v0 = x(() => {
    "use strict";

    U6 = I(G());
    cF();
    eF();
    Io();
    r41 = U6.default.createElement(U6.default.Fragment, null);
  });
function l3(t, a) {
  return a.length === 0 ? t : D3(t, a);
}
var rr = x(() => {
  "use strict";

  D7();
});
function ou(t, a) {
  return t == null ? null : t instanceof Element && t.matches(a) ? t : ou(t.parentElement, a);
}
var lF = x(() => {
  "use strict";
});
function Z4(t, a) {
  let c = t;
  for (let r of a) c = c[r];
  return c;
}
var er = x(() => {
  "use strict";
});
function e41(t) {
  let a = new Wo.Atom(void 0),
    c = new Wo.Atom({}),
    r = new Wo.Atom({}),
    e = 0;
  return {
    addRelatedFlags(l, i) {
      let o = String(++e),
        n = i.map(h => {
          let v = {
              flag: h.flag
            },
            g = [h.affects, l, o];
          return r.setByPointer(s => Z4(s, g), v), g;
        });
      return () => {
        for (let h of n) r.setByPointer(v => Z4(v, h), void 0);
      };
    },
    usePresenceFlag(l) {
      if (!t.enabled) return;
      let i = (0, X9.useMemo)(() => {
        if (!l) return iF;
        let o = a.prism,
          n = (0, Q9.pointerToPrism)(c.pointer[l]),
          h = (0, Q9.pointerToPrism)(r.pointer[l]);
        return (0, Q9.prism)(() => {
          if (n.getValue()) return 2;
          {
            let g = h.getValue(),
              s = o.getValue(),
              d = g && s && g[s];
            if (d) {
              let z;
              for (let u of Object.values(d)) u && (z && z >= u.flag || (z = u.flag));
              return z;
            }
            return;
          }
        });
      }, [l]);
      return G8(i);
    },
    setUserHover(l) {
      let i = a.get();
      i !== l && (i && c.setByPointer(o => o[i], !1), a.set(l), l && c.setByPointer(o => o[l], !0));
    }
  };
}
function i3(t) {
  let a = X9.default.useContext(oF),
    c = a.usePresenceFlag(t);
  return {
    attrs: {
      [nu]: t
    },
    flag: c,
    useRelations(r, e) {
      (0, hu.useEffect)(() => t && a.addRelatedFlags(t, r()), [t, ...e]);
    }
  };
}
function _o(t) {
  let a = X9.default.useContext(oF),
    c = C0("PresenceListeners");
  (0, hu.useEffect)(() => {
    let r;
    if (!t) return;
    let e = l => {
      if (l.target instanceof Node) {
        let i = ou(l.target, "[".concat(nu, "]"));
        if (i) {
          let o = i.getAttribute(nu);
          r !== o && (r = o, a.setUserHover(o || void 0), c._debug("Updated current hover", {
            itemKey: o
          }));
          return;
        }
        r != null && (r = null, a.setUserHover(void 0), c._debug("Cleared current hover"));
      }
    };
    return t.addEventListener("mouseover", e), () => {
      t.removeEventListener("mouseover", e), r != null && (r = null, c._debug("Cleared current hover as part of cleanup"));
    };
  }, [t, a]);
}
var X9,
  hu,
  Q9,
  Wo,
  iF,
  oF,
  nu,
  K6 = x(() => {
    "use strict";

    X9 = I(G()), hu = I(G());
    L5();
    Q9 = require("@theatre/dataverse"), Wo = require("@theatre/dataverse");
    M1();
    lF();
    er();
    iF = (0, Q9.prism)(() => {});
    iF.keepHot();
    oF = X9.default.createContext(e41({
      enabled: !1
    })), nu = "data-pi-key";
  });
var U2,
  nF,
  jo,
  hF,
  mF,
  V5,
  vF,
  fF,
  gF,
  l41,
  dF,
  vu,
  sF,
  i41,
  zF,
  o41,
  uF,
  pF,
  lr,
  n41,
  qo,
  ir = x(() => {
    "use strict";

    G1();
    R0();
    U2 = I(G());
    c1();
    K6();
    jo = B.div(nF || (nF = V(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 16px;\n  margin: 0 0px 0 2px;\n  position: relative;\n  z-index: 0;\n  opacity: 0.7;\n\n  &:after {\n    position: absolute;\n    left: -14px;\n    right: -14px;\n    top: -2px;\n    bottom: -2px;\n    content: ' ';\n    display: none;\n    z-index: -1;\n    background: ", ";\n  }\n\n  &:hover {\n    opacity: 1;\n    &:after {\n      display: block;\n    }\n  }\n"])), N2(.2, "black")), mF = B.div(hF || (hF = V(["\n  background: none;\n  position: relative;\n  border: 0;\n  transition: transform 0.1s ease-out;\n  z-index: 0;\n  outline: none;\n  cursor: pointer;\n\n  &:after {\n    display: none;\n    ", ":hover & {\n      display: block;\n    }\n    position: absolute;\n    left: -4px;\n    right: -4px;\n    top: -4px;\n    bottom: -4px;\n    content: ' ';\n    z-index: -1;\n  }\n"])), jo), V5 = {
      offColor: "#555",
      onColor: "#e0c917"
    }, fF = B(mF)(vF || (vF = V(["\n  &:hover {\n    color: #e0c917;\n  }\n\n  color: ", ";\n"])), t => t.presence === 2 ? "white" : t.isOn ? V5.onColor : V5.offColor), l41 = f2(gF || (gF = V(["\n  pointer-events: none !important;\n"]))), vu = B(mF)(dF || (dF = V(["\n  color: ", ";\n\n  ", ";\n"])), t => t.flag === 2 ? "white" : t.available ? V5.onColor : V5.offColor, t => t.available ? C1 : l41), i41 = B(vu)(sF || (sF = V(["\n  transform: translateX(2px);\n  ", ":hover & {\n    transform: translateX(-7px);\n  }\n"])), jo), o41 = B(vu)(zF || (zF = V(["\n  transform: translateX(-2px);\n  ", ":hover & {\n    transform: translateX(7px);\n  }\n"])), jo);
    (l => {
      let t = B.g(uF || (uF = V(["\n    stroke-width: 1;\n    ", ":hover & path {\n      stroke-width: 3;\n    }\n  "])), vu);
      l.Prev = () => U2.default.createElement("svg", {
        width: "12",
        height: "12",
        viewBox: "0 0 12 12",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, U2.default.createElement(t, {
        transform: "translate(6 3)"
      }, U2.default.createElement("path", {
        d: "M4 1L1 4L4 7",
        stroke: "currentColor"
      }))), l.Next = () => U2.default.createElement("svg", {
        width: "12",
        height: "12",
        viewBox: "0 0 12 12",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, U2.default.createElement(t, {
        transform: "translate(1 3)"
      }, U2.default.createElement("path", {
        d: "M1 1L4 4L1 7",
        stroke: "currentColor"
      })));
      let r = B.g(pF || (pF = V(["\n    stroke-width: 0;\n    ", ":hover & path {\n      stroke: currentColor;\n      stroke-width: 2;\n    }\n  "])), fF);
      l.Cur = () => U2.default.createElement("svg", {
        width: "8",
        height: "12",
        viewBox: "0 0 8 12",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, U2.default.createElement(r, {
        transform: "translate(1 4)"
      }, U2.default.createElement("path", {
        d: "M3 0L6 3L3 6L0 3L3 0Z",
        fill: "currentColor"
      })));
    })(lr || (lr = {}));
    n41 = t => {
      var e, l, i, o, n;
      let a = i3((e = t.prev) == null ? void 0 : e.itemKey),
        c = i3(((l = t.cur) == null ? void 0 : l.type) === "on" ? t.cur.itemKey : void 0),
        r = i3((i = t.next) == null ? void 0 : i.itemKey);
      return U2.default.createElement(jo, null, U2.default.createElement(i41, S({
        available: !!t.prev,
        onClick: (o = t.prev) == null ? void 0 : o.jump,
        flag: a.flag
      }, a.attrs), U2.default.createElement(lr.Prev, null)), U2.default.createElement(fF, S({
        isOn: t.cur.type === "on",
        onClick: t.cur.toggle,
        presence: c.flag
      }, c.attrs), U2.default.createElement(lr.Cur, null)), U2.default.createElement(o41, S({
        available: !!t.next,
        onClick: (n = t.next) == null ? void 0 : n.jump,
        flag: r.flag
      }, r.attrs), U2.default.createElement(lr.Next, null)));
    }, qo = n41;
  });
var Uo,
  No,
  MF,
  h41,
  xF,
  v41,
  CF,
  g41,
  d41,
  Y9,
  gu = x(() => {
    "use strict";

    R0();
    Uo = I(G());
    c1();
    f1();
    ir();
    H5();
    No = {
      defaultState: {
        color: N2(.95, "#C4C4C4"),
        hoverColor: N2(.15, V5.onColor)
      },
      withStaticOverride: {
        color: N2(.85, "#C4C4C4"),
        hoverColor: N2(.15, V5.onColor)
      }
    }, h41 = B.div(MF || (MF = V(["\n  width: 16px;\n  margin: 0 0px 0 2px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n\n  color: ", ";\n\n  &:hover {\n    color: ", ";\n  }\n"])), t => t.hasStaticOverride ? No.withStaticOverride.color : No.defaultState.color, t => t.hasStaticOverride ? No.withStaticOverride.hoverColor : No.defaultState.hoverColor), v41 = B.div(xF || (xF = V(["\n  width: 5px;\n  height: 5px;\n  border-radius: 1px;\n  transform: rotate(45deg);\n  /* border: 1px solid currentColor; */\n  background-color: currentColor;\n"]))), g41 = B.div(CF || (CF = V(["\n  width: 5px;\n  height: 5px;\n  background-color: currentColor;\n  border-radius: 1px;\n  transform: rotate(45deg);\n"]))), d41 = t => {
      let {
        hasStaticOverride: a,
        obj: c,
        propConfig: r,
        pathToProp: e
      } = t;
      return Uo.default.createElement(h41, {
        hasStaticOverride: a,
        onClick: () => {
          T().transaction(({
            stateEditors: i
          }) => {
            for (let {
              path: o,
              conf: n
            } of Y8(r, e)) {
              if (G0(n)) continue;
              let h = D(S({}, c.address), {
                pathToProp: o
              });
              i.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsSequenced(h, r);
            }
          });
        },
        title: "Sequence this prop"
      }, a ? Uo.default.createElement(g41, {
        title: "The default value is overridden"
      }) : Uo.default.createElement(v41, {
        title: "This is the default value for this prop"
      }));
    }, Y9 = d41;
  });
function J8(t) {
  return JSON.stringify(du(t));
}
function du(t) {
  return M8(t) ? Object.keys(t).sort().reduce((a, c) => (a[c] = du(t[c]), a), {}) : Array.isArray(t) ? t.map(du) : t;
}
var LF = x(() => {
  "use strict";

  H2();
});
var s41,
  J9,
  su = x(() => {
    s41 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", J9 = (t = 21) => {
      let a = "",
        c = t;
      for (; c--;) a += s41[Math.random() * 64 | 0];
      return a;
    };
  });
function zu() {
  return J9(10);
}
function HF() {
  return J9(10);
}
function VF() {
  return J9(10);
}
var c2,
  O4 = x(() => {
    "use strict";

    LF();
    su();
    c2 = {
      forSheet() {
        return "sheet";
      },
      forSheetObject(t) {
        return J8({
          o: t.address.objectKey
        });
      },
      forSheetObjectProp(t, a) {
        return J8({
          o: t.address.objectKey,
          p: a
        });
      },
      forTrackKeyframe(t, a, c) {
        return J8({
          o: t.address.objectKey,
          t: a,
          k: c
        });
      },
      forSheetObjectAggregateKeyframe(t, a) {
        return c2.forCompoundPropAggregateKeyframe(t, [], a);
      },
      forSheetAggregateKeyframe(t, a) {
        return J8({
          o: t.address.sheetId,
          pos: a
        });
      },
      forCompoundPropAggregateKeyframe(t, a, c) {
        return J8({
          o: t.address.objectKey,
          p: a,
          pos: c
        });
      }
    };
  });
function Ko(t, a, c) {
  if (!a || a.data.keyframes.length === 0) return z41;
  let r = wF.get(a.data);
  if (r && r[0] === c) return r[1];
  function e(o) {
    if (!a) return;
    let n = a.data.keyframes[o];
    return n && {
      kf: n,
      track: a,
      itemKey: c2.forTrackKeyframe(t, a.id, n.id)
    };
  }
  let i = (() => {
    let o = a.data.keyframes.findIndex(h => h.position >= c);
    if (o === -1) return {
      prev: e(a.data.keyframes.length - 1)
    };
    let n = e(o);
    return n.kf.position === c ? {
      prev: e(o - 1),
      cur: n,
      next: e(o + 1)
    } : {
      next: n,
      prev: e(o - 1)
    };
  })();
  return wF.set(a.data, [c, i]), i;
}
var wF,
  z41,
  uu = x(() => {
    "use strict";

    O4();
    wF = new WeakMap(), z41 = {};
  });
var $o,
  pu = x(() => {
    "use strict";

    $o = {};
  });
function BF(t, a, c) {
  let r = (0, Z0.getPointerParts)(t).path;
  return v1(() => {
    if (!cu(c)) return {
      type: "AllStatic",
      beingScrubbed: !1,
      contextMenuItems: [],
      controlIndicators: t7.default.createElement(Y9, {
        hasStaticOverride: !1,
        obj: a,
        pathToProp: r,
        propConfig: c
      })
    };
    let e = !!(0, Z0.val)(D3(T().atomP.ephemeral.projects.stateByProjectId[a.address.projectId].stateBySheetId[a.address.sheetId].stateByObjectKey[a.address.objectKey].valuesBeingScrubbed, (0, Z0.getPointerParts)(t).path)),
      l = [],
      i = {
        beingScrubbed: e,
        contextMenuItems: l,
        controlIndicators: t7.default.createElement(t7.default.Fragment, null)
      },
      o = (0, Z0.val)(a.template.getMapOfValidSequenceTracks_forStudio()),
      n = l3(o, r),
      h = n !== void 0 && Object.keys(n).length !== 0,
      v = [],
      g = (0, Z0.val)(a.template.getStaticButNotSequencedOverrides()),
      d = l3(g != null ? g : $o, r) !== void 0;
    if (h) for (let z of Y8(c, [])) {
      if (G0(z.conf)) continue;
      let u = l3(n, z.path);
      typeof u != "string" ? d = !0 : v.push(u);
    }
    if ((d || h) && l.push({
      label: "Reset all to default",
      callback: () => {
        T().transaction(({
          unset: z
        }) => {
          z(t);
        });
      }
    }), h && l.push({
      label: "Make all static",
      callback: () => {
        T().transaction(({
          stateEditors: z
        }) => {
          for (let {
            path: u,
            conf: f
          } of Y8(c, [])) {
            if (G0(f)) continue;
            let p = D(S({}, a.address), {
                pathToProp: [...r, ...u]
              }),
              m = Z4(t, u);
            z.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsStatic(D(S({}, p), {
              value: a.getValueByPointer(m)
            }));
          }
        });
      }
    }), (!h || h && d) && l.push({
      label: "Sequence all",
      callback: () => {
        T().transaction(({
          stateEditors: z
        }) => {
          for (let {
            path: u,
            conf: f
          } of Y8(c, r)) {
            if (G0(f)) continue;
            let p = D(S({}, a.address), {
              pathToProp: u
            });
            z.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsSequenced(p, c);
          }
        });
      }
    }), h) {
      let z = Z0.prism.memo("controlIndicators", () => t7.default.createElement(u41, {
        pointerToProp: t,
        obj: a,
        possibleSequenceTrackIds: n,
        listOfDescendantTrackIds: v
      }), [n, v]);
      return D(S({}, i), {
        type: "HasSequences",
        controlIndicators: z
      });
    } else return D(S({}, i), {
      type: "AllStatic",
      controlIndicators: t7.default.createElement(Y9, {
        hasStaticOverride: d,
        obj: a,
        pathToProp: r,
        propConfig: c
      })
    });
  }, []);
}
function u41({
  pointerToProp: t,
  obj: a,
  possibleSequenceTrackIds: c,
  listOfDescendantTrackIds: r
}) {
  return v1(() => {
    let e = (0, Z0.getPointerParts)(t).path,
      l = (0, Z0.val)(a.sheet.getSequence().positionPrism),
      i = r.map(d => ({
        trackId: d,
        track: (0, Z0.val)(a.template.project.pointers.historic.sheetsById[a.address.sheetId].sequence.tracksByObject[a.address.objectKey].trackData[d])
      })).filter(({
        track: d
      }) => !!d).map(d => D(S({}, d), {
        nearbies: Ko(a, {
          id: d.trackId,
          data: d.track,
          sheetObject: a
        }, l)
      })),
      o = i.find(({
        nearbies: d
      }) => !!d.cur),
      n = i.every(({
        nearbies: d
      }) => !!d.cur),
      h = i.reduce((d, z) => z.nearbies.prev && (d === void 0 || z.nearbies.prev.kf.position > d.kf.position) ? z.nearbies.prev : d, void 0),
      v = i.reduce((d, z) => z.nearbies.next && (d === void 0 || z.nearbies.next.kf.position < d.kf.position) ? z.nearbies.next : d, void 0),
      g = () => {
        n ? T().transaction(d => {
          d.unset(t);
        }) : o ? T().transaction(d => {
          d.set(t, (0, Z0.val)(t));
        }) : T().transaction(d => {
          d.set(t, (0, Z0.val)(t));
        });
      },
      s = {
        cur: o ? {
          type: "on",
          itemKey: c2.forCompoundPropAggregateKeyframe(a, e, l),
          toggle: g
        } : {
          toggle: g,
          type: "off"
        },
        prev: h !== void 0 ? {
          position: h.kf.position,
          itemKey: c2.forCompoundPropAggregateKeyframe(a, e, h.kf.position),
          jump: () => {
            a.sheet.getSequence().position = h.kf.position;
          }
        } : void 0,
        next: v !== void 0 ? {
          position: v.kf.position,
          itemKey: c2.forCompoundPropAggregateKeyframe(a, e, v.kf.position),
          jump: () => {
            a.sheet.getSequence().position = v.kf.position;
          }
        } : void 0
      };
    return t7.default.createElement(qo, S({}, s));
  }, [t, a, c, r]);
}
var Z0,
  t7,
  yF = x(() => {
    "use strict";

    f1();
    rr();
    M1();
    Z0 = require("@theatre/dataverse");
    D7();
    t7 = I(G());
    gu();
    H5();
    O4();
    er();
    ir();
    uu();
    pu();
  });
function p41() {
  let t = 0,
    a = new AF.Atom({
      hasLock: !1
    });
  return {
    replaceLock(c, r) {
      let e = t++,
        l = a.get();
      return l.hasLock && l.cleanup(), a.set({
        hasLock: !0,
        lockId: e,
        cleanup: r,
        deepPath: m41(SF(c))
      }), function () {
        let o = a.get();
        o.hasLock && o.lockId === e && (o.cleanup(), a.set({
          hasLock: !1
        }));
      };
    },
    getIsPropHighlightedD(c) {
      let r = Z4(a.pointer.deepPath, SF(c));
      return (0, RF.prism)(() => {
        let e = (0, kF.val)(r);
        return e === !0 ? "self" : e ? "descendent" : null;
      });
    }
  };
}
function SF(t) {
  return [t.projectId, t.sheetId, t.objectKey, ...t.pathToProp];
}
function m41(t) {
  let a = {};
  return i6(a, t, !0), a;
}
var kF,
  AF,
  RF,
  tt,
  Qo = x(() => {
    "use strict";

    kF = require("@theatre/dataverse"), AF = require("@theatre/dataverse"), RF = require("@theatre/dataverse");
    er();
    Xe();
    tt = p41();
  });
function bF(t, a) {
  return JSON.stringify(t, a, 2).replace(/^([\{\[])\n (\s+)/, "$1$2").replace(/(\n[ ]+[\{\[])\n\s+/g, "$1 ").replace(/\n\s*([\]\}])/g, " $1");
}
var FF = x(() => {
  "use strict";
});
function mu(t, a = !0) {
  try {
    return typeof t == "string" ? t : typeof t == "function" || t instanceof Error ? t.toString() : a ? bF(t) : JSON.stringify(t);
  } catch (c) {
    return (t == null ? void 0 : t.name) || String(t);
  }
}
var IF = x(() => {
  "use strict";

  FF();
});
function GF(t, a, c) {
  t || (arguments.length > 2 ? PF(a, c) : PF(a));
}
function PF(t, a) {
  let c = arguments.length > 1,
    r = mu(typeof t == "function" ? t() : t),
    e = c ? "\nInstead found: ".concat(mu(a)) : "";
  throw new fu("Invariant: ".concat(r).concat(e), a);
}
var f41,
  M41,
  x41,
  C41,
  fu,
  TF = x(() => {
    "use strict";

    IF();
    f41 = /^\s*at.+node:internal.+/gm, M41 = /^\s*(at|[^@]+@) (?:Object\.)?invariant.+/gm, x41 = /^\s*(at|[^@]+@).+test\-helpers.+/gm, C41 = /^\s*(at|[^@]+@).+(debounce|invariant|iif)\.[tj]s.*/gm, fu = class extends Error {
      constructor(c, r) {
        var e;
        super(c);
        y1(this, "found");
        r !== void 0 && (this.found = r), this.stack = (e = this.stack) == null ? void 0 : e.replace(M41, "").replace(C41, "").replace(x41, "").replace(f41, "");
      }
    };
  });
function L41(t) {
  return (0, at.prism)(() => {
    if (Array.isArray(t)) {
      let a = new Array(t.length);
      for (let c = 0; c < t.length; c++) a[c] = t[c].getValue();
      return a;
    } else {
      let a = {};
      for (let c in t) a[c] = (0, at.val)(t[c]);
      return a;
    }
  });
}
function or(t) {
  let a = $6.default.memo($6.default.forwardRef(function (r, e) {
    let l = [],
      i = {},
      o = {
        ref: e
      };
    for (let g in r) {
      let s = r[g];
      (0, at.isPrism)(s) ? (l.push(s), i[g] = s) : o[g] = s;
    }
    let n = (0, $6.useRef)(l.length);
    GF(n.current === l.length, "expect same number of observable props on every invocation of deriver wrapped component.", {
      initial: n.current,
      count: l.length
    });
    let h = (0, $6.useMemo)(() => L41(i), l),
      v = G8(h);
    return v && $6.default.createElement(t, S(S({}, o), v));
  }));
  return a.displayName = "deriver(".concat(t.displayName, ")"), a;
}
var at,
  $6,
  Mu = x(() => {
    "use strict";

    at = require("@theatre/dataverse");
    M1();
    $6 = I(G());
    TF();
  });
function H41(t, a, c) {
  return (0, o3.prism)(() => {
    var z;
    let r = (0, o3.getPointerParts)(t).path,
      e = a.getValueByPointer(t),
      l = o3.prism.memo("editPropValue", () => {
        let u = null;
        return {
          temporarilySetValue(f) {
            u || (u = T().scrub()), u.capture(p => {
              p.set(t, f);
            });
          },
          discardTemporaryValue() {
            u && (u.discard(), u = null);
          },
          permanentlySetValue(f) {
            u ? (u.capture(p => {
              p.set(t, f);
            }), u.commit(), u = null) : T().transaction(p => {
              p.set(t, f);
            });
          }
        };
      }, []),
      i = {
        createAsset: u => a.sheet.project.assetStorage.createAsset(u),
        getAssetUrl: u => u.id ? a.sheet.project.assetStorage.getAssetUrl(u.id) : void 0
      },
      o = (0, o3.val)(D3(T().atomP.ephemeral.projects.stateByProjectId[a.address.projectId].stateBySheetId[a.address.sheetId].stateByObjectKey[a.address.objectKey].valuesBeingScrubbed, (0, o3.getPointerParts)(t).path)) === !0,
      n = [],
      h = D(S(S({}, l), i), {
        value: e,
        beingScrubbed: o,
        contextMenuItems: n,
        controlIndicators: ct.default.createElement(ct.default.Fragment, null)
      }),
      v = jb(c);
    if (v) {
      let u = (0, o3.val)(a.template.getMapOfValidSequenceTracks_forStudio()),
        f = l3(u, r);
      if (typeof f == "string") {
        n.push({
          label: "Make static",
          callback: () => {
            T().transaction(({
              stateEditors: U
            }) => {
              let A = D(S({}, a.address), {
                pathToProp: r
              });
              U.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsStatic(D(S({}, A), {
                value: a.getValueByPointer(t)
              }));
            });
          }
        });
        let m = f,
          M = o3.prism.sub("lcr", () => {
            let U = (0, o3.val)(a.template.project.pointers.historic.sheetsById[a.address.sheetId].sequence.tracksByObject[a.address.objectKey].trackData[m]),
              A = (0, o3.val)(a.sheet.getSequence().positionPrism);
            return Ko(a, U && {
              data: U,
              id: m,
              sheetObject: a
            }, A);
          }, [m]),
          w;
        h.beingScrubbed ? w = "Sequenced_OnKeyframe_BeingScrubbed" : M.cur ? w = "Sequenced_OnKeyframe" : ((z = M.prev) == null ? void 0 : z.kf.connectedRight) === !0 ? w = "Sequenced_BeingInterpolated" : w = "Sequened_NotBeingInterpolated";
        let H = () => {
            M.cur ? T().transaction(U => {
              U.unset(t);
            }) : T().transaction(U => {
              U.set(t, h.value);
            });
          },
          y = {
            cur: M.cur ? {
              type: "on",
              itemKey: M.cur.itemKey,
              toggle: H
            } : {
              type: "off",
              toggle: H
            },
            prev: M.prev !== void 0 ? {
              itemKey: M.prev.itemKey,
              position: M.prev.kf.position,
              jump: () => {
                a.sheet.getSequence().position = M.prev.kf.position;
              }
            } : void 0,
            next: M.next !== void 0 ? {
              itemKey: M.next.itemKey,
              position: M.next.kf.position,
              jump: () => {
                a.sheet.getSequence().position = M.next.kf.position;
              }
            } : void 0
          },
          k = ct.default.createElement(qo, S({}, y));
        return D(S({}, h), {
          type: "Sequenced",
          shade: w,
          nearbyKeyframes: M,
          controlIndicators: k
        });
      }
    }
    let g = (0, o3.val)(a.template.getStaticValues()),
      s = l3(g, r);
    return typeof s != "undefined" && n.push({
      label: "Reset to default",
      callback: () => {
        T().transaction(({
          unset: u
        }) => {
          u(t);
        });
      }
    }), v && n.push({
      label: "Sequence",
      callback: () => {
        T().transaction(({
          stateEditors: u
        }) => {
          let f = D(S({}, a.address), {
            pathToProp: r
          });
          u.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsSequenced(f, c);
        });
      }
    }), typeof s != "undefined" ? D(S({}, h), {
      type: "Static",
      shade: h.beingScrubbed ? "Static_BeingScrubbed" : "Static",
      controlIndicators: ct.default.createElement(Y9, {
        hasStaticOverride: !0,
        obj: a,
        pathToProp: r,
        propConfig: c
      })
    }) : D(S({}, h), {
      type: "Default",
      shade: "Default",
      controlIndicators: ct.default.createElement(Y9, {
        hasStaticOverride: !0,
        obj: a,
        pathToProp: r,
        propConfig: c
      })
    });
  });
}
function V41(t, a, c) {
  if (xu.has(t)) return xu.get(t);
  {
    let r = H41(t, a, c);
    return xu.set(t, r), r;
  }
}
function rt(t, a, c) {
  let r = V41(t, a, c);
  return G8(r);
}
var ct,
  o3,
  xu,
  Xo = x(() => {
    "use strict";

    D7();
    ct = I(G()), o3 = require("@theatre/dataverse");
    f1();
    rr();
    M1();
    H5();
    gu();
    uu();
    ir();
    xu = new WeakMap();
  });
function F41({
  propConfig: t,
  pointerToProp: a,
  obj: c,
  SimpleEditorComponent: r
}) {
  let e = rt(a, c, t);
  return R2.default.createElement(xo, {
    editingTools: e,
    propConfig: t,
    value: e.value
  });
}
function P41({
  pointerToProp: t,
  obj: a,
  propConfig: c,
  visualIndentation: r
}) {
  var m;
  let e = (m = c.label) != null ? m : M3((0, et.getPointerParts)(t).path),
    l = Object.entries(c.props),
    i = l.filter(([M, w]) => G0(w)),
    o = l.filter(([M, w]) => !G0(w)),
    [n, h] = z1(null),
    v = BF(t, a, c),
    [g] = Z1(h, {
      menuItems: v.contextMenuItems
    }),
    s = i.length > 0,
    d = (0, R2.useMemo)(() => tt.getIsPropHighlightedD(D(S({}, a.address), {
      pathToProp: (0, et.getPointerParts)(t).path
    })), [t]),
    z = "".concat(a.address.projectId, ",").concat(a.address.sheetId, ",").concat(a.address.sheetInstanceId, ",").concat(a.address.objectKey, ",").concat((0, et.getPointerParts)(t).path.join()),
    u = b41(c);
  (0, R2.useLayoutEffect)(() => {
    Cu.has(z) || Cu.set(z, new et.Atom(u));
  }, [z, c]);
  let f = Cu.get(z),
    p = v1(() => f ? (0, NF.val)(f.pointer) : u, [f]);
  return R2.default.createElement(w41, null, g, R2.default.createElement(UF, {
    style: {
      "--depth": r - 1
    }
  }, R2.default.createElement(B41, {
    isVectorProp: u
  }, R2.default.createElement(y41, null, v.controlIndicators), R2.default.createElement(S41, {
    isHighlighted: d,
    ref: n
  }, R2.default.createElement("span", null, e || "Props")), R2.default.createElement(k41, {
    isCollapsed: p,
    isVector: u,
    onClick: () => {
      f == null || f.set(!f.get());
    }
  }, R2.default.createElement(Co, null))), u && p && R2.default.createElement(I41, null, [...l].map(([M, w]) => R2.default.createElement(F41, {
    key: "prop-" + M,
    propConfig: w,
    pointerToProp: t[M],
    obj: a
  })))), !p && R2.default.createElement(R41, {
    style: {
      "--depth": r
    },
    depth: r,
    lastSubIsComposite: s
  }, [...o, ...i].map(([M, w]) => R2.default.createElement(Yo, {
    key: "prop-" + M,
    propConfig: w,
    pointerToProp: t[M],
    obj: a,
    visualIndentation: r + 1
  }))));
}
var et,
  R2,
  NF,
  ZF,
  w41,
  OF,
  UF,
  EF,
  B41,
  DF,
  y41,
  WF,
  S41,
  _F,
  k41,
  A41,
  jF,
  R41,
  b41,
  qF,
  I41,
  KF,
  Cu,
  $F = x(() => {
    "use strict";

    H5();
    et = require("@theatre/dataverse");
    ma();
    R0();
    R2 = I(G());
    c1();
    ru();
    N6();
    G1();
    P1();
    Lu();
    v0();
    yF();
    Qo();
    Mu();
    Gz();
    Xo();
    M1();
    NF = require("@theatre/dataverse");
    K8();
    tr();
    w41 = B.div(ZF || (ZF = V(["\n  --step: 15px;\n  --left-pad: 15px;\n  ", ";\n  --right-width: 60%;\n"])), C1), UF = B.div(OF || (OF = V(["\n  height: 30px;\n  display: flex;\n  align-items: stretch;\n  position: relative;\n"]))), B41 = B.div(EF || (EF = V(["\n  padding-left: ", ";\n  display: flex;\n  align-items: center;\n  overflow: hidden;\n  ", ";\n"])), To, ({
      isVectorProp: t
    }) => t ? "width: calc(100% - var(--right-width))" : ""), y41 = B.div(DF || (DF = V(["\n  flexshrink: 0;\n"]))), S41 = or(B.div(WF || (WF = V(["\n  margin-left: 4px;\n  cursor: default;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  gap: 4px;\n  user-select: none;\n  &:hover {\n    color: white;\n  }\n  overflow: hidden;\n\n  ", ";\n"])), () => T0)), k41 = B.span(_F || (_F = V(["\n  width: 28px;\n  height: 28px;\n  font-size: 9px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  transition: transform 0.05s ease-out, color 0.1s ease-out;\n  transform: rotateZ(", "deg);\n  color: #66686a;\n\n  visibility: ", ";\n\n  ", ":hover & {\n    visibility: visible;\n  }\n\n  &:hover {\n    transform: rotateZ(", "deg);\n    color: #c0c4c9;\n  }\n"])), t => t.isCollapsed ? 0 : 90, t => !t.isVector && t.isCollapsed || t.isVector && !t.isCollapsed ? "visible" : "hidden", UF, t => t.isCollapsed ? 15 : 75), A41 = N2(.05, "#282b2f"), R41 = B.div(jF || (jF = V(["\n  /* background: ", "; */\n  /* padding: ", " 0; */\n"])), ({
      depth: t
    }) => A6(t * .03, A41), t => t.lastSubIsComposite ? 0 : "4px"), b41 = T4(t => {
      let a = Object.entries(t.props);
      return a.length <= 3 && a.every(([c, r]) => r.type === "number" && ["x", "y", "z"].includes(c));
    });
    I41 = B.div(qF || (qF = V(["\n  display: flex;\n  align-items: center;\n  justify-content: stretch;\n  padding: 0 8px 0 2px;\n  box-sizing: border-box;\n  height: 100%;\n  width: var(--right-width);\n  flex-shrink: 0;\n  flex-grow: 0;\n"])));
    KF = R2.default.memo(P41), Cu = new Map();
  });
function QF({
  isHighlighted: t
}) {
  return t === "self" ? "#1857a4" : t === "descendent" ? "#0a2f5c" : "initial";
}
var XF = x(() => {
  "use strict";
});
function rI({
  propConfig: t,
  pointerToProp: a,
  editingTools: c,
  children: r,
  isPropHighlightedD: e
}) {
  var h;
  let l = (h = t.label) != null ? h : M3((0, Hu.getPointerParts)(a).path),
    [i, o] = z1(null),
    [n] = Z1(o, {
      menuItems: c.contextMenuItems
    });
  return lt.default.createElement(G41, {
    isHighlighted: e
  }, n, lt.default.createElement(T41, null, lt.default.createElement(O41, null, c.controlIndicators), lt.default.createElement(Z41, {
    isHighlighted: e,
    ref: i,
    title: ["obj", "props", ...(0, Hu.getPointerParts)(a).path].join(".")
  }, l)), lt.default.createElement(E41, null, r));
}
var Hu,
  lt,
  YF,
  G41,
  JF,
  T41,
  tI,
  Z41,
  aI,
  O41,
  cI,
  E41,
  eI = x(() => {
    "use strict";

    Hu = require("@theatre/dataverse");
    v0();
    P1();
    H2();
    lt = I(G());
    c1();
    G1();
    N6();
    Mu();
    ru();
    XF();
    G41 = or(B.div(YF || (YF = V(["\n  display: flex;\n  height: 30px;\n  justify-content: flex-start;\n  align-items: stretch;\n  // We cannot calculate both the container (details panel) width and the descendant\n  // (this) width dynamically. This leads to the container width being calculated\n  // without this percentage being taken into consideration leads to horizontal\n  // clipping/scrolling--the same way as if we explicitly fixed either the container\n  // width, or the descendant width.\n  // The correct solution for tabulated UIs with dynamic container widths is to use\n  // CSS grid. For now I fixed this issue by just giving a great enough width\n  // to the details panel so most things don't break.\n  --right-width: 60%;\n  position: relative;\n  ", ";\n\n  /* background-color: ", "; */\n"])), C1, QF)), T41 = B.div(JF || (JF = V(["\n  box-sizing: border-box;\n  padding-left: ", ";\n  padding-right: 4px;\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: stretch;\n  gap: 4px;\n  flex-grow: 0;\n  flex-shrink: 0;\n  width: calc(100% - var(--right-width));\n"])), To), Z41 = or(B.div(tI || (tI = V(["\n  text-align: left;\n  flex: 1 0;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: flex;\n  align-items: center;\n  user-select: none;\n  cursor: default;\n\n  ", ";\n  &:hover {\n    color: white;\n  }\n"])), T0)), O41 = B.div(aI || (aI = V(["\n  flex-basis: 8px;\n  flex: 0 0;\n  display: flex;\n  align-items: center;\n"]))), E41 = B.div(cI || (cI = V(["\n  display: flex;\n  align-items: center;\n  justify-content: stretch;\n  padding: 0 8px 0 2px;\n  box-sizing: border-box;\n  height: 100%;\n  width: var(--right-width);\n  flex-shrink: 0;\n  flex-grow: 0;\n"])));
  });
function D41({
  propConfig: t,
  pointerToProp: a,
  obj: c,
  SimpleEditorComponent: r
}) {
  let e = rt(a, c, t),
    l = (0, it.useMemo)(() => tt.getIsPropHighlightedD(D(S({}, c.address), {
      pathToProp: (0, lI.getPointerParts)(a).path
    })), [a]);
  return it.default.createElement(rI, {
    editingTools: e,
    propConfig: t,
    pointerToProp: a,
    isPropHighlightedD: l
  }, it.default.createElement(r, {
    editingTools: e,
    propConfig: t,
    value: e.value
  }));
}
var it,
  lI,
  iI,
  oI = x(() => {
    "use strict";

    it = I(G());
    Xo();
    eI();
    lI = require("@theatre/dataverse");
    Qo();
    iI = it.default.memo(D41);
  });
var nr,
  W41,
  Yo,
  Lu = x(() => {
    "use strict";

    nr = I(G());
    au();
    $F();
    oI();
    W41 = ({
      propConfig: t,
      visualIndentation: a,
      pointerToProp: c,
      obj: r
    }) => {
      if (t.type === "compound") return nr.default.createElement(KF, {
        obj: r,
        visualIndentation: a,
        pointerToProp: c,
        propConfig: t
      });
      if (t.type === "enum") return nr.default.createElement(nr.default.Fragment, null);
      {
        let e = Go[t.type];
        return nr.default.createElement(iI, {
          SimpleEditorComponent: e,
          obj: r,
          visualIndentation: a,
          pointerToProp: c,
          propConfig: t
        });
      }
    }, Yo = W41;
  });
function hr(t) {
  return Vu.has(t) || Vu.set(t, (_41++).toString()), Vu.get(t);
}
var Vu,
  _41,
  wu = x(() => {
    "use strict";

    Vu = new WeakMap(), _41 = 0;
  });
var ot,
  nI,
  j41,
  hI,
  q41,
  N41,
  vI,
  gI = x(() => {
    "use strict";

    ot = I(G());
    Lu();
    M1();
    wu();
    c1();
    j41 = B.div(nI || (nI = V(["\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n  padding: 8px;\n"]))), q41 = B.button(hI || (hI = V(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  outline: none;\n  border-radius: 2px;\n\n  color: #a8a8a9;\n  background: rgba(255, 255, 255, 0.1);\n\n  border: none;\n  height: 28px;\n\n  &:hover {\n    background: rgba(255, 255, 255, 0.15);\n  }\n\n  &:active {\n    background: rgba(255, 255, 255, 0.2);\n  }\n"]))), N41 = ({
      objects: t
    }) => {
      let a = t[0],
        c = s1(a.template.configPointer),
        r = s1(a.template._temp_actionsPointer);
      return ot.default.createElement(ot.default.Fragment, null, ot.default.createElement(Yo, {
        key: hr(a),
        obj: a,
        pointerToProp: a.propsP,
        propConfig: c,
        visualIndentation: 1
      }), ot.default.createElement(j41, null, r && Object.entries(r).map(([e, l]) => ot.default.createElement(q41, {
        key: e,
        onClick: () => {
          l(a.publicApi);
        }
      }, e))));
    }, vI = N41;
  });
var dI,
  U41,
  vr,
  Bu = x(() => {
    "use strict";

    c1();
    U41 = B.button(dI || (dI = V(["\n  text-align: center;\n  padding: 8px;\n  border-radius: 2px;\n  border: 1px solid #627b7b87;\n  background-color: #4b787d3d;\n  color: #eaeaea;\n  font-weight: 400;\n  display: block;\n  appearance: none;\n  flex-grow: 1;\n  cursor: ", ";\n  opacity: ", ";\n\n  &:hover {\n    background-color: #7dc1c878;\n    border-color: #9ebcbf;\n  }\n"])), t => t.disabled ? "none" : "pointer", t => t.disabled ? .4 : 1), vr = U41;
  });
var sI = x(() => {});
var zI,
  uI = x(() => {
    sI();
    zI = (t = 21) => {
      let a = "",
        c = crypto.getRandomValues(new Uint8Array(t));
      for (; t--;) {
        let r = c[t] & 63;
        r < 36 ? a += r.toString(36) : r < 62 ? a += (r - 26).toString(36).toUpperCase() : r < 63 ? a += "_" : a += "-";
      }
      return a;
    };
  });
function Jo() {
  return zI(16);
}
var yu = x(() => {
  "use strict";

  uI();
});
var pI,
  O0,
  mI,
  K41,
  fI,
  $41,
  MI,
  Su = x(() => {
    "use strict";

    pI = require("@theatre/dataverse");
    P1();
    O0 = I(G()), mI = (0, O0.createContext)(null), K41 = 0, fI = () => {
      let t = (0, O0.useMemo)(() => K41++, []),
        {
          cur: a,
          set: c
        } = (0, O0.useContext)(mI),
        [r, e] = z1(!1),
        l = (0, O0.useCallback)((i, o) => {
          c(i ? t : -1, o);
        }, []);
      return (0, O0.useEffect)(() => a.onStale(() => {
        let i = a.getValue() === t;
        r.current !== i && (r.current = i);
      }), [a, t]), [e, l];
    }, $41 = ({
      children: t
    }) => {
      let a = (0, O0.useMemo)(() => new pI.Atom(-1), []),
        c = a.prism,
        r = (0, O0.useMemo)(() => {
          let e;
          return (l, i) => {
            let o = e !== void 0;
            e !== void 0 && (clearTimeout(e), e = void 0), i === 0 || o ? a.set(l) : e = setTimeout(() => {
              a.set(l), e = void 0;
            }, i);
          };
        }, []);
      return O0.default.createElement(mI.Provider, {
        value: {
          cur: c,
          set: r
        }
      }, t);
    }, MI = $41;
  });
function R3(t, a) {
  let c = t.enabled !== !1,
    [r, e] = fI(),
    [l, i] = z1(null);
  (0, CI.useEffect)(() => {
    if (!c) return;
    let h = l.current;
    if (!h) return;
    let v = () => {
        var s;
        return e(!0, (s = t.enterDelay) != null ? s : 400);
      },
      g = () => {
        var s;
        return e(!1, (s = t.exitDelay) != null ? s : 200);
      };
    return h.addEventListener("mouseenter", v), h.addEventListener("mouseleave", g), () => {
      h.removeEventListener("mouseenter", v), h.removeEventListener("mouseleave", g);
    };
  }, [l, c, t.enterDelay, t.exitDelay]);
  let o = (0, xI.useContext)(a3);
  return [c && r && i ? (0, LI.createPortal)(tn.default.createElement(Fo, {
    children: a,
    target: i,
    onClickOutside: h0,
    verticalPlacement: t.verticalPlacement,
    verticalGap: t.verticalGap
  }), o) : tn.default.createElement(tn.default.Fragment, null), l, r];
}
var xI,
  CI,
  tn,
  LI,
  nt = x(() => {
    "use strict";

    P1();
    xI = I(G()), CI = I(G()), tn = I(G());
    Jz();
    LI = I(B4());
    Su();
    T6();
    W8();
  });
var HI,
  Q41,
  w5,
  gr = x(() => {
    "use strict";

    c1();
    e4();
    Q41 = B(T2)(HI || (HI = V(["\n  padding: 1em;\n  max-width: 240px;\n  pointer-events: none !important;\n  --popover-outer-stroke: transparent;\n  --popover-inner-stroke: #45464d;\n"]))), w5 = Q41;
  });
var E4,
  VI,
  X41,
  wI,
  Y41,
  BI,
  J41,
  t51,
  a51,
  yI,
  SI = x(() => {
    "use strict";

    M1();
    f1();
    E4 = I(G());
    c1();
    yu();
    nt();
    gr();
    Bu();
    X41 = B.div(VI || (VI = V(["\n  padding: 8px 10px;\n  position: relative;\n  background-color: #6d232352;\n  &:before {\n    position: absolute;\n    content: ' ';\n    display: block;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    width: 2px;\n    background-color: #ff000070;\n  }\n"]))), Y41 = B.div(wI || (wI = V(["\n  margin-bottom: 1em;\n  & a {\n    color: inherit;\n  }\n"]))), J41 = B.div(BI || (BI = V(["\n  display: flex;\n  gap: 8px;\n"]))), t51 = ({
      projectId: t
    }) => {
      let a = s1(T().atomP.ephemeral.coreByProject[t].loadingState);
      return a && a.type === "browserStateIsNotBasedOnDiskState" ? E4.default.createElement(a51, {
        loadingState: a,
        projectId: t
      }) : null;
    }, a51 = ({
      projectId: t,
      loadingState: a
    }) => {
      let c = () => {
          T().transaction(({
            drafts: n,
            stateEditors: h
          }) => {
            h.coreByProject.historic.revisionHistory.add({
              projectId: t,
              revision: a.onDiskState.revisionHistory[0]
            }), h.coreByProject.historic.revisionHistory.add({
              projectId: t,
              revision: Jo()
            }), n.ephemeral.coreByProject[t].loadingState = {
              type: "loaded"
            };
          });
        },
        r = () => {
          T().transaction(({
            drafts: n
          }) => {
            n.historic.coreByProject[t] = a.onDiskState, n.ephemeral.coreByProject[t].loadingState = {
              type: "loaded"
            };
          });
        },
        [e, l] = R3({}, () => E4.default.createElement(w5, null, "The browser's state will override the disk state.")),
        [i, o] = R3({}, () => E4.default.createElement(w5, null, "The disk's state will override the browser's state."));
      return E4.default.createElement(X41, null, E4.default.createElement(Y41, null, "Browser state is not based on disk state.", " ", E4.default.createElement("a", {
        href: "https://www.theatrejs.com/docs/latest/manual/projects#state",
        target: "_blank"
      }, "Learn more.")), E4.default.createElement(J41, null, e, E4.default.createElement(vr, {
        onClick: c,
        ref: l
      }, "Use browser's state"), i, E4.default.createElement(vr, {
        onClick: r,
        ref: o
      }, "Use disk state")));
    }, yI = t51;
  });
var AI = L1((kI, ku) => {
  (function (t) {
    typeof kI == "object" && typeof ku != "undefined" ? ku.exports = t() : typeof define == "function" && define.amd ? define([], t) : (typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this).JSZip = t();
  })(function () {
    return function t(a, c, r) {
      function e(o, n) {
        if (!c[o]) {
          if (!a[o]) {
            var h = typeof require == "function" && require;
            if (!n && h) return h(o, !0);
            if (l) return l(o, !0);
            var v = new Error("Cannot find module '" + o + "'");
            throw v.code = "MODULE_NOT_FOUND", v;
          }
          var g = c[o] = {
            exports: {}
          };
          a[o][0].call(g.exports, function (s) {
            var d = a[o][1][s];
            return e(d || s);
          }, g, g.exports, t, a, c, r);
        }
        return c[o].exports;
      }
      for (var l = typeof require == "function" && require, i = 0; i < r.length; i++) e(r[i]);
      return e;
    }({
      1: [function (t, a, c) {
        "use strict";

        var r = t("./utils"),
          e = t("./support"),
          l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        c.encode = function (i) {
          for (var o, n, h, v, g, s, d, z = [], u = 0, f = i.length, p = f, m = r.getTypeOf(i) !== "string"; u < i.length;) p = f - u, h = m ? (o = i[u++], n = u < f ? i[u++] : 0, u < f ? i[u++] : 0) : (o = i.charCodeAt(u++), n = u < f ? i.charCodeAt(u++) : 0, u < f ? i.charCodeAt(u++) : 0), v = o >> 2, g = (3 & o) << 4 | n >> 4, s = 1 < p ? (15 & n) << 2 | h >> 6 : 64, d = 2 < p ? 63 & h : 64, z.push(l.charAt(v) + l.charAt(g) + l.charAt(s) + l.charAt(d));
          return z.join("");
        }, c.decode = function (i) {
          var o,
            n,
            h,
            v,
            g,
            s,
            d = 0,
            z = 0,
            u = "data:";
          if (i.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
          var f,
            p = 3 * (i = i.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (i.charAt(i.length - 1) === l.charAt(64) && p--, i.charAt(i.length - 2) === l.charAt(64) && p--, p % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (f = e.uint8array ? new Uint8Array(0 | p) : new Array(0 | p); d < i.length;) o = l.indexOf(i.charAt(d++)) << 2 | (v = l.indexOf(i.charAt(d++))) >> 4, n = (15 & v) << 4 | (g = l.indexOf(i.charAt(d++))) >> 2, h = (3 & g) << 6 | (s = l.indexOf(i.charAt(d++))), f[z++] = o, g !== 64 && (f[z++] = n), s !== 64 && (f[z++] = h);
          return f;
        };
      }, {
        "./support": 30,
        "./utils": 32
      }],
      2: [function (t, a, c) {
        "use strict";

        var r = t("./external"),
          e = t("./stream/DataWorker"),
          l = t("./stream/Crc32Probe"),
          i = t("./stream/DataLengthProbe");
        function o(n, h, v, g, s) {
          this.compressedSize = n, this.uncompressedSize = h, this.crc32 = v, this.compression = g, this.compressedContent = s;
        }
        o.prototype = {
          getContentWorker: function () {
            var n = new e(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new i("data_length")),
              h = this;
            return n.on("end", function () {
              if (this.streamInfo.data_length !== h.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
            }), n;
          },
          getCompressedWorker: function () {
            return new e(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
          }
        }, o.createWorkerFrom = function (n, h, v) {
          return n.pipe(new l()).pipe(new i("uncompressedSize")).pipe(h.compressWorker(v)).pipe(new i("compressedSize")).withStreamInfo("compression", h);
        }, a.exports = o;
      }, {
        "./external": 6,
        "./stream/Crc32Probe": 25,
        "./stream/DataLengthProbe": 26,
        "./stream/DataWorker": 27
      }],
      3: [function (t, a, c) {
        "use strict";

        var r = t("./stream/GenericWorker");
        c.STORE = {
          magic: "\0\0",
          compressWorker: function () {
            return new r("STORE compression");
          },
          uncompressWorker: function () {
            return new r("STORE decompression");
          }
        }, c.DEFLATE = t("./flate");
      }, {
        "./flate": 7,
        "./stream/GenericWorker": 28
      }],
      4: [function (t, a, c) {
        "use strict";

        var r = t("./utils"),
          e = function () {
            for (var l, i = [], o = 0; o < 256; o++) {
              l = o;
              for (var n = 0; n < 8; n++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
              i[o] = l;
            }
            return i;
          }();
        a.exports = function (l, i) {
          return l !== void 0 && l.length ? r.getTypeOf(l) !== "string" ? function (o, n, h, v) {
            var g = e,
              s = v + h;
            o ^= -1;
            for (var d = v; d < s; d++) o = o >>> 8 ^ g[255 & (o ^ n[d])];
            return -1 ^ o;
          }(0 | i, l, l.length, 0) : function (o, n, h, v) {
            var g = e,
              s = v + h;
            o ^= -1;
            for (var d = v; d < s; d++) o = o >>> 8 ^ g[255 & (o ^ n.charCodeAt(d))];
            return -1 ^ o;
          }(0 | i, l, l.length, 0) : 0;
        };
      }, {
        "./utils": 32
      }],
      5: [function (t, a, c) {
        "use strict";

        c.base64 = !1, c.binary = !1, c.dir = !1, c.createFolders = !0, c.date = null, c.compression = null, c.compressionOptions = null, c.comment = null, c.unixPermissions = null, c.dosPermissions = null;
      }, {}],
      6: [function (t, a, c) {
        "use strict";

        var r = null;
        r = typeof Promise != "undefined" ? Promise : t("lie"), a.exports = {
          Promise: r
        };
      }, {
        lie: 37
      }],
      7: [function (t, a, c) {
        "use strict";

        var r = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined",
          e = t("pako"),
          l = t("./utils"),
          i = t("./stream/GenericWorker"),
          o = r ? "uint8array" : "array";
        function n(h, v) {
          i.call(this, "FlateWorker/" + h), this._pako = null, this._pakoAction = h, this._pakoOptions = v, this.meta = {};
        }
        c.magic = "\b\0", l.inherits(n, i), n.prototype.processChunk = function (h) {
          this.meta = h.meta, this._pako === null && this._createPako(), this._pako.push(l.transformTo(o, h.data), !1);
        }, n.prototype.flush = function () {
          i.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
        }, n.prototype.cleanUp = function () {
          i.prototype.cleanUp.call(this), this._pako = null;
        }, n.prototype._createPako = function () {
          this._pako = new e[this._pakoAction]({
            raw: !0,
            level: this._pakoOptions.level || -1
          });
          var h = this;
          this._pako.onData = function (v) {
            h.push({
              data: v,
              meta: h.meta
            });
          };
        }, c.compressWorker = function (h) {
          return new n("Deflate", h);
        }, c.uncompressWorker = function () {
          return new n("Inflate", {});
        };
      }, {
        "./stream/GenericWorker": 28,
        "./utils": 32,
        pako: 38
      }],
      8: [function (t, a, c) {
        "use strict";

        function r(g, s) {
          var d,
            z = "";
          for (d = 0; d < s; d++) z += String.fromCharCode(255 & g), g >>>= 8;
          return z;
        }
        function e(g, s, d, z, u, f) {
          var p,
            m,
            M = g.file,
            w = g.compression,
            H = f !== o.utf8encode,
            y = l.transformTo("string", f(M.name)),
            k = l.transformTo("string", o.utf8encode(M.name)),
            F = M.comment,
            U = l.transformTo("string", f(F)),
            A = l.transformTo("string", o.utf8encode(F)),
            P = k.length !== M.name.length,
            C = A.length !== F.length,
            E = "",
            a1 = "",
            j = "",
            K = M.dir,
            Z = M.date,
            J = {
              crc32: 0,
              compressedSize: 0,
              uncompressedSize: 0
            };
          s && !d || (J.crc32 = g.crc32, J.compressedSize = g.compressedSize, J.uncompressedSize = g.uncompressedSize);
          var W = 0;
          s && (W |= 8), H || !P && !C || (W |= 2048);
          var _ = 0,
            g1 = 0;
          K && (_ |= 16), u === "UNIX" ? (g1 = 798, _ |= function ($, o1) {
            var u1 = $;
            return $ || (u1 = o1 ? 16893 : 33204), (65535 & u1) << 16;
          }(M.unixPermissions, K)) : (g1 = 20, _ |= function ($) {
            return 63 & ($ || 0);
          }(M.dosPermissions)), p = Z.getUTCHours(), p <<= 6, p |= Z.getUTCMinutes(), p <<= 5, p |= Z.getUTCSeconds() / 2, m = Z.getUTCFullYear() - 1980, m <<= 4, m |= Z.getUTCMonth() + 1, m <<= 5, m |= Z.getUTCDate(), P && (a1 = r(1, 1) + r(n(y), 4) + k, E += "up" + r(a1.length, 2) + a1), C && (j = r(1, 1) + r(n(U), 4) + A, E += "uc" + r(j.length, 2) + j);
          var X = "";
          return X += "\n\0", X += r(W, 2), X += w.magic, X += r(p, 2), X += r(m, 2), X += r(J.crc32, 4), X += r(J.compressedSize, 4), X += r(J.uncompressedSize, 4), X += r(y.length, 2), X += r(E.length, 2), {
            fileRecord: h.LOCAL_FILE_HEADER + X + y + E,
            dirRecord: h.CENTRAL_FILE_HEADER + r(g1, 2) + X + r(U.length, 2) + "\0\0\0\0" + r(_, 4) + r(z, 4) + y + E + U
          };
        }
        var l = t("../utils"),
          i = t("../stream/GenericWorker"),
          o = t("../utf8"),
          n = t("../crc32"),
          h = t("../signature");
        function v(g, s, d, z) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = s, this.zipPlatform = d, this.encodeFileName = z, this.streamFiles = g, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        l.inherits(v, i), v.prototype.push = function (g) {
          var s = g.meta.percent || 0,
            d = this.entriesCount,
            z = this._sources.length;
          this.accumulate ? this.contentBuffer.push(g) : (this.bytesWritten += g.data.length, i.prototype.push.call(this, {
            data: g.data,
            meta: {
              currentFile: this.currentFile,
              percent: d ? (s + 100 * (d - z - 1)) / d : 100
            }
          }));
        }, v.prototype.openedSource = function (g) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = g.file.name;
          var s = this.streamFiles && !g.file.dir;
          if (s) {
            var d = e(g, s, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({
              data: d.fileRecord,
              meta: {
                percent: 0
              }
            });
          } else this.accumulate = !0;
        }, v.prototype.closedSource = function (g) {
          this.accumulate = !1;
          var s = this.streamFiles && !g.file.dir,
            d = e(g, s, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(d.dirRecord), s) this.push({
            data: function (z) {
              return h.DATA_DESCRIPTOR + r(z.crc32, 4) + r(z.compressedSize, 4) + r(z.uncompressedSize, 4);
            }(g),
            meta: {
              percent: 100
            }
          });else for (this.push({
            data: d.fileRecord,
            meta: {
              percent: 0
            }
          }); this.contentBuffer.length;) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, v.prototype.flush = function () {
          for (var g = this.bytesWritten, s = 0; s < this.dirRecords.length; s++) this.push({
            data: this.dirRecords[s],
            meta: {
              percent: 100
            }
          });
          var d = this.bytesWritten - g,
            z = function (u, f, p, m, M) {
              var w = l.transformTo("string", M(m));
              return h.CENTRAL_DIRECTORY_END + "\0\0\0\0" + r(u, 2) + r(u, 2) + r(f, 4) + r(p, 4) + r(w.length, 2) + w;
            }(this.dirRecords.length, d, g, this.zipComment, this.encodeFileName);
          this.push({
            data: z,
            meta: {
              percent: 100
            }
          });
        }, v.prototype.prepareNextSource = function () {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, v.prototype.registerPrevious = function (g) {
          this._sources.push(g);
          var s = this;
          return g.on("data", function (d) {
            s.processChunk(d);
          }), g.on("end", function () {
            s.closedSource(s.previous.streamInfo), s._sources.length ? s.prepareNextSource() : s.end();
          }), g.on("error", function (d) {
            s.error(d);
          }), this;
        }, v.prototype.resume = function () {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
        }, v.prototype.error = function (g) {
          var s = this._sources;
          if (!i.prototype.error.call(this, g)) return !1;
          for (var d = 0; d < s.length; d++) try {
            s[d].error(g);
          } catch (z) {}
          return !0;
        }, v.prototype.lock = function () {
          i.prototype.lock.call(this);
          for (var g = this._sources, s = 0; s < g.length; s++) g[s].lock();
        }, a.exports = v;
      }, {
        "../crc32": 4,
        "../signature": 23,
        "../stream/GenericWorker": 28,
        "../utf8": 31,
        "../utils": 32
      }],
      9: [function (t, a, c) {
        "use strict";

        var r = t("../compressions"),
          e = t("./ZipFileWorker");
        c.generateWorker = function (l, i, o) {
          var n = new e(i.streamFiles, o, i.platform, i.encodeFileName),
            h = 0;
          try {
            l.forEach(function (v, g) {
              h++;
              var s = function (f, p) {
                  var m = f || p,
                    M = r[m];
                  if (!M) throw new Error(m + " is not a valid compression method !");
                  return M;
                }(g.options.compression, i.compression),
                d = g.options.compressionOptions || i.compressionOptions || {},
                z = g.dir,
                u = g.date;
              g._compressWorker(s, d).withStreamInfo("file", {
                name: v,
                dir: z,
                date: u,
                comment: g.comment || "",
                unixPermissions: g.unixPermissions,
                dosPermissions: g.dosPermissions
              }).pipe(n);
            }), n.entriesCount = h;
          } catch (v) {
            n.error(v);
          }
          return n;
        };
      }, {
        "../compressions": 3,
        "./ZipFileWorker": 8
      }],
      10: [function (t, a, c) {
        "use strict";

        function r() {
          if (!(this instanceof r)) return new r();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = Object.create(null), this.comment = null, this.root = "", this.clone = function () {
            var e = new r();
            for (var l in this) typeof this[l] != "function" && (e[l] = this[l]);
            return e;
          };
        }
        (r.prototype = t("./object")).loadAsync = t("./load"), r.support = t("./support"), r.defaults = t("./defaults"), r.version = "3.10.1", r.loadAsync = function (e, l) {
          return new r().loadAsync(e, l);
        }, r.external = t("./external"), a.exports = r;
      }, {
        "./defaults": 5,
        "./external": 6,
        "./load": 11,
        "./object": 15,
        "./support": 30
      }],
      11: [function (t, a, c) {
        "use strict";

        var r = t("./utils"),
          e = t("./external"),
          l = t("./utf8"),
          i = t("./zipEntries"),
          o = t("./stream/Crc32Probe"),
          n = t("./nodejsUtils");
        function h(v) {
          return new e.Promise(function (g, s) {
            var d = v.decompressed.getContentWorker().pipe(new o());
            d.on("error", function (z) {
              s(z);
            }).on("end", function () {
              d.streamInfo.crc32 !== v.decompressed.crc32 ? s(new Error("Corrupted zip : CRC32 mismatch")) : g();
            }).resume();
          });
        }
        a.exports = function (v, g) {
          var s = this;
          return g = r.extend(g || {}, {
            base64: !1,
            checkCRC32: !1,
            optimizedBinaryString: !1,
            createFolders: !1,
            decodeFileName: l.utf8decode
          }), n.isNode && n.isStream(v) ? e.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : r.prepareContent("the loaded zip file", v, !0, g.optimizedBinaryString, g.base64).then(function (d) {
            var z = new i(g);
            return z.load(d), z;
          }).then(function (d) {
            var z = [e.Promise.resolve(d)],
              u = d.files;
            if (g.checkCRC32) for (var f = 0; f < u.length; f++) z.push(h(u[f]));
            return e.Promise.all(z);
          }).then(function (d) {
            for (var z = d.shift(), u = z.files, f = 0; f < u.length; f++) {
              var p = u[f],
                m = p.fileNameStr,
                M = r.resolve(p.fileNameStr);
              s.file(M, p.decompressed, {
                binary: !0,
                optimizedBinaryString: !0,
                date: p.date,
                dir: p.dir,
                comment: p.fileCommentStr.length ? p.fileCommentStr : null,
                unixPermissions: p.unixPermissions,
                dosPermissions: p.dosPermissions,
                createFolders: g.createFolders
              }), p.dir || (s.file(M).unsafeOriginalName = m);
            }
            return z.zipComment.length && (s.comment = z.zipComment), s;
          });
        };
      }, {
        "./external": 6,
        "./nodejsUtils": 14,
        "./stream/Crc32Probe": 25,
        "./utf8": 31,
        "./utils": 32,
        "./zipEntries": 33
      }],
      12: [function (t, a, c) {
        "use strict";

        var r = t("../utils"),
          e = t("../stream/GenericWorker");
        function l(i, o) {
          e.call(this, "Nodejs stream input adapter for " + i), this._upstreamEnded = !1, this._bindStream(o);
        }
        r.inherits(l, e), l.prototype._bindStream = function (i) {
          var o = this;
          (this._stream = i).pause(), i.on("data", function (n) {
            o.push({
              data: n,
              meta: {
                percent: 0
              }
            });
          }).on("error", function (n) {
            o.isPaused ? this.generatedError = n : o.error(n);
          }).on("end", function () {
            o.isPaused ? o._upstreamEnded = !0 : o.end();
          });
        }, l.prototype.pause = function () {
          return !!e.prototype.pause.call(this) && (this._stream.pause(), !0);
        }, l.prototype.resume = function () {
          return !!e.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
        }, a.exports = l;
      }, {
        "../stream/GenericWorker": 28,
        "../utils": 32
      }],
      13: [function (t, a, c) {
        "use strict";

        var r = t("readable-stream").Readable;
        function e(l, i, o) {
          r.call(this, i), this._helper = l;
          var n = this;
          l.on("data", function (h, v) {
            n.push(h) || n._helper.pause(), o && o(v);
          }).on("error", function (h) {
            n.emit("error", h);
          }).on("end", function () {
            n.push(null);
          });
        }
        t("../utils").inherits(e, r), e.prototype._read = function () {
          this._helper.resume();
        }, a.exports = e;
      }, {
        "../utils": 32,
        "readable-stream": 16
      }],
      14: [function (t, a, c) {
        "use strict";

        a.exports = {
          isNode: typeof Buffer != "undefined",
          newBufferFrom: function (r, e) {
            if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(r, e);
            if (typeof r == "number") throw new Error('The "data" argument must not be a number');
            return new Buffer(r, e);
          },
          allocBuffer: function (r) {
            if (Buffer.alloc) return Buffer.alloc(r);
            var e = new Buffer(r);
            return e.fill(0), e;
          },
          isBuffer: function (r) {
            return Buffer.isBuffer(r);
          },
          isStream: function (r) {
            return r && typeof r.on == "function" && typeof r.pause == "function" && typeof r.resume == "function";
          }
        };
      }, {}],
      15: [function (t, a, c) {
        "use strict";

        function r(M, w, H) {
          var y,
            k = l.getTypeOf(w),
            F = l.extend(H || {}, n);
          F.date = F.date || new Date(), F.compression !== null && (F.compression = F.compression.toUpperCase()), typeof F.unixPermissions == "string" && (F.unixPermissions = parseInt(F.unixPermissions, 8)), F.unixPermissions && 16384 & F.unixPermissions && (F.dir = !0), F.dosPermissions && 16 & F.dosPermissions && (F.dir = !0), F.dir && (M = u(M)), F.createFolders && (y = z(M)) && f.call(this, y, !0);
          var U = k === "string" && F.binary === !1 && F.base64 === !1;
          H && H.binary !== void 0 || (F.binary = !U), (w instanceof h && w.uncompressedSize === 0 || F.dir || !w || w.length === 0) && (F.base64 = !1, F.binary = !0, w = "", F.compression = "STORE", k = "string");
          var A = null;
          A = w instanceof h || w instanceof i ? w : s.isNode && s.isStream(w) ? new d(M, w) : l.prepareContent(M, w, F.binary, F.optimizedBinaryString, F.base64);
          var P = new v(M, A, F);
          this.files[M] = P;
        }
        var e = t("./utf8"),
          l = t("./utils"),
          i = t("./stream/GenericWorker"),
          o = t("./stream/StreamHelper"),
          n = t("./defaults"),
          h = t("./compressedObject"),
          v = t("./zipObject"),
          g = t("./generate"),
          s = t("./nodejsUtils"),
          d = t("./nodejs/NodejsStreamInputAdapter"),
          z = function (M) {
            M.slice(-1) === "/" && (M = M.substring(0, M.length - 1));
            var w = M.lastIndexOf("/");
            return 0 < w ? M.substring(0, w) : "";
          },
          u = function (M) {
            return M.slice(-1) !== "/" && (M += "/"), M;
          },
          f = function (M, w) {
            return w = w !== void 0 ? w : n.createFolders, M = u(M), this.files[M] || r.call(this, M, null, {
              dir: !0,
              createFolders: w
            }), this.files[M];
          };
        function p(M) {
          return Object.prototype.toString.call(M) === "[object RegExp]";
        }
        var m = {
          load: function () {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          },
          forEach: function (M) {
            var w, H, y;
            for (w in this.files) y = this.files[w], (H = w.slice(this.root.length, w.length)) && w.slice(0, this.root.length) === this.root && M(H, y);
          },
          filter: function (M) {
            var w = [];
            return this.forEach(function (H, y) {
              M(H, y) && w.push(y);
            }), w;
          },
          file: function (M, w, H) {
            if (arguments.length !== 1) return M = this.root + M, r.call(this, M, w, H), this;
            if (p(M)) {
              var y = M;
              return this.filter(function (F, U) {
                return !U.dir && y.test(F);
              });
            }
            var k = this.files[this.root + M];
            return k && !k.dir ? k : null;
          },
          folder: function (M) {
            if (!M) return this;
            if (p(M)) return this.filter(function (k, F) {
              return F.dir && M.test(k);
            });
            var w = this.root + M,
              H = f.call(this, w),
              y = this.clone();
            return y.root = H.name, y;
          },
          remove: function (M) {
            M = this.root + M;
            var w = this.files[M];
            if (w || (M.slice(-1) !== "/" && (M += "/"), w = this.files[M]), w && !w.dir) delete this.files[M];else for (var H = this.filter(function (k, F) {
                return F.name.slice(0, M.length) === M;
              }), y = 0; y < H.length; y++) delete this.files[H[y].name];
            return this;
          },
          generate: function () {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          },
          generateInternalStream: function (M) {
            var w,
              H = {};
            try {
              if ((H = l.extend(M || {}, {
                streamFiles: !1,
                compression: "STORE",
                compressionOptions: null,
                type: "",
                platform: "DOS",
                comment: null,
                mimeType: "application/zip",
                encodeFileName: e.utf8encode
              })).type = H.type.toLowerCase(), H.compression = H.compression.toUpperCase(), H.type === "binarystring" && (H.type = "string"), !H.type) throw new Error("No output type specified.");
              l.checkSupport(H.type), H.platform !== "darwin" && H.platform !== "freebsd" && H.platform !== "linux" && H.platform !== "sunos" || (H.platform = "UNIX"), H.platform === "win32" && (H.platform = "DOS");
              var y = H.comment || this.comment || "";
              w = g.generateWorker(this, H, y);
            } catch (k) {
              (w = new i("error")).error(k);
            }
            return new o(w, H.type || "string", H.mimeType);
          },
          generateAsync: function (M, w) {
            return this.generateInternalStream(M).accumulate(w);
          },
          generateNodeStream: function (M, w) {
            return (M = M || {}).type || (M.type = "nodebuffer"), this.generateInternalStream(M).toNodejsStream(w);
          }
        };
        a.exports = m;
      }, {
        "./compressedObject": 2,
        "./defaults": 5,
        "./generate": 9,
        "./nodejs/NodejsStreamInputAdapter": 12,
        "./nodejsUtils": 14,
        "./stream/GenericWorker": 28,
        "./stream/StreamHelper": 29,
        "./utf8": 31,
        "./utils": 32,
        "./zipObject": 35
      }],
      16: [function (t, a, c) {
        "use strict";

        a.exports = t("stream");
      }, {
        stream: void 0
      }],
      17: [function (t, a, c) {
        "use strict";

        var r = t("./DataReader");
        function e(l) {
          r.call(this, l);
          for (var i = 0; i < this.data.length; i++) l[i] = 255 & l[i];
        }
        t("../utils").inherits(e, r), e.prototype.byteAt = function (l) {
          return this.data[this.zero + l];
        }, e.prototype.lastIndexOfSignature = function (l) {
          for (var i = l.charCodeAt(0), o = l.charCodeAt(1), n = l.charCodeAt(2), h = l.charCodeAt(3), v = this.length - 4; 0 <= v; --v) if (this.data[v] === i && this.data[v + 1] === o && this.data[v + 2] === n && this.data[v + 3] === h) return v - this.zero;
          return -1;
        }, e.prototype.readAndCheckSignature = function (l) {
          var i = l.charCodeAt(0),
            o = l.charCodeAt(1),
            n = l.charCodeAt(2),
            h = l.charCodeAt(3),
            v = this.readData(4);
          return i === v[0] && o === v[1] && n === v[2] && h === v[3];
        }, e.prototype.readData = function (l) {
          if (this.checkOffset(l), l === 0) return [];
          var i = this.data.slice(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, i;
        }, a.exports = e;
      }, {
        "../utils": 32,
        "./DataReader": 18
      }],
      18: [function (t, a, c) {
        "use strict";

        var r = t("../utils");
        function e(l) {
          this.data = l, this.length = l.length, this.index = 0, this.zero = 0;
        }
        e.prototype = {
          checkOffset: function (l) {
            this.checkIndex(this.index + l);
          },
          checkIndex: function (l) {
            if (this.length < this.zero + l || l < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + l + "). Corrupted zip ?");
          },
          setIndex: function (l) {
            this.checkIndex(l), this.index = l;
          },
          skip: function (l) {
            this.setIndex(this.index + l);
          },
          byteAt: function () {},
          readInt: function (l) {
            var i,
              o = 0;
            for (this.checkOffset(l), i = this.index + l - 1; i >= this.index; i--) o = (o << 8) + this.byteAt(i);
            return this.index += l, o;
          },
          readString: function (l) {
            return r.transformTo("string", this.readData(l));
          },
          readData: function () {},
          lastIndexOfSignature: function () {},
          readAndCheckSignature: function () {},
          readDate: function () {
            var l = this.readInt(4);
            return new Date(Date.UTC(1980 + (l >> 25 & 127), (l >> 21 & 15) - 1, l >> 16 & 31, l >> 11 & 31, l >> 5 & 63, (31 & l) << 1));
          }
        }, a.exports = e;
      }, {
        "../utils": 32
      }],
      19: [function (t, a, c) {
        "use strict";

        var r = t("./Uint8ArrayReader");
        function e(l) {
          r.call(this, l);
        }
        t("../utils").inherits(e, r), e.prototype.readData = function (l) {
          this.checkOffset(l);
          var i = this.data.slice(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, i;
        }, a.exports = e;
      }, {
        "../utils": 32,
        "./Uint8ArrayReader": 21
      }],
      20: [function (t, a, c) {
        "use strict";

        var r = t("./DataReader");
        function e(l) {
          r.call(this, l);
        }
        t("../utils").inherits(e, r), e.prototype.byteAt = function (l) {
          return this.data.charCodeAt(this.zero + l);
        }, e.prototype.lastIndexOfSignature = function (l) {
          return this.data.lastIndexOf(l) - this.zero;
        }, e.prototype.readAndCheckSignature = function (l) {
          return l === this.readData(4);
        }, e.prototype.readData = function (l) {
          this.checkOffset(l);
          var i = this.data.slice(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, i;
        }, a.exports = e;
      }, {
        "../utils": 32,
        "./DataReader": 18
      }],
      21: [function (t, a, c) {
        "use strict";

        var r = t("./ArrayReader");
        function e(l) {
          r.call(this, l);
        }
        t("../utils").inherits(e, r), e.prototype.readData = function (l) {
          if (this.checkOffset(l), l === 0) return new Uint8Array(0);
          var i = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, i;
        }, a.exports = e;
      }, {
        "../utils": 32,
        "./ArrayReader": 17
      }],
      22: [function (t, a, c) {
        "use strict";

        var r = t("../utils"),
          e = t("../support"),
          l = t("./ArrayReader"),
          i = t("./StringReader"),
          o = t("./NodeBufferReader"),
          n = t("./Uint8ArrayReader");
        a.exports = function (h) {
          var v = r.getTypeOf(h);
          return r.checkSupport(v), v !== "string" || e.uint8array ? v === "nodebuffer" ? new o(h) : e.uint8array ? new n(r.transformTo("uint8array", h)) : new l(r.transformTo("array", h)) : new i(h);
        };
      }, {
        "../support": 30,
        "../utils": 32,
        "./ArrayReader": 17,
        "./NodeBufferReader": 19,
        "./StringReader": 20,
        "./Uint8ArrayReader": 21
      }],
      23: [function (t, a, c) {
        "use strict";

        c.LOCAL_FILE_HEADER = "PK", c.CENTRAL_FILE_HEADER = "PK", c.CENTRAL_DIRECTORY_END = "PK", c.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", c.ZIP64_CENTRAL_DIRECTORY_END = "PK", c.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}],
      24: [function (t, a, c) {
        "use strict";

        var r = t("./GenericWorker"),
          e = t("../utils");
        function l(i) {
          r.call(this, "ConvertWorker to " + i), this.destType = i;
        }
        e.inherits(l, r), l.prototype.processChunk = function (i) {
          this.push({
            data: e.transformTo(this.destType, i.data),
            meta: i.meta
          });
        }, a.exports = l;
      }, {
        "../utils": 32,
        "./GenericWorker": 28
      }],
      25: [function (t, a, c) {
        "use strict";

        var r = t("./GenericWorker"),
          e = t("../crc32");
        function l() {
          r.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        t("../utils").inherits(l, r), l.prototype.processChunk = function (i) {
          this.streamInfo.crc32 = e(i.data, this.streamInfo.crc32 || 0), this.push(i);
        }, a.exports = l;
      }, {
        "../crc32": 4,
        "../utils": 32,
        "./GenericWorker": 28
      }],
      26: [function (t, a, c) {
        "use strict";

        var r = t("../utils"),
          e = t("./GenericWorker");
        function l(i) {
          e.call(this, "DataLengthProbe for " + i), this.propName = i, this.withStreamInfo(i, 0);
        }
        r.inherits(l, e), l.prototype.processChunk = function (i) {
          if (i) {
            var o = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = o + i.data.length;
          }
          e.prototype.processChunk.call(this, i);
        }, a.exports = l;
      }, {
        "../utils": 32,
        "./GenericWorker": 28
      }],
      27: [function (t, a, c) {
        "use strict";

        var r = t("../utils"),
          e = t("./GenericWorker");
        function l(i) {
          e.call(this, "DataWorker");
          var o = this;
          this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, i.then(function (n) {
            o.dataIsReady = !0, o.data = n, o.max = n && n.length || 0, o.type = r.getTypeOf(n), o.isPaused || o._tickAndRepeat();
          }, function (n) {
            o.error(n);
          });
        }
        r.inherits(l, e), l.prototype.cleanUp = function () {
          e.prototype.cleanUp.call(this), this.data = null;
        }, l.prototype.resume = function () {
          return !!e.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, r.delay(this._tickAndRepeat, [], this)), !0);
        }, l.prototype._tickAndRepeat = function () {
          this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (r.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
        }, l.prototype._tick = function () {
          if (this.isPaused || this.isFinished) return !1;
          var i = null,
            o = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              i = this.data.substring(this.index, o);
              break;
            case "uint8array":
              i = this.data.subarray(this.index, o);
              break;
            case "array":
            case "nodebuffer":
              i = this.data.slice(this.index, o);
          }
          return this.index = o, this.push({
            data: i,
            meta: {
              percent: this.max ? this.index / this.max * 100 : 0
            }
          });
        }, a.exports = l;
      }, {
        "../utils": 32,
        "./GenericWorker": 28
      }],
      28: [function (t, a, c) {
        "use strict";

        function r(e) {
          this.name = e || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
            data: [],
            end: [],
            error: []
          }, this.previous = null;
        }
        r.prototype = {
          push: function (e) {
            this.emit("data", e);
          },
          end: function () {
            if (this.isFinished) return !1;
            this.flush();
            try {
              this.emit("end"), this.cleanUp(), this.isFinished = !0;
            } catch (e) {
              this.emit("error", e);
            }
            return !0;
          },
          error: function (e) {
            return !this.isFinished && (this.isPaused ? this.generatedError = e : (this.isFinished = !0, this.emit("error", e), this.previous && this.previous.error(e), this.cleanUp()), !0);
          },
          on: function (e, l) {
            return this._listeners[e].push(l), this;
          },
          cleanUp: function () {
            this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
          },
          emit: function (e, l) {
            if (this._listeners[e]) for (var i = 0; i < this._listeners[e].length; i++) this._listeners[e][i].call(this, l);
          },
          pipe: function (e) {
            return e.registerPrevious(this);
          },
          registerPrevious: function (e) {
            if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
            this.streamInfo = e.streamInfo, this.mergeStreamInfo(), this.previous = e;
            var l = this;
            return e.on("data", function (i) {
              l.processChunk(i);
            }), e.on("end", function () {
              l.end();
            }), e.on("error", function (i) {
              l.error(i);
            }), this;
          },
          pause: function () {
            return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
          },
          resume: function () {
            if (!this.isPaused || this.isFinished) return !1;
            var e = this.isPaused = !1;
            return this.generatedError && (this.error(this.generatedError), e = !0), this.previous && this.previous.resume(), !e;
          },
          flush: function () {},
          processChunk: function (e) {
            this.push(e);
          },
          withStreamInfo: function (e, l) {
            return this.extraStreamInfo[e] = l, this.mergeStreamInfo(), this;
          },
          mergeStreamInfo: function () {
            for (var e in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e) && (this.streamInfo[e] = this.extraStreamInfo[e]);
          },
          lock: function () {
            if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
            this.isLocked = !0, this.previous && this.previous.lock();
          },
          toString: function () {
            var e = "Worker " + this.name;
            return this.previous ? this.previous + " -> " + e : e;
          }
        }, a.exports = r;
      }, {}],
      29: [function (t, a, c) {
        "use strict";

        var r = t("../utils"),
          e = t("./ConvertWorker"),
          l = t("./GenericWorker"),
          i = t("../base64"),
          o = t("../support"),
          n = t("../external"),
          h = null;
        if (o.nodestream) try {
          h = t("../nodejs/NodejsStreamOutputAdapter");
        } catch (s) {}
        function v(s, d) {
          return new n.Promise(function (z, u) {
            var f = [],
              p = s._internalType,
              m = s._outputType,
              M = s._mimeType;
            s.on("data", function (w, H) {
              f.push(w), d && d(H);
            }).on("error", function (w) {
              f = [], u(w);
            }).on("end", function () {
              try {
                var w = function (H, y, k) {
                  switch (H) {
                    case "blob":
                      return r.newBlob(r.transformTo("arraybuffer", y), k);
                    case "base64":
                      return i.encode(y);
                    default:
                      return r.transformTo(H, y);
                  }
                }(m, function (H, y) {
                  var k,
                    F = 0,
                    U = null,
                    A = 0;
                  for (k = 0; k < y.length; k++) A += y[k].length;
                  switch (H) {
                    case "string":
                      return y.join("");
                    case "array":
                      return Array.prototype.concat.apply([], y);
                    case "uint8array":
                      for (U = new Uint8Array(A), k = 0; k < y.length; k++) U.set(y[k], F), F += y[k].length;
                      return U;
                    case "nodebuffer":
                      return Buffer.concat(y);
                    default:
                      throw new Error("concat : unsupported type '" + H + "'");
                  }
                }(p, f), M);
                z(w);
              } catch (H) {
                u(H);
              }
              f = [];
            }).resume();
          });
        }
        function g(s, d, z) {
          var u = d;
          switch (d) {
            case "blob":
            case "arraybuffer":
              u = "uint8array";
              break;
            case "base64":
              u = "string";
          }
          try {
            this._internalType = u, this._outputType = d, this._mimeType = z, r.checkSupport(u), this._worker = s.pipe(new e(u)), s.lock();
          } catch (f) {
            this._worker = new l("error"), this._worker.error(f);
          }
        }
        g.prototype = {
          accumulate: function (s) {
            return v(this, s);
          },
          on: function (s, d) {
            var z = this;
            return s === "data" ? this._worker.on(s, function (u) {
              d.call(z, u.data, u.meta);
            }) : this._worker.on(s, function () {
              r.delay(d, arguments, z);
            }), this;
          },
          resume: function () {
            return r.delay(this._worker.resume, [], this._worker), this;
          },
          pause: function () {
            return this._worker.pause(), this;
          },
          toNodejsStream: function (s) {
            if (r.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
            return new h(this, {
              objectMode: this._outputType !== "nodebuffer"
            }, s);
          }
        }, a.exports = g;
      }, {
        "../base64": 1,
        "../external": 6,
        "../nodejs/NodejsStreamOutputAdapter": 13,
        "../support": 30,
        "../utils": 32,
        "./ConvertWorker": 24,
        "./GenericWorker": 28
      }],
      30: [function (t, a, c) {
        "use strict";

        if (c.base64 = !0, c.array = !0, c.string = !0, c.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", c.nodebuffer = typeof Buffer != "undefined", c.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined") c.blob = !1;else {
          var r = new ArrayBuffer(0);
          try {
            c.blob = new Blob([r], {
              type: "application/zip"
            }).size === 0;
          } catch (l) {
            try {
              var e = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              e.append(r), c.blob = e.getBlob("application/zip").size === 0;
            } catch (i) {
              c.blob = !1;
            }
          }
        }
        try {
          c.nodestream = !!t("readable-stream").Readable;
        } catch (l) {
          c.nodestream = !1;
        }
      }, {
        "readable-stream": 16
      }],
      31: [function (t, a, c) {
        "use strict";

        for (var r = t("./utils"), e = t("./support"), l = t("./nodejsUtils"), i = t("./stream/GenericWorker"), o = new Array(256), n = 0; n < 256; n++) o[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        o[254] = o[254] = 1;
        function h() {
          i.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function v() {
          i.call(this, "utf-8 encode");
        }
        c.utf8encode = function (g) {
          return e.nodebuffer ? l.newBufferFrom(g, "utf-8") : function (s) {
            var d,
              z,
              u,
              f,
              p,
              m = s.length,
              M = 0;
            for (f = 0; f < m; f++) (64512 & (z = s.charCodeAt(f))) == 55296 && f + 1 < m && (64512 & (u = s.charCodeAt(f + 1))) == 56320 && (z = 65536 + (z - 55296 << 10) + (u - 56320), f++), M += z < 128 ? 1 : z < 2048 ? 2 : z < 65536 ? 3 : 4;
            for (d = e.uint8array ? new Uint8Array(M) : new Array(M), f = p = 0; p < M; f++) (64512 & (z = s.charCodeAt(f))) == 55296 && f + 1 < m && (64512 & (u = s.charCodeAt(f + 1))) == 56320 && (z = 65536 + (z - 55296 << 10) + (u - 56320), f++), z < 128 ? d[p++] = z : (z < 2048 ? d[p++] = 192 | z >>> 6 : (z < 65536 ? d[p++] = 224 | z >>> 12 : (d[p++] = 240 | z >>> 18, d[p++] = 128 | z >>> 12 & 63), d[p++] = 128 | z >>> 6 & 63), d[p++] = 128 | 63 & z);
            return d;
          }(g);
        }, c.utf8decode = function (g) {
          return e.nodebuffer ? r.transformTo("nodebuffer", g).toString("utf-8") : function (s) {
            var d,
              z,
              u,
              f,
              p = s.length,
              m = new Array(2 * p);
            for (d = z = 0; d < p;) if ((u = s[d++]) < 128) m[z++] = u;else if (4 < (f = o[u])) m[z++] = 65533, d += f - 1;else {
              for (u &= f === 2 ? 31 : f === 3 ? 15 : 7; 1 < f && d < p;) u = u << 6 | 63 & s[d++], f--;
              1 < f ? m[z++] = 65533 : u < 65536 ? m[z++] = u : (u -= 65536, m[z++] = 55296 | u >> 10 & 1023, m[z++] = 56320 | 1023 & u);
            }
            return m.length !== z && (m.subarray ? m = m.subarray(0, z) : m.length = z), r.applyFromCharCode(m);
          }(g = r.transformTo(e.uint8array ? "uint8array" : "array", g));
        }, r.inherits(h, i), h.prototype.processChunk = function (g) {
          var s = r.transformTo(e.uint8array ? "uint8array" : "array", g.data);
          if (this.leftOver && this.leftOver.length) {
            if (e.uint8array) {
              var d = s;
              (s = new Uint8Array(d.length + this.leftOver.length)).set(this.leftOver, 0), s.set(d, this.leftOver.length);
            } else s = this.leftOver.concat(s);
            this.leftOver = null;
          }
          var z = function (f, p) {
              var m;
              for ((p = p || f.length) > f.length && (p = f.length), m = p - 1; 0 <= m && (192 & f[m]) == 128;) m--;
              return m < 0 || m === 0 ? p : m + o[f[m]] > p ? m : p;
            }(s),
            u = s;
          z !== s.length && (e.uint8array ? (u = s.subarray(0, z), this.leftOver = s.subarray(z, s.length)) : (u = s.slice(0, z), this.leftOver = s.slice(z, s.length))), this.push({
            data: c.utf8decode(u),
            meta: g.meta
          });
        }, h.prototype.flush = function () {
          this.leftOver && this.leftOver.length && (this.push({
            data: c.utf8decode(this.leftOver),
            meta: {}
          }), this.leftOver = null);
        }, c.Utf8DecodeWorker = h, r.inherits(v, i), v.prototype.processChunk = function (g) {
          this.push({
            data: c.utf8encode(g.data),
            meta: g.meta
          });
        }, c.Utf8EncodeWorker = v;
      }, {
        "./nodejsUtils": 14,
        "./stream/GenericWorker": 28,
        "./support": 30,
        "./utils": 32
      }],
      32: [function (t, a, c) {
        "use strict";

        var r = t("./support"),
          e = t("./base64"),
          l = t("./nodejsUtils"),
          i = t("./external");
        function o(d) {
          return d;
        }
        function n(d, z) {
          for (var u = 0; u < d.length; ++u) z[u] = 255 & d.charCodeAt(u);
          return z;
        }
        t("setimmediate"), c.newBlob = function (d, z) {
          c.checkSupport("blob");
          try {
            return new Blob([d], {
              type: z
            });
          } catch (f) {
            try {
              var u = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return u.append(d), u.getBlob(z);
            } catch (p) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var h = {
          stringifyByChunk: function (d, z, u) {
            var f = [],
              p = 0,
              m = d.length;
            if (m <= u) return String.fromCharCode.apply(null, d);
            for (; p < m;) z === "array" || z === "nodebuffer" ? f.push(String.fromCharCode.apply(null, d.slice(p, Math.min(p + u, m)))) : f.push(String.fromCharCode.apply(null, d.subarray(p, Math.min(p + u, m)))), p += u;
            return f.join("");
          },
          stringifyByChar: function (d) {
            for (var z = "", u = 0; u < d.length; u++) z += String.fromCharCode(d[u]);
            return z;
          },
          applyCanBeUsed: {
            uint8array: function () {
              try {
                return r.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
              } catch (d) {
                return !1;
              }
            }(),
            nodebuffer: function () {
              try {
                return r.nodebuffer && String.fromCharCode.apply(null, l.allocBuffer(1)).length === 1;
              } catch (d) {
                return !1;
              }
            }()
          }
        };
        function v(d) {
          var z = 65536,
            u = c.getTypeOf(d),
            f = !0;
          if (u === "uint8array" ? f = h.applyCanBeUsed.uint8array : u === "nodebuffer" && (f = h.applyCanBeUsed.nodebuffer), f) for (; 1 < z;) try {
            return h.stringifyByChunk(d, u, z);
          } catch (p) {
            z = Math.floor(z / 2);
          }
          return h.stringifyByChar(d);
        }
        function g(d, z) {
          for (var u = 0; u < d.length; u++) z[u] = d[u];
          return z;
        }
        c.applyFromCharCode = v;
        var s = {};
        s.string = {
          string: o,
          array: function (d) {
            return n(d, new Array(d.length));
          },
          arraybuffer: function (d) {
            return s.string.uint8array(d).buffer;
          },
          uint8array: function (d) {
            return n(d, new Uint8Array(d.length));
          },
          nodebuffer: function (d) {
            return n(d, l.allocBuffer(d.length));
          }
        }, s.array = {
          string: v,
          array: o,
          arraybuffer: function (d) {
            return new Uint8Array(d).buffer;
          },
          uint8array: function (d) {
            return new Uint8Array(d);
          },
          nodebuffer: function (d) {
            return l.newBufferFrom(d);
          }
        }, s.arraybuffer = {
          string: function (d) {
            return v(new Uint8Array(d));
          },
          array: function (d) {
            return g(new Uint8Array(d), new Array(d.byteLength));
          },
          arraybuffer: o,
          uint8array: function (d) {
            return new Uint8Array(d);
          },
          nodebuffer: function (d) {
            return l.newBufferFrom(new Uint8Array(d));
          }
        }, s.uint8array = {
          string: v,
          array: function (d) {
            return g(d, new Array(d.length));
          },
          arraybuffer: function (d) {
            return d.buffer;
          },
          uint8array: o,
          nodebuffer: function (d) {
            return l.newBufferFrom(d);
          }
        }, s.nodebuffer = {
          string: v,
          array: function (d) {
            return g(d, new Array(d.length));
          },
          arraybuffer: function (d) {
            return s.nodebuffer.uint8array(d).buffer;
          },
          uint8array: function (d) {
            return g(d, new Uint8Array(d.length));
          },
          nodebuffer: o
        }, c.transformTo = function (d, z) {
          if (z = z || "", !d) return z;
          c.checkSupport(d);
          var u = c.getTypeOf(z);
          return s[u][d](z);
        }, c.resolve = function (d) {
          for (var z = d.split("/"), u = [], f = 0; f < z.length; f++) {
            var p = z[f];
            p === "." || p === "" && f !== 0 && f !== z.length - 1 || (p === ".." ? u.pop() : u.push(p));
          }
          return u.join("/");
        }, c.getTypeOf = function (d) {
          return typeof d == "string" ? "string" : Object.prototype.toString.call(d) === "[object Array]" ? "array" : r.nodebuffer && l.isBuffer(d) ? "nodebuffer" : r.uint8array && d instanceof Uint8Array ? "uint8array" : r.arraybuffer && d instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, c.checkSupport = function (d) {
          if (!r[d.toLowerCase()]) throw new Error(d + " is not supported by this platform");
        }, c.MAX_VALUE_16BITS = 65535, c.MAX_VALUE_32BITS = -1, c.pretty = function (d) {
          var z,
            u,
            f = "";
          for (u = 0; u < (d || "").length; u++) f += "\\x" + ((z = d.charCodeAt(u)) < 16 ? "0" : "") + z.toString(16).toUpperCase();
          return f;
        }, c.delay = function (d, z, u) {
          setImmediate(function () {
            d.apply(u || null, z || []);
          });
        }, c.inherits = function (d, z) {
          function u() {}
          u.prototype = z.prototype, d.prototype = new u();
        }, c.extend = function () {
          var d,
            z,
            u = {};
          for (d = 0; d < arguments.length; d++) for (z in arguments[d]) Object.prototype.hasOwnProperty.call(arguments[d], z) && u[z] === void 0 && (u[z] = arguments[d][z]);
          return u;
        }, c.prepareContent = function (d, z, u, f, p) {
          return i.Promise.resolve(z).then(function (m) {
            return r.blob && (m instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(m)) !== -1) && typeof FileReader != "undefined" ? new i.Promise(function (M, w) {
              var H = new FileReader();
              H.onload = function (y) {
                M(y.target.result);
              }, H.onerror = function (y) {
                w(y.target.error);
              }, H.readAsArrayBuffer(m);
            }) : m;
          }).then(function (m) {
            var M = c.getTypeOf(m);
            return M ? (M === "arraybuffer" ? m = c.transformTo("uint8array", m) : M === "string" && (p ? m = e.decode(m) : u && f !== !0 && (m = function (w) {
              return n(w, r.uint8array ? new Uint8Array(w.length) : new Array(w.length));
            }(m))), m) : i.Promise.reject(new Error("Can't read the data of '" + d + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, {
        "./base64": 1,
        "./external": 6,
        "./nodejsUtils": 14,
        "./support": 30,
        setimmediate: 54
      }],
      33: [function (t, a, c) {
        "use strict";

        var r = t("./reader/readerFor"),
          e = t("./utils"),
          l = t("./signature"),
          i = t("./zipEntry"),
          o = t("./support");
        function n(h) {
          this.files = [], this.loadOptions = h;
        }
        n.prototype = {
          checkSignature: function (h) {
            if (!this.reader.readAndCheckSignature(h)) {
              this.reader.index -= 4;
              var v = this.reader.readString(4);
              throw new Error("Corrupted zip or bug: unexpected signature (" + e.pretty(v) + ", expected " + e.pretty(h) + ")");
            }
          },
          isSignature: function (h, v) {
            var g = this.reader.index;
            this.reader.setIndex(h);
            var s = this.reader.readString(4) === v;
            return this.reader.setIndex(g), s;
          },
          readBlockEndOfCentral: function () {
            this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
            var h = this.reader.readData(this.zipCommentLength),
              v = o.uint8array ? "uint8array" : "array",
              g = e.transformTo(v, h);
            this.zipComment = this.loadOptions.decodeFileName(g);
          },
          readBlockZip64EndOfCentral: function () {
            this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
            for (var h, v, g, s = this.zip64EndOfCentralSize - 44; 0 < s;) h = this.reader.readInt(2), v = this.reader.readInt(4), g = this.reader.readData(v), this.zip64ExtensibleData[h] = {
              id: h,
              length: v,
              value: g
            };
          },
          readBlockZip64EndOfCentralLocator: function () {
            if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
          },
          readLocalFiles: function () {
            var h, v;
            for (h = 0; h < this.files.length; h++) v = this.files[h], this.reader.setIndex(v.localHeaderOffset), this.checkSignature(l.LOCAL_FILE_HEADER), v.readLocalPart(this.reader), v.handleUTF8(), v.processAttributes();
          },
          readCentralDir: function () {
            var h;
            for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(l.CENTRAL_FILE_HEADER);) (h = new i({
              zip64: this.zip64
            }, this.loadOptions)).readCentralPart(this.reader), this.files.push(h);
            if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          },
          readEndOfCentral: function () {
            var h = this.reader.lastIndexOfSignature(l.CENTRAL_DIRECTORY_END);
            if (h < 0) throw this.isSignature(0, l.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            this.reader.setIndex(h);
            var v = h;
            if (this.checkSignature(l.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === e.MAX_VALUE_16BITS || this.diskWithCentralDirStart === e.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === e.MAX_VALUE_16BITS || this.centralDirRecords === e.MAX_VALUE_16BITS || this.centralDirSize === e.MAX_VALUE_32BITS || this.centralDirOffset === e.MAX_VALUE_32BITS) {
              if (this.zip64 = !0, (h = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
              if (this.reader.setIndex(h), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, l.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
              this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
            }
            var g = this.centralDirOffset + this.centralDirSize;
            this.zip64 && (g += 20, g += 12 + this.zip64EndOfCentralSize);
            var s = v - g;
            if (0 < s) this.isSignature(v, l.CENTRAL_FILE_HEADER) || (this.reader.zero = s);else if (s < 0) throw new Error("Corrupted zip: missing " + Math.abs(s) + " bytes.");
          },
          prepareReader: function (h) {
            this.reader = r(h);
          },
          load: function (h) {
            this.prepareReader(h), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
          }
        }, a.exports = n;
      }, {
        "./reader/readerFor": 22,
        "./signature": 23,
        "./support": 30,
        "./utils": 32,
        "./zipEntry": 34
      }],
      34: [function (t, a, c) {
        "use strict";

        var r = t("./reader/readerFor"),
          e = t("./utils"),
          l = t("./compressedObject"),
          i = t("./crc32"),
          o = t("./utf8"),
          n = t("./compressions"),
          h = t("./support");
        function v(g, s) {
          this.options = g, this.loadOptions = s;
        }
        v.prototype = {
          isEncrypted: function () {
            return (1 & this.bitFlag) == 1;
          },
          useUTF8: function () {
            return (2048 & this.bitFlag) == 2048;
          },
          readLocalPart: function (g) {
            var s, d;
            if (g.skip(22), this.fileNameLength = g.readInt(2), d = g.readInt(2), this.fileName = g.readData(this.fileNameLength), g.skip(d), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
            if ((s = function (z) {
              for (var u in n) if (Object.prototype.hasOwnProperty.call(n, u) && n[u].magic === z) return n[u];
              return null;
            }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + e.pretty(this.compressionMethod) + " unknown (inner file : " + e.transformTo("string", this.fileName) + ")");
            this.decompressed = new l(this.compressedSize, this.uncompressedSize, this.crc32, s, g.readData(this.compressedSize));
          },
          readCentralPart: function (g) {
            this.versionMadeBy = g.readInt(2), g.skip(2), this.bitFlag = g.readInt(2), this.compressionMethod = g.readString(2), this.date = g.readDate(), this.crc32 = g.readInt(4), this.compressedSize = g.readInt(4), this.uncompressedSize = g.readInt(4);
            var s = g.readInt(2);
            if (this.extraFieldsLength = g.readInt(2), this.fileCommentLength = g.readInt(2), this.diskNumberStart = g.readInt(2), this.internalFileAttributes = g.readInt(2), this.externalFileAttributes = g.readInt(4), this.localHeaderOffset = g.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
            g.skip(s), this.readExtraFields(g), this.parseZIP64ExtraField(g), this.fileComment = g.readData(this.fileCommentLength);
          },
          processAttributes: function () {
            this.unixPermissions = null, this.dosPermissions = null;
            var g = this.versionMadeBy >> 8;
            this.dir = !!(16 & this.externalFileAttributes), g == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), g == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
          },
          parseZIP64ExtraField: function () {
            if (this.extraFields[1]) {
              var g = r(this.extraFields[1].value);
              this.uncompressedSize === e.MAX_VALUE_32BITS && (this.uncompressedSize = g.readInt(8)), this.compressedSize === e.MAX_VALUE_32BITS && (this.compressedSize = g.readInt(8)), this.localHeaderOffset === e.MAX_VALUE_32BITS && (this.localHeaderOffset = g.readInt(8)), this.diskNumberStart === e.MAX_VALUE_32BITS && (this.diskNumberStart = g.readInt(4));
            }
          },
          readExtraFields: function (g) {
            var s,
              d,
              z,
              u = g.index + this.extraFieldsLength;
            for (this.extraFields || (this.extraFields = {}); g.index + 4 < u;) s = g.readInt(2), d = g.readInt(2), z = g.readData(d), this.extraFields[s] = {
              id: s,
              length: d,
              value: z
            };
            g.setIndex(u);
          },
          handleUTF8: function () {
            var g = h.uint8array ? "uint8array" : "array";
            if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);else {
              var s = this.findExtraFieldUnicodePath();
              if (s !== null) this.fileNameStr = s;else {
                var d = e.transformTo(g, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(d);
              }
              var z = this.findExtraFieldUnicodeComment();
              if (z !== null) this.fileCommentStr = z;else {
                var u = e.transformTo(g, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(u);
              }
            }
          },
          findExtraFieldUnicodePath: function () {
            var g = this.extraFields[28789];
            if (g) {
              var s = r(g.value);
              return s.readInt(1) !== 1 || i(this.fileName) !== s.readInt(4) ? null : o.utf8decode(s.readData(g.length - 5));
            }
            return null;
          },
          findExtraFieldUnicodeComment: function () {
            var g = this.extraFields[25461];
            if (g) {
              var s = r(g.value);
              return s.readInt(1) !== 1 || i(this.fileComment) !== s.readInt(4) ? null : o.utf8decode(s.readData(g.length - 5));
            }
            return null;
          }
        }, a.exports = v;
      }, {
        "./compressedObject": 2,
        "./compressions": 3,
        "./crc32": 4,
        "./reader/readerFor": 22,
        "./support": 30,
        "./utf8": 31,
        "./utils": 32
      }],
      35: [function (t, a, c) {
        "use strict";

        function r(s, d, z) {
          this.name = s, this.dir = z.dir, this.date = z.date, this.comment = z.comment, this.unixPermissions = z.unixPermissions, this.dosPermissions = z.dosPermissions, this._data = d, this._dataBinary = z.binary, this.options = {
            compression: z.compression,
            compressionOptions: z.compressionOptions
          };
        }
        var e = t("./stream/StreamHelper"),
          l = t("./stream/DataWorker"),
          i = t("./utf8"),
          o = t("./compressedObject"),
          n = t("./stream/GenericWorker");
        r.prototype = {
          internalStream: function (s) {
            var d = null,
              z = "string";
            try {
              if (!s) throw new Error("No output type specified.");
              var u = (z = s.toLowerCase()) === "string" || z === "text";
              z !== "binarystring" && z !== "text" || (z = "string"), d = this._decompressWorker();
              var f = !this._dataBinary;
              f && !u && (d = d.pipe(new i.Utf8EncodeWorker())), !f && u && (d = d.pipe(new i.Utf8DecodeWorker()));
            } catch (p) {
              (d = new n("error")).error(p);
            }
            return new e(d, z, "");
          },
          async: function (s, d) {
            return this.internalStream(s).accumulate(d);
          },
          nodeStream: function (s, d) {
            return this.internalStream(s || "nodebuffer").toNodejsStream(d);
          },
          _compressWorker: function (s, d) {
            if (this._data instanceof o && this._data.compression.magic === s.magic) return this._data.getCompressedWorker();
            var z = this._decompressWorker();
            return this._dataBinary || (z = z.pipe(new i.Utf8EncodeWorker())), o.createWorkerFrom(z, s, d);
          },
          _decompressWorker: function () {
            return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof n ? this._data : new l(this._data);
          }
        };
        for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], v = function () {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, g = 0; g < h.length; g++) r.prototype[h[g]] = v;
        a.exports = r;
      }, {
        "./compressedObject": 2,
        "./stream/DataWorker": 27,
        "./stream/GenericWorker": 28,
        "./stream/StreamHelper": 29,
        "./utf8": 31
      }],
      36: [function (t, a, c) {
        (function (r) {
          "use strict";

          var e,
            l,
            i = r.MutationObserver || r.WebKitMutationObserver;
          if (i) {
            var o = 0,
              n = new i(s),
              h = r.document.createTextNode("");
            n.observe(h, {
              characterData: !0
            }), e = function () {
              h.data = o = ++o % 2;
            };
          } else if (r.setImmediate || r.MessageChannel === void 0) e = "document" in r && "onreadystatechange" in r.document.createElement("script") ? function () {
            var d = r.document.createElement("script");
            d.onreadystatechange = function () {
              s(), d.onreadystatechange = null, d.parentNode.removeChild(d), d = null;
            }, r.document.documentElement.appendChild(d);
          } : function () {
            setTimeout(s, 0);
          };else {
            var v = new r.MessageChannel();
            v.port1.onmessage = s, e = function () {
              v.port2.postMessage(0);
            };
          }
          var g = [];
          function s() {
            var d, z;
            l = !0;
            for (var u = g.length; u;) {
              for (z = g, g = [], d = -1; ++d < u;) z[d]();
              u = g.length;
            }
            l = !1;
          }
          a.exports = function (d) {
            g.push(d) !== 1 || l || e();
          };
        }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
      }, {}],
      37: [function (t, a, c) {
        "use strict";

        var r = t("immediate");
        function e() {}
        var l = {},
          i = ["REJECTED"],
          o = ["FULFILLED"],
          n = ["PENDING"];
        function h(u) {
          if (typeof u != "function") throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, u !== e && d(this, u);
        }
        function v(u, f, p) {
          this.promise = u, typeof f == "function" && (this.onFulfilled = f, this.callFulfilled = this.otherCallFulfilled), typeof p == "function" && (this.onRejected = p, this.callRejected = this.otherCallRejected);
        }
        function g(u, f, p) {
          r(function () {
            var m;
            try {
              m = f(p);
            } catch (M) {
              return l.reject(u, M);
            }
            m === u ? l.reject(u, new TypeError("Cannot resolve promise with itself")) : l.resolve(u, m);
          });
        }
        function s(u) {
          var f = u && u.then;
          if (u && (typeof u == "object" || typeof u == "function") && typeof f == "function") return function () {
            f.apply(u, arguments);
          };
        }
        function d(u, f) {
          var p = !1;
          function m(H) {
            p || (p = !0, l.reject(u, H));
          }
          function M(H) {
            p || (p = !0, l.resolve(u, H));
          }
          var w = z(function () {
            f(M, m);
          });
          w.status === "error" && m(w.value);
        }
        function z(u, f) {
          var p = {};
          try {
            p.value = u(f), p.status = "success";
          } catch (m) {
            p.status = "error", p.value = m;
          }
          return p;
        }
        (a.exports = h).prototype.finally = function (u) {
          if (typeof u != "function") return this;
          var f = this.constructor;
          return this.then(function (p) {
            return f.resolve(u()).then(function () {
              return p;
            });
          }, function (p) {
            return f.resolve(u()).then(function () {
              throw p;
            });
          });
        }, h.prototype.catch = function (u) {
          return this.then(null, u);
        }, h.prototype.then = function (u, f) {
          if (typeof u != "function" && this.state === o || typeof f != "function" && this.state === i) return this;
          var p = new this.constructor(e);
          return this.state !== n ? g(p, this.state === o ? u : f, this.outcome) : this.queue.push(new v(p, u, f)), p;
        }, v.prototype.callFulfilled = function (u) {
          l.resolve(this.promise, u);
        }, v.prototype.otherCallFulfilled = function (u) {
          g(this.promise, this.onFulfilled, u);
        }, v.prototype.callRejected = function (u) {
          l.reject(this.promise, u);
        }, v.prototype.otherCallRejected = function (u) {
          g(this.promise, this.onRejected, u);
        }, l.resolve = function (u, f) {
          var p = z(s, f);
          if (p.status === "error") return l.reject(u, p.value);
          var m = p.value;
          if (m) d(u, m);else {
            u.state = o, u.outcome = f;
            for (var M = -1, w = u.queue.length; ++M < w;) u.queue[M].callFulfilled(f);
          }
          return u;
        }, l.reject = function (u, f) {
          u.state = i, u.outcome = f;
          for (var p = -1, m = u.queue.length; ++p < m;) u.queue[p].callRejected(f);
          return u;
        }, h.resolve = function (u) {
          return u instanceof this ? u : l.resolve(new this(e), u);
        }, h.reject = function (u) {
          var f = new this(e);
          return l.reject(f, u);
        }, h.all = function (u) {
          var f = this;
          if (Object.prototype.toString.call(u) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var p = u.length,
            m = !1;
          if (!p) return this.resolve([]);
          for (var M = new Array(p), w = 0, H = -1, y = new this(e); ++H < p;) k(u[H], H);
          return y;
          function k(F, U) {
            f.resolve(F).then(function (A) {
              M[U] = A, ++w !== p || m || (m = !0, l.resolve(y, M));
            }, function (A) {
              m || (m = !0, l.reject(y, A));
            });
          }
        }, h.race = function (u) {
          var f = this;
          if (Object.prototype.toString.call(u) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var p = u.length,
            m = !1;
          if (!p) return this.resolve([]);
          for (var M = -1, w = new this(e); ++M < p;) H = u[M], f.resolve(H).then(function (y) {
            m || (m = !0, l.resolve(w, y));
          }, function (y) {
            m || (m = !0, l.reject(w, y));
          });
          var H;
          return w;
        };
      }, {
        immediate: 36
      }],
      38: [function (t, a, c) {
        "use strict";

        var r = {};
        (0, t("./lib/utils/common").assign)(r, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), a.exports = r;
      }, {
        "./lib/deflate": 39,
        "./lib/inflate": 40,
        "./lib/utils/common": 41,
        "./lib/zlib/constants": 44
      }],
      39: [function (t, a, c) {
        "use strict";

        var r = t("./zlib/deflate"),
          e = t("./utils/common"),
          l = t("./utils/strings"),
          i = t("./zlib/messages"),
          o = t("./zlib/zstream"),
          n = Object.prototype.toString,
          h = 0,
          v = -1,
          g = 0,
          s = 8;
        function d(u) {
          if (!(this instanceof d)) return new d(u);
          this.options = e.assign({
            level: v,
            method: s,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: g,
            to: ""
          }, u || {});
          var f = this.options;
          f.raw && 0 < f.windowBits ? f.windowBits = -f.windowBits : f.gzip && 0 < f.windowBits && f.windowBits < 16 && (f.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new o(), this.strm.avail_out = 0;
          var p = r.deflateInit2(this.strm, f.level, f.method, f.windowBits, f.memLevel, f.strategy);
          if (p !== h) throw new Error(i[p]);
          if (f.header && r.deflateSetHeader(this.strm, f.header), f.dictionary) {
            var m;
            if (m = typeof f.dictionary == "string" ? l.string2buf(f.dictionary) : n.call(f.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(f.dictionary) : f.dictionary, (p = r.deflateSetDictionary(this.strm, m)) !== h) throw new Error(i[p]);
            this._dict_set = !0;
          }
        }
        function z(u, f) {
          var p = new d(f);
          if (p.push(u, !0), p.err) throw p.msg || i[p.err];
          return p.result;
        }
        d.prototype.push = function (u, f) {
          var p,
            m,
            M = this.strm,
            w = this.options.chunkSize;
          if (this.ended) return !1;
          m = f === ~~f ? f : f === !0 ? 4 : 0, typeof u == "string" ? M.input = l.string2buf(u) : n.call(u) === "[object ArrayBuffer]" ? M.input = new Uint8Array(u) : M.input = u, M.next_in = 0, M.avail_in = M.input.length;
          do {
            if (M.avail_out === 0 && (M.output = new e.Buf8(w), M.next_out = 0, M.avail_out = w), (p = r.deflate(M, m)) !== 1 && p !== h) return this.onEnd(p), !(this.ended = !0);
            M.avail_out !== 0 && (M.avail_in !== 0 || m !== 4 && m !== 2) || (this.options.to === "string" ? this.onData(l.buf2binstring(e.shrinkBuf(M.output, M.next_out))) : this.onData(e.shrinkBuf(M.output, M.next_out)));
          } while ((0 < M.avail_in || M.avail_out === 0) && p !== 1);
          return m === 4 ? (p = r.deflateEnd(this.strm), this.onEnd(p), this.ended = !0, p === h) : m !== 2 || (this.onEnd(h), !(M.avail_out = 0));
        }, d.prototype.onData = function (u) {
          this.chunks.push(u);
        }, d.prototype.onEnd = function (u) {
          u === h && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = e.flattenChunks(this.chunks)), this.chunks = [], this.err = u, this.msg = this.strm.msg;
        }, c.Deflate = d, c.deflate = z, c.deflateRaw = function (u, f) {
          return (f = f || {}).raw = !0, z(u, f);
        }, c.gzip = function (u, f) {
          return (f = f || {}).gzip = !0, z(u, f);
        };
      }, {
        "./utils/common": 41,
        "./utils/strings": 42,
        "./zlib/deflate": 46,
        "./zlib/messages": 51,
        "./zlib/zstream": 53
      }],
      40: [function (t, a, c) {
        "use strict";

        var r = t("./zlib/inflate"),
          e = t("./utils/common"),
          l = t("./utils/strings"),
          i = t("./zlib/constants"),
          o = t("./zlib/messages"),
          n = t("./zlib/zstream"),
          h = t("./zlib/gzheader"),
          v = Object.prototype.toString;
        function g(d) {
          if (!(this instanceof g)) return new g(d);
          this.options = e.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, d || {});
          var z = this.options;
          z.raw && 0 <= z.windowBits && z.windowBits < 16 && (z.windowBits = -z.windowBits, z.windowBits === 0 && (z.windowBits = -15)), !(0 <= z.windowBits && z.windowBits < 16) || d && d.windowBits || (z.windowBits += 32), 15 < z.windowBits && z.windowBits < 48 && !(15 & z.windowBits) && (z.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new n(), this.strm.avail_out = 0;
          var u = r.inflateInit2(this.strm, z.windowBits);
          if (u !== i.Z_OK) throw new Error(o[u]);
          this.header = new h(), r.inflateGetHeader(this.strm, this.header);
        }
        function s(d, z) {
          var u = new g(z);
          if (u.push(d, !0), u.err) throw u.msg || o[u.err];
          return u.result;
        }
        g.prototype.push = function (d, z) {
          var u,
            f,
            p,
            m,
            M,
            w,
            H = this.strm,
            y = this.options.chunkSize,
            k = this.options.dictionary,
            F = !1;
          if (this.ended) return !1;
          f = z === ~~z ? z : z === !0 ? i.Z_FINISH : i.Z_NO_FLUSH, typeof d == "string" ? H.input = l.binstring2buf(d) : v.call(d) === "[object ArrayBuffer]" ? H.input = new Uint8Array(d) : H.input = d, H.next_in = 0, H.avail_in = H.input.length;
          do {
            if (H.avail_out === 0 && (H.output = new e.Buf8(y), H.next_out = 0, H.avail_out = y), (u = r.inflate(H, i.Z_NO_FLUSH)) === i.Z_NEED_DICT && k && (w = typeof k == "string" ? l.string2buf(k) : v.call(k) === "[object ArrayBuffer]" ? new Uint8Array(k) : k, u = r.inflateSetDictionary(this.strm, w)), u === i.Z_BUF_ERROR && F === !0 && (u = i.Z_OK, F = !1), u !== i.Z_STREAM_END && u !== i.Z_OK) return this.onEnd(u), !(this.ended = !0);
            H.next_out && (H.avail_out !== 0 && u !== i.Z_STREAM_END && (H.avail_in !== 0 || f !== i.Z_FINISH && f !== i.Z_SYNC_FLUSH) || (this.options.to === "string" ? (p = l.utf8border(H.output, H.next_out), m = H.next_out - p, M = l.buf2string(H.output, p), H.next_out = m, H.avail_out = y - m, m && e.arraySet(H.output, H.output, p, m, 0), this.onData(M)) : this.onData(e.shrinkBuf(H.output, H.next_out)))), H.avail_in === 0 && H.avail_out === 0 && (F = !0);
          } while ((0 < H.avail_in || H.avail_out === 0) && u !== i.Z_STREAM_END);
          return u === i.Z_STREAM_END && (f = i.Z_FINISH), f === i.Z_FINISH ? (u = r.inflateEnd(this.strm), this.onEnd(u), this.ended = !0, u === i.Z_OK) : f !== i.Z_SYNC_FLUSH || (this.onEnd(i.Z_OK), !(H.avail_out = 0));
        }, g.prototype.onData = function (d) {
          this.chunks.push(d);
        }, g.prototype.onEnd = function (d) {
          d === i.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = e.flattenChunks(this.chunks)), this.chunks = [], this.err = d, this.msg = this.strm.msg;
        }, c.Inflate = g, c.inflate = s, c.inflateRaw = function (d, z) {
          return (z = z || {}).raw = !0, s(d, z);
        }, c.ungzip = s;
      }, {
        "./utils/common": 41,
        "./utils/strings": 42,
        "./zlib/constants": 44,
        "./zlib/gzheader": 47,
        "./zlib/inflate": 49,
        "./zlib/messages": 51,
        "./zlib/zstream": 53
      }],
      41: [function (t, a, c) {
        "use strict";

        var r = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
        c.assign = function (i) {
          for (var o = Array.prototype.slice.call(arguments, 1); o.length;) {
            var n = o.shift();
            if (n) {
              if (typeof n != "object") throw new TypeError(n + "must be non-object");
              for (var h in n) n.hasOwnProperty(h) && (i[h] = n[h]);
            }
          }
          return i;
        }, c.shrinkBuf = function (i, o) {
          return i.length === o ? i : i.subarray ? i.subarray(0, o) : (i.length = o, i);
        };
        var e = {
            arraySet: function (i, o, n, h, v) {
              if (o.subarray && i.subarray) i.set(o.subarray(n, n + h), v);else for (var g = 0; g < h; g++) i[v + g] = o[n + g];
            },
            flattenChunks: function (i) {
              var o, n, h, v, g, s;
              for (o = h = 0, n = i.length; o < n; o++) h += i[o].length;
              for (s = new Uint8Array(h), o = v = 0, n = i.length; o < n; o++) g = i[o], s.set(g, v), v += g.length;
              return s;
            }
          },
          l = {
            arraySet: function (i, o, n, h, v) {
              for (var g = 0; g < h; g++) i[v + g] = o[n + g];
            },
            flattenChunks: function (i) {
              return [].concat.apply([], i);
            }
          };
        c.setTyped = function (i) {
          i ? (c.Buf8 = Uint8Array, c.Buf16 = Uint16Array, c.Buf32 = Int32Array, c.assign(c, e)) : (c.Buf8 = Array, c.Buf16 = Array, c.Buf32 = Array, c.assign(c, l));
        }, c.setTyped(r);
      }, {}],
      42: [function (t, a, c) {
        "use strict";

        var r = t("./common"),
          e = !0,
          l = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (h) {
          e = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (h) {
          l = !1;
        }
        for (var i = new r.Buf8(256), o = 0; o < 256; o++) i[o] = 252 <= o ? 6 : 248 <= o ? 5 : 240 <= o ? 4 : 224 <= o ? 3 : 192 <= o ? 2 : 1;
        function n(h, v) {
          if (v < 65537 && (h.subarray && l || !h.subarray && e)) return String.fromCharCode.apply(null, r.shrinkBuf(h, v));
          for (var g = "", s = 0; s < v; s++) g += String.fromCharCode(h[s]);
          return g;
        }
        i[254] = i[254] = 1, c.string2buf = function (h) {
          var v,
            g,
            s,
            d,
            z,
            u = h.length,
            f = 0;
          for (d = 0; d < u; d++) (64512 & (g = h.charCodeAt(d))) == 55296 && d + 1 < u && (64512 & (s = h.charCodeAt(d + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (s - 56320), d++), f += g < 128 ? 1 : g < 2048 ? 2 : g < 65536 ? 3 : 4;
          for (v = new r.Buf8(f), d = z = 0; z < f; d++) (64512 & (g = h.charCodeAt(d))) == 55296 && d + 1 < u && (64512 & (s = h.charCodeAt(d + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (s - 56320), d++), g < 128 ? v[z++] = g : (g < 2048 ? v[z++] = 192 | g >>> 6 : (g < 65536 ? v[z++] = 224 | g >>> 12 : (v[z++] = 240 | g >>> 18, v[z++] = 128 | g >>> 12 & 63), v[z++] = 128 | g >>> 6 & 63), v[z++] = 128 | 63 & g);
          return v;
        }, c.buf2binstring = function (h) {
          return n(h, h.length);
        }, c.binstring2buf = function (h) {
          for (var v = new r.Buf8(h.length), g = 0, s = v.length; g < s; g++) v[g] = h.charCodeAt(g);
          return v;
        }, c.buf2string = function (h, v) {
          var g,
            s,
            d,
            z,
            u = v || h.length,
            f = new Array(2 * u);
          for (g = s = 0; g < u;) if ((d = h[g++]) < 128) f[s++] = d;else if (4 < (z = i[d])) f[s++] = 65533, g += z - 1;else {
            for (d &= z === 2 ? 31 : z === 3 ? 15 : 7; 1 < z && g < u;) d = d << 6 | 63 & h[g++], z--;
            1 < z ? f[s++] = 65533 : d < 65536 ? f[s++] = d : (d -= 65536, f[s++] = 55296 | d >> 10 & 1023, f[s++] = 56320 | 1023 & d);
          }
          return n(f, s);
        }, c.utf8border = function (h, v) {
          var g;
          for ((v = v || h.length) > h.length && (v = h.length), g = v - 1; 0 <= g && (192 & h[g]) == 128;) g--;
          return g < 0 || g === 0 ? v : g + i[h[g]] > v ? g : v;
        };
      }, {
        "./common": 41
      }],
      43: [function (t, a, c) {
        "use strict";

        a.exports = function (r, e, l, i) {
          for (var o = 65535 & r | 0, n = r >>> 16 & 65535 | 0, h = 0; l !== 0;) {
            for (l -= h = 2e3 < l ? 2e3 : l; n = n + (o = o + e[i++] | 0) | 0, --h;);
            o %= 65521, n %= 65521;
          }
          return o | n << 16 | 0;
        };
      }, {}],
      44: [function (t, a, c) {
        "use strict";

        a.exports = {
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          Z_BUF_ERROR: -5,
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          Z_BINARY: 0,
          Z_TEXT: 1,
          Z_UNKNOWN: 2,
          Z_DEFLATED: 8
        };
      }, {}],
      45: [function (t, a, c) {
        "use strict";

        var r = function () {
          for (var e, l = [], i = 0; i < 256; i++) {
            e = i;
            for (var o = 0; o < 8; o++) e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
            l[i] = e;
          }
          return l;
        }();
        a.exports = function (e, l, i, o) {
          var n = r,
            h = o + i;
          e ^= -1;
          for (var v = o; v < h; v++) e = e >>> 8 ^ n[255 & (e ^ l[v])];
          return -1 ^ e;
        };
      }, {}],
      46: [function (t, a, c) {
        "use strict";

        var r,
          e = t("../utils/common"),
          l = t("./trees"),
          i = t("./adler32"),
          o = t("./crc32"),
          n = t("./messages"),
          h = 0,
          v = 4,
          g = 0,
          s = -2,
          d = -1,
          z = 4,
          u = 2,
          f = 8,
          p = 9,
          m = 286,
          M = 30,
          w = 19,
          H = 2 * m + 1,
          y = 15,
          k = 3,
          F = 258,
          U = F + k + 1,
          A = 42,
          P = 113,
          C = 1,
          E = 2,
          a1 = 3,
          j = 4;
        function K(L, Y) {
          return L.msg = n[Y], Y;
        }
        function Z(L) {
          return (L << 1) - (4 < L ? 9 : 0);
        }
        function J(L) {
          for (var Y = L.length; 0 <= --Y;) L[Y] = 0;
        }
        function W(L) {
          var Y = L.state,
            Q = Y.pending;
          Q > L.avail_out && (Q = L.avail_out), Q !== 0 && (e.arraySet(L.output, Y.pending_buf, Y.pending_out, Q, L.next_out), L.next_out += Q, Y.pending_out += Q, L.total_out += Q, L.avail_out -= Q, Y.pending -= Q, Y.pending === 0 && (Y.pending_out = 0));
        }
        function _(L, Y) {
          l._tr_flush_block(L, 0 <= L.block_start ? L.block_start : -1, L.strstart - L.block_start, Y), L.block_start = L.strstart, W(L.strm);
        }
        function g1(L, Y) {
          L.pending_buf[L.pending++] = Y;
        }
        function X(L, Y) {
          L.pending_buf[L.pending++] = Y >>> 8 & 255, L.pending_buf[L.pending++] = 255 & Y;
        }
        function $(L, Y) {
          var Q,
            b,
            R = L.max_chain_length,
            O = L.strstart,
            t1 = L.prev_length,
            r1 = L.nice_match,
            q = L.strstart > L.w_size - U ? L.strstart - (L.w_size - U) : 0,
            h1 = L.window,
            d1 = L.w_mask,
            l1 = L.prev,
            e1 = L.strstart + F,
            w1 = h1[O + t1 - 1],
            R1 = h1[O + t1];
          L.prev_length >= L.good_match && (R >>= 2), r1 > L.lookahead && (r1 = L.lookahead);
          do if (h1[(Q = Y) + t1] === R1 && h1[Q + t1 - 1] === w1 && h1[Q] === h1[O] && h1[++Q] === h1[O + 1]) {
            O += 2, Q++;
            do ; while (h1[++O] === h1[++Q] && h1[++O] === h1[++Q] && h1[++O] === h1[++Q] && h1[++O] === h1[++Q] && h1[++O] === h1[++Q] && h1[++O] === h1[++Q] && h1[++O] === h1[++Q] && h1[++O] === h1[++Q] && O < e1);
            if (b = F - (e1 - O), O = e1 - F, t1 < b) {
              if (L.match_start = Y, r1 <= (t1 = b)) break;
              w1 = h1[O + t1 - 1], R1 = h1[O + t1];
            }
          } while ((Y = l1[Y & d1]) > q && --R != 0);
          return t1 <= L.lookahead ? t1 : L.lookahead;
        }
        function o1(L) {
          var Y,
            Q,
            b,
            R,
            O,
            t1,
            r1,
            q,
            h1,
            d1,
            l1 = L.w_size;
          do {
            if (R = L.window_size - L.lookahead - L.strstart, L.strstart >= l1 + (l1 - U)) {
              for (e.arraySet(L.window, L.window, l1, l1, 0), L.match_start -= l1, L.strstart -= l1, L.block_start -= l1, Y = Q = L.hash_size; b = L.head[--Y], L.head[Y] = l1 <= b ? b - l1 : 0, --Q;);
              for (Y = Q = l1; b = L.prev[--Y], L.prev[Y] = l1 <= b ? b - l1 : 0, --Q;);
              R += l1;
            }
            if (L.strm.avail_in === 0) break;
            if (t1 = L.strm, r1 = L.window, q = L.strstart + L.lookahead, h1 = R, d1 = void 0, d1 = t1.avail_in, h1 < d1 && (d1 = h1), Q = d1 === 0 ? 0 : (t1.avail_in -= d1, e.arraySet(r1, t1.input, t1.next_in, d1, q), t1.state.wrap === 1 ? t1.adler = i(t1.adler, r1, d1, q) : t1.state.wrap === 2 && (t1.adler = o(t1.adler, r1, d1, q)), t1.next_in += d1, t1.total_in += d1, d1), L.lookahead += Q, L.lookahead + L.insert >= k) for (O = L.strstart - L.insert, L.ins_h = L.window[O], L.ins_h = (L.ins_h << L.hash_shift ^ L.window[O + 1]) & L.hash_mask; L.insert && (L.ins_h = (L.ins_h << L.hash_shift ^ L.window[O + k - 1]) & L.hash_mask, L.prev[O & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = O, O++, L.insert--, !(L.lookahead + L.insert < k)););
          } while (L.lookahead < U && L.strm.avail_in !== 0);
        }
        function u1(L, Y) {
          for (var Q, b;;) {
            if (L.lookahead < U) {
              if (o1(L), L.lookahead < U && Y === h) return C;
              if (L.lookahead === 0) break;
            }
            if (Q = 0, L.lookahead >= k && (L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + k - 1]) & L.hash_mask, Q = L.prev[L.strstart & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = L.strstart), Q !== 0 && L.strstart - Q <= L.w_size - U && (L.match_length = $(L, Q)), L.match_length >= k) {
              if (b = l._tr_tally(L, L.strstart - L.match_start, L.match_length - k), L.lookahead -= L.match_length, L.match_length <= L.max_lazy_match && L.lookahead >= k) {
                for (L.match_length--; L.strstart++, L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + k - 1]) & L.hash_mask, Q = L.prev[L.strstart & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = L.strstart, --L.match_length != 0;);
                L.strstart++;
              } else L.strstart += L.match_length, L.match_length = 0, L.ins_h = L.window[L.strstart], L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + 1]) & L.hash_mask;
            } else b = l._tr_tally(L, 0, L.window[L.strstart]), L.lookahead--, L.strstart++;
            if (b && (_(L, !1), L.strm.avail_out === 0)) return C;
          }
          return L.insert = L.strstart < k - 1 ? L.strstart : k - 1, Y === v ? (_(L, !0), L.strm.avail_out === 0 ? a1 : j) : L.last_lit && (_(L, !1), L.strm.avail_out === 0) ? C : E;
        }
        function N(L, Y) {
          for (var Q, b, R;;) {
            if (L.lookahead < U) {
              if (o1(L), L.lookahead < U && Y === h) return C;
              if (L.lookahead === 0) break;
            }
            if (Q = 0, L.lookahead >= k && (L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + k - 1]) & L.hash_mask, Q = L.prev[L.strstart & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = L.strstart), L.prev_length = L.match_length, L.prev_match = L.match_start, L.match_length = k - 1, Q !== 0 && L.prev_length < L.max_lazy_match && L.strstart - Q <= L.w_size - U && (L.match_length = $(L, Q), L.match_length <= 5 && (L.strategy === 1 || L.match_length === k && 4096 < L.strstart - L.match_start) && (L.match_length = k - 1)), L.prev_length >= k && L.match_length <= L.prev_length) {
              for (R = L.strstart + L.lookahead - k, b = l._tr_tally(L, L.strstart - 1 - L.prev_match, L.prev_length - k), L.lookahead -= L.prev_length - 1, L.prev_length -= 2; ++L.strstart <= R && (L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + k - 1]) & L.hash_mask, Q = L.prev[L.strstart & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = L.strstart), --L.prev_length != 0;);
              if (L.match_available = 0, L.match_length = k - 1, L.strstart++, b && (_(L, !1), L.strm.avail_out === 0)) return C;
            } else if (L.match_available) {
              if ((b = l._tr_tally(L, 0, L.window[L.strstart - 1])) && _(L, !1), L.strstart++, L.lookahead--, L.strm.avail_out === 0) return C;
            } else L.match_available = 1, L.strstart++, L.lookahead--;
          }
          return L.match_available && (b = l._tr_tally(L, 0, L.window[L.strstart - 1]), L.match_available = 0), L.insert = L.strstart < k - 1 ? L.strstart : k - 1, Y === v ? (_(L, !0), L.strm.avail_out === 0 ? a1 : j) : L.last_lit && (_(L, !1), L.strm.avail_out === 0) ? C : E;
        }
        function x1(L, Y, Q, b, R) {
          this.good_length = L, this.max_lazy = Y, this.nice_length = Q, this.max_chain = b, this.func = R;
        }
        function i1() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = f, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new e.Buf16(2 * H), this.dyn_dtree = new e.Buf16(2 * (2 * M + 1)), this.bl_tree = new e.Buf16(2 * (2 * w + 1)), J(this.dyn_ltree), J(this.dyn_dtree), J(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new e.Buf16(y + 1), this.heap = new e.Buf16(2 * m + 1), J(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new e.Buf16(2 * m + 1), J(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function B1(L) {
          var Y;
          return L && L.state ? (L.total_in = L.total_out = 0, L.data_type = u, (Y = L.state).pending = 0, Y.pending_out = 0, Y.wrap < 0 && (Y.wrap = -Y.wrap), Y.status = Y.wrap ? A : P, L.adler = Y.wrap === 2 ? 0 : 1, Y.last_flush = h, l._tr_init(Y), g) : K(L, s);
        }
        function k1(L) {
          var Y = B1(L);
          return Y === g && function (Q) {
            Q.window_size = 2 * Q.w_size, J(Q.head), Q.max_lazy_match = r[Q.level].max_lazy, Q.good_match = r[Q.level].good_length, Q.nice_match = r[Q.level].nice_length, Q.max_chain_length = r[Q.level].max_chain, Q.strstart = 0, Q.block_start = 0, Q.lookahead = 0, Q.insert = 0, Q.match_length = Q.prev_length = k - 1, Q.match_available = 0, Q.ins_h = 0;
          }(L.state), Y;
        }
        function A1(L, Y, Q, b, R, O) {
          if (!L) return s;
          var t1 = 1;
          if (Y === d && (Y = 6), b < 0 ? (t1 = 0, b = -b) : 15 < b && (t1 = 2, b -= 16), R < 1 || p < R || Q !== f || b < 8 || 15 < b || Y < 0 || 9 < Y || O < 0 || z < O) return K(L, s);
          b === 8 && (b = 9);
          var r1 = new i1();
          return (L.state = r1).strm = L, r1.wrap = t1, r1.gzhead = null, r1.w_bits = b, r1.w_size = 1 << r1.w_bits, r1.w_mask = r1.w_size - 1, r1.hash_bits = R + 7, r1.hash_size = 1 << r1.hash_bits, r1.hash_mask = r1.hash_size - 1, r1.hash_shift = ~~((r1.hash_bits + k - 1) / k), r1.window = new e.Buf8(2 * r1.w_size), r1.head = new e.Buf16(r1.hash_size), r1.prev = new e.Buf16(r1.w_size), r1.lit_bufsize = 1 << R + 6, r1.pending_buf_size = 4 * r1.lit_bufsize, r1.pending_buf = new e.Buf8(r1.pending_buf_size), r1.d_buf = 1 * r1.lit_bufsize, r1.l_buf = 3 * r1.lit_bufsize, r1.level = Y, r1.strategy = O, r1.method = Q, k1(L);
        }
        r = [new x1(0, 0, 0, 0, function (L, Y) {
          var Q = 65535;
          for (Q > L.pending_buf_size - 5 && (Q = L.pending_buf_size - 5);;) {
            if (L.lookahead <= 1) {
              if (o1(L), L.lookahead === 0 && Y === h) return C;
              if (L.lookahead === 0) break;
            }
            L.strstart += L.lookahead, L.lookahead = 0;
            var b = L.block_start + Q;
            if ((L.strstart === 0 || L.strstart >= b) && (L.lookahead = L.strstart - b, L.strstart = b, _(L, !1), L.strm.avail_out === 0) || L.strstart - L.block_start >= L.w_size - U && (_(L, !1), L.strm.avail_out === 0)) return C;
          }
          return L.insert = 0, Y === v ? (_(L, !0), L.strm.avail_out === 0 ? a1 : j) : (L.strstart > L.block_start && (_(L, !1), L.strm.avail_out), C);
        }), new x1(4, 4, 8, 4, u1), new x1(4, 5, 16, 8, u1), new x1(4, 6, 32, 32, u1), new x1(4, 4, 16, 16, N), new x1(8, 16, 32, 32, N), new x1(8, 16, 128, 128, N), new x1(8, 32, 128, 256, N), new x1(32, 128, 258, 1024, N), new x1(32, 258, 258, 4096, N)], c.deflateInit = function (L, Y) {
          return A1(L, Y, f, 15, 8, 0);
        }, c.deflateInit2 = A1, c.deflateReset = k1, c.deflateResetKeep = B1, c.deflateSetHeader = function (L, Y) {
          return L && L.state ? L.state.wrap !== 2 ? s : (L.state.gzhead = Y, g) : s;
        }, c.deflate = function (L, Y) {
          var Q, b, R, O;
          if (!L || !L.state || 5 < Y || Y < 0) return L ? K(L, s) : s;
          if (b = L.state, !L.output || !L.input && L.avail_in !== 0 || b.status === 666 && Y !== v) return K(L, L.avail_out === 0 ? -5 : s);
          if (b.strm = L, Q = b.last_flush, b.last_flush = Y, b.status === A) if (b.wrap === 2) L.adler = 0, g1(b, 31), g1(b, 139), g1(b, 8), b.gzhead ? (g1(b, (b.gzhead.text ? 1 : 0) + (b.gzhead.hcrc ? 2 : 0) + (b.gzhead.extra ? 4 : 0) + (b.gzhead.name ? 8 : 0) + (b.gzhead.comment ? 16 : 0)), g1(b, 255 & b.gzhead.time), g1(b, b.gzhead.time >> 8 & 255), g1(b, b.gzhead.time >> 16 & 255), g1(b, b.gzhead.time >> 24 & 255), g1(b, b.level === 9 ? 2 : 2 <= b.strategy || b.level < 2 ? 4 : 0), g1(b, 255 & b.gzhead.os), b.gzhead.extra && b.gzhead.extra.length && (g1(b, 255 & b.gzhead.extra.length), g1(b, b.gzhead.extra.length >> 8 & 255)), b.gzhead.hcrc && (L.adler = o(L.adler, b.pending_buf, b.pending, 0)), b.gzindex = 0, b.status = 69) : (g1(b, 0), g1(b, 0), g1(b, 0), g1(b, 0), g1(b, 0), g1(b, b.level === 9 ? 2 : 2 <= b.strategy || b.level < 2 ? 4 : 0), g1(b, 3), b.status = P);else {
            var t1 = f + (b.w_bits - 8 << 4) << 8;
            t1 |= (2 <= b.strategy || b.level < 2 ? 0 : b.level < 6 ? 1 : b.level === 6 ? 2 : 3) << 6, b.strstart !== 0 && (t1 |= 32), t1 += 31 - t1 % 31, b.status = P, X(b, t1), b.strstart !== 0 && (X(b, L.adler >>> 16), X(b, 65535 & L.adler)), L.adler = 1;
          }
          if (b.status === 69) if (b.gzhead.extra) {
            for (R = b.pending; b.gzindex < (65535 & b.gzhead.extra.length) && (b.pending !== b.pending_buf_size || (b.gzhead.hcrc && b.pending > R && (L.adler = o(L.adler, b.pending_buf, b.pending - R, R)), W(L), R = b.pending, b.pending !== b.pending_buf_size));) g1(b, 255 & b.gzhead.extra[b.gzindex]), b.gzindex++;
            b.gzhead.hcrc && b.pending > R && (L.adler = o(L.adler, b.pending_buf, b.pending - R, R)), b.gzindex === b.gzhead.extra.length && (b.gzindex = 0, b.status = 73);
          } else b.status = 73;
          if (b.status === 73) if (b.gzhead.name) {
            R = b.pending;
            do {
              if (b.pending === b.pending_buf_size && (b.gzhead.hcrc && b.pending > R && (L.adler = o(L.adler, b.pending_buf, b.pending - R, R)), W(L), R = b.pending, b.pending === b.pending_buf_size)) {
                O = 1;
                break;
              }
              O = b.gzindex < b.gzhead.name.length ? 255 & b.gzhead.name.charCodeAt(b.gzindex++) : 0, g1(b, O);
            } while (O !== 0);
            b.gzhead.hcrc && b.pending > R && (L.adler = o(L.adler, b.pending_buf, b.pending - R, R)), O === 0 && (b.gzindex = 0, b.status = 91);
          } else b.status = 91;
          if (b.status === 91) if (b.gzhead.comment) {
            R = b.pending;
            do {
              if (b.pending === b.pending_buf_size && (b.gzhead.hcrc && b.pending > R && (L.adler = o(L.adler, b.pending_buf, b.pending - R, R)), W(L), R = b.pending, b.pending === b.pending_buf_size)) {
                O = 1;
                break;
              }
              O = b.gzindex < b.gzhead.comment.length ? 255 & b.gzhead.comment.charCodeAt(b.gzindex++) : 0, g1(b, O);
            } while (O !== 0);
            b.gzhead.hcrc && b.pending > R && (L.adler = o(L.adler, b.pending_buf, b.pending - R, R)), O === 0 && (b.status = 103);
          } else b.status = 103;
          if (b.status === 103 && (b.gzhead.hcrc ? (b.pending + 2 > b.pending_buf_size && W(L), b.pending + 2 <= b.pending_buf_size && (g1(b, 255 & L.adler), g1(b, L.adler >> 8 & 255), L.adler = 0, b.status = P)) : b.status = P), b.pending !== 0) {
            if (W(L), L.avail_out === 0) return b.last_flush = -1, g;
          } else if (L.avail_in === 0 && Z(Y) <= Z(Q) && Y !== v) return K(L, -5);
          if (b.status === 666 && L.avail_in !== 0) return K(L, -5);
          if (L.avail_in !== 0 || b.lookahead !== 0 || Y !== h && b.status !== 666) {
            var r1 = b.strategy === 2 ? function (q, h1) {
              for (var d1;;) {
                if (q.lookahead === 0 && (o1(q), q.lookahead === 0)) {
                  if (h1 === h) return C;
                  break;
                }
                if (q.match_length = 0, d1 = l._tr_tally(q, 0, q.window[q.strstart]), q.lookahead--, q.strstart++, d1 && (_(q, !1), q.strm.avail_out === 0)) return C;
              }
              return q.insert = 0, h1 === v ? (_(q, !0), q.strm.avail_out === 0 ? a1 : j) : q.last_lit && (_(q, !1), q.strm.avail_out === 0) ? C : E;
            }(b, Y) : b.strategy === 3 ? function (q, h1) {
              for (var d1, l1, e1, w1, R1 = q.window;;) {
                if (q.lookahead <= F) {
                  if (o1(q), q.lookahead <= F && h1 === h) return C;
                  if (q.lookahead === 0) break;
                }
                if (q.match_length = 0, q.lookahead >= k && 0 < q.strstart && (l1 = R1[e1 = q.strstart - 1]) === R1[++e1] && l1 === R1[++e1] && l1 === R1[++e1]) {
                  w1 = q.strstart + F;
                  do ; while (l1 === R1[++e1] && l1 === R1[++e1] && l1 === R1[++e1] && l1 === R1[++e1] && l1 === R1[++e1] && l1 === R1[++e1] && l1 === R1[++e1] && l1 === R1[++e1] && e1 < w1);
                  q.match_length = F - (w1 - e1), q.match_length > q.lookahead && (q.match_length = q.lookahead);
                }
                if (q.match_length >= k ? (d1 = l._tr_tally(q, 1, q.match_length - k), q.lookahead -= q.match_length, q.strstart += q.match_length, q.match_length = 0) : (d1 = l._tr_tally(q, 0, q.window[q.strstart]), q.lookahead--, q.strstart++), d1 && (_(q, !1), q.strm.avail_out === 0)) return C;
              }
              return q.insert = 0, h1 === v ? (_(q, !0), q.strm.avail_out === 0 ? a1 : j) : q.last_lit && (_(q, !1), q.strm.avail_out === 0) ? C : E;
            }(b, Y) : r[b.level].func(b, Y);
            if (r1 !== a1 && r1 !== j || (b.status = 666), r1 === C || r1 === a1) return L.avail_out === 0 && (b.last_flush = -1), g;
            if (r1 === E && (Y === 1 ? l._tr_align(b) : Y !== 5 && (l._tr_stored_block(b, 0, 0, !1), Y === 3 && (J(b.head), b.lookahead === 0 && (b.strstart = 0, b.block_start = 0, b.insert = 0))), W(L), L.avail_out === 0)) return b.last_flush = -1, g;
          }
          return Y !== v ? g : b.wrap <= 0 ? 1 : (b.wrap === 2 ? (g1(b, 255 & L.adler), g1(b, L.adler >> 8 & 255), g1(b, L.adler >> 16 & 255), g1(b, L.adler >> 24 & 255), g1(b, 255 & L.total_in), g1(b, L.total_in >> 8 & 255), g1(b, L.total_in >> 16 & 255), g1(b, L.total_in >> 24 & 255)) : (X(b, L.adler >>> 16), X(b, 65535 & L.adler)), W(L), 0 < b.wrap && (b.wrap = -b.wrap), b.pending !== 0 ? g : 1);
        }, c.deflateEnd = function (L) {
          var Y;
          return L && L.state ? (Y = L.state.status) !== A && Y !== 69 && Y !== 73 && Y !== 91 && Y !== 103 && Y !== P && Y !== 666 ? K(L, s) : (L.state = null, Y === P ? K(L, -3) : g) : s;
        }, c.deflateSetDictionary = function (L, Y) {
          var Q,
            b,
            R,
            O,
            t1,
            r1,
            q,
            h1,
            d1 = Y.length;
          if (!L || !L.state || (O = (Q = L.state).wrap) === 2 || O === 1 && Q.status !== A || Q.lookahead) return s;
          for (O === 1 && (L.adler = i(L.adler, Y, d1, 0)), Q.wrap = 0, d1 >= Q.w_size && (O === 0 && (J(Q.head), Q.strstart = 0, Q.block_start = 0, Q.insert = 0), h1 = new e.Buf8(Q.w_size), e.arraySet(h1, Y, d1 - Q.w_size, Q.w_size, 0), Y = h1, d1 = Q.w_size), t1 = L.avail_in, r1 = L.next_in, q = L.input, L.avail_in = d1, L.next_in = 0, L.input = Y, o1(Q); Q.lookahead >= k;) {
            for (b = Q.strstart, R = Q.lookahead - (k - 1); Q.ins_h = (Q.ins_h << Q.hash_shift ^ Q.window[b + k - 1]) & Q.hash_mask, Q.prev[b & Q.w_mask] = Q.head[Q.ins_h], Q.head[Q.ins_h] = b, b++, --R;);
            Q.strstart = b, Q.lookahead = k - 1, o1(Q);
          }
          return Q.strstart += Q.lookahead, Q.block_start = Q.strstart, Q.insert = Q.lookahead, Q.lookahead = 0, Q.match_length = Q.prev_length = k - 1, Q.match_available = 0, L.next_in = r1, L.input = q, L.avail_in = t1, Q.wrap = O, g;
        }, c.deflateInfo = "pako deflate (from Nodeca project)";
      }, {
        "../utils/common": 41,
        "./adler32": 43,
        "./crc32": 45,
        "./messages": 51,
        "./trees": 52
      }],
      47: [function (t, a, c) {
        "use strict";

        a.exports = function () {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        };
      }, {}],
      48: [function (t, a, c) {
        "use strict";

        a.exports = function (r, e) {
          var l, i, o, n, h, v, g, s, d, z, u, f, p, m, M, w, H, y, k, F, U, A, P, C, E;
          l = r.state, i = r.next_in, C = r.input, o = i + (r.avail_in - 5), n = r.next_out, E = r.output, h = n - (e - r.avail_out), v = n + (r.avail_out - 257), g = l.dmax, s = l.wsize, d = l.whave, z = l.wnext, u = l.window, f = l.hold, p = l.bits, m = l.lencode, M = l.distcode, w = (1 << l.lenbits) - 1, H = (1 << l.distbits) - 1;
          t: do {
            p < 15 && (f += C[i++] << p, p += 8, f += C[i++] << p, p += 8), y = m[f & w];
            a: for (;;) {
              if (f >>>= k = y >>> 24, p -= k, (k = y >>> 16 & 255) === 0) E[n++] = 65535 & y;else {
                if (!(16 & k)) {
                  if (!(64 & k)) {
                    y = m[(65535 & y) + (f & (1 << k) - 1)];
                    continue a;
                  }
                  if (32 & k) {
                    l.mode = 12;
                    break t;
                  }
                  r.msg = "invalid literal/length code", l.mode = 30;
                  break t;
                }
                F = 65535 & y, (k &= 15) && (p < k && (f += C[i++] << p, p += 8), F += f & (1 << k) - 1, f >>>= k, p -= k), p < 15 && (f += C[i++] << p, p += 8, f += C[i++] << p, p += 8), y = M[f & H];
                c: for (;;) {
                  if (f >>>= k = y >>> 24, p -= k, !(16 & (k = y >>> 16 & 255))) {
                    if (!(64 & k)) {
                      y = M[(65535 & y) + (f & (1 << k) - 1)];
                      continue c;
                    }
                    r.msg = "invalid distance code", l.mode = 30;
                    break t;
                  }
                  if (U = 65535 & y, p < (k &= 15) && (f += C[i++] << p, (p += 8) < k && (f += C[i++] << p, p += 8)), g < (U += f & (1 << k) - 1)) {
                    r.msg = "invalid distance too far back", l.mode = 30;
                    break t;
                  }
                  if (f >>>= k, p -= k, (k = n - h) < U) {
                    if (d < (k = U - k) && l.sane) {
                      r.msg = "invalid distance too far back", l.mode = 30;
                      break t;
                    }
                    if (P = u, (A = 0) === z) {
                      if (A += s - k, k < F) {
                        for (F -= k; E[n++] = u[A++], --k;);
                        A = n - U, P = E;
                      }
                    } else if (z < k) {
                      if (A += s + z - k, (k -= z) < F) {
                        for (F -= k; E[n++] = u[A++], --k;);
                        if (A = 0, z < F) {
                          for (F -= k = z; E[n++] = u[A++], --k;);
                          A = n - U, P = E;
                        }
                      }
                    } else if (A += z - k, k < F) {
                      for (F -= k; E[n++] = u[A++], --k;);
                      A = n - U, P = E;
                    }
                    for (; 2 < F;) E[n++] = P[A++], E[n++] = P[A++], E[n++] = P[A++], F -= 3;
                    F && (E[n++] = P[A++], 1 < F && (E[n++] = P[A++]));
                  } else {
                    for (A = n - U; E[n++] = E[A++], E[n++] = E[A++], E[n++] = E[A++], 2 < (F -= 3););
                    F && (E[n++] = E[A++], 1 < F && (E[n++] = E[A++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (i < o && n < v);
          i -= F = p >> 3, f &= (1 << (p -= F << 3)) - 1, r.next_in = i, r.next_out = n, r.avail_in = i < o ? o - i + 5 : 5 - (i - o), r.avail_out = n < v ? v - n + 257 : 257 - (n - v), l.hold = f, l.bits = p;
        };
      }, {}],
      49: [function (t, a, c) {
        "use strict";

        var r = t("../utils/common"),
          e = t("./adler32"),
          l = t("./crc32"),
          i = t("./inffast"),
          o = t("./inftrees"),
          n = 1,
          h = 2,
          v = 0,
          g = -2,
          s = 1,
          d = 852,
          z = 592;
        function u(A) {
          return (A >>> 24 & 255) + (A >>> 8 & 65280) + ((65280 & A) << 8) + ((255 & A) << 24);
        }
        function f() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function p(A) {
          var P;
          return A && A.state ? (P = A.state, A.total_in = A.total_out = P.total = 0, A.msg = "", P.wrap && (A.adler = 1 & P.wrap), P.mode = s, P.last = 0, P.havedict = 0, P.dmax = 32768, P.head = null, P.hold = 0, P.bits = 0, P.lencode = P.lendyn = new r.Buf32(d), P.distcode = P.distdyn = new r.Buf32(z), P.sane = 1, P.back = -1, v) : g;
        }
        function m(A) {
          var P;
          return A && A.state ? ((P = A.state).wsize = 0, P.whave = 0, P.wnext = 0, p(A)) : g;
        }
        function M(A, P) {
          var C, E;
          return A && A.state ? (E = A.state, P < 0 ? (C = 0, P = -P) : (C = 1 + (P >> 4), P < 48 && (P &= 15)), P && (P < 8 || 15 < P) ? g : (E.window !== null && E.wbits !== P && (E.window = null), E.wrap = C, E.wbits = P, m(A))) : g;
        }
        function w(A, P) {
          var C, E;
          return A ? (E = new f(), (A.state = E).window = null, (C = M(A, P)) !== v && (A.state = null), C) : g;
        }
        var H,
          y,
          k = !0;
        function F(A) {
          if (k) {
            var P;
            for (H = new r.Buf32(512), y = new r.Buf32(32), P = 0; P < 144;) A.lens[P++] = 8;
            for (; P < 256;) A.lens[P++] = 9;
            for (; P < 280;) A.lens[P++] = 7;
            for (; P < 288;) A.lens[P++] = 8;
            for (o(n, A.lens, 0, 288, H, 0, A.work, {
              bits: 9
            }), P = 0; P < 32;) A.lens[P++] = 5;
            o(h, A.lens, 0, 32, y, 0, A.work, {
              bits: 5
            }), k = !1;
          }
          A.lencode = H, A.lenbits = 9, A.distcode = y, A.distbits = 5;
        }
        function U(A, P, C, E) {
          var a1,
            j = A.state;
          return j.window === null && (j.wsize = 1 << j.wbits, j.wnext = 0, j.whave = 0, j.window = new r.Buf8(j.wsize)), E >= j.wsize ? (r.arraySet(j.window, P, C - j.wsize, j.wsize, 0), j.wnext = 0, j.whave = j.wsize) : (E < (a1 = j.wsize - j.wnext) && (a1 = E), r.arraySet(j.window, P, C - E, a1, j.wnext), (E -= a1) ? (r.arraySet(j.window, P, C - E, E, 0), j.wnext = E, j.whave = j.wsize) : (j.wnext += a1, j.wnext === j.wsize && (j.wnext = 0), j.whave < j.wsize && (j.whave += a1))), 0;
        }
        c.inflateReset = m, c.inflateReset2 = M, c.inflateResetKeep = p, c.inflateInit = function (A) {
          return w(A, 15);
        }, c.inflateInit2 = w, c.inflate = function (A, P) {
          var C,
            E,
            a1,
            j,
            K,
            Z,
            J,
            W,
            _,
            g1,
            X,
            $,
            o1,
            u1,
            N,
            x1,
            i1,
            B1,
            k1,
            A1,
            L,
            Y,
            Q,
            b,
            R = 0,
            O = new r.Buf8(4),
            t1 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!A || !A.state || !A.output || !A.input && A.avail_in !== 0) return g;
          (C = A.state).mode === 12 && (C.mode = 13), K = A.next_out, a1 = A.output, J = A.avail_out, j = A.next_in, E = A.input, Z = A.avail_in, W = C.hold, _ = C.bits, g1 = Z, X = J, Y = v;
          t: for (;;) switch (C.mode) {
            case s:
              if (C.wrap === 0) {
                C.mode = 13;
                break;
              }
              for (; _ < 16;) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              if (2 & C.wrap && W === 35615) {
                O[C.check = 0] = 255 & W, O[1] = W >>> 8 & 255, C.check = l(C.check, O, 2, 0), _ = W = 0, C.mode = 2;
                break;
              }
              if (C.flags = 0, C.head && (C.head.done = !1), !(1 & C.wrap) || (((255 & W) << 8) + (W >> 8)) % 31) {
                A.msg = "incorrect header check", C.mode = 30;
                break;
              }
              if ((15 & W) != 8) {
                A.msg = "unknown compression method", C.mode = 30;
                break;
              }
              if (_ -= 4, L = 8 + (15 & (W >>>= 4)), C.wbits === 0) C.wbits = L;else if (L > C.wbits) {
                A.msg = "invalid window size", C.mode = 30;
                break;
              }
              C.dmax = 1 << L, A.adler = C.check = 1, C.mode = 512 & W ? 10 : 12, _ = W = 0;
              break;
            case 2:
              for (; _ < 16;) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              if (C.flags = W, (255 & C.flags) != 8) {
                A.msg = "unknown compression method", C.mode = 30;
                break;
              }
              if (57344 & C.flags) {
                A.msg = "unknown header flags set", C.mode = 30;
                break;
              }
              C.head && (C.head.text = W >> 8 & 1), 512 & C.flags && (O[0] = 255 & W, O[1] = W >>> 8 & 255, C.check = l(C.check, O, 2, 0)), _ = W = 0, C.mode = 3;
            case 3:
              for (; _ < 32;) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              C.head && (C.head.time = W), 512 & C.flags && (O[0] = 255 & W, O[1] = W >>> 8 & 255, O[2] = W >>> 16 & 255, O[3] = W >>> 24 & 255, C.check = l(C.check, O, 4, 0)), _ = W = 0, C.mode = 4;
            case 4:
              for (; _ < 16;) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              C.head && (C.head.xflags = 255 & W, C.head.os = W >> 8), 512 & C.flags && (O[0] = 255 & W, O[1] = W >>> 8 & 255, C.check = l(C.check, O, 2, 0)), _ = W = 0, C.mode = 5;
            case 5:
              if (1024 & C.flags) {
                for (; _ < 16;) {
                  if (Z === 0) break t;
                  Z--, W += E[j++] << _, _ += 8;
                }
                C.length = W, C.head && (C.head.extra_len = W), 512 & C.flags && (O[0] = 255 & W, O[1] = W >>> 8 & 255, C.check = l(C.check, O, 2, 0)), _ = W = 0;
              } else C.head && (C.head.extra = null);
              C.mode = 6;
            case 6:
              if (1024 & C.flags && (Z < ($ = C.length) && ($ = Z), $ && (C.head && (L = C.head.extra_len - C.length, C.head.extra || (C.head.extra = new Array(C.head.extra_len)), r.arraySet(C.head.extra, E, j, $, L)), 512 & C.flags && (C.check = l(C.check, E, $, j)), Z -= $, j += $, C.length -= $), C.length)) break t;
              C.length = 0, C.mode = 7;
            case 7:
              if (2048 & C.flags) {
                if (Z === 0) break t;
                for ($ = 0; L = E[j + $++], C.head && L && C.length < 65536 && (C.head.name += String.fromCharCode(L)), L && $ < Z;);
                if (512 & C.flags && (C.check = l(C.check, E, $, j)), Z -= $, j += $, L) break t;
              } else C.head && (C.head.name = null);
              C.length = 0, C.mode = 8;
            case 8:
              if (4096 & C.flags) {
                if (Z === 0) break t;
                for ($ = 0; L = E[j + $++], C.head && L && C.length < 65536 && (C.head.comment += String.fromCharCode(L)), L && $ < Z;);
                if (512 & C.flags && (C.check = l(C.check, E, $, j)), Z -= $, j += $, L) break t;
              } else C.head && (C.head.comment = null);
              C.mode = 9;
            case 9:
              if (512 & C.flags) {
                for (; _ < 16;) {
                  if (Z === 0) break t;
                  Z--, W += E[j++] << _, _ += 8;
                }
                if (W !== (65535 & C.check)) {
                  A.msg = "header crc mismatch", C.mode = 30;
                  break;
                }
                _ = W = 0;
              }
              C.head && (C.head.hcrc = C.flags >> 9 & 1, C.head.done = !0), A.adler = C.check = 0, C.mode = 12;
              break;
            case 10:
              for (; _ < 32;) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              A.adler = C.check = u(W), _ = W = 0, C.mode = 11;
            case 11:
              if (C.havedict === 0) return A.next_out = K, A.avail_out = J, A.next_in = j, A.avail_in = Z, C.hold = W, C.bits = _, 2;
              A.adler = C.check = 1, C.mode = 12;
            case 12:
              if (P === 5 || P === 6) break t;
            case 13:
              if (C.last) {
                W >>>= 7 & _, _ -= 7 & _, C.mode = 27;
                break;
              }
              for (; _ < 3;) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              switch (C.last = 1 & W, _ -= 1, 3 & (W >>>= 1)) {
                case 0:
                  C.mode = 14;
                  break;
                case 1:
                  if (F(C), C.mode = 20, P !== 6) break;
                  W >>>= 2, _ -= 2;
                  break t;
                case 2:
                  C.mode = 17;
                  break;
                case 3:
                  A.msg = "invalid block type", C.mode = 30;
              }
              W >>>= 2, _ -= 2;
              break;
            case 14:
              for (W >>>= 7 & _, _ -= 7 & _; _ < 32;) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              if ((65535 & W) != (W >>> 16 ^ 65535)) {
                A.msg = "invalid stored block lengths", C.mode = 30;
                break;
              }
              if (C.length = 65535 & W, _ = W = 0, C.mode = 15, P === 6) break t;
            case 15:
              C.mode = 16;
            case 16:
              if ($ = C.length) {
                if (Z < $ && ($ = Z), J < $ && ($ = J), $ === 0) break t;
                r.arraySet(a1, E, j, $, K), Z -= $, j += $, J -= $, K += $, C.length -= $;
                break;
              }
              C.mode = 12;
              break;
            case 17:
              for (; _ < 14;) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              if (C.nlen = 257 + (31 & W), W >>>= 5, _ -= 5, C.ndist = 1 + (31 & W), W >>>= 5, _ -= 5, C.ncode = 4 + (15 & W), W >>>= 4, _ -= 4, 286 < C.nlen || 30 < C.ndist) {
                A.msg = "too many length or distance symbols", C.mode = 30;
                break;
              }
              C.have = 0, C.mode = 18;
            case 18:
              for (; C.have < C.ncode;) {
                for (; _ < 3;) {
                  if (Z === 0) break t;
                  Z--, W += E[j++] << _, _ += 8;
                }
                C.lens[t1[C.have++]] = 7 & W, W >>>= 3, _ -= 3;
              }
              for (; C.have < 19;) C.lens[t1[C.have++]] = 0;
              if (C.lencode = C.lendyn, C.lenbits = 7, Q = {
                bits: C.lenbits
              }, Y = o(0, C.lens, 0, 19, C.lencode, 0, C.work, Q), C.lenbits = Q.bits, Y) {
                A.msg = "invalid code lengths set", C.mode = 30;
                break;
              }
              C.have = 0, C.mode = 19;
            case 19:
              for (; C.have < C.nlen + C.ndist;) {
                for (; x1 = (R = C.lencode[W & (1 << C.lenbits) - 1]) >>> 16 & 255, i1 = 65535 & R, !((N = R >>> 24) <= _);) {
                  if (Z === 0) break t;
                  Z--, W += E[j++] << _, _ += 8;
                }
                if (i1 < 16) W >>>= N, _ -= N, C.lens[C.have++] = i1;else {
                  if (i1 === 16) {
                    for (b = N + 2; _ < b;) {
                      if (Z === 0) break t;
                      Z--, W += E[j++] << _, _ += 8;
                    }
                    if (W >>>= N, _ -= N, C.have === 0) {
                      A.msg = "invalid bit length repeat", C.mode = 30;
                      break;
                    }
                    L = C.lens[C.have - 1], $ = 3 + (3 & W), W >>>= 2, _ -= 2;
                  } else if (i1 === 17) {
                    for (b = N + 3; _ < b;) {
                      if (Z === 0) break t;
                      Z--, W += E[j++] << _, _ += 8;
                    }
                    _ -= N, L = 0, $ = 3 + (7 & (W >>>= N)), W >>>= 3, _ -= 3;
                  } else {
                    for (b = N + 7; _ < b;) {
                      if (Z === 0) break t;
                      Z--, W += E[j++] << _, _ += 8;
                    }
                    _ -= N, L = 0, $ = 11 + (127 & (W >>>= N)), W >>>= 7, _ -= 7;
                  }
                  if (C.have + $ > C.nlen + C.ndist) {
                    A.msg = "invalid bit length repeat", C.mode = 30;
                    break;
                  }
                  for (; $--;) C.lens[C.have++] = L;
                }
              }
              if (C.mode === 30) break;
              if (C.lens[256] === 0) {
                A.msg = "invalid code -- missing end-of-block", C.mode = 30;
                break;
              }
              if (C.lenbits = 9, Q = {
                bits: C.lenbits
              }, Y = o(n, C.lens, 0, C.nlen, C.lencode, 0, C.work, Q), C.lenbits = Q.bits, Y) {
                A.msg = "invalid literal/lengths set", C.mode = 30;
                break;
              }
              if (C.distbits = 6, C.distcode = C.distdyn, Q = {
                bits: C.distbits
              }, Y = o(h, C.lens, C.nlen, C.ndist, C.distcode, 0, C.work, Q), C.distbits = Q.bits, Y) {
                A.msg = "invalid distances set", C.mode = 30;
                break;
              }
              if (C.mode = 20, P === 6) break t;
            case 20:
              C.mode = 21;
            case 21:
              if (6 <= Z && 258 <= J) {
                A.next_out = K, A.avail_out = J, A.next_in = j, A.avail_in = Z, C.hold = W, C.bits = _, i(A, X), K = A.next_out, a1 = A.output, J = A.avail_out, j = A.next_in, E = A.input, Z = A.avail_in, W = C.hold, _ = C.bits, C.mode === 12 && (C.back = -1);
                break;
              }
              for (C.back = 0; x1 = (R = C.lencode[W & (1 << C.lenbits) - 1]) >>> 16 & 255, i1 = 65535 & R, !((N = R >>> 24) <= _);) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              if (x1 && !(240 & x1)) {
                for (B1 = N, k1 = x1, A1 = i1; x1 = (R = C.lencode[A1 + ((W & (1 << B1 + k1) - 1) >> B1)]) >>> 16 & 255, i1 = 65535 & R, !(B1 + (N = R >>> 24) <= _);) {
                  if (Z === 0) break t;
                  Z--, W += E[j++] << _, _ += 8;
                }
                W >>>= B1, _ -= B1, C.back += B1;
              }
              if (W >>>= N, _ -= N, C.back += N, C.length = i1, x1 === 0) {
                C.mode = 26;
                break;
              }
              if (32 & x1) {
                C.back = -1, C.mode = 12;
                break;
              }
              if (64 & x1) {
                A.msg = "invalid literal/length code", C.mode = 30;
                break;
              }
              C.extra = 15 & x1, C.mode = 22;
            case 22:
              if (C.extra) {
                for (b = C.extra; _ < b;) {
                  if (Z === 0) break t;
                  Z--, W += E[j++] << _, _ += 8;
                }
                C.length += W & (1 << C.extra) - 1, W >>>= C.extra, _ -= C.extra, C.back += C.extra;
              }
              C.was = C.length, C.mode = 23;
            case 23:
              for (; x1 = (R = C.distcode[W & (1 << C.distbits) - 1]) >>> 16 & 255, i1 = 65535 & R, !((N = R >>> 24) <= _);) {
                if (Z === 0) break t;
                Z--, W += E[j++] << _, _ += 8;
              }
              if (!(240 & x1)) {
                for (B1 = N, k1 = x1, A1 = i1; x1 = (R = C.distcode[A1 + ((W & (1 << B1 + k1) - 1) >> B1)]) >>> 16 & 255, i1 = 65535 & R, !(B1 + (N = R >>> 24) <= _);) {
                  if (Z === 0) break t;
                  Z--, W += E[j++] << _, _ += 8;
                }
                W >>>= B1, _ -= B1, C.back += B1;
              }
              if (W >>>= N, _ -= N, C.back += N, 64 & x1) {
                A.msg = "invalid distance code", C.mode = 30;
                break;
              }
              C.offset = i1, C.extra = 15 & x1, C.mode = 24;
            case 24:
              if (C.extra) {
                for (b = C.extra; _ < b;) {
                  if (Z === 0) break t;
                  Z--, W += E[j++] << _, _ += 8;
                }
                C.offset += W & (1 << C.extra) - 1, W >>>= C.extra, _ -= C.extra, C.back += C.extra;
              }
              if (C.offset > C.dmax) {
                A.msg = "invalid distance too far back", C.mode = 30;
                break;
              }
              C.mode = 25;
            case 25:
              if (J === 0) break t;
              if ($ = X - J, C.offset > $) {
                if (($ = C.offset - $) > C.whave && C.sane) {
                  A.msg = "invalid distance too far back", C.mode = 30;
                  break;
                }
                o1 = $ > C.wnext ? ($ -= C.wnext, C.wsize - $) : C.wnext - $, $ > C.length && ($ = C.length), u1 = C.window;
              } else u1 = a1, o1 = K - C.offset, $ = C.length;
              for (J < $ && ($ = J), J -= $, C.length -= $; a1[K++] = u1[o1++], --$;);
              C.length === 0 && (C.mode = 21);
              break;
            case 26:
              if (J === 0) break t;
              a1[K++] = C.length, J--, C.mode = 21;
              break;
            case 27:
              if (C.wrap) {
                for (; _ < 32;) {
                  if (Z === 0) break t;
                  Z--, W |= E[j++] << _, _ += 8;
                }
                if (X -= J, A.total_out += X, C.total += X, X && (A.adler = C.check = C.flags ? l(C.check, a1, X, K - X) : e(C.check, a1, X, K - X)), X = J, (C.flags ? W : u(W)) !== C.check) {
                  A.msg = "incorrect data check", C.mode = 30;
                  break;
                }
                _ = W = 0;
              }
              C.mode = 28;
            case 28:
              if (C.wrap && C.flags) {
                for (; _ < 32;) {
                  if (Z === 0) break t;
                  Z--, W += E[j++] << _, _ += 8;
                }
                if (W !== (4294967295 & C.total)) {
                  A.msg = "incorrect length check", C.mode = 30;
                  break;
                }
                _ = W = 0;
              }
              C.mode = 29;
            case 29:
              Y = 1;
              break t;
            case 30:
              Y = -3;
              break t;
            case 31:
              return -4;
            case 32:
            default:
              return g;
          }
          return A.next_out = K, A.avail_out = J, A.next_in = j, A.avail_in = Z, C.hold = W, C.bits = _, (C.wsize || X !== A.avail_out && C.mode < 30 && (C.mode < 27 || P !== 4)) && U(A, A.output, A.next_out, X - A.avail_out) ? (C.mode = 31, -4) : (g1 -= A.avail_in, X -= A.avail_out, A.total_in += g1, A.total_out += X, C.total += X, C.wrap && X && (A.adler = C.check = C.flags ? l(C.check, a1, X, A.next_out - X) : e(C.check, a1, X, A.next_out - X)), A.data_type = C.bits + (C.last ? 64 : 0) + (C.mode === 12 ? 128 : 0) + (C.mode === 20 || C.mode === 15 ? 256 : 0), (g1 == 0 && X === 0 || P === 4) && Y === v && (Y = -5), Y);
        }, c.inflateEnd = function (A) {
          if (!A || !A.state) return g;
          var P = A.state;
          return P.window && (P.window = null), A.state = null, v;
        }, c.inflateGetHeader = function (A, P) {
          var C;
          return A && A.state && 2 & (C = A.state).wrap ? ((C.head = P).done = !1, v) : g;
        }, c.inflateSetDictionary = function (A, P) {
          var C,
            E = P.length;
          return A && A.state ? (C = A.state).wrap !== 0 && C.mode !== 11 ? g : C.mode === 11 && e(1, P, E, 0) !== C.check ? -3 : U(A, P, E, E) ? (C.mode = 31, -4) : (C.havedict = 1, v) : g;
        }, c.inflateInfo = "pako inflate (from Nodeca project)";
      }, {
        "../utils/common": 41,
        "./adler32": 43,
        "./crc32": 45,
        "./inffast": 48,
        "./inftrees": 50
      }],
      50: [function (t, a, c) {
        "use strict";

        var r = t("../utils/common"),
          e = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
          l = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
          i = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
          o = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        a.exports = function (n, h, v, g, s, d, z, u) {
          var f,
            p,
            m,
            M,
            w,
            H,
            y,
            k,
            F,
            U = u.bits,
            A = 0,
            P = 0,
            C = 0,
            E = 0,
            a1 = 0,
            j = 0,
            K = 0,
            Z = 0,
            J = 0,
            W = 0,
            _ = null,
            g1 = 0,
            X = new r.Buf16(16),
            $ = new r.Buf16(16),
            o1 = null,
            u1 = 0;
          for (A = 0; A <= 15; A++) X[A] = 0;
          for (P = 0; P < g; P++) X[h[v + P]]++;
          for (a1 = U, E = 15; 1 <= E && X[E] === 0; E--);
          if (E < a1 && (a1 = E), E === 0) return s[d++] = 20971520, s[d++] = 20971520, u.bits = 1, 0;
          for (C = 1; C < E && X[C] === 0; C++);
          for (a1 < C && (a1 = C), A = Z = 1; A <= 15; A++) if (Z <<= 1, (Z -= X[A]) < 0) return -1;
          if (0 < Z && (n === 0 || E !== 1)) return -1;
          for ($[1] = 0, A = 1; A < 15; A++) $[A + 1] = $[A] + X[A];
          for (P = 0; P < g; P++) h[v + P] !== 0 && (z[$[h[v + P]]++] = P);
          if (H = n === 0 ? (_ = o1 = z, 19) : n === 1 ? (_ = e, g1 -= 257, o1 = l, u1 -= 257, 256) : (_ = i, o1 = o, -1), A = C, w = d, K = P = W = 0, m = -1, M = (J = 1 << (j = a1)) - 1, n === 1 && 852 < J || n === 2 && 592 < J) return 1;
          for (;;) {
            for (y = A - K, F = z[P] < H ? (k = 0, z[P]) : z[P] > H ? (k = o1[u1 + z[P]], _[g1 + z[P]]) : (k = 96, 0), f = 1 << A - K, C = p = 1 << j; s[w + (W >> K) + (p -= f)] = y << 24 | k << 16 | F | 0, p !== 0;);
            for (f = 1 << A - 1; W & f;) f >>= 1;
            if (f !== 0 ? (W &= f - 1, W += f) : W = 0, P++, --X[A] == 0) {
              if (A === E) break;
              A = h[v + z[P]];
            }
            if (a1 < A && (W & M) !== m) {
              for (K === 0 && (K = a1), w += C, Z = 1 << (j = A - K); j + K < E && !((Z -= X[j + K]) <= 0);) j++, Z <<= 1;
              if (J += 1 << j, n === 1 && 852 < J || n === 2 && 592 < J) return 1;
              s[m = W & M] = a1 << 24 | j << 16 | w - d | 0;
            }
          }
          return W !== 0 && (s[w + W] = A - K << 24 | 64 << 16 | 0), u.bits = a1, 0;
        };
      }, {
        "../utils/common": 41
      }],
      51: [function (t, a, c) {
        "use strict";

        a.exports = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        };
      }, {}],
      52: [function (t, a, c) {
        "use strict";

        var r = t("../utils/common"),
          e = 0,
          l = 1;
        function i(R) {
          for (var O = R.length; 0 <= --O;) R[O] = 0;
        }
        var o = 0,
          n = 29,
          h = 256,
          v = h + 1 + n,
          g = 30,
          s = 19,
          d = 2 * v + 1,
          z = 15,
          u = 16,
          f = 7,
          p = 256,
          m = 16,
          M = 17,
          w = 18,
          H = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
          y = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
          k = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
          F = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
          U = new Array(2 * (v + 2));
        i(U);
        var A = new Array(2 * g);
        i(A);
        var P = new Array(512);
        i(P);
        var C = new Array(256);
        i(C);
        var E = new Array(n);
        i(E);
        var a1,
          j,
          K,
          Z = new Array(g);
        function J(R, O, t1, r1, q) {
          this.static_tree = R, this.extra_bits = O, this.extra_base = t1, this.elems = r1, this.max_length = q, this.has_stree = R && R.length;
        }
        function W(R, O) {
          this.dyn_tree = R, this.max_code = 0, this.stat_desc = O;
        }
        function _(R) {
          return R < 256 ? P[R] : P[256 + (R >>> 7)];
        }
        function g1(R, O) {
          R.pending_buf[R.pending++] = 255 & O, R.pending_buf[R.pending++] = O >>> 8 & 255;
        }
        function X(R, O, t1) {
          R.bi_valid > u - t1 ? (R.bi_buf |= O << R.bi_valid & 65535, g1(R, R.bi_buf), R.bi_buf = O >> u - R.bi_valid, R.bi_valid += t1 - u) : (R.bi_buf |= O << R.bi_valid & 65535, R.bi_valid += t1);
        }
        function $(R, O, t1) {
          X(R, t1[2 * O], t1[2 * O + 1]);
        }
        function o1(R, O) {
          for (var t1 = 0; t1 |= 1 & R, R >>>= 1, t1 <<= 1, 0 < --O;);
          return t1 >>> 1;
        }
        function u1(R, O, t1) {
          var r1,
            q,
            h1 = new Array(z + 1),
            d1 = 0;
          for (r1 = 1; r1 <= z; r1++) h1[r1] = d1 = d1 + t1[r1 - 1] << 1;
          for (q = 0; q <= O; q++) {
            var l1 = R[2 * q + 1];
            l1 !== 0 && (R[2 * q] = o1(h1[l1]++, l1));
          }
        }
        function N(R) {
          var O;
          for (O = 0; O < v; O++) R.dyn_ltree[2 * O] = 0;
          for (O = 0; O < g; O++) R.dyn_dtree[2 * O] = 0;
          for (O = 0; O < s; O++) R.bl_tree[2 * O] = 0;
          R.dyn_ltree[2 * p] = 1, R.opt_len = R.static_len = 0, R.last_lit = R.matches = 0;
        }
        function x1(R) {
          8 < R.bi_valid ? g1(R, R.bi_buf) : 0 < R.bi_valid && (R.pending_buf[R.pending++] = R.bi_buf), R.bi_buf = 0, R.bi_valid = 0;
        }
        function i1(R, O, t1, r1) {
          var q = 2 * O,
            h1 = 2 * t1;
          return R[q] < R[h1] || R[q] === R[h1] && r1[O] <= r1[t1];
        }
        function B1(R, O, t1) {
          for (var r1 = R.heap[t1], q = t1 << 1; q <= R.heap_len && (q < R.heap_len && i1(O, R.heap[q + 1], R.heap[q], R.depth) && q++, !i1(O, r1, R.heap[q], R.depth));) R.heap[t1] = R.heap[q], t1 = q, q <<= 1;
          R.heap[t1] = r1;
        }
        function k1(R, O, t1) {
          var r1,
            q,
            h1,
            d1,
            l1 = 0;
          if (R.last_lit !== 0) for (; r1 = R.pending_buf[R.d_buf + 2 * l1] << 8 | R.pending_buf[R.d_buf + 2 * l1 + 1], q = R.pending_buf[R.l_buf + l1], l1++, r1 === 0 ? $(R, q, O) : ($(R, (h1 = C[q]) + h + 1, O), (d1 = H[h1]) !== 0 && X(R, q -= E[h1], d1), $(R, h1 = _(--r1), t1), (d1 = y[h1]) !== 0 && X(R, r1 -= Z[h1], d1)), l1 < R.last_lit;);
          $(R, p, O);
        }
        function A1(R, O) {
          var t1,
            r1,
            q,
            h1 = O.dyn_tree,
            d1 = O.stat_desc.static_tree,
            l1 = O.stat_desc.has_stree,
            e1 = O.stat_desc.elems,
            w1 = -1;
          for (R.heap_len = 0, R.heap_max = d, t1 = 0; t1 < e1; t1++) h1[2 * t1] !== 0 ? (R.heap[++R.heap_len] = w1 = t1, R.depth[t1] = 0) : h1[2 * t1 + 1] = 0;
          for (; R.heap_len < 2;) h1[2 * (q = R.heap[++R.heap_len] = w1 < 2 ? ++w1 : 0)] = 1, R.depth[q] = 0, R.opt_len--, l1 && (R.static_len -= d1[2 * q + 1]);
          for (O.max_code = w1, t1 = R.heap_len >> 1; 1 <= t1; t1--) B1(R, h1, t1);
          for (q = e1; t1 = R.heap[1], R.heap[1] = R.heap[R.heap_len--], B1(R, h1, 1), r1 = R.heap[1], R.heap[--R.heap_max] = t1, R.heap[--R.heap_max] = r1, h1[2 * q] = h1[2 * t1] + h1[2 * r1], R.depth[q] = (R.depth[t1] >= R.depth[r1] ? R.depth[t1] : R.depth[r1]) + 1, h1[2 * t1 + 1] = h1[2 * r1 + 1] = q, R.heap[1] = q++, B1(R, h1, 1), 2 <= R.heap_len;);
          R.heap[--R.heap_max] = R.heap[1], function (R1, a0) {
            var V0,
              p4,
              Xt,
              p2,
              he,
              iv,
              a5 = a0.dyn_tree,
              ff = a0.max_code,
              Lq = a0.stat_desc.static_tree,
              Hq = a0.stat_desc.has_stree,
              Vq = a0.stat_desc.extra_bits,
              Mf = a0.stat_desc.extra_base,
              Yt = a0.stat_desc.max_length,
              ve = 0;
            for (p2 = 0; p2 <= z; p2++) R1.bl_count[p2] = 0;
            for (a5[2 * R1.heap[R1.heap_max] + 1] = 0, V0 = R1.heap_max + 1; V0 < d; V0++) Yt < (p2 = a5[2 * a5[2 * (p4 = R1.heap[V0]) + 1] + 1] + 1) && (p2 = Yt, ve++), a5[2 * p4 + 1] = p2, ff < p4 || (R1.bl_count[p2]++, he = 0, Mf <= p4 && (he = Vq[p4 - Mf]), iv = a5[2 * p4], R1.opt_len += iv * (p2 + he), Hq && (R1.static_len += iv * (Lq[2 * p4 + 1] + he)));
            if (ve !== 0) {
              do {
                for (p2 = Yt - 1; R1.bl_count[p2] === 0;) p2--;
                R1.bl_count[p2]--, R1.bl_count[p2 + 1] += 2, R1.bl_count[Yt]--, ve -= 2;
              } while (0 < ve);
              for (p2 = Yt; p2 !== 0; p2--) for (p4 = R1.bl_count[p2]; p4 !== 0;) ff < (Xt = R1.heap[--V0]) || (a5[2 * Xt + 1] !== p2 && (R1.opt_len += (p2 - a5[2 * Xt + 1]) * a5[2 * Xt], a5[2 * Xt + 1] = p2), p4--);
            }
          }(R, O), u1(h1, w1, R.bl_count);
        }
        function L(R, O, t1) {
          var r1,
            q,
            h1 = -1,
            d1 = O[1],
            l1 = 0,
            e1 = 7,
            w1 = 4;
          for (d1 === 0 && (e1 = 138, w1 = 3), O[2 * (t1 + 1) + 1] = 65535, r1 = 0; r1 <= t1; r1++) q = d1, d1 = O[2 * (r1 + 1) + 1], ++l1 < e1 && q === d1 || (l1 < w1 ? R.bl_tree[2 * q] += l1 : q !== 0 ? (q !== h1 && R.bl_tree[2 * q]++, R.bl_tree[2 * m]++) : l1 <= 10 ? R.bl_tree[2 * M]++ : R.bl_tree[2 * w]++, h1 = q, w1 = (l1 = 0) === d1 ? (e1 = 138, 3) : q === d1 ? (e1 = 6, 3) : (e1 = 7, 4));
        }
        function Y(R, O, t1) {
          var r1,
            q,
            h1 = -1,
            d1 = O[1],
            l1 = 0,
            e1 = 7,
            w1 = 4;
          for (d1 === 0 && (e1 = 138, w1 = 3), r1 = 0; r1 <= t1; r1++) if (q = d1, d1 = O[2 * (r1 + 1) + 1], !(++l1 < e1 && q === d1)) {
            if (l1 < w1) for (; $(R, q, R.bl_tree), --l1 != 0;);else q !== 0 ? (q !== h1 && ($(R, q, R.bl_tree), l1--), $(R, m, R.bl_tree), X(R, l1 - 3, 2)) : l1 <= 10 ? ($(R, M, R.bl_tree), X(R, l1 - 3, 3)) : ($(R, w, R.bl_tree), X(R, l1 - 11, 7));
            h1 = q, w1 = (l1 = 0) === d1 ? (e1 = 138, 3) : q === d1 ? (e1 = 6, 3) : (e1 = 7, 4);
          }
        }
        i(Z);
        var Q = !1;
        function b(R, O, t1, r1) {
          X(R, (o << 1) + (r1 ? 1 : 0), 3), function (q, h1, d1, l1) {
            x1(q), l1 && (g1(q, d1), g1(q, ~d1)), r.arraySet(q.pending_buf, q.window, h1, d1, q.pending), q.pending += d1;
          }(R, O, t1, !0);
        }
        c._tr_init = function (R) {
          Q || (function () {
            var O,
              t1,
              r1,
              q,
              h1,
              d1 = new Array(z + 1);
            for (q = r1 = 0; q < n - 1; q++) for (E[q] = r1, O = 0; O < 1 << H[q]; O++) C[r1++] = q;
            for (C[r1 - 1] = q, q = h1 = 0; q < 16; q++) for (Z[q] = h1, O = 0; O < 1 << y[q]; O++) P[h1++] = q;
            for (h1 >>= 7; q < g; q++) for (Z[q] = h1 << 7, O = 0; O < 1 << y[q] - 7; O++) P[256 + h1++] = q;
            for (t1 = 0; t1 <= z; t1++) d1[t1] = 0;
            for (O = 0; O <= 143;) U[2 * O + 1] = 8, O++, d1[8]++;
            for (; O <= 255;) U[2 * O + 1] = 9, O++, d1[9]++;
            for (; O <= 279;) U[2 * O + 1] = 7, O++, d1[7]++;
            for (; O <= 287;) U[2 * O + 1] = 8, O++, d1[8]++;
            for (u1(U, v + 1, d1), O = 0; O < g; O++) A[2 * O + 1] = 5, A[2 * O] = o1(O, 5);
            a1 = new J(U, H, h + 1, v, z), j = new J(A, y, 0, g, z), K = new J(new Array(0), k, 0, s, f);
          }(), Q = !0), R.l_desc = new W(R.dyn_ltree, a1), R.d_desc = new W(R.dyn_dtree, j), R.bl_desc = new W(R.bl_tree, K), R.bi_buf = 0, R.bi_valid = 0, N(R);
        }, c._tr_stored_block = b, c._tr_flush_block = function (R, O, t1, r1) {
          var q,
            h1,
            d1 = 0;
          0 < R.level ? (R.strm.data_type === 2 && (R.strm.data_type = function (l1) {
            var e1,
              w1 = 4093624447;
            for (e1 = 0; e1 <= 31; e1++, w1 >>>= 1) if (1 & w1 && l1.dyn_ltree[2 * e1] !== 0) return e;
            if (l1.dyn_ltree[18] !== 0 || l1.dyn_ltree[20] !== 0 || l1.dyn_ltree[26] !== 0) return l;
            for (e1 = 32; e1 < h; e1++) if (l1.dyn_ltree[2 * e1] !== 0) return l;
            return e;
          }(R)), A1(R, R.l_desc), A1(R, R.d_desc), d1 = function (l1) {
            var e1;
            for (L(l1, l1.dyn_ltree, l1.l_desc.max_code), L(l1, l1.dyn_dtree, l1.d_desc.max_code), A1(l1, l1.bl_desc), e1 = s - 1; 3 <= e1 && l1.bl_tree[2 * F[e1] + 1] === 0; e1--);
            return l1.opt_len += 3 * (e1 + 1) + 5 + 5 + 4, e1;
          }(R), q = R.opt_len + 3 + 7 >>> 3, (h1 = R.static_len + 3 + 7 >>> 3) <= q && (q = h1)) : q = h1 = t1 + 5, t1 + 4 <= q && O !== -1 ? b(R, O, t1, r1) : R.strategy === 4 || h1 === q ? (X(R, 2 + (r1 ? 1 : 0), 3), k1(R, U, A)) : (X(R, 4 + (r1 ? 1 : 0), 3), function (l1, e1, w1, R1) {
            var a0;
            for (X(l1, e1 - 257, 5), X(l1, w1 - 1, 5), X(l1, R1 - 4, 4), a0 = 0; a0 < R1; a0++) X(l1, l1.bl_tree[2 * F[a0] + 1], 3);
            Y(l1, l1.dyn_ltree, e1 - 1), Y(l1, l1.dyn_dtree, w1 - 1);
          }(R, R.l_desc.max_code + 1, R.d_desc.max_code + 1, d1 + 1), k1(R, R.dyn_ltree, R.dyn_dtree)), N(R), r1 && x1(R);
        }, c._tr_tally = function (R, O, t1) {
          return R.pending_buf[R.d_buf + 2 * R.last_lit] = O >>> 8 & 255, R.pending_buf[R.d_buf + 2 * R.last_lit + 1] = 255 & O, R.pending_buf[R.l_buf + R.last_lit] = 255 & t1, R.last_lit++, O === 0 ? R.dyn_ltree[2 * t1]++ : (R.matches++, O--, R.dyn_ltree[2 * (C[t1] + h + 1)]++, R.dyn_dtree[2 * _(O)]++), R.last_lit === R.lit_bufsize - 1;
        }, c._tr_align = function (R) {
          X(R, 2, 3), $(R, p, U), function (O) {
            O.bi_valid === 16 ? (g1(O, O.bi_buf), O.bi_buf = 0, O.bi_valid = 0) : 8 <= O.bi_valid && (O.pending_buf[O.pending++] = 255 & O.bi_buf, O.bi_buf >>= 8, O.bi_valid -= 8);
          }(R);
        };
      }, {
        "../utils/common": 41
      }],
      53: [function (t, a, c) {
        "use strict";

        a.exports = function () {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}],
      54: [function (t, a, c) {
        (function (r) {
          (function (e, l) {
            "use strict";

            if (!e.setImmediate) {
              var i,
                o,
                n,
                h,
                v = 1,
                g = {},
                s = !1,
                d = e.document,
                z = Object.getPrototypeOf && Object.getPrototypeOf(e);
              z = z && z.setTimeout ? z : e, i = {}.toString.call(e.process) === "[object process]" ? function (m) {
                process.nextTick(function () {
                  f(m);
                });
              } : function () {
                if (e.postMessage && !e.importScripts) {
                  var m = !0,
                    M = e.onmessage;
                  return e.onmessage = function () {
                    m = !1;
                  }, e.postMessage("", "*"), e.onmessage = M, m;
                }
              }() ? (h = "setImmediate$" + Math.random() + "$", e.addEventListener ? e.addEventListener("message", p, !1) : e.attachEvent("onmessage", p), function (m) {
                e.postMessage(h + m, "*");
              }) : e.MessageChannel ? ((n = new MessageChannel()).port1.onmessage = function (m) {
                f(m.data);
              }, function (m) {
                n.port2.postMessage(m);
              }) : d && "onreadystatechange" in d.createElement("script") ? (o = d.documentElement, function (m) {
                var M = d.createElement("script");
                M.onreadystatechange = function () {
                  f(m), M.onreadystatechange = null, o.removeChild(M), M = null;
                }, o.appendChild(M);
              }) : function (m) {
                setTimeout(f, 0, m);
              }, z.setImmediate = function (m) {
                typeof m != "function" && (m = new Function("" + m));
                for (var M = new Array(arguments.length - 1), w = 0; w < M.length; w++) M[w] = arguments[w + 1];
                var H = {
                  callback: m,
                  args: M
                };
                return g[v] = H, i(v), v++;
              }, z.clearImmediate = u;
            }
            function u(m) {
              delete g[m];
            }
            function f(m) {
              if (s) setTimeout(f, 0, m);else {
                var M = g[m];
                if (M) {
                  s = !0;
                  try {
                    (function (w) {
                      var H = w.callback,
                        y = w.args;
                      switch (y.length) {
                        case 0:
                          H();
                          break;
                        case 1:
                          H(y[0]);
                          break;
                        case 2:
                          H(y[0], y[1]);
                          break;
                        case 3:
                          H(y[0], y[1], y[2]);
                          break;
                        default:
                          H.apply(l, y);
                      }
                    })(M);
                  } finally {
                    u(m), s = !1;
                  }
                }
              }
            }
            function p(m) {
              m.source === e && typeof m.data == "string" && m.data.indexOf(h) === 0 && f(+m.data.slice(h.length));
            }
          })(typeof self == "undefined" ? r === void 0 ? this : r : self);
        }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
      }, {}]
    }, {}, [10])(10);
  });
});
var en,
  dr,
  c51,
  RI,
  r51,
  Ny1,
  e51,
  an,
  l51,
  bI,
  i51,
  Au,
  cn,
  rn,
  a7,
  o51,
  n51,
  h51,
  sr,
  n3,
  v51,
  g51,
  Ru,
  ln,
  FI = x(() => {
    en = I(G(), 1), dr = I(G(), 1), c51 = t => typeof t == "function", RI = (t, a) => c51(t) ? t(a) : t, r51 = (() => {
      let t = 0;
      return () => (++t).toString();
    })(), Ny1 = (() => {
      let t;
      return () => {
        if (t === void 0 && typeof window < "u") {
          let a = matchMedia("(prefers-reduced-motion: reduce)");
          t = !a || a.matches;
        }
        return t;
      };
    })(), e51 = 20, an = new Map(), l51 = 1e3, bI = t => {
      if (an.has(t)) return;
      let a = setTimeout(() => {
        an.delete(t), a7({
          type: 4,
          toastId: t
        });
      }, l51);
      an.set(t, a);
    }, i51 = t => {
      let a = an.get(t);
      a && clearTimeout(a);
    }, Au = (t, a) => {
      switch (a.type) {
        case 0:
          return D(S({}, t), {
            toasts: [a.toast, ...t.toasts].slice(0, e51)
          });
        case 1:
          return a.toast.id && i51(a.toast.id), D(S({}, t), {
            toasts: t.toasts.map(l => l.id === a.toast.id ? S(S({}, l), a.toast) : l)
          });
        case 2:
          let {
            toast: c
          } = a;
          return t.toasts.find(l => l.id === c.id) ? Au(t, {
            type: 1,
            toast: c
          }) : Au(t, {
            type: 0,
            toast: c
          });
        case 3:
          let {
            toastId: r
          } = a;
          return r ? bI(r) : t.toasts.forEach(l => {
            bI(l.id);
          }), D(S({}, t), {
            toasts: t.toasts.map(l => l.id === r || r === void 0 ? D(S({}, l), {
              visible: !1
            }) : l)
          });
        case 4:
          return a.toastId === void 0 ? D(S({}, t), {
            toasts: []
          }) : D(S({}, t), {
            toasts: t.toasts.filter(l => l.id !== a.toastId)
          });
        case 5:
          return D(S({}, t), {
            pausedAt: a.time
          });
        case 6:
          let e = a.time - (t.pausedAt || 0);
          return D(S({}, t), {
            pausedAt: void 0,
            toasts: t.toasts.map(l => D(S({}, l), {
              pauseDuration: l.pauseDuration + e
            }))
          });
      }
    }, cn = [], rn = {
      toasts: [],
      pausedAt: void 0
    }, a7 = t => {
      rn = Au(rn, t), cn.forEach(a => {
        a(rn);
      });
    }, o51 = {
      blank: 4e3,
      error: 4e3,
      success: 2e3,
      loading: 1 / 0,
      custom: 4e3
    }, n51 = (t = {}) => {
      let [a, c] = (0, en.useState)(rn);
      (0, en.useEffect)(() => (cn.push(c), () => {
        let e = cn.indexOf(c);
        e > -1 && cn.splice(e, 1);
      }), [a]);
      let r = a.toasts.map(e => {
        var l, i;
        return D(S(S(S({}, t), t[e.type]), e), {
          duration: e.duration || ((l = t[e.type]) == null ? void 0 : l.duration) || (t == null ? void 0 : t.duration) || o51[e.type],
          style: S(S(S({}, t.style), (i = t[e.type]) == null ? void 0 : i.style), e.style)
        });
      });
      return D(S({}, a), {
        toasts: r
      });
    }, h51 = (t, a = "blank", c) => D(S({
      createdAt: Date.now(),
      visible: !0,
      type: a,
      ariaProps: {
        role: "status",
        "aria-live": "polite"
      },
      message: t,
      pauseDuration: 0
    }, c), {
      id: (c == null ? void 0 : c.id) || r51()
    }), sr = t => (a, c) => {
      let r = h51(a, t, c);
      return a7({
        type: 2,
        toast: r
      }), r.id;
    }, n3 = (t, a) => sr("blank")(t, a);
    n3.error = sr("error");
    n3.success = sr("success");
    n3.loading = sr("loading");
    n3.custom = sr("custom");
    n3.dismiss = t => {
      a7({
        type: 3,
        toastId: t
      });
    };
    n3.remove = t => a7({
      type: 4,
      toastId: t
    });
    n3.promise = (t, a, c) => {
      let r = n3.loading(a.loading, S(S({}, c), c == null ? void 0 : c.loading));
      return t.then(e => (n3.success(RI(a.success, e), S(S({
        id: r
      }, c), c == null ? void 0 : c.success)), e)).catch(e => {
        n3.error(RI(a.error, e), S(S({
          id: r
        }, c), c == null ? void 0 : c.error));
      }), t;
    };
    v51 = (t, a) => {
      a7({
        type: 1,
        toast: {
          id: t,
          height: a
        }
      });
    }, g51 = () => {
      a7({
        type: 5,
        time: Date.now()
      });
    }, Ru = t => {
      let {
        toasts: a,
        pausedAt: c
      } = n51(t);
      (0, dr.useEffect)(() => {
        if (c) return;
        let l = Date.now(),
          i = a.map(o => {
            if (o.duration === 1 / 0) return;
            let n = (o.duration || 0) + o.pauseDuration - (l - o.createdAt);
            if (n < 0) {
              o.visible && n3.dismiss(o.id);
              return;
            }
            return setTimeout(() => n3.dismiss(o.id), n);
          });
        return () => {
          i.forEach(o => o && clearTimeout(o));
        };
      }, [a, c]);
      let r = (0, dr.useCallback)(() => {
          c && a7({
            type: 6,
            time: Date.now()
          });
        }, [c]),
        e = (0, dr.useCallback)((l, i) => {
          let {
              reverseOrder: o = !1,
              gutter: n = 8,
              defaultPosition: h
            } = i || {},
            v = a.filter(d => (d.position || h) === (l.position || h) && d.height),
            g = v.findIndex(d => d.id === l.id),
            s = v.filter((d, z) => z < g && d.visible).length;
          return v.filter(d => d.visible).slice(...(o ? [s + 1] : [0, s])).reduce((d, z) => d + (z.height || 0) + n, 0);
        }, [a]);
      return {
        toasts: a,
        handlers: {
          updateHeight: v51,
          startPause: g51,
          endPause: r,
          calculateOffset: e
        }
      };
    }, ln = n3;
  });
function EI() {
  return {
    async: !1,
    baseUrl: null,
    breaks: !1,
    extensions: null,
    gfm: !0,
    headerIds: !0,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: !0,
    pedantic: !1,
    renderer: null,
    sanitize: !1,
    sanitizer: null,
    silent: !1,
    smartypants: !1,
    tokenizer: null,
    walkTokens: null,
    xhtml: !1
  };
}
function d51(t) {
  ht = t;
}
function Z2(t, a) {
  if (a) {
    if (s51.test(t)) return t.replace(z51, II);
  } else if (u51.test(t)) return t.replace(p51, II);
  return t;
}
function DI(t) {
  return t.replace(f51, (a, c) => (c = c.toLowerCase(), c === "colon" ? ":" : c.charAt(0) === "#" ? c.charAt(1) === "x" ? String.fromCharCode(parseInt(c.substring(2), 16)) : String.fromCharCode(+c.substring(1)) : ""));
}
function U1(t, a) {
  t = typeof t == "string" ? t : t.source, a = a || "";
  let c = {
    replace: (r, e) => (e = e.source || e, e = e.replace(M51, "$1"), t = t.replace(r, e), c),
    getRegex: () => new RegExp(t, a)
  };
  return c;
}
function PI(t, a, c) {
  if (t) {
    let r;
    try {
      r = decodeURIComponent(DI(c)).replace(x51, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (r.indexOf("javascript:") === 0 || r.indexOf("vbscript:") === 0 || r.indexOf("data:") === 0) return null;
  }
  a && !C51.test(c) && (c = w51(a, c));
  try {
    c = encodeURI(c).replace(/%25/g, "%");
  } catch (r) {
    return null;
  }
  return c;
}
function w51(t, a) {
  on[" " + t] || (L51.test(t) ? on[" " + t] = t + "/" : on[" " + t] = nn(t, "/", !0)), t = on[" " + t];
  let c = t.indexOf(":") === -1;
  return a.substring(0, 2) === "//" ? c ? a : t.replace(H51, "$1") + a : a.charAt(0) === "/" ? c ? a : t.replace(V51, "$1") + a : t + a;
}
function l4(t) {
  let a = 1,
    c,
    r;
  for (; a < arguments.length; a++) {
    c = arguments[a];
    for (r in c) Object.prototype.hasOwnProperty.call(c, r) && (t[r] = c[r]);
  }
  return t;
}
function GI(t, a) {
  let c = t.replace(/\|/g, (l, i, o) => {
      let n = !1,
        h = i;
      for (; --h >= 0 && o[h] === "\\";) n = !n;
      return n ? "|" : " |";
    }),
    r = c.split(/ \|/),
    e = 0;
  if (r[0].trim() || r.shift(), r.length > 0 && !r[r.length - 1].trim() && r.pop(), r.length > a) r.splice(a);else for (; r.length < a;) r.push("");
  for (; e < r.length; e++) r[e] = r[e].trim().replace(/\\\|/g, "|");
  return r;
}
function nn(t, a, c) {
  let r = t.length;
  if (r === 0) return "";
  let e = 0;
  for (; e < r;) {
    let l = t.charAt(r - e - 1);
    if (l === a && !c) e++;else if (l !== a && c) e++;else break;
  }
  return t.slice(0, r - e);
}
function B51(t, a) {
  if (t.indexOf(a[1]) === -1) return -1;
  let c = t.length,
    r = 0,
    e = 0;
  for (; e < c; e++) if (t[e] === "\\") e++;else if (t[e] === a[0]) r++;else if (t[e] === a[1] && (r--, r < 0)) return e;
  return -1;
}
function WI(t) {
  t && t.sanitize && !t.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
}
function TI(t, a) {
  if (a < 1) return "";
  let c = "";
  for (; a > 1;) a & 1 && (c += t), a >>= 1, t += t;
  return c + t;
}
function ZI(t, a, c, r) {
  let e = a.href,
    l = a.title ? Z2(a.title) : null,
    i = t[1].replace(/\\([\[\]])/g, "$1");
  if (t[0].charAt(0) !== "!") {
    r.state.inLink = !0;
    let o = {
      type: "link",
      raw: c,
      href: e,
      title: l,
      text: i,
      tokens: r.inlineTokens(i)
    };
    return r.state.inLink = !1, o;
  }
  return {
    type: "image",
    raw: c,
    href: e,
    title: l,
    text: Z2(i)
  };
}
function y51(t, a) {
  let c = t.match(/^(\s+)(?:```)/);
  if (c === null) return a;
  let r = c[1];
  return a.split("\n").map(e => {
    let l = e.match(/^\s+/);
    if (l === null) return e;
    let [i] = l;
    return i.length >= r.length ? e.slice(r.length) : e;
  }).join("\n");
}
function S51(t) {
  return t.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function OI(t) {
  let a = "",
    c,
    r,
    e = t.length;
  for (c = 0; c < e; c++) r = t.charCodeAt(c), Math.random() > .5 && (r = "x" + r.toString(16)), a += "&#" + r + ";";
  return a;
}
function V1(t, a, c) {
  if (typeof t == "undefined" || t === null) throw new Error("marked(): input parameter is undefined or null");
  if (typeof t != "string") throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(t) + ", string expected");
  if (typeof a == "function" && (c = a, a = null), a = l4({}, V1.defaults, a || {}), WI(a), c) {
    let e = a.highlight,
      l;
    try {
      l = Q6.lex(t, a);
    } catch (n) {
      return c(n);
    }
    let i = function (n) {
      let h;
      if (!n) try {
        a.walkTokens && V1.walkTokens(l, a.walkTokens), h = B5.parse(l, a);
      } catch (v) {
        n = v;
      }
      return a.highlight = e, n ? c(n) : c(null, h);
    };
    if (!e || e.length < 3 || (delete a.highlight, !l.length)) return i();
    let o = 0;
    V1.walkTokens(l, function (n) {
      n.type === "code" && (o++, setTimeout(() => {
        e(n.text, n.lang, function (h, v) {
          if (h) return i(h);
          v != null && v !== n.text && (n.text = v, n.escaped = !0), o--, o === 0 && i();
        });
      }, 0));
    }), o === 0 && i();
    return;
  }
  function r(e) {
    if (e.message += "\nPlease report this to https://github.com/markedjs/marked.", a.silent) return "<p>An error occurred:</p><pre>" + Z2(e.message + "", !0) + "</pre>";
    throw e;
  }
  try {
    let e = Q6.lex(t, a);
    if (a.walkTokens) {
      if (a.async) return Promise.all(V1.walkTokens(e, a.walkTokens)).then(() => B5.parse(e, a)).catch(r);
      V1.walkTokens(e, a.walkTokens);
    }
    return B5.parse(e, a);
  } catch (e) {
    r(e);
  }
}
var ht,
  s51,
  z51,
  u51,
  p51,
  m51,
  II,
  f51,
  M51,
  x51,
  C51,
  on,
  L51,
  H51,
  V51,
  hn,
  zr,
  H1,
  m1,
  Q6,
  ur,
  vn,
  gn,
  B5,
  $y1,
  Qy1,
  Xy1,
  Yy1,
  Jy1,
  tS1,
  aS1,
  _I = x(() => {
    ht = EI();
    s51 = /[&<>"']/, z51 = /[&<>"']/g, u51 = /[<>"']|&(?!#?\w+;)/, p51 = /[<>"']|&(?!#?\w+;)/g, m51 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, II = t => m51[t];
    f51 = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    M51 = /(^|[^\[])\^/g;
    x51 = /[^\w:]/g, C51 = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    on = {}, L51 = /^[^:]+:\/*[^/]*$/, H51 = /^([^:]+:)[\s\S]*$/, V51 = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    hn = {
      exec: function () {}
    };
    zr = class {
      constructor(a) {
        this.options = a || ht;
      }
      space(a) {
        let c = this.rules.block.newline.exec(a);
        if (c && c[0].length > 0) return {
          type: "space",
          raw: c[0]
        };
      }
      code(a) {
        let c = this.rules.block.code.exec(a);
        if (c) {
          let r = c[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: c[0],
            codeBlockStyle: "indented",
            text: this.options.pedantic ? r : nn(r, "\n")
          };
        }
      }
      fences(a) {
        let c = this.rules.block.fences.exec(a);
        if (c) {
          let r = c[0],
            e = y51(r, c[3] || "");
          return {
            type: "code",
            raw: r,
            lang: c[2] ? c[2].trim() : c[2],
            text: e
          };
        }
      }
      heading(a) {
        let c = this.rules.block.heading.exec(a);
        if (c) {
          let r = c[2].trim();
          if (/#$/.test(r)) {
            let e = nn(r, "#");
            (this.options.pedantic || !e || / $/.test(e)) && (r = e.trim());
          }
          return {
            type: "heading",
            raw: c[0],
            depth: c[1].length,
            text: r,
            tokens: this.lexer.inline(r)
          };
        }
      }
      hr(a) {
        let c = this.rules.block.hr.exec(a);
        if (c) return {
          type: "hr",
          raw: c[0]
        };
      }
      blockquote(a) {
        let c = this.rules.block.blockquote.exec(a);
        if (c) {
          let r = c[0].replace(/^ *>[ \t]?/gm, "");
          return {
            type: "blockquote",
            raw: c[0],
            tokens: this.lexer.blockTokens(r, []),
            text: r
          };
        }
      }
      list(a) {
        let c = this.rules.block.list.exec(a);
        if (c) {
          let r,
            e,
            l,
            i,
            o,
            n,
            h,
            v,
            g,
            s,
            d,
            z,
            u = c[1].trim(),
            f = u.length > 1,
            p = {
              type: "list",
              raw: "",
              ordered: f,
              start: f ? +u.slice(0, -1) : "",
              loose: !1,
              items: []
            };
          u = f ? "\\d{1,9}\\".concat(u.slice(-1)) : "\\".concat(u), this.options.pedantic && (u = f ? u : "[*+-]");
          let m = new RegExp("^( {0,3}".concat(u, ")((?:[	 ][^\\n]*)?(?:\\n|$))"));
          for (; a && (z = !1, !(!(c = m.exec(a)) || this.rules.block.hr.test(a)));) {
            if (r = c[0], a = a.substring(r.length), v = c[2].split("\n", 1)[0], g = a.split("\n", 1)[0], this.options.pedantic ? (i = 2, d = v.trimLeft()) : (i = c[2].search(/[^ ]/), i = i > 4 ? 1 : i, d = v.slice(i), i += c[1].length), n = !1, !v && /^ *$/.test(g) && (r += g + "\n", a = a.substring(g.length + 1), z = !0), !z) {
              let w = new RegExp("^ {0,".concat(Math.min(3, i - 1), "}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))")),
                H = new RegExp("^ {0,".concat(Math.min(3, i - 1), "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)")),
                y = new RegExp("^ {0,".concat(Math.min(3, i - 1), "}(?:```|~~~)")),
                k = new RegExp("^ {0,".concat(Math.min(3, i - 1), "}#"));
              for (; a && (s = a.split("\n", 1)[0], v = s, this.options.pedantic && (v = v.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !(y.test(v) || k.test(v) || w.test(v) || H.test(a)));) {
                if (v.search(/[^ ]/) >= i || !v.trim()) d += "\n" + v.slice(i);else if (!n) d += "\n" + v;else break;
                !n && !v.trim() && (n = !0), r += s + "\n", a = a.substring(s.length + 1);
              }
            }
            p.loose || (h ? p.loose = !0 : /\n *\n *$/.test(r) && (h = !0)), this.options.gfm && (e = /^\[[ xX]\] /.exec(d), e && (l = e[0] !== "[ ] ", d = d.replace(/^\[[ xX]\] +/, ""))), p.items.push({
              type: "list_item",
              raw: r,
              task: !!e,
              checked: l,
              loose: !1,
              text: d
            }), p.raw += r;
          }
          p.items[p.items.length - 1].raw = r.trimRight(), p.items[p.items.length - 1].text = d.trimRight(), p.raw = p.raw.trimRight();
          let M = p.items.length;
          for (o = 0; o < M; o++) {
            this.lexer.state.top = !1, p.items[o].tokens = this.lexer.blockTokens(p.items[o].text, []);
            let w = p.items[o].tokens.filter(y => y.type === "space"),
              H = w.every(y => {
                let k = y.raw.split(""),
                  F = 0;
                for (let U of k) if (U === "\n" && (F += 1), F > 1) return !0;
                return !1;
              });
            !p.loose && w.length && H && (p.loose = !0, p.items[o].loose = !0);
          }
          return p;
        }
      }
      html(a) {
        let c = this.rules.block.html.exec(a);
        if (c) {
          let r = {
            type: "html",
            raw: c[0],
            pre: !this.options.sanitizer && (c[1] === "pre" || c[1] === "script" || c[1] === "style"),
            text: c[0]
          };
          if (this.options.sanitize) {
            let e = this.options.sanitizer ? this.options.sanitizer(c[0]) : Z2(c[0]);
            r.type = "paragraph", r.text = e, r.tokens = this.lexer.inline(e);
          }
          return r;
        }
      }
      def(a) {
        let c = this.rules.block.def.exec(a);
        if (c) return c[3] && (c[3] = c[3].substring(1, c[3].length - 1)), {
          type: "def",
          tag: c[1].toLowerCase().replace(/\s+/g, " "),
          raw: c[0],
          href: c[2],
          title: c[3]
        };
      }
      table(a) {
        let c = this.rules.block.table.exec(a);
        if (c) {
          let r = {
            type: "table",
            header: GI(c[1]).map(e => ({
              text: e
            })),
            align: c[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: c[3] && c[3].trim() ? c[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (r.header.length === r.align.length) {
            r.raw = c[0];
            let e = r.align.length,
              l,
              i,
              o,
              n;
            for (l = 0; l < e; l++) /^ *-+: *$/.test(r.align[l]) ? r.align[l] = "right" : /^ *:-+: *$/.test(r.align[l]) ? r.align[l] = "center" : /^ *:-+ *$/.test(r.align[l]) ? r.align[l] = "left" : r.align[l] = null;
            for (e = r.rows.length, l = 0; l < e; l++) r.rows[l] = GI(r.rows[l], r.header.length).map(h => ({
              text: h
            }));
            for (e = r.header.length, i = 0; i < e; i++) r.header[i].tokens = this.lexer.inline(r.header[i].text);
            for (e = r.rows.length, i = 0; i < e; i++) for (n = r.rows[i], o = 0; o < n.length; o++) n[o].tokens = this.lexer.inline(n[o].text);
            return r;
          }
        }
      }
      lheading(a) {
        let c = this.rules.block.lheading.exec(a);
        if (c) return {
          type: "heading",
          raw: c[0],
          depth: c[2].charAt(0) === "=" ? 1 : 2,
          text: c[1],
          tokens: this.lexer.inline(c[1])
        };
      }
      paragraph(a) {
        let c = this.rules.block.paragraph.exec(a);
        if (c) {
          let r = c[1].charAt(c[1].length - 1) === "\n" ? c[1].slice(0, -1) : c[1];
          return {
            type: "paragraph",
            raw: c[0],
            text: r,
            tokens: this.lexer.inline(r)
          };
        }
      }
      text(a) {
        let c = this.rules.block.text.exec(a);
        if (c) return {
          type: "text",
          raw: c[0],
          text: c[0],
          tokens: this.lexer.inline(c[0])
        };
      }
      escape(a) {
        let c = this.rules.inline.escape.exec(a);
        if (c) return {
          type: "escape",
          raw: c[0],
          text: Z2(c[1])
        };
      }
      tag(a) {
        let c = this.rules.inline.tag.exec(a);
        if (c) return !this.lexer.state.inLink && /^<a /i.test(c[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(c[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(c[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(c[0]) && (this.lexer.state.inRawBlock = !1), {
          type: this.options.sanitize ? "text" : "html",
          raw: c[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(c[0]) : Z2(c[0]) : c[0]
        };
      }
      link(a) {
        let c = this.rules.inline.link.exec(a);
        if (c) {
          let r = c[2].trim();
          if (!this.options.pedantic && /^</.test(r)) {
            if (!/>$/.test(r)) return;
            let i = nn(r.slice(0, -1), "\\");
            if ((r.length - i.length) % 2 === 0) return;
          } else {
            let i = B51(c[2], "()");
            if (i > -1) {
              let n = (c[0].indexOf("!") === 0 ? 5 : 4) + c[1].length + i;
              c[2] = c[2].substring(0, i), c[0] = c[0].substring(0, n).trim(), c[3] = "";
            }
          }
          let e = c[2],
            l = "";
          if (this.options.pedantic) {
            let i = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(e);
            i && (e = i[1], l = i[3]);
          } else l = c[3] ? c[3].slice(1, -1) : "";
          return e = e.trim(), /^</.test(e) && (this.options.pedantic && !/>$/.test(r) ? e = e.slice(1) : e = e.slice(1, -1)), ZI(c, {
            href: e && e.replace(this.rules.inline._escapes, "$1"),
            title: l && l.replace(this.rules.inline._escapes, "$1")
          }, c[0], this.lexer);
        }
      }
      reflink(a, c) {
        let r;
        if ((r = this.rules.inline.reflink.exec(a)) || (r = this.rules.inline.nolink.exec(a))) {
          let e = (r[2] || r[1]).replace(/\s+/g, " ");
          if (e = c[e.toLowerCase()], !e || !e.href) {
            let l = r[0].charAt(0);
            return {
              type: "text",
              raw: l,
              text: l
            };
          }
          return ZI(r, e, r[0], this.lexer);
        }
      }
      emStrong(a, c, r = "") {
        let e = this.rules.inline.emStrong.lDelim.exec(a);
        if (!e || e[3] && r.match(/[\p{L}\p{N}]/u)) return;
        let l = e[1] || e[2] || "";
        if (!l || l && (r === "" || this.rules.inline.punctuation.exec(r))) {
          let i = e[0].length - 1,
            o,
            n,
            h = i,
            v = 0,
            g = e[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          for (g.lastIndex = 0, c = c.slice(-1 * a.length + i); (e = g.exec(c)) != null;) {
            if (o = e[1] || e[2] || e[3] || e[4] || e[5] || e[6], !o) continue;
            if (n = o.length, e[3] || e[4]) {
              h += n;
              continue;
            } else if ((e[5] || e[6]) && i % 3 && !((i + n) % 3)) {
              v += n;
              continue;
            }
            if (h -= n, h > 0) continue;
            if (n = Math.min(n, n + h + v), Math.min(i, n) % 2) {
              let d = a.slice(1, i + e.index + n);
              return {
                type: "em",
                raw: a.slice(0, i + e.index + n + 1),
                text: d,
                tokens: this.lexer.inlineTokens(d)
              };
            }
            let s = a.slice(2, i + e.index + n - 1);
            return {
              type: "strong",
              raw: a.slice(0, i + e.index + n + 1),
              text: s,
              tokens: this.lexer.inlineTokens(s)
            };
          }
        }
      }
      codespan(a) {
        let c = this.rules.inline.code.exec(a);
        if (c) {
          let r = c[2].replace(/\n/g, " "),
            e = /[^ ]/.test(r),
            l = /^ /.test(r) && / $/.test(r);
          return e && l && (r = r.substring(1, r.length - 1)), r = Z2(r, !0), {
            type: "codespan",
            raw: c[0],
            text: r
          };
        }
      }
      br(a) {
        let c = this.rules.inline.br.exec(a);
        if (c) return {
          type: "br",
          raw: c[0]
        };
      }
      del(a) {
        let c = this.rules.inline.del.exec(a);
        if (c) return {
          type: "del",
          raw: c[0],
          text: c[2],
          tokens: this.lexer.inlineTokens(c[2])
        };
      }
      autolink(a, c) {
        let r = this.rules.inline.autolink.exec(a);
        if (r) {
          let e, l;
          return r[2] === "@" ? (e = Z2(this.options.mangle ? c(r[1]) : r[1]), l = "mailto:" + e) : (e = Z2(r[1]), l = e), {
            type: "link",
            raw: r[0],
            text: e,
            href: l,
            tokens: [{
              type: "text",
              raw: e,
              text: e
            }]
          };
        }
      }
      url(a, c) {
        let r;
        if (r = this.rules.inline.url.exec(a)) {
          let e, l;
          if (r[2] === "@") e = Z2(this.options.mangle ? c(r[0]) : r[0]), l = "mailto:" + e;else {
            let i;
            do i = r[0], r[0] = this.rules.inline._backpedal.exec(r[0])[0]; while (i !== r[0]);
            e = Z2(r[0]), r[1] === "www." ? l = "http://" + e : l = e;
          }
          return {
            type: "link",
            raw: r[0],
            text: e,
            href: l,
            tokens: [{
              type: "text",
              raw: e,
              text: e
            }]
          };
        }
      }
      inlineText(a, c) {
        let r = this.rules.inline.text.exec(a);
        if (r) {
          let e;
          return this.lexer.state.inRawBlock ? e = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(r[0]) : Z2(r[0]) : r[0] : e = Z2(this.options.smartypants ? c(r[0]) : r[0]), {
            type: "text",
            raw: r[0],
            text: e
          };
        }
      }
    }, H1 = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: hn,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    H1._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    H1._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    H1.def = U1(H1.def).replace("label", H1._label).replace("title", H1._title).getRegex();
    H1.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    H1.listItemStart = U1(/^( *)(bull) */).replace("bull", H1.bullet).getRegex();
    H1.list = U1(H1.list).replace(/bull/g, H1.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + H1.def.source + ")").getRegex();
    H1._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    H1._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    H1.html = U1(H1.html, "i").replace("comment", H1._comment).replace("tag", H1._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    H1.paragraph = U1(H1._paragraph).replace("hr", H1.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", H1._tag).getRegex();
    H1.blockquote = U1(H1.blockquote).replace("paragraph", H1.paragraph).getRegex();
    H1.normal = l4({}, H1);
    H1.gfm = l4({}, H1.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    });
    H1.gfm.table = U1(H1.gfm.table).replace("hr", H1.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", H1._tag).getRegex();
    H1.gfm.paragraph = U1(H1._paragraph).replace("hr", H1.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", H1.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", H1._tag).getRegex();
    H1.pedantic = l4({}, H1.normal, {
      html: U1("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment", H1._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: hn,
      paragraph: U1(H1.normal._paragraph).replace("hr", H1.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", H1.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    m1 = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: hn,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: hn,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    m1._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    m1.punctuation = U1(m1.punctuation).replace(/punctuation/g, m1._punctuation).getRegex();
    m1.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    m1.escapedEmSt = /\\\*|\\_/g;
    m1._comment = U1(H1._comment).replace("(?:-->|$)", "-->").getRegex();
    m1.emStrong.lDelim = U1(m1.emStrong.lDelim).replace(/punct/g, m1._punctuation).getRegex();
    m1.emStrong.rDelimAst = U1(m1.emStrong.rDelimAst, "g").replace(/punct/g, m1._punctuation).getRegex();
    m1.emStrong.rDelimUnd = U1(m1.emStrong.rDelimUnd, "g").replace(/punct/g, m1._punctuation).getRegex();
    m1._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    m1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    m1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    m1.autolink = U1(m1.autolink).replace("scheme", m1._scheme).replace("email", m1._email).getRegex();
    m1._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    m1.tag = U1(m1.tag).replace("comment", m1._comment).replace("attribute", m1._attribute).getRegex();
    m1._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    m1._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    m1._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    m1.link = U1(m1.link).replace("label", m1._label).replace("href", m1._href).replace("title", m1._title).getRegex();
    m1.reflink = U1(m1.reflink).replace("label", m1._label).replace("ref", H1._label).getRegex();
    m1.nolink = U1(m1.nolink).replace("ref", H1._label).getRegex();
    m1.reflinkSearch = U1(m1.reflinkSearch, "g").replace("reflink", m1.reflink).replace("nolink", m1.nolink).getRegex();
    m1.normal = l4({}, m1);
    m1.pedantic = l4({}, m1.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: U1(/^!?\[(label)\]\((.*?)\)/).replace("label", m1._label).getRegex(),
      reflink: U1(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", m1._label).getRegex()
    });
    m1.gfm = l4({}, m1.normal, {
      escape: U1(m1.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    m1.gfm.url = U1(m1.gfm.url, "i").replace("email", m1.gfm._extended_email).getRegex();
    m1.breaks = l4({}, m1.gfm, {
      br: U1(m1.br).replace("{2,}", "*").getRegex(),
      text: U1(m1.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    Q6 = class t {
      constructor(a) {
        this.tokens = [], this.tokens.links = Object.create(null), this.options = a || ht, this.options.tokenizer = this.options.tokenizer || new zr(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
          inLink: !1,
          inRawBlock: !1,
          top: !0
        };
        let c = {
          block: H1.normal,
          inline: m1.normal
        };
        this.options.pedantic ? (c.block = H1.pedantic, c.inline = m1.pedantic) : this.options.gfm && (c.block = H1.gfm, this.options.breaks ? c.inline = m1.breaks : c.inline = m1.gfm), this.tokenizer.rules = c;
      }
      static get rules() {
        return {
          block: H1,
          inline: m1
        };
      }
      static lex(a, c) {
        return new t(c).lex(a);
      }
      static lexInline(a, c) {
        return new t(c).inlineTokens(a);
      }
      lex(a) {
        a = a.replace(/\r\n|\r/g, "\n"), this.blockTokens(a, this.tokens);
        let c;
        for (; c = this.inlineQueue.shift();) this.inlineTokens(c.src, c.tokens);
        return this.tokens;
      }
      blockTokens(a, c = []) {
        this.options.pedantic ? a = a.replace(/\t/g, "    ").replace(/^ +$/gm, "") : a = a.replace(/^( *)(\t+)/gm, (o, n, h) => n + "    ".repeat(h.length));
        let r, e, l, i;
        for (; a;) if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(o => (r = o.call({
          lexer: this
        }, a, c)) ? (a = a.substring(r.raw.length), c.push(r), !0) : !1))) {
          if (r = this.tokenizer.space(a)) {
            a = a.substring(r.raw.length), r.raw.length === 1 && c.length > 0 ? c[c.length - 1].raw += "\n" : c.push(r);
            continue;
          }
          if (r = this.tokenizer.code(a)) {
            a = a.substring(r.raw.length), e = c[c.length - 1], e && (e.type === "paragraph" || e.type === "text") ? (e.raw += "\n" + r.raw, e.text += "\n" + r.text, this.inlineQueue[this.inlineQueue.length - 1].src = e.text) : c.push(r);
            continue;
          }
          if (r = this.tokenizer.fences(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.heading(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.hr(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.blockquote(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.list(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.html(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.def(a)) {
            a = a.substring(r.raw.length), e = c[c.length - 1], e && (e.type === "paragraph" || e.type === "text") ? (e.raw += "\n" + r.raw, e.text += "\n" + r.raw, this.inlineQueue[this.inlineQueue.length - 1].src = e.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = {
              href: r.href,
              title: r.title
            });
            continue;
          }
          if (r = this.tokenizer.table(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.lheading(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (l = a, this.options.extensions && this.options.extensions.startBlock) {
            let o = 1 / 0,
              n = a.slice(1),
              h;
            this.options.extensions.startBlock.forEach(function (v) {
              h = v.call({
                lexer: this
              }, n), typeof h == "number" && h >= 0 && (o = Math.min(o, h));
            }), o < 1 / 0 && o >= 0 && (l = a.substring(0, o + 1));
          }
          if (this.state.top && (r = this.tokenizer.paragraph(l))) {
            e = c[c.length - 1], i && e.type === "paragraph" ? (e.raw += "\n" + r.raw, e.text += "\n" + r.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = e.text) : c.push(r), i = l.length !== a.length, a = a.substring(r.raw.length);
            continue;
          }
          if (r = this.tokenizer.text(a)) {
            a = a.substring(r.raw.length), e = c[c.length - 1], e && e.type === "text" ? (e.raw += "\n" + r.raw, e.text += "\n" + r.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = e.text) : c.push(r);
            continue;
          }
          if (a) {
            let o = "Infinite loop on byte: " + a.charCodeAt(0);
            if (this.options.silent) {
              console.error(o);
              break;
            } else throw new Error(o);
          }
        }
        return this.state.top = !0, c;
      }
      inline(a, c = []) {
        return this.inlineQueue.push({
          src: a,
          tokens: c
        }), c;
      }
      inlineTokens(a, c = []) {
        let r,
          e,
          l,
          i = a,
          o,
          n,
          h;
        if (this.tokens.links) {
          let v = Object.keys(this.tokens.links);
          if (v.length > 0) for (; (o = this.tokenizer.rules.inline.reflinkSearch.exec(i)) != null;) v.includes(o[0].slice(o[0].lastIndexOf("[") + 1, -1)) && (i = i.slice(0, o.index) + "[" + TI("a", o[0].length - 2) + "]" + i.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
        }
        for (; (o = this.tokenizer.rules.inline.blockSkip.exec(i)) != null;) i = i.slice(0, o.index) + "[" + TI("a", o[0].length - 2) + "]" + i.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        for (; (o = this.tokenizer.rules.inline.escapedEmSt.exec(i)) != null;) i = i.slice(0, o.index) + "++" + i.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        for (; a;) if (n || (h = ""), n = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(v => (r = v.call({
          lexer: this
        }, a, c)) ? (a = a.substring(r.raw.length), c.push(r), !0) : !1))) {
          if (r = this.tokenizer.escape(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.tag(a)) {
            a = a.substring(r.raw.length), e = c[c.length - 1], e && r.type === "text" && e.type === "text" ? (e.raw += r.raw, e.text += r.text) : c.push(r);
            continue;
          }
          if (r = this.tokenizer.link(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.reflink(a, this.tokens.links)) {
            a = a.substring(r.raw.length), e = c[c.length - 1], e && r.type === "text" && e.type === "text" ? (e.raw += r.raw, e.text += r.text) : c.push(r);
            continue;
          }
          if (r = this.tokenizer.emStrong(a, i, h)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.codespan(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.br(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.del(a)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (r = this.tokenizer.autolink(a, OI)) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (!this.state.inLink && (r = this.tokenizer.url(a, OI))) {
            a = a.substring(r.raw.length), c.push(r);
            continue;
          }
          if (l = a, this.options.extensions && this.options.extensions.startInline) {
            let v = 1 / 0,
              g = a.slice(1),
              s;
            this.options.extensions.startInline.forEach(function (d) {
              s = d.call({
                lexer: this
              }, g), typeof s == "number" && s >= 0 && (v = Math.min(v, s));
            }), v < 1 / 0 && v >= 0 && (l = a.substring(0, v + 1));
          }
          if (r = this.tokenizer.inlineText(l, S51)) {
            a = a.substring(r.raw.length), r.raw.slice(-1) !== "_" && (h = r.raw.slice(-1)), n = !0, e = c[c.length - 1], e && e.type === "text" ? (e.raw += r.raw, e.text += r.text) : c.push(r);
            continue;
          }
          if (a) {
            let v = "Infinite loop on byte: " + a.charCodeAt(0);
            if (this.options.silent) {
              console.error(v);
              break;
            } else throw new Error(v);
          }
        }
        return c;
      }
    }, ur = class {
      constructor(a) {
        this.options = a || ht;
      }
      code(a, c, r) {
        let e = (c || "").match(/\S*/)[0];
        if (this.options.highlight) {
          let l = this.options.highlight(a, e);
          l != null && l !== a && (r = !0, a = l);
        }
        return a = a.replace(/\n$/, "") + "\n", e ? '<pre><code class="' + this.options.langPrefix + Z2(e, !0) + '">' + (r ? a : Z2(a, !0)) + "</code></pre>\n" : "<pre><code>" + (r ? a : Z2(a, !0)) + "</code></pre>\n";
      }
      blockquote(a) {
        return "<blockquote>\n".concat(a, "</blockquote>\n");
      }
      html(a) {
        return a;
      }
      heading(a, c, r, e) {
        if (this.options.headerIds) {
          let l = this.options.headerPrefix + e.slug(r);
          return "<h".concat(c, ' id="').concat(l, '">').concat(a, "</h").concat(c, ">\n");
        }
        return "<h".concat(c, ">").concat(a, "</h").concat(c, ">\n");
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(a, c, r) {
        let e = c ? "ol" : "ul",
          l = c && r !== 1 ? ' start="' + r + '"' : "";
        return "<" + e + l + ">\n" + a + "</" + e + ">\n";
      }
      listitem(a) {
        return "<li>".concat(a, "</li>\n");
      }
      checkbox(a) {
        return "<input " + (a ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      paragraph(a) {
        return "<p>".concat(a, "</p>\n");
      }
      table(a, c) {
        return c && (c = "<tbody>".concat(c, "</tbody>")), "<table>\n<thead>\n" + a + "</thead>\n" + c + "</table>\n";
      }
      tablerow(a) {
        return "<tr>\n".concat(a, "</tr>\n");
      }
      tablecell(a, c) {
        let r = c.header ? "th" : "td";
        return (c.align ? "<".concat(r, ' align="').concat(c.align, '">') : "<".concat(r, ">")) + a + "</".concat(r, ">\n");
      }
      strong(a) {
        return "<strong>".concat(a, "</strong>");
      }
      em(a) {
        return "<em>".concat(a, "</em>");
      }
      codespan(a) {
        return "<code>".concat(a, "</code>");
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      del(a) {
        return "<del>".concat(a, "</del>");
      }
      link(a, c, r) {
        if (a = PI(this.options.sanitize, this.options.baseUrl, a), a === null) return r;
        let e = '<a href="' + Z2(a) + '"';
        return c && (e += ' title="' + c + '"'), e += ">" + r + "</a>", e;
      }
      image(a, c, r) {
        if (a = PI(this.options.sanitize, this.options.baseUrl, a), a === null) return r;
        let e = '<img src="'.concat(a, '" alt="').concat(r, '"');
        return c && (e += ' title="'.concat(c, '"')), e += this.options.xhtml ? "/>" : ">", e;
      }
      text(a) {
        return a;
      }
    }, vn = class {
      strong(a) {
        return a;
      }
      em(a) {
        return a;
      }
      codespan(a) {
        return a;
      }
      del(a) {
        return a;
      }
      html(a) {
        return a;
      }
      text(a) {
        return a;
      }
      link(a, c, r) {
        return "" + r;
      }
      image(a, c, r) {
        return "" + r;
      }
      br() {
        return "";
      }
    }, gn = class {
      constructor() {
        this.seen = {};
      }
      serialize(a) {
        return a.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      getNextSafeSlug(a, c) {
        let r = a,
          e = 0;
        if (this.seen.hasOwnProperty(r)) {
          e = this.seen[a];
          do e++, r = a + "-" + e; while (this.seen.hasOwnProperty(r));
        }
        return c || (this.seen[a] = e, this.seen[r] = 0), r;
      }
      slug(a, c = {}) {
        let r = this.serialize(a);
        return this.getNextSafeSlug(r, c.dryrun);
      }
    }, B5 = class t {
      constructor(a) {
        this.options = a || ht, this.options.renderer = this.options.renderer || new ur(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new vn(), this.slugger = new gn();
      }
      static parse(a, c) {
        return new t(c).parse(a);
      }
      static parseInline(a, c) {
        return new t(c).parseInline(a);
      }
      parse(a, c = !0) {
        let r = "",
          e,
          l,
          i,
          o,
          n,
          h,
          v,
          g,
          s,
          d,
          z,
          u,
          f,
          p,
          m,
          M,
          w,
          H,
          y,
          k = a.length;
        for (e = 0; e < k; e++) {
          if (d = a[e], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[d.type] && (y = this.options.extensions.renderers[d.type].call({
            parser: this
          }, d), y !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(d.type))) {
            r += y || "";
            continue;
          }
          switch (d.type) {
            case "space":
              continue;
            case "hr":
              {
                r += this.renderer.hr();
                continue;
              }
            case "heading":
              {
                r += this.renderer.heading(this.parseInline(d.tokens), d.depth, DI(this.parseInline(d.tokens, this.textRenderer)), this.slugger);
                continue;
              }
            case "code":
              {
                r += this.renderer.code(d.text, d.lang, d.escaped);
                continue;
              }
            case "table":
              {
                for (g = "", v = "", o = d.header.length, l = 0; l < o; l++) v += this.renderer.tablecell(this.parseInline(d.header[l].tokens), {
                  header: !0,
                  align: d.align[l]
                });
                for (g += this.renderer.tablerow(v), s = "", o = d.rows.length, l = 0; l < o; l++) {
                  for (h = d.rows[l], v = "", n = h.length, i = 0; i < n; i++) v += this.renderer.tablecell(this.parseInline(h[i].tokens), {
                    header: !1,
                    align: d.align[i]
                  });
                  s += this.renderer.tablerow(v);
                }
                r += this.renderer.table(g, s);
                continue;
              }
            case "blockquote":
              {
                s = this.parse(d.tokens), r += this.renderer.blockquote(s);
                continue;
              }
            case "list":
              {
                for (z = d.ordered, u = d.start, f = d.loose, o = d.items.length, s = "", l = 0; l < o; l++) m = d.items[l], M = m.checked, w = m.task, p = "", m.task && (H = this.renderer.checkbox(M), f ? m.tokens.length > 0 && m.tokens[0].type === "paragraph" ? (m.tokens[0].text = H + " " + m.tokens[0].text, m.tokens[0].tokens && m.tokens[0].tokens.length > 0 && m.tokens[0].tokens[0].type === "text" && (m.tokens[0].tokens[0].text = H + " " + m.tokens[0].tokens[0].text)) : m.tokens.unshift({
                  type: "text",
                  text: H
                }) : p += H), p += this.parse(m.tokens, f), s += this.renderer.listitem(p, w, M);
                r += this.renderer.list(s, z, u);
                continue;
              }
            case "html":
              {
                r += this.renderer.html(d.text);
                continue;
              }
            case "paragraph":
              {
                r += this.renderer.paragraph(this.parseInline(d.tokens));
                continue;
              }
            case "text":
              {
                for (s = d.tokens ? this.parseInline(d.tokens) : d.text; e + 1 < k && a[e + 1].type === "text";) d = a[++e], s += "\n" + (d.tokens ? this.parseInline(d.tokens) : d.text);
                r += c ? this.renderer.paragraph(s) : s;
                continue;
              }
            default:
              {
                let F = 'Token with "' + d.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(F);
                  return;
                } else throw new Error(F);
              }
          }
        }
        return r;
      }
      parseInline(a, c) {
        c = c || this.renderer;
        let r = "",
          e,
          l,
          i,
          o = a.length;
        for (e = 0; e < o; e++) {
          if (l = a[e], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[l.type] && (i = this.options.extensions.renderers[l.type].call({
            parser: this
          }, l), i !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(l.type))) {
            r += i || "";
            continue;
          }
          switch (l.type) {
            case "escape":
              {
                r += c.text(l.text);
                break;
              }
            case "html":
              {
                r += c.html(l.text);
                break;
              }
            case "link":
              {
                r += c.link(l.href, l.title, this.parseInline(l.tokens, c));
                break;
              }
            case "image":
              {
                r += c.image(l.href, l.title, l.text);
                break;
              }
            case "strong":
              {
                r += c.strong(this.parseInline(l.tokens, c));
                break;
              }
            case "em":
              {
                r += c.em(this.parseInline(l.tokens, c));
                break;
              }
            case "codespan":
              {
                r += c.codespan(l.text);
                break;
              }
            case "br":
              {
                r += c.br();
                break;
              }
            case "del":
              {
                r += c.del(this.parseInline(l.tokens, c));
                break;
              }
            case "text":
              {
                r += c.text(l.text);
                break;
              }
            default:
              {
                let n = 'Token with "' + l.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(n);
                  return;
                } else throw new Error(n);
              }
          }
        }
        return r;
      }
    };
    V1.options = V1.setOptions = function (t) {
      return l4(V1.defaults, t), d51(V1.defaults), V1;
    };
    V1.getDefaults = EI;
    V1.defaults = ht;
    V1.use = function (...t) {
      let a = l4({}, ...t),
        c = V1.defaults.extensions || {
          renderers: {},
          childTokens: {}
        },
        r;
      t.forEach(e => {
        if (e.extensions && (r = !0, e.extensions.forEach(l => {
          if (!l.name) throw new Error("extension name required");
          if (l.renderer) {
            let i = c.renderers ? c.renderers[l.name] : null;
            i ? c.renderers[l.name] = function (...o) {
              let n = l.renderer.apply(this, o);
              return n === !1 && (n = i.apply(this, o)), n;
            } : c.renderers[l.name] = l.renderer;
          }
          if (l.tokenizer) {
            if (!l.level || l.level !== "block" && l.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
            c[l.level] ? c[l.level].unshift(l.tokenizer) : c[l.level] = [l.tokenizer], l.start && (l.level === "block" ? c.startBlock ? c.startBlock.push(l.start) : c.startBlock = [l.start] : l.level === "inline" && (c.startInline ? c.startInline.push(l.start) : c.startInline = [l.start]));
          }
          l.childTokens && (c.childTokens[l.name] = l.childTokens);
        })), e.renderer) {
          let l = V1.defaults.renderer || new ur();
          for (let i in e.renderer) {
            let o = l[i];
            l[i] = (...n) => {
              let h = e.renderer[i].apply(l, n);
              return h === !1 && (h = o.apply(l, n)), h;
            };
          }
          a.renderer = l;
        }
        if (e.tokenizer) {
          let l = V1.defaults.tokenizer || new zr();
          for (let i in e.tokenizer) {
            let o = l[i];
            l[i] = (...n) => {
              let h = e.tokenizer[i].apply(l, n);
              return h === !1 && (h = o.apply(l, n)), h;
            };
          }
          a.tokenizer = l;
        }
        if (e.walkTokens) {
          let l = V1.defaults.walkTokens;
          a.walkTokens = function (i) {
            let o = [];
            return o.push(e.walkTokens.call(this, i)), l && (o = o.concat(l.call(this, i))), o;
          };
        }
        r && (a.extensions = c), V1.setOptions(a);
      });
    };
    V1.walkTokens = function (t, a) {
      let c = [];
      for (let r of t) switch (c = c.concat(a.call(V1, r)), r.type) {
        case "table":
          {
            for (let e of r.header) c = c.concat(V1.walkTokens(e.tokens, a));
            for (let e of r.rows) for (let l of e) c = c.concat(V1.walkTokens(l.tokens, a));
            break;
          }
        case "list":
          {
            c = c.concat(V1.walkTokens(r.items, a));
            break;
          }
        default:
          V1.defaults.extensions && V1.defaults.extensions.childTokens && V1.defaults.extensions.childTokens[r.type] ? V1.defaults.extensions.childTokens[r.type].forEach(function (e) {
            c = c.concat(V1.walkTokens(r[e], a));
          }) : r.tokens && (c = c.concat(V1.walkTokens(r.tokens, a)));
      }
      return c;
    };
    V1.parseInline = function (t, a) {
      if (typeof t == "undefined" || t === null) throw new Error("marked.parseInline(): input parameter is undefined or null");
      if (typeof t != "string") throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(t) + ", string expected");
      a = l4({}, V1.defaults, a || {}), WI(a);
      try {
        let c = Q6.lexInline(t, a);
        return a.walkTokens && V1.walkTokens(c, a.walkTokens), B5.parseInline(c, a);
      } catch (c) {
        if (c.message += "\nPlease report this to https://github.com/markedjs/marked.", a.silent) return "<p>An error occurred:</p><pre>" + Z2(c.message + "", !0) + "</pre>";
        throw c;
      }
    };
    V1.Parser = B5;
    V1.parser = B5.parse;
    V1.Renderer = ur;
    V1.TextRenderer = vn;
    V1.Lexer = Q6;
    V1.lexer = Q6.lex;
    V1.Tokenizer = zr;
    V1.Slugger = gn;
    V1.parse = V1;
    $y1 = V1.options, Qy1 = V1.setOptions, Xy1 = V1.use, Yy1 = V1.walkTokens, Jy1 = V1.parseInline, tS1 = B5.parse, aS1 = Q6.lex;
  });
var jI,
  k51,
  dn,
  bu = x(() => {
    "use strict";

    c1();
    gr();
    k51 = B(w5)(jI || (jI = V(["\n  padding: 6px;\n"]))), dn = k51;
  });
var u2,
  Fu,
  zn,
  Iu,
  NI,
  A51,
  UI,
  rP,
  KI,
  R51,
  $I,
  qI,
  QI,
  b51,
  F51,
  XI,
  I51,
  sn,
  c7,
  YI,
  P51,
  JI,
  G51,
  tP,
  T51,
  aP,
  Z51,
  cP,
  O51,
  eP,
  lP,
  Pu,
  vt = x(() => {
    "use strict";

    u2 = I(G());
    FI();
    c1();
    G1();
    M1();
    f1();
    _I();
    nt();
    bu();
    Fu = ({
      title: t,
      message: a
    }) => "".concat(t, " ").concat(a), zn = (() => {
      let t = new Map();
      return {
        add: a => {
          let c = Fu(a);
          t.has(c) ? t.set(c, t.get(c) + 1) : t.set(c, 1);
        },
        delete: a => {
          let c = Fu(a);
          t.has(c) && t.get(c) > 1 ? t.set(c, t.get(c) - 1) : t.delete(c);
        },
        clear: () => {
          t.clear();
        },
        check: a => t.has(Fu(a))
      };
    })(), Iu = (() => {
      let t = new Map();
      return {
        add: a => {
          t.has(a) ? t.set(a, t.get(a) + 1) : t.set(a, 1);
        },
        delete: a => {
          t.has(a) && t.get(a) > 1 ? t.set(a, t.get(a) - 1) : t.delete(a);
        },
        clear: () => {
          t.clear();
        },
        check: a => t.has(a),
        get types() {
          return Array.of(...t.keys());
        }
      };
    })(), A51 = B.div(NI || (NI = V(["\n  width: 100%;\n  border-radius: 4px;\n  display: flex;\n  gap: 12px;\n  ", ";\n  background-color: rgba(40, 43, 47, 0.8);\n  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.25), 0 2px 6px rgba(0, 0, 0, 0.15);\n  backdrop-filter: blur(14px);\n\n  @supports not (backdrop-filter: blur()) {\n    background: rgba(40, 43, 47, 0.95);\n  }\n"])), C1), rP = B.div(UI || (UI = V(["\n  font-size: 14px;\n  font-weight: bold;\n  color: #fff;\n"]))), R51 = B.div(KI || (KI = V(["\n  flex: 1;\n  flex-direction: column;\n  width: 0;\n  display: flex;\n  padding: 16px 0;\n  gap: 12px;\n"]))), qI = B.div($I || ($I = V(["\n  color: #b4b4b4;\n  font-size: 12px;\n  line-height: 1.4;\n\n  a {\n    color: rgba(255, 255, 255, 0.9);\n  }\n\n  em {\n    font-style: italic;\n  }\n\n  strong {\n    font-weight: bold;\n    color: #d5d5d5;\n  }\n\n  p {\n    margin-bottom: 8px;\n  }\n\n  code {\n    font-family: monospace;\n    background: rgba(0, 0, 0, 0.3);\n    padding: 1px 1px 2px;\n    border-radius: 4px;\n    border: 1px solid rgba(255, 255, 255, 0.08);\n    white-space: pre-wrap;\n  }\n\n  pre > code {\n    white-space: pre;\n    display: block;\n    overflow: auto;\n    padding: 4px;\n  }\n\n  pre {\n    white-space: pre-wrap;\n    margin-bottom: 8px;\n  }\n"]))), b51 = B.button(QI || (QI = V(["\n  color: rgba(255, 255, 255, 0.9);\n  font-weight: 500;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: none;\n  border: none;\n  padding-left: 12px;\n  padding-right: 12px;\n  border-left: 1px solid rgba(255, 255, 255, 0.05);\n\n  &:hover {\n    background: rgba(255, 255, 255, 0.05);\n  }\n"]))), F51 = {
      info: "#3b82f6",
      success: "#10b981",
      warning: "#f59e0b",
      error: "#ef4444"
    }, I51 = B.div(XI || (XI = V(["\n  display: flex;\n  justify-content: center;\n  margin-left: 12px;\n  padding-top: 21px;\n\n  ::before {\n    content: '';\n    width: 8px;\n    height: 8px;\n    border-radius: 999999px;\n    background-color: ", ";\n  }\n"])), ({
      type: t
    }) => F51[t]), sn = t => (a, c, r = [], e = !1) => {
      (e || !zn.check({
        title: a,
        message: c
      })) && (zn.add({
        title: a,
        message: c
      }), Iu.add(t), ln.custom(l => u2.default.createElement(A51, null, u2.default.createElement(I51, {
        type: t
      }), u2.default.createElement(R51, null, u2.default.createElement(rP, null, a), u2.default.createElement(qI, {
        dangerouslySetInnerHTML: {
          __html: V1.parse(c)
        }
      }), r.length > 0 && u2.default.createElement(qI, null, u2.default.createElement("span", null, "Docs:", " ", r.map((i, o) => u2.default.createElement(u2.Fragment, {
        key: o
      }, o > 0 && ", ", u2.default.createElement("a", {
        target: "_blank",
        href: i.url
      }, i.title)))))), u2.default.createElement(b51, {
        onClick: () => {
          ln.remove(l.id), zn.delete({
            title: a,
            message: c
          }), Iu.delete(t);
        }
      }, "Close")), {
        duration: 1 / 0
      }));
    }, c7 = {
      warning: sn("warning"),
      success: sn("success"),
      info: sn("info"),
      error: sn("error")
    }, P51 = B.div(YI || (YI = V(["\n  display: flex;\n  justify-content: ", ";\n  gap: 12px;\n"])), ({
      align: t
    }) => t === "center" ? "center" : "flex-end"), G51 = B.button(JI || (JI = V(["\n  position: relative;\n  border-radius: 4px;\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  ", ";\n  background-color: rgba(40, 43, 47, 0.8);\n  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.25), 0 2px 6px rgba(0, 0, 0, 0.15);\n  backdrop-filter: blur(14px);\n  border: none;\n  padding: 12px;\n  color: #fff;\n  overflow: hidden;\n\n  ::before {\n    content: '';\n    position: absolute;\n    inset: 0;\n  }\n\n  :hover::before {\n    background: ", ";\n  }\n\n  @supports not (backdrop-filter: blur()) {\n    background: rgba(40, 43, 47, 0.95);\n  }\n"])), C1, ({
      danger: t
    }) => t ? "rgba(255, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"), T51 = B.div(tP || (tP = V(["\n  z-index: 10;\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n  position: fixed;\n  right: 92px;\n  top: 50px;\n  width: 500px;\n  height: 85vh;\n  min-height: 400px;\n"]))), Z51 = B.div(aP || (aP = V(["\n  overflow: hidden;\n  pointer-events: auto;\n  border-radius: 4px;\n\n  & > div {\n    display: flex;\n    flex-direction: column-reverse;\n    gap: 8px;\n    overflow: scroll;\n    height: 100%;\n  }\n"]))), O51 = B.div(cP || (cP = V(["\n  width: fit-content;\n  padding: 8px;\n  border-radius: 4px;\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n  color: #b4b4b4;\n  font-size: 12px;\n  line-height: 1.4;\n"]))), eP = () => {
      let {
        hasNotifications: t
      } = Pu();
      return R3({
        enabled: !t
      }, () => u2.default.createElement(dn, null, u2.default.createElement(O51, null, u2.default.createElement(rP, null, "No notifications"), "Notifications will appear here when you get them.")));
    }, lP = () => {
      var l;
      let {
          toasts: t,
          handlers: a
        } = Ru(),
        {
          startPause: c,
          endPause: r
        } = a,
        e = (l = s1(T().atomP.ahistoric.pinNotifications)) != null ? l : !1;
      return u2.default.createElement(T51, null, e ? t.length > 0 && u2.default.createElement(Z51, {
        onMouseEnter: c,
        onMouseLeave: r
      }, u2.default.createElement("div", null, t.map(i => u2.default.createElement("div", {
        key: i.id
      }, i.message(i))))) : null, u2.default.createElement(P51, {
        align: "side"
      }, e && t.length > 0 && u2.default.createElement(G51, {
        onClick: () => {
          Iu.clear(), zn.clear(), ln.remove();
        },
        danger: !0
      }, "Clear")));
    }, Pu = () => {
      let {
        toasts: t
      } = Ru();
      return {
        hasNotifications: t.length > 0
      };
    };
  });
function pr(t, a) {
  var o;
  let c = Object.values((o = (0, iP.val)(t.pointers.historic.sheetsById)) != null ? o : {}),
    r = c.flatMap(n => {
      var h;
      return Object.values((h = n == null ? void 0 : n.staticOverrides.byObject) != null ? h : {});
    }).flatMap(n => Object.values(n != null ? n : {})),
    l = [...c.flatMap(n => {
      var h, v;
      return Object.values((v = (h = n == null ? void 0 : n.sequence) == null ? void 0 : h.tracksByObject) != null ? v : {});
    }).flatMap(n => {
      var h;
      return Object.values((h = n == null ? void 0 : n.trackData) != null ? h : {});
    }).flatMap(n => n == null ? void 0 : n.keyframes).map(n => n == null ? void 0 : n.value)];
  return r.forEach(n => {
    q5(n, h => {
      l.push(h);
    }, []);
  }), l.filter(n => (n == null ? void 0 : n.type) && (a ? (n == null ? void 0 : n.type) == a : typeof (n == null ? void 0 : n.type) == "string")).map(n => n.id).filter((n, h, v) => n !== null && n !== "" && v.indexOf(n) === h);
}
var iP,
  Gu = x(() => {
    "use strict";

    iP = require("@theatre/dataverse");
    de();
  });
function oP(t, a) {
  let c = new File([t], a),
    r = URL.createObjectURL(c),
    e = Object.assign(document.createElement("a"), {
      href: r,
      target: "_blank",
      rel: "noopener"
    });
  e.setAttribute("download", a), e.click(), setTimeout(() => {
    URL.revokeObjectURL(r);
  }, 4e4);
}
var L0,
  gP,
  nP,
  E51,
  hP,
  D51,
  vP,
  W51,
  _51,
  dP,
  sP = x(() => {
    "use strict";

    f1();
    e4();
    c4();
    L0 = I(G());
    c1();
    Bu();
    SI();
    gP = I(AI());
    vt();
    Gu();
    E51 = B.div(nP || (nP = V([""]))), D51 = B.div(hP || (hP = V(["\n  padding: 8px 10px;\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n"]))), W51 = B(T2)(vP || (vP = V(["\n  display flex;\n  flex-direction: column;\n  gap: 1em;\n  width: 280px;\n  padding: 1em;\n"])));
    _51 = ({
      projects: t
    }) => {
      let a = t[0],
        c = a.address.projectId,
        r = c.replace(/[^\w\d'_\-]+/g, " ").trim(),
        e = "".concat(r, ".theatre-project-state.json"),
        [l, i] = (0, L0.useState)(!1),
        o = (0, L0.useCallback)(() => e2(void 0, null, function* () {
          var s, d;
          let h = pr(a),
            v = new Map();
          try {
            yield Promise.all(h.map(z => e2(void 0, null, function* () {
              let u = a.assetStorage.getAssetUrl(z),
                f = yield fetch(u);
              f.ok && v.set(z, yield f.blob());
            })));
          } catch (z) {
            c7.error("Failed to access assets", "Export aborted. Failed to access assets at ".concat((d = (s = a.config.assets) == null ? void 0 : s.baseUrl) != null ? d : "/", ". This is likely due to a CORS issue."));
            return;
          }
          if (v.size > 0) {
            let z = new gP.default();
            for (let [f, p] of v) z.file(f, p);
            let u = yield z.generateAsync({
              type: "blob"
            });
            oP(u, "".concat(r, ".assets.zip"));
          }
          let g = JSON.stringify(T().createContentOfSaveFile(a.address.projectId), null, 2);
          oP(g, e), i(!0), setTimeout(() => {
            i(!1);
          }, 2e3);
        }), [a, e]),
        n = x2({
          debugName: "ProjectDetails",
          pointerDistanceThreshold: 50
        }, () => L0.default.createElement(W51, null, L0.default.createElement("p", null, "This will create a JSON file with the state of your project. You can commit this file to your git repo and include it in your production bundle."), L0.default.createElement("p", null, "If your project uses assets, this will also create a zip file with all the assets that you can unpack in your public folder."), L0.default.createElement("a", {
          href: "https://www.theatrejs.com/docs/latest/manual/projects#state",
          target: "_blank"
        }, "Here is a quick guide on how to export to production.")));
      return L0.default.createElement(L0.default.Fragment, null, n.node, L0.default.createElement(E51, null, L0.default.createElement(yI, {
        projectId: c
      }), L0.default.createElement(D51, null, L0.default.createElement(vr, {
        onMouseEnter: h => n.open(h, h.target),
        onClick: l ? void 0 : o,
        disabled: l
      }, l ? "(Exported)" : "Export ".concat(c, " to JSON")))));
    }, dP = _51;
  });
var X6,
  zP,
  j51,
  uP,
  q51,
  pP,
  N51,
  mP,
  U51,
  K51,
  fP,
  MP = x(() => {
    "use strict";

    X6 = I(G());
    c1();
    b9();
    j51 = B.div(zP || (zP = V(["\n  padding: 16px;\n  display: flex;\n  flex-direction: column;\n  gap: 24px;\n"]))), q51 = B.div(uP || (uP = V(["\n  display: flex;\n  flex-direction: column;\n  gap: 11px;\n  color: rgba(255, 255, 255, 0.9);\n"]))), N51 = B.div(pP || (pP = V(["\n  color: rgba(145, 145, 145, 0.8);\n"]))), U51 = B.a(mP || (mP = V(["\n  color: #919191;\n  font-size: 10px;\n  text-decoration-color: #40434a;\n  text-underline-offset: 3px;\n"]))), K51 = () => X6.default.createElement(j51, null, X6.default.createElement(q51, null, X6.default.createElement(N51, null, X6.default.createElement(Gc, null)), X6.default.createElement("div", null, "Please select an object from the ", X6.default.createElement("u", null, "Outline Menu"), " to see its properties.")), X6.default.createElement(U51, {
      href: "https://www.theatrejs.com/docs/latest/manual/objects",
      target: "_blank"
    }, "Learn more about Objects")), fP = K51;
  });
function mr() {
  let [t, a] = (0, un.useState)(!1),
    c = (0, un.useMemo)(() => {
      let r = new Set();
      return () => {
        let e = () => {
          r.delete(e), a(r.size > 0);
        };
        return r.add(e), a(!0), e;
      };
    }, []);
  return [t, c];
}
var un,
  Tu = x(() => {
    "use strict";

    un = I(G());
  });
var O1,
  Y6,
  $51,
  HP,
  Zu,
  VP,
  xP,
  wP,
  CP,
  BP,
  LP,
  N9,
  Q51,
  yP,
  Ou,
  gt,
  US1,
  Io = x(() => {
    "use strict";

    C5();
    M1();
    O1 = I(G());
    c1();
    N5();
    b4();
    G1();
    gI();
    sP();
    f1();
    bz();
    Y6 = require("@theatre/dataverse");
    MP();
    Tu();
    K6();
    $51 = "32px", Zu = B.div(HP || (HP = V(["\n  ", ";\n  background-color: rgba(40, 43, 47, 0.8);\n  position: fixed;\n  right: 8px;\n  top: 50px;\n  // Temporary, see comment about CSS grid in SingleRowPropEditor.\n  width: 280px;\n  height: fit-content;\n  z-index: ", ";\n\n  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.25), 0 2px 6px rgba(0, 0, 0, 0.15);\n  backdrop-filter: blur(14px);\n  border-radius: 2px;\n\n  display: ", ";\n\n  &:hover {\n    display: block;\n  }\n\n  @supports not (backdrop-filter: blur()) {\n    background: rgba(40, 43, 47, 0.95);\n  }\n"])), C1, M5.propsPanel, ({
      pin: t
    }) => t ? "block" : "none"), xP = B.div(VP || (VP = V(["\n  margin: 0 10px;\n  color: #919191;\n  font-weight: 500;\n  font-size: 10px;\n  user-select: none;\n  ", ";\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n"])), C1), CP = B.div(wP || (wP = V(["\n  height: ", ";\n  display: flex;\n  align-items: center;\n"])), $51), LP = B.div(BP || (BP = V(["\n  ", ";\n  max-height: calc(100vh - 100px);\n  overflow-y: scroll;\n  &::-webkit-scrollbar {\n    display: none;\n  }\n\n  scrollbar-width: none;\n  padding: 0;\n  user-select: none;\n\n  /* Set the font-size for input values in the detail panel */\n  font-size: 12px;\n"])), C1), N9 = (0, O1.createContext)([!1, () => () => {}]), Q51 = t => {
      let a = s1(T().atomP.ahistoric.pinDetails) !== !1,
        c = Dc("right");
      (0, O1.useLayoutEffect)(() => {
        Ou.set(c);
      }, [c]), (0, O1.useEffect)(() => () => {
        gt.set(!1), Ou.set(!1);
      }, []);
      let [r] = (0, O1.useContext)(N9),
        e = a || c || r,
        [l, i] = (0, O1.useState)(null);
      return _o(l), v1(() => {
        let o = c3(),
          n = o.find(c0);
        if (n) return O1.default.createElement(Zu, {
          "data-testid": "DetailPanel-Object",
          pin: e,
          ref: i,
          onMouseEnter: () => {
            gt.set(!0);
          },
          onMouseLeave: () => {
            gt.set(!1);
          }
        }, O1.default.createElement(CP, null, O1.default.createElement(xP, {
          title: "".concat(n.sheet.address.sheetId, ": ").concat(n.sheet.address.sheetInstanceId, " > ").concat(n.address.objectKey)
        }, O1.default.createElement(x5, null, n.sheet.address.sheetId, " "), O1.default.createElement(R9, null, ":", "\xA0"), O1.default.createElement(x5, null, n.sheet.address.sheetInstanceId, " "), O1.default.createElement(R9, null, "\xA0\u2192\xA0"), O1.default.createElement(x5, null, n.address.objectKey))), O1.default.createElement(LP, null, O1.default.createElement(vI, {
          objects: [n]
        })));
        let h = o.find(se);
        return h ? O1.default.createElement(Zu, {
          pin: e
        }, O1.default.createElement(CP, null, O1.default.createElement(xP, {
          title: "".concat(h.address.projectId)
        }, O1.default.createElement(x5, null, h.address.projectId, " "))), O1.default.createElement(LP, null, O1.default.createElement(dP, {
          projects: [h]
        }))) : O1.default.createElement(Zu, {
          pin: e,
          onMouseEnter: () => {
            gt.set(!0);
          },
          onMouseLeave: () => {
            gt.set(!1);
          }
        }, O1.default.createElement(fP, null));
      }, [e]);
    }, yP = () => {
      let t = mr();
      return O1.default.createElement(N9.Provider, {
        value: t
      }, O1.default.createElement(Q51, null));
    }, Ou = new Y6.Atom(!1), gt = new Y6.Atom(!1), US1 = (0, Y6.prism)(() => {
      let t = (0, Y6.val)(gt.prism),
        a = (0, Y6.val)(Ou.prism);
      return t || a;
    });
  });
var pn,
  fr,
  dt,
  SP,
  D4,
  X51,
  mn,
  r7 = x(() => {
    "use strict";

    pn = require("@theatre/dataverse");
    M1();
    f1();
    Tu();
    fr = I(G());
    Ao();
    dt = (t, a) => {
      let c = t.left / a.width,
        r = (t.left + t.width) / a.width,
        e = t.top / a.height,
        l = (t.height + t.top) / a.height;
      return {
        edges: {
          left: c <= .5 ? {
            from: "screenLeft",
            distance: c
          } : {
            from: "screenRight",
            distance: 1 - c
          },
          right: r <= .5 ? {
            from: "screenLeft",
            distance: r
          } : {
            from: "screenRight",
            distance: 1 - r
          },
          top: e <= .5 ? {
            from: "screenTop",
            distance: e
          } : {
            from: "screenBottom",
            distance: 1 - e
          },
          bottom: l <= .5 ? {
            from: "screenTop",
            distance: l
          } : {
            from: "screenBottom",
            distance: 1 - l
          }
        }
      };
    }, SP = fr.default.createContext(null), D4 = () => (0, fr.useContext)(SP), X51 = ({
      panelId: t,
      children: a,
      defaultPosition: c,
      minDims: r
    }) => {
      let e = _9(800, 200),
        [l, i] = mr(),
        {
          stuff: o
        } = v1(() => {
          var p;
          let {
              edges: n
            } = (p = (0, pn.val)(T().atomP.historic.panelPositions[t])) != null ? p : c,
            h = Math.floor(e.width * (n.left.from === "screenLeft" ? n.left.distance : 1 - n.left.distance)),
            v = Math.floor(e.width * (n.right.from === "screenLeft" ? n.right.distance : 1 - n.right.distance)),
            g = Math.floor(e.height * (n.top.from === "screenTop" ? n.top.distance : 1 - n.top.distance)),
            s = Math.floor(e.height * (n.bottom.from === "screenTop" ? n.bottom.distance : 1 - n.bottom.distance)),
            d = Math.max(v - h, r.width),
            z = Math.max(s - g, r.height);
          return {
            stuff: {
              dims: pn.prism.memo("dims", () => ({
                width: d,
                left: h,
                top: g,
                height: z
              }), [d, h, g, z]),
              panelId: t,
              minDims: r,
              boundsHighlighted: l,
              addBoundsHighlightLock: i
            }
          };
        }, [t, e, l, i]);
      return fr.default.createElement(SP.Provider, {
        value: o
      }, a);
    }, mn = X51;
  });
var e7,
  kP,
  Y51,
  J51,
  fn,
  Eu = x(() => {
    "use strict";

    P1();
    f1();
    M2();
    e7 = I(G());
    c1();
    r7();
    I0();
    H2();
    b4();
    Y51 = B.div(kP || (kP = V(["\n  cursor: move;\n"]))), J51 = t => {
      let a = D4(),
        c = (0, e7.useRef)(a);
      c.current = a;
      let [r, e] = z1(null),
        l = (0, e7.useMemo)(() => ({
          debugName: "PanelDragZone",
          lockCursorTo: "move",
          onDragStart() {
            let h = c.current,
              v,
              g = a.addBoundsHighlightLock();
            return {
              onDrag(s, d) {
                let z = D(S({}, h.dims), {
                    top: b1(h.dims.top + d, 0, window.innerHeight - S3),
                    left: b1(h.dims.left + s, -h.dims.width + S3, window.innerWidth - S3)
                  }),
                  u = dt(z, {
                    width: window.innerWidth,
                    height: window.innerHeight
                  });
                v == null || v.discard(), v = T().tempTransaction(({
                  stateEditors: f
                }) => {
                  f.studio.historic.panelPositions.setPanelPosition({
                    position: u,
                    panelId: h.panelId
                  });
                });
              },
              onDragEnd(s) {
                g(), s ? v == null || v.commit() : v == null || v.discard();
              }
            };
          }
        }), []),
        [i] = S1(e, l);
      s2(i, "dragging", "move");
      let [o, n] = (0, e7.useMemo)(() => {
        let h;
        return [function () {
          if (h) {
            let g = h;
            h = void 0, g();
          }
          h = a.addBoundsHighlightLock();
        }, function () {
          if (h) {
            let g = h;
            h = void 0, g();
          }
        }];
      }, []);
      return e7.default.createElement(Y51, D(S({}, t), {
        ref: r,
        onMouseEnter: o,
        onMouseLeave: n
      }));
    }, fn = J51;
  });
var st,
  RP,
  jP,
  bP,
  qP,
  FP,
  NP,
  IP,
  t61,
  PP,
  a61,
  GP,
  UP,
  TP,
  c61,
  ZP,
  r61,
  OP,
  Mn,
  EP,
  e61,
  DP,
  l61,
  WP,
  i61,
  _P,
  o61,
  n61,
  AP,
  h61,
  y5,
  KP = x(() => {
    "use strict";

    P1();
    f1();
    M2();
    R0();
    st = I(G());
    c1();
    r7();
    G1();
    H2();
    b4();
    jP = B.div(RP || (RP = V(["\n  position: absolute;\n  ", ";\n  &:after {\n    position: absolute;\n    inset: -5px;\n    display: block;\n    content: ' ';\n  }\n\n  opacity: 0;\n  background-color: #478698;\n\n  &.isHighlighted {\n    opacity: 0.7;\n  }\n\n  &.isDragging {\n    opacity: 1;\n    /* background-color: ", "; */\n  }\n\n  &:hover {\n    opacity: 1;\n  }\n"])), C1, R6(.2, "#478698")), qP = B(jP)(bP || (bP = V(["\n  /**\n  The horizintal/vertical resize handles have z-index:-1 and are offset 1px outside of the panel\n  to make sure they don't occlude any element that pops out of the panel (like the Playhead in SequenceEditorPanel).\n\n  This means that panels will always need an extra 1px margin for their resize handles to be visible, but that's not a problem\n  that we have to deal with right now (if it is at all a problem).\n  \n   */\n  z-index: -1;\n"]))), NP = B(qP)(FP || (FP = V(["\n  left: 0px;\n  right: 0px;\n  height: 1px;\n"]))), t61 = B(NP)(IP || (IP = V(["\n  top: -1px;\n"]))), a61 = B(NP)(PP || (PP = V(["\n  bottom: -1px;\n"]))), UP = B(qP)(GP || (GP = V(["\n  z-index: -1;\n  top: -1px;\n  bottom: -1px;\n  width: 1px;\n"]))), c61 = B(UP)(TP || (TP = V(["\n  left: -1px;\n"]))), r61 = B(UP)(ZP || (ZP = V(["\n  right: -1px;\n"]))), Mn = B(jP)(OP || (OP = V(["\n  // The angles have z-index: 10 to make sure they _do_ occlude other elements in the panel.\n  z-index: 10;\n  width: 8px;\n  height: 8px;\n"]))), e61 = B(Mn)(EP || (EP = V(["\n  top: 0;\n  left: 0;\n"]))), l61 = B(Mn)(DP || (DP = V(["\n  top: 0;\n  right: 0;\n"]))), i61 = B(Mn)(WP || (WP = V(["\n  bottom: 0;\n  left: 0;\n"]))), o61 = B(Mn)(_P || (_P = V(["\n  bottom: 0;\n  right: 0;\n"]))), n61 = {
      Top: t61,
      TopLeft: e61,
      TopRight: l61,
      Bottom: a61,
      BottomLeft: i61,
      BottomRight: o61,
      Left: c61,
      Right: r61
    }, AP = {
      Top: "ns-resize",
      Bottom: "ns-resize",
      Left: "ew-resize",
      Right: "ew-resize",
      TopLeft: "nw-resize",
      TopRight: "ne-resize",
      BottomLeft: "sw-resize",
      BottomRight: "se-resize"
    }, h61 = ({
      which: t
    }) => {
      let a = D4(),
        c = (0, st.useRef)(a);
      c.current = a;
      let [r, e] = z1(null),
        l = (0, st.useMemo)(() => ({
          debugName: "PanelResizeHandle",
          lockCursorTo: AP[t],
          onDragStart() {
            let h,
              v = c.current,
              g = a.addBoundsHighlightLock();
            return {
              onDrag(s, d) {
                let z = S({}, v.dims);
                if (t.startsWith("Bottom")) z.height = Math.max(z.height + d, v.minDims.height);else if (t.startsWith("Top")) {
                  let f = z.top + z.height,
                    p = b1(z.top + d, 0, Math.min(f - v.minDims.height, window.innerHeight - S3)),
                    m = f - p;
                  z.height = m, z.top = p;
                }
                if (t.endsWith("Left")) {
                  let f = z.left + z.width,
                    p = Math.min(z.left + s, Math.min(f - v.minDims.width, window.innerWidth - S3)),
                    m = f - p;
                  z.width = m, z.left = p;
                } else t.endsWith("Right") && (z.width = Math.max(z.width + s, Math.max(v.minDims.width, S3 - v.dims.left)));
                let u = dt(z, {
                  width: window.innerWidth,
                  height: window.innerHeight
                });
                h == null || h.discard(), h = T().tempTransaction(({
                  stateEditors: f
                }) => {
                  f.studio.historic.panelPositions.setPanelPosition({
                    position: u,
                    panelId: v.panelId
                  });
                });
              },
              onDragEnd(s) {
                g(), s ? h == null || h.commit() : h == null || h.discard();
              }
            };
          }
        }), [t]),
        [i] = S1(e, l),
        o = n61[t],
        n = t.length <= 6;
      return st.default.createElement(o, {
        ref: r,
        className: [i ? "isDragging" : "", a.boundsHighlighted && n ? "isHighlighted" : ""].join(" "),
        style: {
          cursor: AP[t]
        }
      });
    }, y5 = h61;
  });
var i4,
  v61,
  $P,
  QP = x(() => {
    "use strict";

    i4 = I(G());
    KP();
    v61 = t => i4.default.createElement(i4.default.Fragment, null, i4.default.createElement(y5, {
      which: "Bottom"
    }), i4.default.createElement(y5, {
      which: "Top"
    }), i4.default.createElement(y5, {
      which: "Left"
    }), i4.default.createElement(y5, {
      which: "Right"
    }), i4.default.createElement(y5, {
      which: "TopLeft"
    }), i4.default.createElement(y5, {
      which: "TopRight"
    }), i4.default.createElement(y5, {
      which: "BottomLeft"
    }), i4.default.createElement(y5, {
      which: "BottomRight"
    })), $P = v61;
  });
var xn,
  XP,
  g61,
  d61,
  Cn,
  Du = x(() => {
    "use strict";

    G1();
    xn = I(G());
    c1();
    r7();
    QP();
    g61 = B.div(XP || (XP = V(["\n  position: absolute;\n  user-select: none;\n  box-sizing: border-box;\n  ", ";\n  /* box-shadow: 1px 2px 10px -5px black; */\n\n  z-index: 1000;\n"])), C1), d61 = xn.default.forwardRef((t, a) => {
      let c = D4(),
        i = t,
        {
          style: r,
          children: e
        } = i,
        l = m4(i, ["style", "children"]);
      return xn.default.createElement(g61, D(S({
        ref: a
      }, l), {
        style: S({
          width: c.dims.width + "px",
          height: c.dims.height + "px",
          top: c.dims.top + "px",
          left: c.dims.left + "px"
        }, r != null ? r : {})
      }), xn.default.createElement($P, null), e);
    }), Cn = d61;
  });
var JP = L1((Ln, YP) => {
  (function (t, a) {
    typeof Ln == "object" && typeof YP != "undefined" ? a(Ln, G()) : typeof define == "function" && define.amd ? define(["exports", "react"], a) : (t = typeof globalThis != "undefined" ? globalThis : t || self, a(t.ReactErrorBoundary = {}, t.React));
  })(Ln, function (t, a) {
    "use strict";

    function c(g) {
      if (g && g.__esModule) return g;
      var s = Object.create(null);
      return g && Object.keys(g).forEach(function (d) {
        if (d !== "default") {
          var z = Object.getOwnPropertyDescriptor(g, d);
          Object.defineProperty(s, d, z.get ? z : {
            enumerable: !0,
            get: function () {
              return g[d];
            }
          });
        }
      }), s.default = g, Object.freeze(s);
    }
    var r = c(a);
    function e(g, s) {
      return e = Object.setPrototypeOf || function (z, u) {
        return z.__proto__ = u, z;
      }, e(g, s);
    }
    function l(g, s) {
      g.prototype = Object.create(s.prototype), g.prototype.constructor = g, e(g, s);
    }
    var i = function (s, d) {
        return s === void 0 && (s = []), d === void 0 && (d = []), s.length !== d.length || s.some(function (z, u) {
          return !Object.is(z, d[u]);
        });
      },
      o = {
        error: null
      },
      n = function (g) {
        l(s, g);
        function s() {
          for (var z, u = arguments.length, f = new Array(u), p = 0; p < u; p++) f[p] = arguments[p];
          return z = g.call.apply(g, [this].concat(f)) || this, z.state = o, z.updatedWithError = !1, z.resetErrorBoundary = function () {
            for (var m, M = arguments.length, w = new Array(M), H = 0; H < M; H++) w[H] = arguments[H];
            z.props.onReset == null || (m = z.props).onReset.apply(m, w), z.reset();
          }, z;
        }
        s.getDerivedStateFromError = function (u) {
          return {
            error: u
          };
        };
        var d = s.prototype;
        return d.reset = function () {
          this.updatedWithError = !1, this.setState(o);
        }, d.componentDidCatch = function (u, f) {
          var p, m;
          (p = (m = this.props).onError) == null || p.call(m, u, f);
        }, d.componentDidMount = function () {
          var u = this.state.error;
          u !== null && (this.updatedWithError = !0);
        }, d.componentDidUpdate = function (u) {
          var f = this.state.error,
            p = this.props.resetKeys;
          if (f !== null && !this.updatedWithError) {
            this.updatedWithError = !0;
            return;
          }
          if (f !== null && i(u.resetKeys, p)) {
            var m, M;
            (m = (M = this.props).onResetKeysChange) == null || m.call(M, u.resetKeys, p), this.reset();
          }
        }, d.render = function () {
          var u = this.state.error,
            f = this.props,
            p = f.fallbackRender,
            m = f.FallbackComponent,
            M = f.fallback;
          if (u !== null) {
            var w = {
              error: u,
              resetErrorBoundary: this.resetErrorBoundary
            };
            if (r.isValidElement(M)) return M;
            if (typeof p == "function") return p(w);
            if (m) return r.createElement(m, w);
            throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
          }
          return this.props.children;
        }, s;
      }(r.Component);
    function h(g, s) {
      var d = function (f) {
          return r.createElement(n, s, r.createElement(g, f));
        },
        z = g.displayName || g.name || "Unknown";
      return d.displayName = "withErrorBoundary(" + z + ")", d;
    }
    function v(g) {
      var s = r.useState(null),
        d = s[0],
        z = s[1];
      if (g != null) throw g;
      if (d != null) throw d;
      return z;
    }
    t.ErrorBoundary = n, t.useErrorHandler = v, t.withErrorBoundary = h, Object.defineProperty(t, "__esModule", {
      value: !0
    });
  });
});
var B2,
  iG,
  s61,
  z61,
  u61,
  tG,
  p61,
  aG,
  m61,
  cG,
  f61,
  rG,
  M61,
  eG,
  x61,
  lG,
  C61,
  L61,
  H61,
  oG,
  nG = x(() => {
    "use strict";

    B2 = I(G());
    c1();
    b4();
    r7();
    Eu();
    Du();
    iG = I(JP());
    K8();
    f1();
    b4();
    s61 = {
      edges: {
        left: {
          from: "screenLeft",
          distance: .3
        },
        right: {
          from: "screenRight",
          distance: .3
        },
        top: {
          from: "screenTop",
          distance: .3
        },
        bottom: {
          from: "screenBottom",
          distance: .3
        }
      }
    }, z61 = {
      width: 300,
      height: 300
    }, u61 = ({
      paneInstance: t
    }) => B2.default.createElement(mn, {
      panelId: "pane-".concat(t.instanceId),
      defaultPosition: s61,
      minDims: z61
    }, B2.default.createElement(H61, {
      paneInstance: t
    })), p61 = B(Cn)(tG || (tG = V(["\n  display: flex;\n  flex-direction: column;\n\n  box-shadow: 0px 5px 12px -4px rgb(0 0 0 / 22%);\n  z-index: ", ";\n"])), M5.pluginPanes), m61 = B.div(aG || (aG = V(["\n  width: 100%;\n"]))), f61 = B.div(cG || (cG = V(["\n  display: flex;\n  align-items: center;\n  opacity: 1;\n  position: absolute;\n  right: 4px;\n  top: 0;\n  bottom: 0;\n"]))), M61 = B.button(rG || (rG = V(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 2px;\n  font-size: 11px;\n  height: 10px;\n  width: 18px;\n  color: #adadadb3;\n  background: transparent;\n  border: none;\n  cursor: pointer;\n  &:hover {\n    color: white;\n  }\n"]))), x61 = B(YS)(eG || (eG = V(["\n  position: relative;\n  overflow: hidden;\n\n  &:after {\n    z-index: 10;\n    position: absolute;\n    inset: 0;\n    display: block;\n    content: ' ';\n    pointer-events: none;\n\n    #pointer-root:not(.normal) & {\n      pointer-events: auto;\n    }\n  }\n"]))), C61 = B.div(lG || (lG = V(["\n  padding: 12px;\n\n  & > pre {\n    border: 1px solid #ff62624f;\n    background-color: rgb(255 0 0 / 5%);\n    margin: 8px 0;\n    padding: 8px;\n    font-family: monospace;\n    overflow: scroll;\n    color: #ff9896;\n  }\n"]))), L61 = t => B2.default.createElement(C61, null, "An Error occurred rendering this pane. Open the console for more info.", B2.default.createElement("pre", null, JSON.stringify({
      message: t.error.message,
      stack: t.error.stack
    }, null, 2))), H61 = ({
      paneInstance: t
    }) => {
      let [a, c] = (0, B2.useState)(null),
        r = t.definition.mount;
      (0, B2.useLayoutEffect)(() => {
        if (!a) return;
        let l = r({
          paneId: t.instanceId,
          node: a
        });
        if (typeof l == "function") return l;
      }, [a, r, t.instanceId]);
      let e = (0, B2.useCallback)(() => {
        T().paneManager.destroyPane(t.instanceId);
      }, [t]);
      return B2.default.createElement(p61, {
        "data-testid": "theatre-pane-wrapper-".concat(t.instanceId)
      }, B2.default.createElement(fn, null, B2.default.createElement(oo, null, B2.default.createElement(f61, null, B2.default.createElement(M61, {
        onClick: e,
        title: "Close Pane"
      }, B2.default.createElement(AA, null))), B2.default.createElement(m61, null, t.instanceId))), B2.default.createElement(iG.ErrorBoundary, {
        FallbackComponent: L61
      }, B2.default.createElement(x61, {
        "data-testid": "theatre-pane-content-".concat(t.instanceId),
        ref: c
      })));
    }, oG = u61;
  });
var Hn,
  Vn,
  Wu = x(() => {
    "use strict";

    Hn = require("@theatre/dataverse"), Vn = (t, a) => {
      let c = Hn.prism.memo(t, () => new Hn.Atom(a), []);
      return c.set(a), c;
    };
  });
function wn(t, a) {
  (0, hG.useLayoutEffect)(() => {
    if (!t || a.type !== "propWithChildren" && a.type !== "primitiveProp" && a.type !== "sheetObject") return;
    let c = null,
      r = D(S({}, a.sheetObject.address), {
        pathToProp: a.type === "sheetObject" ? [] : a.pathToProp
      });
    function e() {
      c = tt.replaceLock(r, () => {});
    }
    function l() {
      c == null || c();
    }
    return t.addEventListener("mouseenter", e), t.addEventListener("mouseleave", l), () => {
      c == null || c(), t.removeEventListener("mouseenter", e), t.removeEventListener("mouseleave", l);
    };
  }, [t]);
}
var hG,
  _u = x(() => {
    "use strict";

    hG = I(G());
    Qo();
  });
var S5,
  vG,
  ju,
  gG,
  qu,
  dG,
  pG,
  sG,
  V61,
  zG,
  w61,
  uG,
  B61,
  y61,
  zt,
  Mr = x(() => {
    "use strict";

    G1();
    S5 = I(G());
    K8();
    c1();
    N6();
    _u();
    ju = B.li(vG || (vG = V(["\n  --depth: ", ";\n  margin: 0;\n  padding: 0;\n  list-style: none;\n"])), t => t.depth), qu = B.div(gG || (gG = V(["\n  border-bottom: 1px solid #7695b705;\n"]))), pG = B(qu)(dG || (dG = V(["\n  padding-left: calc(8px + var(--depth) * 20px);\n\n  display: flex;\n  align-items: stretch;\n  color: ", ";\n\n  box-sizing: border-box;\n\n  ", ";\n"])), Z6.panel.body.compoudThing.label.color, t => t.isSelected && "background: blue"), V61 = B.span(sG || (sG = V(["\n  ", ";\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  padding-right: 4px;\n  line-height: 26px;\n  flex-wrap: nowrap;\n\n  ", ":hover & {\n    color: #ccc;\n  }\n"])), T0, pG), w61 = B.span(zG || (zG = V(["\n  width: 12px;\n  padding: 8px;\n  font-size: 9px;\n  display: flex;\n  align-items: center;\n\n  transition: transform 0.05s ease-out, color 0.1s ease-out;\n  transform: rotateZ(", "deg);\n  color: #66686a;\n\n  &:hover {\n    transform: rotateZ(", "deg);\n    color: #c0c4c9;\n  }\n"])), t => t.isCollapsed ? 0 : 90, t => t.isCollapsed ? 15 : 75), B61 = B.ul(uG || (uG = V(["\n  margin: 0;\n  padding: 0;\n  list-style: none;\n"]))), y61 = ({
      leaf: t,
      label: a,
      children: c,
      isSelectable: r,
      isSelected: e,
      toggleSelect: l,
      toggleCollapsed: i,
      isCollapsed: o
    }) => {
      let n = Array.isArray(c) && c.length > 0,
        h = (0, S5.useRef)(null);
      return wn(h.current, t), t.shouldRender ? S5.default.createElement(ju, {
        depth: t.depth
      }, S5.default.createElement(pG, {
        ref: h,
        style: {
          height: t.nodeHeight + "px"
        },
        isSelectable: r === !0,
        isSelected: e === !0,
        onClick: l,
        isEven: t.n % 2 === 0
      }, S5.default.createElement(w61, {
        isCollapsed: o,
        onClick: i
      }, S5.default.createElement(Co, null)), S5.default.createElement(V61, null, a)), n && S5.default.createElement(B61, null, c)) : null;
    }, zt = y61;
  });
function mG(t, a) {
  return a.every((c, r) => c === t[r]);
}
function fG(t, a) {
  if (t.length !== a.length) return !1;
  for (let c = 0; c < t.length; c++) if (t[c] !== a[c]) return !1;
  return !0;
}
function J6(t) {
  var c;
  let a = [];
  for (;;) {
    let r = a.length,
      e = (c = t[0]) == null ? void 0 : c[r];
    if (e === void 0) return a;
    for (let l of t) if (e !== l[r]) return a;
    a.push(e);
  }
}
var h3,
  ut,
  o4 = x(() => {
    "use strict";

    tr();
    h3 = T4(t => JSON.stringify(t)), ut = t => JSON.parse(t);
  });
function Nu(t, a) {
  let c = (0, Bn.useRef)({
    combo: t,
    listener: a
  });
  c.current = {
    combo: t,
    listener: a
  }, (0, Bn.useEffect)(() => {
    function r(i) {
      i.key === c.current.combo && c.current.listener({
        down: !0,
        event: i
      });
    }
    function e(i) {
      i.key === c.current.combo && c.current.listener({
        down: !1,
        event: i
      });
    }
    function l(i) {
      c.current.listener({
        down: !1,
        event: void 0
      });
    }
    return document.addEventListener("keydown", r), document.addEventListener("keyup", e), window.addEventListener("blur", l), () => {
      document.removeEventListener("keydown", r), document.removeEventListener("keyup", e), window.removeEventListener("blur", l);
    };
  }, []);
}
var Bn,
  MG = x(() => {
    "use strict";

    Bn = I(G());
  });
function xr(t) {
  let [a, c] = (0, xG.useState)(!1);
  return Nu(t, ({
    down: r
  }) => {
    c(r);
  }), a;
}
var xG,
  Uu = x(() => {
    "use strict";

    xG = I(G());
    MG();
  });
function Ku(t) {
  let a = (0, yn.useMemo)(() => new CG.Atom(t), []);
  return (0, yn.useLayoutEffect)(() => {
    a.set(t);
  }, [t]), a;
}
var CG,
  yn,
  LG = x(() => {
    "use strict";

    CG = require("@theatre/dataverse"), yn = I(G());
  });
function kn(t, a, c) {
  let r = (0, Sn.pointer)({
      root: {},
      path: []
    }),
    e = a(r);
  i6(t, (0, Sn.getPointerParts)(e).path, c);
}
var Sn,
  HG = x(() => {
    "use strict";

    Sn = require("@theatre/dataverse");
    Xe();
  });
var $u,
  S61,
  r2,
  b3 = x(() => {
    "use strict";

    $u = "data-pos", S61 = {
      checkIfMouseEventSnapToPos(t, a) {
        let c = t.composedPath().find(r => r instanceof Element && r !== (a == null ? void 0 : a.ignore) && r.hasAttribute($u));
        if (c) {
          let r = parseFloat(c.getAttribute($u));
          if (isFinite(r)) return r;
        }
        return null;
      },
      includePositionSnapAttrs(t) {
        return {
          [$u]: t
        };
      }
    }, r2 = S61;
  });
function t8(t) {
  let a = t.type === "sheet" ? A61(t) : Qu(t);
  return {
    byPosition: k61(a),
    tracks: a
  };
}
function k61(t) {
  let a = new Map();
  for (let c of t) for (let r of c.data.keyframes) {
    let e = a.get(r.position);
    e || (e = [], a.set(r.position, e)), e.push({
      kf: r,
      track: c,
      itemKey: c2.forTrackKeyframe(c.sheetObject, c.id, r.id)
    });
  }
  return a;
}
function A61(t) {
  return t.children.flatMap(Qu);
}
function Qu(t) {
  return t.children.flatMap(a => a.type === "propWithChildren" ? Qu(a) : R61(a));
}
function R61(t) {
  let a = t.sheetObject,
    c = a.address.projectId,
    r = T().atomP.historic.coreByProject[c].sheetsById[a.address.sheetId].sequence.tracksByObject[a.address.objectKey],
    e = (0, An.val)(r.trackIdByPropPath[h3(t.pathToProp)]);
  if (!e) return [];
  let l = (0, An.val)(r.trackData[e]);
  return l ? [{
    id: e,
    data: l,
    sheetObject: a
  }] : [];
}
function VG(t, a) {
  return x3(t.children.flatMap(c => Rn(c, a)));
}
function Rn(t, a) {
  return x3(t.children.flatMap(c => c.type === "propWithChildren" ? Rn(c, a) : b61(c, a)));
}
function b61(t, a) {
  var i, o;
  let c = t.sheetObject,
    r = c.address.projectId,
    e = T().atomP.historic.coreByProject[r].sheetsById[c.address.sheetId].sequence.tracksByObject[c.address.objectKey],
    l = (0, An.val)(e.trackIdByPropPath[h3(t.pathToProp)]);
  return l ? (o = (i = a[c.address.objectKey]) == null ? void 0 : i[l]) != null ? o : [] : [];
}
var An,
  l7 = x(() => {
    "use strict";

    f1();
    An = require("@theatre/dataverse");
    O4();
    o4();
    H2();
  });
function P61(t, a) {
  let [c, r] = z1(null),
    e = C0("useCaptureSelection");
  return S1(a, (0, a8.useMemo)(() => ({
    debugName: "DopeSheetSelectionView/useCaptureSelection",
    dontBlockMouseDown: !0,
    lockCSSCursorTo: "cell",
    onDragStart(l) {
      if (!l.shiftKey || l.target instanceof HTMLInputElement) return !1;
      let i = a.getBoundingClientRect(),
        o = l.clientX - i.left - (0, F3.val)(t.scaledSpace.leftPadding),
        n = (0, F3.val)(t.scaledSpace.toUnitSpace)(o);
      return c.current = {
        h: [n, n],
        v: [l.clientY - i.top, l.clientY - i.top]
      }, (0, F3.val)(t.selectionAtom).set({
        current: void 0
      }), {
        onDrag(h, v, g) {
          let s = a.getBoundingClientRect(),
            d = g.clientX - s.left - (0, F3.val)(t.scaledSpace.leftPadding),
            z = (0, F3.val)(t.scaledSpace.toUnitSpace)(d);
          c.current = {
            h: [c.current.h[0], z],
            v: [c.current.v[0], g.clientY - s.top]
          };
          let u = Xu.boundsToSelection(e, (0, F3.val)(t), c.current);
          (0, F3.val)(t.selectionAtom).set({
            current: u
          });
        },
        onDragEnd(h) {
          c.current = null;
        }
      };
    }
  }), [t, a, c])), r;
}
var F3,
  a8,
  i7,
  wG,
  F61,
  I61,
  Xu,
  BG,
  G61,
  yG,
  T61,
  SG,
  kG = x(() => {
    "use strict";

    f1();
    M2();
    Uu();
    LG();
    HG();
    P1();
    M1();
    F3 = require("@theatre/dataverse"), a8 = I(G());
    c1();
    b3();
    l7();
    L5();
    i7 = 5, F61 = B.div(wG || (wG = V(["\n  cursor: ", ";\n"])), t => t.isShiftDown ? "cell" : "default"), I61 = ({
      layoutP: t,
      children: a,
      height: c
    }) => {
      let [r, e] = z1(null),
        l = xr("Shift"),
        i = P61(t, e),
        o = (0, a8.useRef)(i);
      return o.current = i, a8.default.createElement(F61, {
        style: {
          height: c + "px"
        },
        ref: r,
        isShiftDown: l,
        className: "selectionview"
      }, i && a8.default.createElement(T61, {
        state: i,
        layoutP: t
      }), a);
    };
    (l => {
      let t = (i, o, n, h, v) => {
          let g = t8(n);
          if (n.top + n.nodeHeight / 2 + i7 > h.v[0] && n.top + n.nodeHeight / 2 - i7 < h.v[1]) for (let [s, d] of g.byPosition) {
            let z = o.scaledSpace.toUnitSpace(i7);
            if (!(s + z <= h.h[0] || s - z >= h.h[1])) for (let f of d) kn(v, p => p[f.track.sheetObject.address.objectKey].byTrackId[f.track.id].byKeyframeId[f.kf.id], !0);
          }
          c(i, o, n, h, v);
        },
        a = {
          sheet(i, o, n, h, v) {
            t(i, o, n, h, v);
          },
          propWithChildren(i, o, n, h, v) {
            t(i, o, n, h, v);
          },
          sheetObject(i, o, n, h, v) {
            t(i, o, n, h, v);
          },
          primitiveProp(i, o, n, h, v) {
            let {
                sheetObject: g,
                trackId: s
              } = n,
              d = (0, F3.val)(T().atomP.historic.coreByProject[g.address.projectId].sheetsById[g.address.sheetId].sequence.tracksByObject[g.address.objectKey].trackData[s]);
            if (!(h.v[0] > n.top + n.heightIncludingChildren / 2 + i7 || n.top + n.heightIncludingChildren / 2 - i7 > h.v[1])) {
              for (let z of d.keyframes) if (!(z.position + o.scaledSpace.toUnitSpace(i7) <= h.h[0])) {
                if (z.position - o.scaledSpace.toUnitSpace(i7) >= h.h[1]) break;
                kn(v, u => u[g.address.objectKey].byTrackId[s].byKeyframeId[z.id], !0);
              }
            }
          }
        },
        c = (i, o, n, h, v) => {
          if ("children" in n) for (let g of n.children) r(i, o, g, h, v);
        };
      function r(i, o, n, h, v) {
        if (!n.shouldRender || h.v[0] > n.top + n.heightIncludingChildren || n.top > h.v[1]) return;
        let g = a[n.type];
        g ? g(i, o, n, h, v) : c(i, o, n, h, v);
      }
      function e(i, o, n) {
        let h = {};
        n = yG(n);
        let v = o.tree;
        r(i.utilFor.internal(), o, v, n, h);
        let g = o.tree.sheet;
        return {
          type: "DopeSheetSelection",
          byObjectKey: h,
          getDragHandlers(s) {
            return {
              debugName: "DopeSheetSelectionView/boundsToSelection",
              onDragStart() {
                let d,
                  z = o.scaledSpace.toUnitSpace;
                return {
                  onDrag(u, f, p) {
                    d && (d.discard(), d = void 0);
                    let m = r2.checkIfMouseEventSnapToPos(p, {
                        ignore: s.domNode
                      }),
                      M = m != null ? m - s.positionAtStartOfDrag : z(u);
                    d = T().tempTransaction(({
                      stateEditors: w
                    }) => {
                      let H = w.coreByProject.historic.sheetsById.sequence.transformKeyframes;
                      for (let y of Object.keys(h)) {
                        let {
                          byTrackId: k
                        } = h[y];
                        for (let F of Object.keys(k)) {
                          let {
                            byKeyframeId: U
                          } = k[F];
                          H({
                            trackId: F,
                            keyframeIds: Object.keys(U),
                            translate: M,
                            scale: 1,
                            origin: 0,
                            snappingFunction: g.getSequence().closestGridPosition,
                            objectKey: y,
                            projectId: s.projectId,
                            sheetId: s.sheetId
                          });
                        }
                      }
                    });
                  },
                  onDragEnd(u) {
                    u ? d == null || d.commit() : d == null || d.discard();
                  }
                };
              }
            };
          },
          delete() {
            T().transaction(({
              stateEditors: s
            }) => {
              let d = s.coreByProject.historic.sheetsById.sequence.deleteKeyframes;
              for (let z of Object.keys(h)) {
                let {
                  byTrackId: u
                } = h[z];
                for (let f of Object.keys(u)) {
                  let {
                    byKeyframeId: p
                  } = u[f];
                  d(D(S({}, g.address), {
                    objectKey: z,
                    trackId: f,
                    keyframeIds: Object.keys(p)
                  }));
                }
              }
            });
          }
        };
      }
      l.boundsToSelection = e;
    })(Xu || (Xu = {}));
    G61 = B.div(BG || (BG = V(["\n  position: absolute;\n  background: rgba(255, 255, 255, 0.1);\n  border: 1px dashed rgba(255, 255, 255, 0.4);\n  box-sizing: border-box;\n"]))), yG = t => ({
      h: [...t.h].sort((a, c) => a - c),
      v: [...t.v].sort((a, c) => a - c)
    }), T61 = ({
      state: t,
      layoutP: a
    }) => {
      let c = Ku(t);
      return v1(() => {
        let r = (0, F3.val)(c.pointer),
          e = yG(r),
          l = (0, F3.val)(a.scaledSpace.fromUnitSpace),
          i = (0, F3.val)(a.scaledSpace.leftPadding),
          o = e.h.map(l).map(s => s + i),
          n = e.v[0],
          h = e.v[1] - e.v[0],
          v = o[0],
          g = o[1] - o[0];
        return a8.default.createElement(G61, {
          style: {
            top: n + "px",
            height: h + "px",
            left: v + "px",
            width: g + "px"
          }
        });
      }, [a, c]);
    }, SG = I61;
  });
var n4,
  AG,
  Z61,
  RG,
  bG,
  O61,
  FG,
  Yu = x(() => {
    "use strict";

    W8();
    n4 = I(G());
    c1();
    W4();
    Z61 = B.div(AG || (AG = V(["\n  position: absolute;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n  z-index: ", ";\n\n  &::-webkit-scrollbar {\n    display: none;\n  }\n\n  scrollbar-width: none;\n"])), () => K2.scrollableArea), RG = (0, n4.createContext)(h0), bG = () => (0, n4.useContext)(RG), O61 = t => {
      let a = (0, n4.useRef)(null),
        c = (0, n4.useCallback)(r => {
          a.current.scrollBy(0, r.deltaY);
        }, []);
      return n4.default.createElement(RG.Provider, {
        value: c
      }, n4.default.createElement(Z61, {
        ref: a
      }, t.children));
    }, FG = O61;
  });
var PG,
  IG = x(() => {
    PG = 'data:image/svg+xml,<svg width="34" height="34" viewBox="0 0 34 34" fill="none" xmlns="http://www.w3.org/2000/svg">%0A  <path d="M1 7V1H7" stroke="%2374FFDE" stroke-width="0.25" />%0A  <path d="M7 33H1L1 27" stroke="%2374FFDE" stroke-width="0.25" />%0A  <path d="M33 27V33H27" stroke="%2374FFDE" stroke-width="0.25" />%0A  <path d="M27 1L33 1V7" stroke="%2374FFDE" stroke-width="0.25" />%0A</svg>';
  });
var H0,
  Cr = x(() => {
    "use strict";

    H0 = (t, a = t) => "\n  left: ".concat(t * -.5, "px;\n  top: ").concat(a * -.5, "px;\n  width: ").concat(t, "px;\n  height: ").concat(a, "px;\n");
  });
var bn,
  D61,
  GG,
  TG = x(() => {
    "use strict";

    bn = require("@theatre/dataverse"), D61 = (0, bn.prism)(() => {
      let [t, a] = bn.prism.state("pos", null);
      return bn.prism.effect("setupListeners", () => {
        let c = r => {
          a(r);
        };
        return document.addEventListener("mousemove", c), () => {
          document.removeEventListener("mousemove", c);
        };
      }, []), t;
    }), GG = D61;
  });
var h4,
  C2,
  Fn,
  W61,
  _61,
  ZG,
  OG,
  g0,
  O2,
  Ju,
  j61,
  EG,
  E2 = x(() => {
    "use strict";

    h4 = require("@theatre/dataverse");
    TG();
    H2();
    C2 = I(G()), Fn = (0, C2.createContext)(null), W61 = 0, _61 = ({
      children: t,
      layoutP: a
    }) => {
      let c = (0, C2.useMemo)(() => new h4.Atom([]), []),
        r = (0, C2.useMemo)(() => (0, h4.prism)(() => {
          let i = h4.prism.memo("p", () => j61(a), [a]).getValue(),
            o = (0, h4.val)(c.pointer);
          return o.length > 0 ? M3(o).position : i;
        }), [a]),
        e = (0, C2.useCallback)(() => {
          let i = W61++;
          return c.reduce(h => [...h, {
            id: i,
            position: [-1, 0]
          }]), {
            set: h => {
              c.reduce(v => {
                let g = v.findIndex(d => d.id === i);
                if (g === -1) return console.warn("Lock is already freed. This is a bug."), v;
                let s = [...v];
                return s.splice(g, 1, {
                  id: i,
                  position: [h, h === -1 ? 0 : 1]
                }), s;
              });
            },
            unlock: () => {
              c.reduce(h => h.filter(v => v.id !== i));
            }
          };
        }, []),
        l = {
          currentD: r,
          getLock: e
        };
      return C2.default.createElement(Fn.Provider, {
        value: l
      }, t);
    }, ZG = () => (0, C2.useContext)(Fn).currentD, OG = () => {
      let {
          getLock: t
        } = (0, C2.useContext)(Fn),
        a = (0, C2.useRef)();
      return (0, C2.useLayoutEffect)(() => () => {
        var c;
        (c = a.current) == null || c.unlock();
      }, []), (0, C2.useMemo)(() => {
        let c;
        return (r, e) => {
          var l, i;
          (c == null ? void 0 : c.shouldLock) !== r && (r ? a.current = t() : (l = a.current) == null || l.unlock()), (c == null ? void 0 : c.pos) !== e && r && ((i = a.current) == null || i.set(e)), c = {
            shouldLock: r,
            pos: e
          };
        };
      }, [t]);
    }, g0 = (t, a) => {
      let {
          getLock: c
        } = (0, C2.useContext)(Fn),
        r = (0, C2.useRef)();
      (0, C2.useLayoutEffect)(() => {
        if (t) return r.current = c(), () => {
          r.current.unlock();
        };
      }, [t, c]), (0, C2.useLayoutEffect)(() => {
        t && r.current.set(a);
      }, [a, t]);
    }, O2 = t => ({
      [Ju]: t === "hide" ? t : t.toFixed(3)
    }), Ju = "data-theatre-lock-framestamp-to", j61 = t => (0, h4.prism)(() => {
      let a = (0, h4.val)(t.rightDims),
        c = (0, h4.val)(t.clippedSpace.toUnitSpace),
        r = (0, h4.val)(GG);
      if (!r) return [-1, 0];
      for (let v of r.composedPath()) {
        if (!(v instanceof HTMLElement || v instanceof SVGElement)) break;
        if (v.hasAttribute(Ju)) {
          let g = v.getAttribute(Ju);
          if (typeof g != "string") continue;
          if (g === "hide") return [-1, 0];
          let s = parseFloat(g);
          if (isFinite(s) && s >= 0) return [s, 2];
        }
      }
      let {
          clientX: e,
          clientY: l
        } = r,
        {
          screenX: i,
          screenY: o,
          width: n,
          height: h
        } = a;
      if (Qe(e, i, i + n) && Qe(l, o + 16, o + h)) {
        let v = e - i;
        return [c(v), 3];
      } else return [-1, 0];
    }), EG = _61;
  });
var q61,
  In,
  DG,
  WG,
  _G,
  v4,
  tp = x(() => {
    "use strict";

    G1();
    I0();
    c1();
    IG();
    Cr();
    b3();
    E2();
    q61 = 12, In = 34, DG = "beingDragged", v4 = {
      BEING_DRAGGED_CLASS: DG,
      CSS: f2(WG || (WG = V(["\n    position: absolute;\n    ", ";\n    ", ";\n\n    &.", " {\n      pointer-events: none !important;\n    }\n  "])), H0(q61), C1, DG),
      CSS_WHEN_SOMETHING_DRAGGING: f2(_G || (_G = V(["\n    pointer-events: auto;\n    cursor: var(", ");\n\n    // \u2E22\u2E24\u2E23\u2E25 thing\n    // This box extends the hitzone so the user does not\n    // accidentally leave the hitzone\n    &:hover:after {\n      position: absolute;\n      top: calc(50% - ", "px);\n      left: calc(50% - ", "px);\n      width: ", "px;\n      height: ", "px;\n      display: block;\n      content: ' ';\n      background: url(", ") no-repeat 100% 100%;\n      // This icon might also fit: GiConvergenceTarget\n    }\n  "])), F0, In / 2, In / 2, In, In, PG),
      reactProps(t) {
        return D(S(S({}, O2(t.position)), r2.includePositionSnapAttrs(t.position)), {
          className: t.isDragging ? v4.BEING_DRAGGED_CLASS : ""
        });
      }
    };
  });
function mt() {
  Pn.set({
    mode: "snapToAll"
  });
}
function I3() {
  Pn.set({
    mode: "snapToNone"
  });
}
function Tn(t) {
  Pn.set({
    mode: "snapToSome",
    positions: t
  });
}
function Zn(t, a) {
  return Object.fromEntries(Object.entries(t).map(([c, r]) => [c, Object.fromEntries(Object.entries(r.trackData).map(([e, l]) => [e, l.keyframes.filter(i => a(i, {
    trackId: e,
    trackData: l,
    objectKey: c
  })).map(i => i.position)]))]));
}
var NG,
  UG,
  ap,
  jG,
  N61,
  qG,
  U61,
  K61,
  pt,
  Pn,
  Gn,
  c8 = x(() => {
    "use strict";

    NG = require("@theatre/dataverse"), UG = require("@theatre/dataverse"), ap = I(G());
    c1();
    tp();
    N61 = B.div(jG || (jG = V(["\n  z-index: 1;\n  cursor: ew-resize;\n\n  ", "\n\n  #pointer-root.draggingPositionInSequenceEditor & {\n    ", "\n  }\n"])), v4.CSS, v4.CSS_WHEN_SOMETHING_DRAGGING), U61 = B.div(qG || (qG = V(["\n  position: absolute;\n"]))), K61 = t => ap.default.createElement(U61, {
      style: {
        top: "".concat(t.leaf.nodeHeight / 2, "px"),
        left: "calc(".concat((0, UG.val)(t.layoutP.scaledSpace.leftPadding), "px + calc(var(--unitSpaceToScaledSpaceMultiplier) * ").concat(t.position, "px))")
      }
    }, ap.default.createElement(N61, S({}, v4.reactProps({
      isDragging: !1,
      position: t.position
    })))), pt = K61, Pn = new NG.Atom({
      mode: "snapToNone"
    }), Gn = Pn.prism;
  });
function X61(t, a) {
  let c = (0, k5.useMemo)(() => ({
      debugName: "HorizontallyScrollableArea",
      onDragStart(e) {
        if (e.target instanceof HTMLInputElement || e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || e.composedPath().some(g => g instanceof HTMLElement && g.draggable === !0)) return !1;
        let l = e.clientX - a.getBoundingClientRect().left,
          i = b1((0, i2.val)(t.clippedSpace.toUnitSpace)(l), 0, 1 / 0),
          o = (0, i2.val)(t.seeker.setIsSeeking),
          n = (0, i2.val)(t.sheet).getSequence();
        n.position = i;
        let h = i,
          v = (0, i2.val)(t.scaledSpace.toUnitSpace);
        return o(!0), mt(), {
          onDrag(g, s, d) {
            let z = v(g),
              f = b1(h + z, 0, n.length),
              p = r2.checkIfMouseEventSnapToPos(d, {});
            p != null && (f = p), n.position = f;
          },
          onDragEnd() {
            o(!1), I3();
          }
        };
      }
    }), [t, a]),
    [r] = S1(a, c);
  s2(r, "draggingPositionInSequenceEditor", "ew-resize");
}
function Y61(t, a) {
  let c = bG();
  (0, k5.useLayoutEffect)(() => {
    if (!a) return;
    let r = l => {
        if (l.ctrlKey) {
          l.preventDefault(), l.stopPropagation();
          let i = l.clientX - a.getBoundingClientRect().left,
            o = (0, i2.val)(t.clippedSpace.toUnitSpace)(i),
            n = (0, i2.val)(t.clippedSpace.range),
            v = 1 + cp(l.deltaY, [-50, 50]) * .03,
            g = l5(n, z => (z - o) * v + o),
            s = (0, i2.val)(t.sheet).getSequence().length,
            d = s + s * .25;
          (0, i2.val)(t.clippedSpace.setRange)(J61(g, [0, d]));
          return;
        } else if (l.shiftKey) {
          l.preventDefault(), l.stopPropagation();
          let i = (0, i2.val)(t.sheet).getSequence().length,
            o = (0, i2.val)(t.clippedSpace.range),
            h = (o.end - o.start) / i,
            g = cp(l.deltaY || l.deltaX, [-50, 50]) * .05 * h,
            s = l5(o, d => d + g);
          (0, i2.val)(t.clippedSpace.setRange)(s);
          return;
        } else {
          c(l), l.preventDefault(), l.stopPropagation();
          let o = (0, i2.val)(t.scaledSpace.toUnitSpace)(l.deltaX * 1),
            n = (0, i2.val)(t.clippedSpace.range),
            h = l5(n, g => g + o);
          (0, i2.val)(t.clippedSpace.setRange)(h);
          return;
        }
      },
      e = {
        capture: !0,
        passive: !1
      };
    return a.addEventListener("wheel", r, e), () => {
      a.removeEventListener("wheel", r, e);
    };
  }, [a, t]), S1(a, (0, k5.useMemo)(() => ({
    onDragStart(r) {
      let e = (0, i2.val)(t.clippedSpace.range),
        l = (0, i2.val)(t.clippedSpace.setRange),
        i = (0, i2.val)(t.scaledSpace.toUnitSpace);
      return r.preventDefault(), r.stopPropagation(), {
        onDrag(o, n, h, v, g) {
          c({
            deltaY: -g
          });
          let s = -i(o),
            d = l5(e, z => z + s);
          l(d);
        }
      };
    },
    debugName: "HorizontallyScrollableArea Middle Button Drag",
    buttons: [1],
    lockCSSCursorTo: "grabbing"
  }), [t]));
}
function cp(t, [a, c]) {
  return Math.max(Math.min(t, c), a);
}
function J61(t, a) {
  return l5(t, c => cp(c, a));
}
function t81(t, a) {
  (0, k5.useLayoutEffect)(() => {
    if (!a) return;
    let c = (0, i2.prism)(() => {
        let i = (0, i2.val)(t.clippedSpace.range);
        return (0, i2.val)(t.scaledSpace.fromUnitSpace)(i.start);
      }),
      r = () => {
        let i = c.getValue();
        a.scrollLeft = i;
      },
      e = c.onStale(r);
    r();
    let l = setTimeout(r, 100);
    return () => {
      clearTimeout(l), e();
    };
  }, [t, a]);
}
var i2,
  k5,
  KG,
  $61,
  Q61,
  On,
  rp = x(() => {
    "use strict";

    M2();
    P1();
    M1();
    i2 = require("@theatre/dataverse");
    H2();
    k5 = I(G());
    c1();
    Yu();
    G1();
    I0();
    b3();
    c8();
    $61 = B.div(KG || (KG = V(["\n  position: absolute;\n\n  right: 0;\n  overflow-x: scroll;\n  overflow-y: hidden;\n  ", ";\n\n  // hide the scrollbar on Gecko\n  scrollbar-width: none;\n\n  // hide the scrollbar on Webkit/Blink\n  &::-webkit-scrollbar {\n    display: none;\n  }\n"])), C1), Q61 = k5.default.memo(({
      layoutP: t,
      children: a,
      height: c
    }) => {
      let {
          width: r,
          unitSpaceToScaledSpaceMultiplier: e
        } = v1(() => ({
          width: (0, i2.val)(t.rightDims.width),
          unitSpaceToScaledSpaceMultiplier: (0, i2.val)(t.scaledSpace.fromUnitSpace)(1)
        }), [t]),
        [l, i] = z1(null);
      return Y61(t, i), X61(t, i), t81(t, i), k5.default.createElement($61, {
        ref: l,
        style: {
          width: r + "px",
          height: c + "px",
          "--unitSpaceToScaledSpaceMultiplier": e
        }
      }, a);
    }), On = Q61;
  });
var En,
  $G,
  a81,
  QG,
  c81,
  XG,
  r81,
  e81,
  A5,
  Lr = x(() => {
    "use strict";

    En = I(G());
    c1();
    a81 = B.li($G || ($G = V(["\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  box-sizing: border-box;\n  position: relative;\n"]))), c81 = B.div(QG || (QG = V(["\n  box-sizing: border-box;\n  width: 100%;\n  position: relative;\n\n  &:before {\n    position: absolute;\n    display: block;\n    content: ' ';\n    left: -40px;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    box-sizing: border-box;\n    border-bottom: 1px solid #252b3869;\n    background: ", ";\n  }\n"])), t => t.isEven ? "transparent" : "#6b8fb505"), r81 = B.ul(XG || (XG = V(["\n  margin: 0;\n  padding: 0;\n  list-style: none;\n"]))), e81 = ({
      leaf: t,
      children: a,
      node: c,
      isCollapsed: r
    }) => {
      let e = Array.isArray(a) && a.length > 0;
      return t.shouldRender ? En.default.createElement(a81, null, En.default.createElement(c81, {
        style: {
          height: t.nodeHeight + "px"
        },
        isEven: t.n % 2 === 0
      }, c), e && En.default.createElement(r81, null, a)) : null;
    }, A5 = e81;
  });
var tT = L1((YG, JG) => {
  (function () {
    var t = this,
      a = {};
    typeof YG != "undefined" ? JG.exports = a : t.fuzzy = a, a.simpleFilter = function (c, r) {
      return r.filter(function (e) {
        return a.test(c, e);
      });
    }, a.test = function (c, r) {
      return a.match(c, r) !== null;
    }, a.match = function (c, r, e) {
      e = e || {};
      var l = 0,
        i = [],
        o = r.length,
        n = 0,
        h = 0,
        v = e.pre || "",
        g = e.post || "",
        s = e.caseSensitive && r || r.toLowerCase(),
        d;
      c = e.caseSensitive && c || c.toLowerCase();
      for (var z = 0; z < o; z++) d = r[z], s[z] === c[l] ? (d = v + d + g, l += 1, h += 1 + h) : h = 0, n += h, i[i.length] = d;
      return l === c.length ? (n = s === c ? 1 / 0 : n, {
        rendered: i.join(""),
        score: n
      }) : null;
    }, a.filter = function (c, r, e) {
      return !r || r.length === 0 ? [] : typeof c != "string" ? r : (e = e || {}, r.reduce(function (l, i, o, n) {
        var h = i;
        e.extract && (h = e.extract(i));
        var v = a.match(c, h, e);
        return v != null && (l[l.length] = {
          string: v.rendered,
          score: v.score,
          index: o,
          original: i
        }), l;
      }, []).sort(function (l, i) {
        var o = i.score - l.score;
        return o || l.index - i.index;
      }));
    };
  })();
});
function aT(t, a) {
  let [c, r] = (0, ft.useState)(!1),
    e = (0, ft.useRef)(a);
  return c || (e.current = a), (0, ft.useMemo)(() => t(r), e.current);
}
var ft,
  cT = x(() => {
    "use strict";

    ft = I(G());
  });
var Dn,
  _4,
  Hr = x(() => {
    "use strict";

    Dn = "rgba(26, 28, 30, 0.97);", _4 = "#272B2F";
  });
function lT(t, a, c, r) {
  let e = aT(l => ({
    debugName: "CurveSegmentEditor/useKeyframeDrag",
    lockCSSCursorTo: "move",
    onDragStart() {
      return l(!0), {
        onDrag(i, o) {
          t && c.onCurveChange(r(i, o));
        },
        onDragEnd(i) {
          l(!1), c.onCancelCurveChange();
        }
      };
    }
  }), [t, c.onCurveChange, c.onCancelCurveChange]);
  S1(a, e);
}
var I1,
  lp,
  Wn,
  wr,
  l81,
  _n,
  i81,
  ep,
  o81,
  n81,
  h81,
  Vr,
  v81,
  Mt,
  g81,
  d81,
  rT,
  iT,
  ip,
  oT,
  eT,
  s81,
  nT,
  hT = x(() => {
    "use strict";

    I1 = I(G());
    M2();
    P1();
    ua();
    c1();
    G1();
    cT();
    Hr();
    lp = .12, Wn = 1 + lp * 2, wr = .01, l81 = 8, _n = (1 - wr) / (l81 - 1), i81 = "#3EAAA4", ep = "#3EAAA4", o81 = "#3EAAA4", n81 = "#3EAAA4", h81 = "#3EAAA4", Vr = "#3EAAA4", v81 = "#3EAAA4", Mt = "#B3B3B3", g81 = "#3eaaa4", d81 = "#67dfd8", rT = ["goldenrod", "cornflowerblue", "dodgerblue", "lawngreen"], ip = B.circle(iT || (iT = V(["\n  stroke-width: 0.1px;\n  vector-effect: non-scaling-stroke;\n  r: 0.04px;\n  pointer-events: none;\n  transition: r 0.15s;\n  fill: ", ";\n"])), g81), eT = B.circle(oT || (oT = V(["\n  stroke-width: 0.1px;\n  vector-effect: non-scaling-stroke;\n  r: 0.09px;\n  cursor: move;\n  ", ";\n  &:hover {\n    opacity: 0.4;\n  }\n  &:hover + ", " {\n    fill: ", ";\n  }\n"])), C1, ip, d81), s81 = t => {
      let {
          curveConnection: {
            left: a,
            right: c
          },
          backgroundConnections: r
        } = t,
        e = Math.min(0, 1 - c.handles[1], 1 - a.handles[3]),
        l = Math.max(1, 1 - c.handles[1], 1 - a.handles[3]),
        i = Math.max(1, l - e),
        o = m => (m - e) / i,
        [n, h] = z1(null),
        v = Wn / ((h == null ? void 0 : h.clientWidth) || 1),
        g = Wn / ((h == null ? void 0 : h.clientHeight) || 1),
        [s, d] = z1(null);
      lT(h, d, t, (m, M) => {
        let w = b1(a.handles[2] + m * v, 0, 1),
          H = a.handles[3] - M * g;
        return [w, H, c.handles[0], c.handles[1]];
      });
      let [z, u] = z1(null);
      lT(h, u, t, (m, M) => {
        let w = b1(c.handles[0] + m * v, 0, 1),
          H = c.handles[1] - M * g;
        return [a.handles[2], a.handles[3], w, H];
      });
      let f = m => "M0 ".concat(o(1), " C").concat(m.left.handles[2], " ").concat(o(1 - m.left.handles[3]), " ").concat(m.right.handles[0], " ").concat(o(1 - m.right.handles[1]), " 1 ").concat(o(0)),
        p = "0,100 100,100 100,0";
      return I1.default.createElement("svg", {
        height: "100%",
        width: "100%",
        ref: n,
        viewBox: "".concat(-lp, " ").concat(-lp, " ").concat(Wn, " ").concat(Wn),
        xmlns: "http://www.w3.org/2000/svg",
        preserveAspectRatio: "none",
        fill: "none"
      }, I1.default.createElement("linearGradient", {
        id: "myGradient",
        gradientTransform: "rotate(90)"
      }, I1.default.createElement("stop", {
        offset: o(-1),
        stopColor: v81
      }), I1.default.createElement("stop", {
        offset: o(0),
        stopColor: Vr
      }), I1.default.createElement("stop", {
        offset: o(.3),
        stopColor: h81
      }), I1.default.createElement("stop", {
        offset: o(.5),
        stopColor: n81
      }), I1.default.createElement("stop", {
        offset: o(.7),
        stopColor: o81
      }), I1.default.createElement("stop", {
        offset: o(1),
        stopColor: ep
      }), I1.default.createElement("stop", {
        offset: o(2),
        stopColor: i81
      })), I1.default.createElement("pattern", {
        id: "dot-background-pattern-1",
        width: _n,
        height: _n / i,
        y: -e / i
      }, I1.default.createElement("rect", {
        width: wr,
        height: wr,
        fill: Mt,
        opacity: .3
      })), I1.default.createElement("rect", {
        x: 0,
        y: 0,
        width: "1",
        height: 1,
        fill: "url(#dot-background-pattern-1)"
      }), I1.default.createElement("pattern", {
        id: "dot-background-pattern-2",
        width: _n,
        height: _n
      }, I1.default.createElement("rect", {
        width: wr,
        height: wr,
        fill: Mt
      })), I1.default.createElement("rect", {
        x: 0,
        y: o(0),
        width: "1",
        height: o(1) - o(0),
        fill: "url(#dot-background-pattern-2)"
      }), !a.type || a.type === "bezier" ? I1.default.createElement(I1.default.Fragment, null, I1.default.createElement("line", {
        x1: 0,
        y1: o(1),
        x2: a.handles[2],
        y2: o(1 - a.handles[3]),
        stroke: Mt,
        strokeWidth: "0.01"
      }), I1.default.createElement("line", {
        x1: 1,
        y1: o(0),
        x2: c.handles[0],
        y2: o(1 - c.handles[1]),
        stroke: Mt,
        strokeWidth: "0.01"
      }), I1.default.createElement("path", {
        d: f(t.curveConnection),
        stroke: "none",
        fill: "url('#myGradient')",
        opacity: "0.1"
      }), r.map((m, M) => I1.default.createElement("path", {
        key: m.objectKey + "/" + m.left.id,
        d: f(m),
        stroke: rT[M % rT.length],
        opacity: .6,
        strokeWidth: "0.01"
      })), I1.default.createElement("path", {
        d: f(t.curveConnection),
        stroke: "url('#myGradient')",
        strokeWidth: "0.02"
      }), I1.default.createElement("circle", {
        cx: 0,
        cy: o(1),
        r: "0.025",
        stroke: ep,
        strokeWidth: "0.02",
        fill: _4
      }), I1.default.createElement("circle", {
        cx: 1,
        cy: o(0),
        r: "0.025",
        stroke: Vr,
        strokeWidth: "0.02",
        fill: _4
      }), I1.default.createElement(eT, {
        ref: s,
        cx: a.handles[2],
        cy: o(1 - a.handles[3]),
        fill: ep,
        opacity: .2
      }), I1.default.createElement(ip, {
        cx: a.handles[2],
        cy: o(1 - a.handles[3])
      }), I1.default.createElement(eT, {
        ref: z,
        cx: c.handles[0],
        cy: o(1 - c.handles[1]),
        fill: Vr,
        opacity: .2
      }), I1.default.createElement(ip, {
        cx: c.handles[0],
        cy: o(1 - c.handles[1])
      })) : I1.default.createElement(I1.default.Fragment, null, I1.default.createElement("line", {
        x1: 0,
        y1: o(1),
        x2: 1,
        y2: o(1),
        stroke: Mt,
        strokeWidth: "0.01"
      }), I1.default.createElement("line", {
        x1: 1,
        y1: o(1),
        x2: 1,
        y2: 0,
        stroke: Mt,
        strokeWidth: "0.01"
      }), I1.default.createElement("circle", {
        cx: 0,
        cy: 1,
        r: "0.025",
        stroke: Vr,
        strokeWidth: "0.02",
        fill: _4
      }), I1.default.createElement("circle", {
        cx: 1,
        cy: 0,
        r: "0.025",
        stroke: Vr,
        strokeWidth: "0.02",
        fill: _4
      })));
    }, nT = s81;
  });
function Br(t) {
  return t.map(a => a.toFixed(3)).join(", ");
}
function xt(t) {
  if (!t || (t == null ? void 0 : t.length) > z81) return null;
  let a = t.split(",");
  if (a.length !== 4) return null;
  let c = a.map(r => Number(r.trim()));
  return !c.every(r => isFinite(r)) || c[0] < 0 || c[0] > 1 || c[2] < 0 || c[2] > 1 ? null : c;
}
function vT(t, a, c = {
  threshold: .02
}) {
  if (!t || !a) return !1;
  let r = 0;
  for (let e = 0; e < 4; e++) r += Math.abs(t[e] - a[e]);
  return r < c.threshold;
}
var z81,
  jn,
  op = x(() => {
    "use strict";

    z81 = 128;
    jn = [{
      label: "Quad Out",
      value: "0.250, 0.460, 0.450, 0.940"
    }, {
      label: "Quad In Out",
      value: "0.455, 0.030, 0.515, 0.955"
    }, {
      label: "Quad In",
      value: "0.550, 0.085, 0.680, 0.530"
    }, {
      label: "Cubic Out",
      value: "0.215, 0.610, 0.355, 1.000"
    }, {
      label: "Cubic In Out",
      value: "0.645, 0.045, 0.355, 1.000"
    }, {
      label: "Cubic In",
      value: "0.550, 0.055, 0.675, 0.190"
    }, {
      label: "Quart Out",
      value: "0.165, 0.840, 0.440, 1.000"
    }, {
      label: "Quart In Out",
      value: "0.770, 0.000, 0.175, 1.000"
    }, {
      label: "Quart In",
      value: "0.895, 0.030, 0.685, 0.220"
    }, {
      label: "Quint Out",
      value: "0.230, 1.000, 0.320, 1.000"
    }, {
      label: "Quint In Out",
      value: "0.860, 0.000, 0.070, 1.000"
    }, {
      label: "Quint In",
      value: "0.755, 0.050, 0.855, 0.060"
    }, {
      label: "Sine Out",
      value: "0.390, 0.575, 0.565, 1.000"
    }, {
      label: "Sine In Out",
      value: "0.445, 0.050, 0.550, 0.950"
    }, {
      label: "Sine In",
      value: "0.470, 0.000, 0.745, 0.715"
    }, {
      label: "Expo Out",
      value: "0.190, 1.000, 0.220, 1.000"
    }, {
      label: "Expo In Out",
      value: "1.000, 0.000, 0.000, 1.000"
    }, {
      label: "Expo In",
      value: "0.780, 0.000, 0.810, 0.00"
    }, {
      label: "Circ Out",
      value: "0.075, 0.820, 0.165, 1.000"
    }, {
      label: "Circ In Out",
      value: "0.785, 0.135, 0.150, 0.860"
    }, {
      label: "Circ In",
      value: "0.600, 0.040, 0.980, 0.335"
    }, {
      label: "Back Out",
      value: "0.175, 0.885, 0.320, 1.275"
    }, {
      label: "Back In Out",
      value: "0.680, -0.550, 0.265, 1.550"
    }, {
      label: "Back In",
      value: "0.600, -0.280, 0.735, 0.045"
    }, {
      label: "linear",
      value: "0.5, 0.5, 0.5, 0.5"
    }, {
      label: "In Out",
      value: "0.42,0,0.58,1"
    }, {
      label: "Hold",
      value: "0, 0, Infinity, Infinity"
    }];
  });
var d0,
  np,
  Ct,
  gT,
  u81,
  p81,
  qn,
  dT,
  sT,
  m81,
  zT,
  uT = x(() => {
    "use strict";

    d0 = I(G()), np = .75, Ct = .1, gT = 1 + np * 2, u81 = "#F5F5F5", p81 = "#888888", qn = "#4f4f4f", dT = "rgba(255, 255, 255, 0.1)", sT = t => 1 - t, m81 = t => {
      let {
          easing: a,
          isSelected: c
        } = t,
        r = c ? u81 : p81,
        e = "".concat(-np, " ").concat(-np, " ").concat(gT, " ").concat(gT);
      if (a) {
        let l = [a[0], sT(a[1])],
          i = [a[2], sT(a[3])];
        return d0.default.createElement("svg", {
          height: "100%",
          width: "100%",
          viewBox: e,
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, d0.default.createElement("line", {
          x1: "0",
          y1: "1",
          x2: l[0],
          y2: l[1],
          stroke: qn,
          strokeWidth: "0.1"
        }), d0.default.createElement("line", {
          x1: "1",
          y1: "0",
          x2: i[0],
          y2: i[1],
          stroke: qn,
          strokeWidth: "0.1"
        }), d0.default.createElement("circle", {
          cx: l[0],
          cy: l[1],
          r: .1,
          fill: dT
        }), d0.default.createElement("circle", {
          cx: i[0],
          cy: i[1],
          r: .1,
          fill: dT
        }), d0.default.createElement("circle", {
          cx: l[0],
          cy: l[1],
          r: Ct,
          fill: qn
        }), d0.default.createElement("circle", {
          cx: i[0],
          cy: i[1],
          r: Ct,
          fill: qn
        }), d0.default.createElement("path", {
          d: "M0 1 C".concat(l[0], " ").concat(l[1], " ").concat(i[0], " \n        ").concat(i[1], " 1 0"),
          stroke: r,
          strokeWidth: "0.08"
        }), d0.default.createElement("circle", {
          cx: 0,
          cy: 1,
          r: Ct,
          fill: r
        }), d0.default.createElement("circle", {
          cx: 1,
          cy: 0,
          r: Ct,
          fill: r
        }));
      }
      return d0.default.createElement("svg", {
        height: "100%",
        width: "100%",
        viewBox: e,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, d0.default.createElement("line", {
        x1: "0",
        y1: "1",
        x2: 1,
        y2: 1,
        stroke: r,
        strokeWidth: "0.08"
      }), d0.default.createElement("line", {
        x1: "1",
        y1: "0",
        x2: 1,
        y2: 1,
        stroke: r,
        strokeWidth: "0.08"
      }), d0.default.createElement("circle", {
        cx: 0,
        cy: 1,
        r: Ct,
        fill: r
      }), d0.default.createElement("circle", {
        cx: 1,
        cy: 0,
        r: Ct,
        fill: r
      }));
    }, zT = m81;
  });
var yr,
  pT,
  mT,
  f81,
  fT,
  M81,
  x81,
  MT,
  xT = x(() => {
    "use strict";

    nt();
    yr = I(G());
    c1();
    op();
    uT();
    Wc();
    Hr();
    e4();
    f81 = B.div(mT || (mT = V(["\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  overflow: hidden;\n  aspect-ratio: 1;\n\n  transition: background-color 0.15s;\n  background-color: ", ";\n  border-radius: 2px;\n  cursor: pointer;\n  outline: none;\n\n  ", "\n\n  &:hover {\n    background-color: #31353a;\n  }\n\n  &:focus {\n    background-color: #383d42;\n  }\n"])), _4, ({
      isSelected: t
    }) => t && f2(pT || (pT = V(["\n      background-color: #383d42;\n    "])))), M81 = B(T2)(fT || (fT = V(["\n  padding: 0.5em;\n  color: white;\n  max-width: 240px;\n  pointer-events: none !important;\n  --popover-bg: black;\n  --popover-outer-stroke: transparent;\n  --popover-inner-stroke: transparent;\n  box-shadow: none;\n"]))), x81 = yr.default.forwardRef((t, a) => {
      let [c, r] = R3({
        enabled: !0,
        verticalPlacement: t.tooltipPlacement,
        verticalGap: 0
      }, () => yr.default.createElement(M81, {
        showPopoverEdgeTriangle: !1
      }, t.easing.label));
      return yr.default.createElement(f81, S({
        ref: D6([r, a])
      }, t), c, yr.default.createElement(zT, {
        easing: xt(t.easing.value),
        isSelected: t.isSelected
      }));
    }), MT = x81;
  });
function LT(t) {
  var i;
  let [a, c] = (0, CT.useState)(null),
    r = o => {
      if (a === null) {
        t.items.length > 0 && c(0);
        return;
      }
      let n = a + o * t.uiColumns,
        h = n < 0,
        v = n > t.items.length - 1;
      if (h || v) {
        if (t.canVerticleExit && t.canVerticleExit(h ? "top" : "bottom")) {
          c(null);
          return;
        }
        return;
      }
      c(n);
    },
    e = o => {
      a === null ? c(VT(o, t.items.length)) : a + o < 0 ? c(null) : c(Math.min(a + o, t.items.length - 1));
    };
  return {
    focusFirstItem() {
      c(0);
    },
    onParentEltKeyDown: o => {
      if (o.key === "ArrowRight") e(1);else if (o.key === "ArrowLeft") e(-1);else if (o.key === "ArrowUp") r(-1);else if (o.key === "ArrowDown") r(1);else return 0;
      return 1;
    },
    gridItems: t.items.map((o, n) => t.renderItem({
      isSelected: n === a,
      item: o,
      select(h) {
        c(n), t.onSelectItem(o) === 1 && (h == null || h.preventDefault(), h == null || h.stopPropagation());
      }
    })),
    currentSelection: (i = t.items[a != null ? a : -1]) != null ? i : null
  };
}
var CT,
  HT = x(() => {
    "use strict";

    CT = I(G());
    Sr();
  });
function wT(t, a, c) {
  var e;
  (e = t.current) == null || e.discard(), t.current = null;
  let r = xt(c);
  r === null ? t.current = k81(a) : t.current = S81(a, r);
}
function BT(t) {
  var a;
  (a = t.current) == null || a.discard(), t.current = null;
}
function S81(t, a) {
  return T().tempTransaction(({
    stateEditors: c
  }) => {
    let {
      setHandlesForKeyframe: r,
      setKeyframeType: e
    } = c.coreByProject.historic.sheetsById.sequence;
    for (let {
      projectId: l,
      sheetId: i,
      objectKey: o,
      trackId: n,
      left: h,
      right: v
    } of t) r({
      projectId: l,
      sheetId: i,
      objectKey: o,
      trackId: n,
      keyframeId: h.id,
      start: [a[0], a[1]]
    }), r({
      projectId: l,
      sheetId: i,
      objectKey: o,
      trackId: n,
      keyframeId: v.id,
      end: [a[2], a[3]]
    }), e({
      projectId: l,
      sheetId: i,
      objectKey: o,
      trackId: n,
      keyframeId: h.id,
      keyframeType: "bezier"
    });
  });
}
function k81(t) {
  return T().tempTransaction(({
    stateEditors: a
  }) => {
    let {
      setKeyframeType: c
    } = a.coreByProject.historic.sheetsById.sequence;
    for (let {
      projectId: r,
      sheetId: e,
      objectKey: l,
      trackId: i,
      left: o
    } of t) c({
      projectId: r,
      sheetId: e,
      objectKey: l,
      trackId: i,
      keyframeId: o.id,
      keyframeType: "hold"
    });
  });
}
function VT(t, a) {
  return (t % a + a) % a;
}
function A81(t, a) {
  return () => setTimeout(t, a);
}
function R81({
  left: t,
  right: a
}) {
  return ({
    left: c,
    right: r
  }) => t.handles[2] !== c.handles[2] || t.handles[3] !== c.handles[3] || a.handles[0] !== r.handles[0] || a.handles[1] !== r.handles[1];
}
var kr,
  D1,
  bT,
  FT,
  IT,
  C81,
  yT,
  L81,
  ST,
  H81,
  kT,
  V81,
  AT,
  w81,
  RT,
  B81,
  y81,
  Nn,
  WR1,
  Un,
  b81,
  Sr = x(() => {
    "use strict";

    kr = require("@theatre/dataverse"), D1 = I(G());
    c1();
    bT = I(tT());
    f1();
    hT();
    xT();
    op();
    Hr();
    P1();
    HT();
    FT = 3, IT = 53, C81 = 25, L81 = B.div(yT || (yT = V(["\n  background: ", ";\n  display: grid;\n  grid-template-areas:\n    'search  tween'\n    'presets tween';\n  grid-template-rows: 32px 1fr;\n  grid-template-columns: ", "px 120px;\n  gap: 1px;\n  height: 120px;\n"])), Dn, FT * IT), H81 = B.div(ST || (ST = V(["\n  overflow: auto;\n  grid-area: presets;\n\n  display: grid;\n  grid-template-columns: repeat(", ", 1fr);\n  grid-auto-rows: min-content;\n  gap: 1px;\n\n  overflow-y: scroll;\n  scrollbar-width: none; /* Firefox */\n  -ms-overflow-style: none; /* Internet Explorer 10+ */\n  &::-webkit-scrollbar {\n    /* WebKit */\n    width: 0;\n    height: 0;\n  }\n"])), FT), V81 = B.input.attrs({
      type: "text"
    })(kT || (kT = V(["\n  background-color: ", ";\n  border: none;\n  border-radius: 2px;\n  color: rgba(255, 255, 255, 0.8);\n  padding: 6px;\n  font-size: 12px;\n  outline: none;\n  cursor: text;\n  text-align: left;\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n\n  grid-area: search;\n\n  &:hover {\n    background-color: #212121;\n  }\n\n  &:focus {\n    background-color: rgba(16, 16, 16, 0.26);\n    outline: 1px solid rgba(0, 0, 0, 0.35);\n  }\n"])), _4), w81 = B.div(AT || (AT = V(["\n  grid-area: tween;\n  background: ", ";\n"])), _4), B81 = B.div(RT || (RT = V(["\n  grid-column: 1 / 4;\n  padding: 6px;\n  color: #888888;\n"]))), y81 = t => {
      let a = (0, D1.useMemo)(() => [t.curveConnection, ...t.additionalConnections], [t.curveConnection, ...t.additionalConnections]),
        c = (0, D1.useRef)(null);
      (0, D1.useEffect)(() => {
        let C = b81(a);
        return () => {
          var E;
          C(), (E = c.current) == null || E.commit();
        };
      }, [c]);
      let r = [t.curveConnection.left.handles[2], t.curveConnection.left.handles[3], t.curveConnection.right.handles[0], t.curveConnection.right.handles[1]],
        e = (0, D1.useRef)(null);
      (0, D1.useLayoutEffect)(() => {
        var C, E;
        (C = e.current) == null || C.select(), (E = e.current) == null || E.focus();
      }, [e.current]);
      let [l, i] = (0, D1.useState)(Br(r)),
        o = C => {
          if (C === void 0) return;
          v(1), i(C.target.value), xt(C.target.value) && s(C.target.value);
        },
        n = C => {
          var E, a1;
          v(1), (C.key === "ArrowDown" || C.key === "ArrowUp") && C.preventDefault(), C.key === "ArrowDown" ? (P.focusFirstItem(), (a1 = (E = y.current[p[0].label]) == null ? void 0 : E.current) == null || a1.focus()) : C.key === "Escape" ? (BT(c), t.onRequestClose("key Escape")) : C.key === "Enter" && t.onRequestClose("key Enter");
        },
        [h, v] = (0, D1.useState)(0);
      (0, D1.useEffect)(() => {
        h === 2 ? i(Br(r)) : h === 3 && l !== "" && i("");
      }, a);
      let [g, s] = (0, D1.useState)(Br(r)),
        [d, z] = (0, D1.useState)(null);
      (0, D1.useEffect)(() => {
        var C;
        h !== 0 && h !== 3 && wT(c, a, (C = d != null ? d : g) != null ? C : "");
      }, [d, g, h]), a.some(R81(t.curveConnection)) && h === 0 && v(3);
      let u = C => {
          var a1, j;
          v(2);
          let E = Br(C);
          i(E), s(E), (a1 = e.current) == null || a1.select(), (j = e.current) == null || j.focus();
        },
        f = () => {},
        p = (0, D1.useMemo)(() => /^[A-Za-z]/.test(l) ? bT.default.filter(l, jn, {
          extract: E => E.label
        }).map(E => E.original) : jn, [l]);
      (0, D1.useEffect)(() => {
        h === 1 && p[0] && s(p[0].value);
      }, [p]);
      let m = C => {
          C.key === "Escape" ? (BT(c), t.onRequestClose("key Escape"), C.stopPropagation()) : C.key === "Enter" && (t.onRequestClose("key Enter"), C.stopPropagation());
        },
        M = C => {
          h === 0 && v(2), z(C.value);
        },
        w = () => z(null),
        H = C => (wT(c, a, C.value), t.onRequestClose("selected easing option"), 1),
        y = (0, D1.useRef)(jn.reduce((C, E) => (C[E.label] = {
          current: null
        }, C), {})),
        [k, F] = z1(null),
        [U, A] = (0, D1.useState)(0);
      (0, D1.useEffect)(() => {
        let C = () => {
          var E;
          A((E = F == null ? void 0 : F.scrollTop) != null ? E : 0);
        };
        return F == null || F.addEventListener("scroll", C), () => F == null ? void 0 : F.removeEventListener("scroll", C);
      }, [F]);
      let P = LT({
        items: p,
        uiColumns: 3,
        onSelectItem: H,
        canVerticleExit(C) {
          var E, a1;
          return C === "top" ? ((E = e.current) == null || E.select(), (a1 = e.current) == null || a1.focus(), 1) : 0;
        },
        renderItem: ({
          item: C,
          select: E
        }) => {
          var a1, j;
          return D1.default.createElement(MT, {
            key: C.label,
            easing: C,
            tabIndex: 0,
            onKeyDown: m,
            ref: y.current[C.label],
            onMouseOver: () => M(C),
            onMouseOut: w,
            onClick: E,
            tooltipPlacement: ((j = (a1 = y.current[C.label].current) == null ? void 0 : a1.offsetTop) != null ? j : 0) - (U != null ? U : 0) < IT + C81 ? "bottom" : "top",
            isSelected: vT(r, xt(C.value))
          });
        }
      });
      return (0, D1.useLayoutEffect)(() => {
        var C, E;
        if (P.currentSelection !== null && document.activeElement !== e.current) {
          let a1 = (E = (C = y.current) == null ? void 0 : C[P.currentSelection.label]) == null ? void 0 : E.current;
          a1 == null || a1.focus(), s(P.currentSelection.value), /^[A-Za-z]/.test(l) || i(P.currentSelection.value);
        }
      }, [P.currentSelection]), D1.default.createElement(L81, null, D1.default.createElement(V81, {
        value: l,
        placeholder: h === 3 ? "Multiple easings selected" : "Search presets...",
        onPaste: A81(o),
        onChange: o,
        ref: e,
        onKeyDown: n
      }), D1.default.createElement(H81, {
        ref: k,
        onKeyDown: C => P.onParentEltKeyDown(C)
      }, P.gridItems, P.gridItems.length === 0 ? D1.default.createElement(B81, null, "No results found") : void 0), D1.default.createElement(w81, {
        onClick: () => {
          var C;
          return (C = e.current) == null ? void 0 : C.focus();
        }
      }, D1.default.createElement(nT, {
        curveConnection: t.curveConnection,
        backgroundConnections: t.additionalConnections,
        onCurveChange: u,
        onCancelCurveChange: f
      })));
    }, Nn = y81;
    ({
      isCurveEditorOpenD: WR1,
      isConnectionEditingInCurvePopover: Un,
      getLock: b81
    } = (() => {
      let t = new kr.Atom([]);
      return {
        getLock(a) {
          return t.set(a), function () {
            t.set([]);
          };
        },
        isCurveEditorOpenD: (0, kr.prism)(() => t.prism.getValue().length > 0),
        isConnectionEditingInCurvePopover(a) {
          return kr.prism.ensurePrism(), t.prism.getValue().some(({
            left: c,
            right: r
          }) => a.left.id === c.id && a.right.id === r.id);
        }
      };
    })());
  });
function F81(t, a) {
  for (let {
    keyframeId: c
  } of G81(a)) if (t.left.id === c) return !0;
  return !1;
}
function Kn(t, a, c) {
  return (0, Ar.prism)(() => {
    if (c === void 0) return [];
    let r = [];
    for (let {
      objectKey: e,
      trackId: l
    } of PT(c)) {
      let i = (0, Ar.val)(T().atomP.historic.coreByProject[t].sheetsById[a].sequence.tracksByObject[e].trackData[l]);
      i && (r = r.concat(P81(i.keyframes).filter(o => F81(o, c)).map(({
        left: o,
        right: n
      }) => ({
        left: o,
        right: n,
        trackId: l,
        objectKey: e,
        sheetId: a,
        projectId: t
      }))));
    }
    return r;
  });
}
function r8(t, a, c) {
  var i;
  if (c === void 0) return [];
  let r = [];
  for (let {
    objectKey: o,
    trackId: n,
    keyframeIds: h
  } of PT(c)) r = r.concat((i = Rr({
    projectId: t,
    sheetId: a,
    objectKey: o,
    trackId: n,
    keyframeIds: h
  })) != null ? i : []);
  let e = J6(r.map(o => o.pathToProp));
  return r.map(({
    keyframe: o,
    pathToProp: n
  }) => ({
    keyframe: o,
    pathToProp: n.slice(e.length)
  }));
}
function Rr({
  projectId: t,
  sheetId: a,
  objectKey: c,
  trackId: r,
  keyframeIds: e
}) {
  let l = (0, Ar.val)(T().atomP.historic.coreByProject[t].sheetsById[a].sequence.tracksByObject[c]),
    i = l == null ? void 0 : l.trackData[r];
  if (!i) return null;
  let n = I81((l == null ? void 0 : l.trackIdByPropPath) || {})[r];
  if (!n) return null;
  let h = [c, ...ut(n)];
  return e.map(v => ({
    keyframe: i.keyframes.find(g => g.id === v),
    pathToProp: h
  })).filter(({
    keyframe: v
  }) => v !== void 0);
}
function I81(t) {
  let a = {};
  for (let [c, r] of Object.entries(t)) a[r] = c;
  return a;
}
function P81(t) {
  return t.map((a, c) => ({
    left: a,
    right: t[c + 1]
  })).slice(0, -1);
}
function G81(t) {
  var c, r, e;
  let a = [];
  for (let [l, i] of Object.entries((c = t == null ? void 0 : t.byObjectKey) != null ? c : {})) for (let [o, n] of Object.entries((r = i == null ? void 0 : i.byTrackId) != null ? r : {})) for (let h of Object.keys((e = n == null ? void 0 : n.byKeyframeId) != null ? e : {})) a.push({
    objectKey: l,
    trackId: o,
    keyframeId: h
  });
  return a;
}
function PT(t) {
  var c, r, e;
  let a = [];
  for (let [l, i] of Object.entries((c = t == null ? void 0 : t.byObjectKey) != null ? c : {})) for (let [o, n] of Object.entries((r = i == null ? void 0 : i.byTrackId) != null ? r : {})) a.push({
    objectKey: l,
    trackId: o,
    keyframeIds: Object.keys((e = n == null ? void 0 : n.byKeyframeId) != null ? e : {})
  });
  return a;
}
var Ar,
  o7 = x(() => {
    "use strict";

    Ar = require("@theatre/dataverse");
    f1();
    o4();
  });
function TT(t, a) {
  return (0, GT.useMemo)(() => T81(t, a), []);
}
function T81(t, a) {
  let c = null,
    r = i => T().tempTransaction(o => t(o, i));
  function e() {
    c == null || c.discard(), c = null;
  }
  let l = {
    createAsset: a.sheet.project.assetStorage.createAsset,
    getAssetUrl: i => i.id ? a.sheet.project.assetStorage.getAssetUrl(i.id) : void 0
  };
  return S({
    temporarilySetValue(i) {
      e(), c = r(i);
    },
    discardTemporaryValue: e,
    permanentlySetValue(i) {
      e(), r(i).commit();
    }
  }, l);
}
var GT,
  ZT = x(() => {
    "use strict";

    f1();
    GT = I(G());
  });
function $n(t) {
  var a;
  if (t.type === "sheetObject") return $2.default.createElement($2.default.Fragment, null, $2.default.createElement(hp, {
    style: {
      paddingLeft: "".concat(t.indent * vp, "px")
    }
  }, t.sheetObject.address.objectKey), t.children.map((c, r) => $2.default.createElement($n, D(S({
    key: r
  }, c), {
    autoFocusInput: t.autoFocusInput && r === 0,
    indent: t.indent + 1
  }))));
  if (t.type === "propWithChildren") {
    let c = (a = t.propConfig.label) != null ? a : M3(t.pathToProp);
    return $2.default.createElement($2.default.Fragment, null, $2.default.createElement(hp, {
      style: {
        paddingLeft: "".concat(t.indent * vp, "px")
      }
    }, c), t.children.map((r, e) => $2.default.createElement($n, D(S({
      key: e
    }, r), {
      autoFocusInput: t.autoFocusInput && e === 0,
      indent: t.indent + 1
    }))));
  } else return $2.default.createElement(E81, D(S({}, t), {
    autoFocusInput: t.autoFocusInput,
    indent: t.indent
  }));
}
function E81(t) {
  var r;
  let a = (r = t.propConfig.label) != null ? r : M3(t.pathToProp),
    c = D81(t);
  if (t.propConfig.type === "enum") return $2.default.createElement($2.default.Fragment, null);
  {
    let e = Go[t.propConfig.type];
    return $2.default.createElement(Z81, null, $2.default.createElement(hp, null, $2.default.createElement("span", {
      style: {
        paddingLeft: "".concat(t.indent * vp, "px")
      }
    }, a)), $2.default.createElement(O81, null, $2.default.createElement(e, {
      editingTools: c,
      propConfig: t.propConfig,
      value: X8(t.keyframe.value, t.propConfig),
      autoFocus: t.autoFocusInput
    })));
  }
}
function D81(t) {
  let a = t.sheetObject;
  return TT(({
    stateEditors: c
  }, r) => {
    let e = D(S({}, t.keyframe), {
      value: r
    });
    c.coreByProject.historic.sheetsById.sequence.replaceKeyframes(D(S({}, a.address), {
      trackId: t.trackId,
      keyframes: [e],
      snappingFunction: a.sheet.getSequence().closestGridPosition
    }));
  }, a);
}
var $2,
  OT,
  Z81,
  ET,
  hp,
  vp,
  DT,
  O81,
  WT = x(() => {
    "use strict";

    $2 = I(G());
    c1();
    au();
    ma();
    ZT();
    H5();
    Z81 = B.div(OT || (OT = V(["\n  display: flex;\n  align-items: stretch;\n  min-width: 200px;\n\n  select {\n    min-width: 100px;\n  }\n"]))), hp = B.div(ET || (ET = V(["\n  font-style: normal;\n  font-weight: 400;\n  font-size: 11px;\n  line-height: 13px;\n  letter-spacing: 0.01em;\n  padding: 6px 6px 6px 0;\n\n  width: 40%;\n\n  color: #919191;\n\n  overflow: hidden;\n"]))), vp = 10;
    O81 = B.div(DT || (DT = V(["\n  display: flex;\n  align-items: center;\n  width: 60%;\n"])));
  });
function e8(t) {
  return x2({
    debugName: "useKeyframeInlineEditorPopover"
  }, () => Qn.default.createElement(T2, {
    showPopoverEdgeTriangle: !0
  }, Qn.default.createElement("div", {
    style: {
      margin: "1px 2px 1px 10px"
    }
  }, Array.isArray(t) ? t.map((a, c) => Qn.default.createElement($n, D(S({
    key: c
  }, a), {
    autoFocusInput: c === 0,
    indent: 0
  }))) : void 0)));
}
var Qn,
  br = x(() => {
    "use strict";

    Qn = I(G());
    c4();
    e4();
    WT();
  });
function q81(t, a, c) {
  return Z1(t, {
    displayName: "Keyframe",
    menuItems: () => {
      let r = r8(c.leaf.sheetObject.address.projectId, c.leaf.sheetObject.address.sheetId, c.selection);
      return [{
        label: r.length > 0 ? "Copy (selection)" : "Copy",
        callback: () => {
          r.length > 0 ? T().transaction(e => {
            e.stateEditors.studio.ahistoric.setClipboardKeyframes(r);
          }) : T().transaction(e => {
            e.stateEditors.studio.ahistoric.setClipboardKeyframes([{
              keyframe: c.keyframe,
              pathToProp: c.leaf.pathToProp
            }]);
          });
        }
      }, {
        label: c.selection !== void 0 ? "Delete (selection)" : "Delete",
        callback: () => {
          c.selection ? c.selection.delete() : T().transaction(({
            stateEditors: e
          }) => {
            e.coreByProject.historic.sheetsById.sequence.deleteKeyframes(D(S({}, c.leaf.sheetObject.address), {
              keyframeIds: [c.keyframe.id],
              trackId: c.leaf.trackId
            }));
          });
        }
      }];
    },
    onOpen() {
      a._debug("Show keyframe", c);
    }
  });
}
function N81(t, a, c) {
  let r = (0, j4.useRef)(a);
  r.current = a;
  let {
      onClickFromDrag: e
    } = c,
    l = (0, j4.useMemo)(() => ({
      debugName: "KeyframeDot/useDragKeyframe",
      onDragStart(o) {
        let n = r.current,
          h = (0, Yn.val)(T().atomP.historic.coreByProject[n.leaf.sheetObject.address.projectId].sheetsById[n.leaf.sheetObject.address.sheetId].sequence.tracksByObject),
          v = Zn(h, function (u, {
            trackId: f,
            objectKey: p
          }) {
            var m, M;
            return u.id !== n.keyframe.id && !(n.selection && (M = (m = n.selection.byObjectKey[p]) == null ? void 0 : m.byTrackId[f]) != null && M.byKeyframeId[u.id]);
          });
        if (Tn(v), n.selection) {
          let {
              selection: z,
              leaf: u
            } = n,
            {
              sheetObject: f
            } = u,
            p = z.getDragHandlers(D(S({}, f.address), {
              domNode: t,
              positionAtStartOfDrag: n.track.data.keyframes[n.index].position
            })).onDragStart(o);
          return p && D(S({}, p), {
            onClick: e,
            onDragEnd: (...m) => {
              var M;
              (M = p.onDragEnd) == null || M.call(p, ...m), I3();
            }
          });
        }
        let g = n,
          s = (0, Yn.val)(g.layoutP.scaledSpace.toUnitSpace),
          d;
        return {
          onDrag(z, u, f) {
            var M;
            let p = g.track.data.keyframes[g.index],
              m = Math.max((M = r2.checkIfMouseEventSnapToPos(f, {
                ignore: t
              })) != null ? M : p.position + s(z), 0);
            d == null || d.discard(), d = void 0, d = T().tempTransaction(({
              stateEditors: w
            }) => {
              w.coreByProject.historic.sheetsById.sequence.replaceKeyframes(D(S({}, g.leaf.sheetObject.address), {
                trackId: g.leaf.trackId,
                keyframes: [D(S({}, p), {
                  position: m
                })],
                snappingFunction: (0, Yn.val)(g.layoutP.sheet).getSequence().closestGridPosition
              }));
            });
          },
          onDragEnd(z) {
            z ? d == null || d.commit() : d == null || d.discard(), I3();
          },
          onClick(z) {
            e(z);
          }
        };
      }
    }), [e]),
    [i] = S1(t, l);
  return g0(i, a.keyframe.position), s2(i, "draggingPositionInSequenceEditor", "ew-resize"), [i];
}
var j4,
  Yn,
  Fr,
  _T,
  Xn,
  UT,
  jT,
  gp,
  qT,
  W81,
  NT,
  _81,
  j81,
  KT,
  sp = x(() => {
    "use strict";

    j4 = I(G());
    c1();
    f1();
    v0();
    M2();
    P1();
    Yn = require("@theatre/dataverse");
    E2();
    I0();
    b3();
    Cr();
    L5();
    o7();
    G1();
    c8();
    br();
    K6();
    Fr = 6, _T = Fr + 2, Xn = {
      normalColor: "#40AAA4",
      selectedColor: "#F2C95C",
      inlineEditorOpenColor: "#FCF3DC",
      selectedAndInlineEditorOpenColor: "#CBEBEA"
    }, UT = ({
      isSelected: t,
      isInlineEditorPopoverOpen: a
    }) => t && a ? Xn.inlineEditorOpenColor : t ? Xn.selectedColor : a ? Xn.selectedAndInlineEditorOpenColor : Xn.normalColor, gp = B.div(jT || (jT = V(["\n  position: absolute;\n  ", "\n\n  background: ", ";\n  transform: rotateZ(45deg);\n\n  ", ";\n\n  z-index: 1;\n  pointer-events: none;\n"])), H0(Fr), t => UT(t), t => t.flag === 2 ? "outline: 2px solid white;" : ""), W81 = B.div(qT || (qT = V(["\n  position: absolute;\n  ", "\n\n  background: ", ";\n\n  ", ";\n\n  z-index: 1;\n  pointer-events: none;\n"])), H0(Fr * 1.5), t => UT(t), t => t.flag === 2 ? "outline: 2px solid white;" : ""), _81 = B.div(NT || (NT = V(["\n  z-index: 1;\n  cursor: ew-resize;\n\n  position: absolute;\n  ", ";\n  ", ";\n\n  & + ", " {\n    ", "\n  }\n\n  &:hover + ", " {\n    ", "\n  }\n"])), H0(12), C1, gp, t => t.isInlineEditorPopoverOpen ? H0(_T) : "", gp, H0(_T)), j81 = t => {
      let a = C0("SingleKeyframeDot", t.keyframe.id),
        c = i3(t.itemKey),
        [r, e] = z1(null),
        [l] = q81(e, a, t),
        {
          node: i,
          toggle: o,
          isOpen: n
        } = e8([{
          type: "primitiveProp",
          keyframe: t.keyframe,
          pathToProp: t.leaf.pathToProp,
          propConfig: t.leaf.propConf,
          sheetObject: t.leaf.sheetObject,
          trackId: t.leaf.trackId
        }]),
        [h] = N81(e, t, {
          onClickFromDrag(g) {
            o(g, r.current);
          }
        }),
        v = !t.keyframe.type || t.keyframe.type === "bezier";
      return j4.default.createElement(j4.default.Fragment, null, j4.default.createElement(_81, S({
        ref: r,
        isInlineEditorPopoverOpen: n
      }, c.attrs)), v ? j4.default.createElement(gp, {
        isSelected: !!t.selection,
        isInlineEditorPopoverOpen: n,
        flag: c.flag
      }) : j4.default.createElement(W81, {
        isSelected: !!t.selection,
        isInlineEditorPopoverOpen: n,
        flag: c.flag
      }), i, l);
    }, KT = j81;
  });
var zp,
  $T,
  XT,
  Lt,
  QT,
  U81,
  Jn,
  up = x(() => {
    "use strict";

    R0();
    zp = I(G());
    c1();
    sp();
    $T = Fr / 2 + 1, XT = 1e3, Lt = {
      normalColor: "#365b59",
      selectedColor: "#8A7842",
      barColor: t => {
        let a = t.isSelected ? Lt.selectedColor : Lt.normalColor;
        return t.isPopoverOpen ? _i(.2, R6(.2, a)) : a;
      },
      hoverColor: t => {
        let a = t.isSelected ? Lt.selectedColor : Lt.normalColor;
        return t.isPopoverOpen ? _i(.2, R6(.2, a)) : _i(.1, R6(.1, a));
      }
    }, U81 = B.div(QT || (QT = V(["\n  position: absolute;\n  background: ", ";\n  height: ", "px;\n  width: ", "px;\n\n  left: 0;\n  top: -", "px;\n  transform-origin: top left;\n  z-index: 0;\n  cursor: ew-resize;\n\n  &:after {\n    display: block;\n    position: absolute;\n    content: ' ';\n    top: -4px;\n    bottom: -4px;\n    left: 0;\n    right: 0;\n  }\n\n  &:hover {\n    background: ", ";\n  }\n"])), Lt.barColor, $T, XT, $T / 2, Lt.hoverColor), Jn = zp.default.forwardRef((t, a) => {
      let c = {
        isPopoverOpen: t.isPopoverOpen,
        isSelected: t.isSelected
      };
      return zp.default.createElement(U81, D(S({}, c), {
        ref: a,
        style: {
          transform: "scaleX(calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(t.connectorLengthInUnitSpace / XT, "))")
        },
        onClick: r => {
          var e;
          (e = t.openPopover) == null || e.call(t, r);
        }
      }), t.children);
    });
  });
function X81(t, a) {
  let c = (0, ah.useRef)(a);
  c.current = a;
  let r = (0, ah.useMemo)(() => ({
    debugName: "useDragKeyframe",
    lockCSSCursorTo: "ew-resize",
    onDragStart(e) {
      let l = c.current,
        i;
      if (l.selection) {
        let {
            selection: v,
            leaf: g
          } = l,
          {
            sheetObject: s
          } = g;
        return v.getDragHandlers(D(S({}, s.address), {
          domNode: t,
          positionAtStartOfDrag: l.track.data.keyframes[l.index].position
        })).onDragStart(e);
      }
      let o = l,
        n = (0, th.val)(o.layoutP.sheet).getSequence(),
        h = (0, th.val)(o.layoutP.scaledSpace.toUnitSpace);
      return {
        onDrag(v, g, s) {
          let d = h(v);
          i && (i.discard(), i = void 0), i = T().tempTransaction(({
            stateEditors: z
          }) => {
            z.coreByProject.historic.sheetsById.sequence.transformKeyframes(D(S({}, o.leaf.sheetObject.address), {
              trackId: o.leaf.trackId,
              keyframeIds: [o.keyframe.id, o.track.data.keyframes[o.index + 1].id],
              translate: d,
              scale: 1,
              origin: 0,
              snappingFunction: n.closestGridPosition
            }));
          });
        },
        onDragEnd(v) {
          v ? i && i.commit() : i && i.discard();
        }
      };
    }
  }), []);
  S1(t, r);
}
function Y81(t, a, c, r) {
  return Z1(a, {
    displayName: "Tween",
    menuItems: () => {
      let e = r8(t.leaf.sheetObject.address.projectId, t.leaf.sheetObject.address.sheetId, t.selection);
      return [{
        label: e.length > 0 ? "Copy (selection)" : "Copy",
        callback: () => {
          e.length > 0 ? T().transaction(l => {
            l.stateEditors.studio.ahistoric.setClipboardKeyframes(e);
          }) : T().transaction(l => {
            l.stateEditors.studio.ahistoric.setClipboardKeyframes([{
              keyframe: c,
              pathToProp: t.leaf.pathToProp
            }, {
              keyframe: r,
              pathToProp: t.leaf.pathToProp
            }]);
          });
        }
      }, {
        label: t.selection ? "Delete (selection)" : "Delete",
        callback: () => {
          t.selection ? t.selection.delete() : T().transaction(({
            stateEditors: l
          }) => {
            l.coreByProject.historic.sheetsById.sequence.deleteKeyframes(D(S({}, t.leaf.sheetObject.address), {
              keyframeIds: [c.id, r.id],
              trackId: t.leaf.trackId
            }));
          });
        }
      }];
    }
  });
}
var th,
  l8,
  ah,
  YT,
  JT,
  K81,
  $81,
  tZ,
  Q81,
  aZ = x(() => {
    "use strict";

    f1();
    v0();
    M2();
    P1();
    th = require("@theatre/dataverse"), l8 = I(G()), ah = I(G());
    c4();
    e4();
    Sr();
    up();
    Hr();
    M1();
    o7();
    o7();
    c1();
    YT = 5, K81 = B(T2)(JT || (JT = V(["\n  --popover-outer-stroke: transparent;\n  --popover-inner-stroke: ", ";\n"])), Dn), $81 = t => {
      let {
          index: a,
          track: c
        } = t,
        r = c.data.keyframes[a],
        e = c.data.keyframes[a + 1],
        [l, i] = z1(null),
        {
          node: o,
          toggle: n,
          close: h
        } = x2(() => {
          let z = (0, th.val)(t.layoutP.rightDims);
          return {
            debugName: "Connector",
            constraints: {
              minX: z.screenX + YT,
              maxX: z.screenX + z.width - YT
            }
          };
        }, () => l8.default.createElement(Q81, D(S({}, t), {
          closePopover: h
        }))),
        [v] = Y81(t, i, r, e);
      X81(i, t);
      let g = e.position - r.position,
        d = {
          isPopoverOpen: v1(() => Un(D(S({}, t.leaf.sheetObject.address), {
            trackId: t.leaf.trackId,
            left: r,
            right: e
          })), [t.leaf.sheetObject.address, t.leaf.trackId, r, e]),
          isSelected: t.selection !== void 0
        };
      return l8.default.createElement(l8.default.Fragment, null, l8.default.createElement(Jn, D(S({
        ref: l,
        connectorLengthInUnitSpace: g
      }, d), {
        openPopover: z => {
          i && n(z, i);
        }
      }), o), v);
    }, tZ = $81, Q81 = l8.default.forwardRef((t, a) => {
      let {
          index: c,
          track: {
            data: r
          },
          selection: e
        } = t,
        l = r.keyframes[c],
        i = r.keyframes[c + 1],
        o = t.leaf.trackId,
        n = t.leaf.sheetObject.address,
        h = v1(() => Kn(n.projectId, n.sheetId, e).getValue(), [n, e]),
        v = S({
          left: l,
          right: i,
          trackId: o
        }, n);
      return l8.default.createElement(K81, {
        showPopoverEdgeTriangle: !1,
        ref: a
      }, l8.default.createElement(Nn, {
        curveConnection: v,
        additionalConnections: h,
        onRequestClose: t.closePopover
      }));
    });
  });
var rZ,
  n7,
  cZ,
  J81,
  t71,
  a71,
  eZ,
  lZ = x(() => {
    "use strict";

    rZ = require("@theatre/dataverse"), n7 = I(G());
    c1();
    aZ();
    sp();
    J81 = B.div(cZ || (cZ = V(["\n  position: absolute;\n"]))), t71 = n7.default.createElement(n7.default.Fragment, null), a71 = n7.default.memo(t => {
      let {
          index: a,
          track: {
            data: c
          }
        } = t,
        r = c.keyframes[a],
        e = c.keyframes[a + 1],
        l = r.connectedRight && !!e;
      return n7.default.createElement(J81, {
        style: {
          top: "".concat(t.leaf.nodeHeight / 2, "px"),
          left: "calc(".concat((0, rZ.val)(t.layoutP.scaledSpace.leftPadding), "px + calc(var(--unitSpaceToScaledSpaceMultiplier) * ").concat(r.position, "px))")
        }
      }, n7.default.createElement(KT, D(S({}, t), {
        itemKey: t.itemKey
      })), l ? n7.default.createElement(tZ, S({}, t)) : t71);
    }), eZ = a71;
  });
function r71(t, a) {
  return Z1(t, {
    displayName: "Keyframe Track",
    menuItems: () => {
      var r;
      let c = (r = (0, Ht.val)(T().atomP.ahistoric.clipboard.keyframesWithRelativePaths)) != null ? r : [];
      return [e71(a, c)];
    }
  });
}
function e71(t, a) {
  return {
    label: "Paste Keyframes",
    enabled: a.length > 0,
    callback: () => {
      var i;
      let r = (0, Ht.val)(t.layoutP.sheet).getSequence(),
        e = (i = a[0]) == null ? void 0 : i.pathToProp,
        l = a.filter(({
          keyframe: o,
          pathToProp: n
        }) => fG(e, n)).map(({
          keyframe: o,
          pathToProp: n
        }) => o);
      T().transaction(({
        stateEditors: o
      }) => {
        var h;
        r.position = r.closestGridPosition(r.position);
        let n = (h = l71(l)) == null ? void 0 : h.position;
        for (let v of l) o.coreByProject.historic.sheetsById.sequence.setKeyframeAtPosition(D(S({}, t.leaf.sheetObject.address), {
          trackId: t.leaf.trackId,
          position: r.position + v.position - n,
          handles: v.handles,
          value: v.value,
          snappingFunction: r.closestGridPosition,
          type: v.type
        }));
      });
    }
  };
}
function l71(t) {
  let a = null;
  for (let c of t) (a === null || c.position < a.position) && (a = c);
  return a;
}
var Ht,
  q4,
  iZ,
  c71,
  oZ,
  nZ,
  hZ = x(() => {
    "use strict";

    M1();
    Ht = require("@theatre/dataverse"), q4 = I(G());
    c1();
    lZ();
    v0();
    P1();
    f1();
    o4();
    c8();
    O4();
    c71 = B.div(iZ || (iZ = V(["\n  position: relative;\n  height: 100%;\n  width: 100%;\n"]))), oZ = q4.default.memo(t => {
      var m;
      let {
          layoutP: a,
          trackData: c,
          leaf: r
        } = t,
        [e, l] = z1(null),
        {
          selectedKeyframeIds: i,
          selection: o
        } = v1(() => {
          let M = (0, Ht.val)(a.selectionAtom),
            w = (0, Ht.val)(M.pointer.current.byObjectKey[r.sheetObject.address.objectKey].byTrackId[r.trackId].byKeyframeId);
          return w ? {
            selectedKeyframeIds: w,
            selection: (0, Ht.val)(M.pointer.current)
          } : {
            selectedKeyframeIds: {},
            selection: void 0
          };
        }, [a, r.trackId]),
        [n, h, v] = r71(l, t),
        g = s1(Gn),
        s = g.mode === "snapToSome" ? (m = g.positions[r.sheetObject.address.objectKey]) == null ? void 0 : m[r.trackId] : [],
        d = g.mode === "snapToAll",
        z = (0, q4.useMemo)(() => ({
          data: c,
          id: r.trackId,
          sheetObject: t.leaf.sheetObject
        }), [c, r.trackId]),
        u = c.keyframes.map((M, w) => q4.default.createElement(eZ, {
          key: "keyframe-" + M.id,
          itemKey: c2.forTrackKeyframe(r.sheetObject, r.trackId, M.id),
          keyframe: M,
          index: w,
          track: z,
          layoutP: a,
          leaf: r,
          selection: i[M.id] === !0 ? o : void 0
        })),
        f = s.map(M => q4.default.createElement(pt, {
          key: "snap-target-" + M,
          layoutP: a,
          leaf: r,
          position: M
        })),
        p = d ? c.keyframes.map(M => q4.default.createElement(pt, {
          key: "additionalSnapTarget-".concat(M.id),
          layoutP: a,
          leaf: r,
          position: M.position
        })) : null;
      return q4.default.createElement(c71, {
        ref: e,
        style: {
          background: v ? "#444850 " : "unset"
        }
      }, u, f, q4.default.createElement(q4.default.Fragment, null, p), n);
    });
    oZ.displayName = "BasicKeyframedTrack";
    nZ = oZ;
  });
var vZ,
  Ir,
  i71,
  gZ,
  dZ = x(() => {
    "use strict";

    f1();
    M1();
    vZ = require("@theatre/dataverse"), Ir = I(G());
    Lr();
    hZ();
    L5();
    i71 = ({
      leaf: t,
      layoutP: a
    }) => {
      let c = C0("PrimitivePropRow", t.pathToProp.join());
      return v1(() => {
        let {
            sheetObject: r
          } = t,
          {
            trackId: e
          } = t,
          l = (0, vZ.val)(T().atomP.historic.coreByProject[r.address.projectId].sheetsById[r.address.sheetId].sequence.tracksByObject[r.address.objectKey].trackData[e]);
        return (l == null ? void 0 : l.type) !== "BasicKeyframedTrack" ? (c.errorDev("trackData type ".concat(l == null ? void 0 : l.type, " is not yet supported on the sequence editor")), Ir.default.createElement(A5, {
          leaf: t,
          isCollapsed: !1,
          node: Ir.default.createElement("div", null)
        })) : Ir.default.createElement(A5, {
          leaf: t,
          isCollapsed: !1,
          node: Ir.default.createElement(nZ, {
            layoutP: a,
            trackData: l,
            leaf: t
          })
        });
      }, [t, a]);
    }, gZ = i71;
  });
function sZ(t) {
  return t();
}
var zZ = x(() => {
  "use strict";
});
function ch(t) {
  let {
    index: a,
    aggregateKeyframes: c,
    selection: r
  } = t;
  return v1(mp(t), [a, c, r, t.viewModel]);
}
function mp(t) {
  let {
      index: a,
      aggregateKeyframes: c,
      selection: r
    } = t,
    {
      projectId: e,
      sheetId: l
    } = t.viewModel.type === "sheet" ? t.viewModel.sheet.address : t.viewModel.sheetObject.address;
  return () => {
    let i = c[a],
      o = c[a + 1],
      h = o && i.keyframes.length === o.keyframes.length && i.keyframes.every(({
        track: z
      }, u) => o.keyframes[u].track === z) ? {
        length: o.position - i.position,
        selected: i.selected === 0 && o.selected === 0
      } : null,
      v = h ? i.keyframes.map(({
        kf: z,
        track: u
      }, f) => D(S({}, u.sheetObject.address), {
        trackId: u.id,
        left: z,
        right: o.keyframes[f].kf
      })) : [],
      g = sZ(() => {
        let z = pp.prism.memo("selectedConnections", () => Kn(e, l, r), [e, l, r]).getValue();
        return [...v, ...z];
      }),
      s = v.every(z => Un(z));
    return {
      itemKey: pp.prism.memo("itemKey", () => t.viewModel.type === "sheet" ? c2.forSheetAggregateKeyframe(t.viewModel.sheet, i.position) : t.viewModel.type === "sheetObject" ? c2.forSheetObjectAggregateKeyframe(t.viewModel.sheetObject, i.position) : c2.forCompoundPropAggregateKeyframe(t.viewModel.sheetObject, t.viewModel.pathToProp, i.position), [t.viewModel, i.position]),
      cur: i,
      connected: h,
      isAggregateEditingInCurvePopover: s,
      allConnections: g
    };
  };
}
var pp,
  rh = x(() => {
    "use strict";

    pp = require("@theatre/dataverse");
    O4();
    Sr();
    M1();
    o7();
    zZ();
  });
function h71(t, a) {
  let c = (0, E0.useRef)(a);
  c.current = a;
  let r = (0, E0.useMemo)(() => ({
    debugName: "useDragKeyframe",
    lockCSSCursorTo: "ew-resize",
    onDragStart(e) {
      let l = c.current,
        i,
        o = l.aggregateKeyframes[l.index].keyframes,
        {
          selection: n,
          viewModel: h
        } = l,
        v = h.type === "sheet" ? h.sheet.address : h.sheetObject.address;
      if (n && l.aggregateKeyframes[l.index].selected === 0) return n.getDragHandlers(D(S({}, v), {
        domNode: t,
        positionAtStartOfDrag: l.aggregateKeyframes[l.index].position
      })).onDragStart(e);
      let g = l,
        s = (0, eh.val)(g.layoutP.sheet).getSequence(),
        d = (0, eh.val)(g.layoutP.scaledSpace.toUnitSpace);
      return {
        onDrag(z, u, f) {
          let p = d(z);
          i && (i.discard(), i = void 0), i = T().tempTransaction(({
            stateEditors: m
          }) => {
            for (let M of o) m.coreByProject.historic.sheetsById.sequence.transformKeyframes(D(S({}, M.track.sheetObject.address), {
              trackId: M.track.id,
              keyframeIds: [M.kf.id, M.track.data.keyframes[M.track.data.keyframes.indexOf(M.kf) + 1].id],
              translate: p,
              scale: 1,
              origin: 0,
              snappingFunction: s.closestGridPosition
            }));
          });
        },
        onDragEnd(z) {
          z ? i && i.commit() : i && i.discard();
        }
      };
    }
  }), []);
  return S1(t, r);
}
function v71(t, a) {
  return Z1(a, {
    displayName: "Aggregate Tween",
    menuItems: () => {
      let c = t.utils.allConnections.reduce((o, n) => {
          var h;
          return o.concat((h = Rr(D(S({}, n), {
            keyframeIds: [n.left.id, n.right.id]
          }))) != null ? h : []);
        }, []),
        r = J6(c.map(o => o.pathToProp)),
        e = c.map(({
          keyframe: o,
          pathToProp: n
        }) => ({
          keyframe: o,
          pathToProp: n.slice(r.length)
        })),
        l = t.editorProps.viewModel,
        i = l.type === "sheet" ? l.sheet.address : l.sheetObject.address;
      return [{
        label: "Copy",
        callback: () => {
          if (t.editorProps.selection) {
            let o = r8(i.projectId, i.sheetId, t.editorProps.selection);
            T().transaction(n => {
              n.stateEditors.studio.ahistoric.setClipboardKeyframes(o);
            });
          } else T().transaction(o => {
            o.stateEditors.studio.ahistoric.setClipboardKeyframes(e);
          });
        }
      }, {
        label: "Delete",
        callback: () => {
          t.editorProps.selection ? t.editorProps.selection.delete() : T().transaction(({
            stateEditors: o
          }) => {
            for (let n of t.utils.allConnections) o.coreByProject.historic.sheetsById.sequence.deleteKeyframes(D(S({}, i), {
              objectKey: n.objectKey,
              keyframeIds: [n.left.id, n.right.id],
              trackId: n.trackId
            }));
          });
        }
      }];
    }
  });
}
var eh,
  E0,
  uZ,
  pZ,
  o71,
  n71,
  mZ,
  fZ = x(() => {
    "use strict";

    eh = require("@theatre/dataverse"), E0 = I(G());
    up();
    c4();
    P1();
    f1();
    M2();
    Sr();
    rh();
    c1();
    e4();
    o7();
    v0();
    o4();
    uZ = 5, o71 = B(T2)(pZ || (pZ = V(["\n  --popover-outer-stroke: transparent;\n  --popover-inner-stroke: rgba(26, 28, 30, 0.97);\n"]))), n71 = E0.default.forwardRef((t, a) => {
      let {
        allConnections: c
      } = ch(t);
      return E0.default.createElement(o71, {
        showPopoverEdgeTriangle: !1,
        ref: a
      }, E0.default.createElement(Nn, {
        curveConnection: c[0],
        additionalConnections: c,
        onRequestClose: t.closePopover
      }));
    }), mZ = t => {
      let [a, c] = z1(null),
        {
          editorProps: r
        } = t,
        [e] = v71(t, c),
        [l] = h71(c, t.editorProps),
        {
          node: i,
          toggle: o,
          close: n
        } = x2(() => {
          let g = (0, eh.val)(r.layoutP.rightDims);
          return {
            debugName: "Connector",
            constraints: {
              minX: g.screenX + uZ,
              maxX: g.screenX + g.width - uZ
            }
          };
        }, () => E0.default.createElement(n71, D(S({}, r), {
          closePopover: n
        }))),
        {
          connected: h,
          isAggregateEditingInCurvePopover: v
        } = t.utils;
      return h || l ? E0.default.createElement(E0.default.Fragment, null, E0.default.createElement(Jn, {
        ref: a,
        connectorLengthInUnitSpace: h ? h.length : 0,
        isSelected: h ? h.selected : !1,
        isPopoverOpen: v,
        openPopover: g => {
          c && o(g, c);
        }
      }), i, e) : E0.default.createElement(E0.default.Fragment, null);
    };
  });
function HZ(t) {
  let a = {
    isSelected: t.isSelected,
    flag: t.flag
  };
  return R5.default.createElement(fp, null, t.isAllHere ? R5.default.createElement(s71, S({}, a)) : R5.default.createElement(z71, S({}, a)));
}
var R5,
  CZ,
  g71,
  MZ,
  fp,
  xZ,
  LZ,
  VZ,
  wZ,
  BZ,
  yZ,
  d71,
  s71,
  z71,
  SZ = x(() => {
    "use strict";

    R5 = I(G());
    c1();
    Cr();
    G1();
    CZ = 16, g71 = CZ + 2, fp = B.div(MZ || (MZ = V(["\n  position: absolute;\n  ", "\n  z-index: 1;\n"])), H0(CZ)), LZ = B.div(xZ || (xZ = V(["\n  z-index: 2;\n  cursor: ew-resize;\n\n  position: absolute;\n  ", ";\n  ", ";\n\n  &:hover\n    + ", ",\n    #pointer-root.draggingPositionInSequenceEditor\n    &:hover\n    + ", " {\n    ", "\n  }\n"])), H0(12), C1, fp, fp, H0(g71));
    VZ = "#F2C95C", wZ = "#40AAA4", BZ = "#45747C", yZ = t => t.isSelected === 0 ? VZ : t.isSelected === 1 ? wZ : BZ, d71 = t => t.isSelected === 0 ? VZ : t.isSelected === 1 ? wZ : BZ, s71 = t => R5.default.createElement("svg", {
      width: "100%",
      height: "100%",
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, R5.default.createElement("rect", {
      x: "4.46443",
      y: "10.0078",
      width: "5",
      height: "5",
      transform: "rotate(-45 4.46443 10.0078)",
      fill: "#212327",
      stroke: d71(t)
    }), R5.default.createElement("rect", {
      x: "3.75732",
      y: "6.01953",
      width: "6",
      height: "6",
      transform: "rotate(-45 3.75732 6.01953)",
      fill: yZ(t),
      stroke: t.flag === 2 ? "white" : void 0,
      strokeWidth: t.flag === 2 ? "2px" : void 0
    })), z71 = t => R5.default.createElement("svg", {
      width: "100%",
      height: "100%",
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, R5.default.createElement("rect", {
      x: "4.46443",
      y: "8",
      width: "5",
      height: "5",
      transform: "rotate(-45 4.46443 8)",
      fill: "#23262B",
      stroke: t.flag === 2 ? "white" : yZ(t),
      strokeWidth: t.flag === 2 ? "2px" : void 0
    }));
  });
function u71(t, a) {
  let c = t.children.map(r => r.type === "propWithChildren" ? Mp(r, a) : AZ(r, a)).filter(kZ);
  return c.length === 0 ? null : {
    type: "sheetObject",
    sheetObject: t.sheetObject,
    children: c
  };
}
function Mp(t, a) {
  let c = t.children.map(r => r.type === "propWithChildren" ? Mp(r, a) : AZ(r, a)).filter(kZ);
  return c.length === 0 ? null : {
    type: "propWithChildren",
    pathToProp: t.pathToProp,
    propConfig: t.propConf,
    children: c
  };
}
function AZ(t, a) {
  let c = a.find(r => r.track.id === t.trackId);
  return c ? {
    type: "primitiveProp",
    keyframe: c.kf,
    pathToProp: t.pathToProp,
    propConfig: t.propConf,
    sheetObject: t.sheetObject,
    trackId: t.trackId
  } : null;
}
function RZ(t) {
  var o, n, h, v;
  let {
      cur: a
    } = t.utils,
    c = e8(t.editorProps.viewModel.type === "sheet" ? null : t.editorProps.viewModel.type === "sheetObject" ? (n = (o = u71(t.editorProps.viewModel, a.keyframes)) == null ? void 0 : o.children) != null ? n : null : (v = (h = Mp(t.editorProps.viewModel, a.keyframes)) == null ? void 0 : h.children) != null ? v : null),
    r = i3(t.utils.itemKey);
  r.useRelations(() => a.keyframes.map(g => ({
    affects: g.itemKey,
    flag: 2
  })), [a.keyframes.map(g => g.track.id).join("-")]);
  let [e, l] = z1(null),
    [i] = p71(t, l);
  return Pr.default.createElement(Pr.default.Fragment, null, Pr.default.createElement(LZ, D(S(S({
    ref: e
  }, r.attrs), r2.includePositionSnapAttrs(a.position)), {
    onClick: g => t.editorProps.viewModel.type !== "sheet" ? c.open(g, e.current) : null
  })), Pr.default.createElement(HZ, {
    flag: r.flag,
    isAllHere: a.allHere,
    isSelected: a.selected
  }), i, c.node);
}
function p71(t, a) {
  return Z1(a, {
    displayName: "Aggregate Keyframe",
    menuItems: () => {
      let c = t.editorProps.viewModel,
        r = t.editorProps.selection;
      return [{
        label: r ? "Copy (selection)" : "Copy",
        callback: () => {
          if (r) {
            let {
                projectId: e,
                sheetId: l
              } = c.type === "sheet" ? c.sheet.address : c.sheetObject.address,
              i = r8(e, l, r);
            T().transaction(o => {
              o.stateEditors.studio.ahistoric.setClipboardKeyframes(i);
            });
          } else {
            let e = t.utils.cur.keyframes.flatMap(n => {
                var h;
                return (h = Rr(D(S({}, n.track.sheetObject.address), {
                  trackId: n.track.id,
                  keyframeIds: [n.kf.id]
                }))) != null ? h : [];
              }),
              l = c.type === "sheet" ? [] : c.type === "sheetObject" ? [c.sheetObject.address.objectKey] : c.type === "propWithChildren" ? [c.sheetObject.address.objectKey, ...c.pathToProp] : [],
              i = J6([l, ...e.map(n => n.pathToProp)]),
              o = e.map(({
                keyframe: n,
                pathToProp: h
              }) => ({
                keyframe: n,
                pathToProp: h.slice(i.length)
              }));
            T().transaction(n => {
              n.stateEditors.studio.ahistoric.setClipboardKeyframes(o);
            });
          }
        }
      }, {
        label: r ? "Delete (selection)" : "Delete",
        callback: () => {
          r ? r.delete() : T().transaction(({
            stateEditors: e
          }) => {
            for (let l of t.utils.cur.keyframes) e.coreByProject.historic.sheetsById.sequence.deleteKeyframes(D(S({}, l.track.sheetObject.address), {
              keyframeIds: [l.kf.id],
              trackId: l.track.id
            }));
          });
        }
      }];
    }
  });
}
var Pr,
  kZ,
  bZ = x(() => {
    "use strict";

    Pr = I(G());
    P1();
    K6();
    v0();
    SZ();
    f1();
    o7();
    o4();
    b3();
    br();
    kZ = t => t !== null;
  });
var IZ,
  Gr,
  FZ,
  m71,
  f71,
  PZ,
  GZ = x(() => {
    "use strict";

    IZ = require("@theatre/dataverse"), Gr = I(G());
    c1();
    fZ();
    rh();
    bZ();
    m71 = B.div(FZ || (FZ = V(["\n  position: absolute;\n"]))), f71 = Gr.default.memo(t => {
      let a = ch(t);
      return Gr.default.createElement(m71, {
        style: {
          top: "".concat(t.viewModel.nodeHeight / 2, "px"),
          left: "calc(".concat((0, IZ.val)(t.layoutP.scaledSpace.leftPadding), "px + calc(var(--unitSpaceToScaledSpaceMultiplier) * ").concat(a.cur.position, "px))")
        }
      }, Gr.default.createElement(RZ, {
        editorProps: t,
        utils: a
      }), Gr.default.createElement(mZ, {
        editorProps: t,
        utils: a
      }));
    }), PZ = f71;
  });
function C71(t) {
  let {
      layoutP: a,
      aggregatedKeyframes: c,
      viewModel: r
    } = t,
    e = C0("AggregatedKeyframeTrack"),
    [l, i] = z1(null),
    {
      selectedPositions: o,
      selection: n
    } = H71(a, c),
    [h, v, g] = B71(i, t, () => e._debug("see aggregatedKeyframes", t.aggregatedKeyframes)),
    s = (0, D0.useMemo)(() => [...c.byPosition.entries()].sort((H, y) => H[0] - y[0]).map(([H, y]) => ({
      position: H,
      keyframes: y,
      selected: o.get(H),
      allHere: y.length === c.tracks.length
    })), [c, o]),
    d = s1(Gn),
    z = d.mode === "snapToAll",
    u = d.mode === "snapToSome" ? d.positions : $o,
    p = (0, D0.useMemo)(() => r.type === "sheet" ? VG(r, u) : Rn(r, u), [u]).map(H => D0.default.createElement(pt, {
      key: "snap-target-" + H,
      layoutP: a,
      leaf: r,
      position: H
    })),
    m = (0, D0.useMemo)(() => s.map(({
      position: H,
      keyframes: y
    }, k) => ({
      position: H,
      editorProps: {
        index: k,
        layoutP: a,
        viewModel: r,
        aggregateKeyframes: s,
        selection: o.has(H) ? n : void 0
      }
    })), [s, r, o]),
    [M] = A71(i, H => {
      var y;
      return (y = m.find(k => k.position === H)) == null ? void 0 : y.editorProps;
    }, {
      onClickFromDrag(H) {}
    }),
    w = m.map((H, y) => D0.default.createElement(D0.Fragment, {
      key: "agg-" + s[y].keyframes[0].kf.id
    }, z && D0.default.createElement(pt, {
      layoutP: a,
      leaf: r,
      position: H.position
    }), D0.default.createElement(PZ, S({}, H.editorProps))));
  return D0.default.createElement(M71, {
    ref: l,
    style: {
      background: g ? "#444850 " : "unset"
    }
  }, w, p, h);
}
function H71(t, a) {
  return v1(() => (0, Q2.val)(V71(t, a)), [t, a]);
}
function V71(t, a) {
  return (0, Q2.prism)(() => {
    let c = (0, Q2.val)(t.selectionAtom),
      r = (0, Q2.val)(c.pointer.current);
    if (!r) return x71;
    let e = new Map();
    for (let [l, i] of a.byPosition) {
      let o = w71(i, r);
      o !== void 0 && o !== xp && e.set(l, o);
    }
    return {
      selectedPositions: e,
      selection: (0, Q2.val)(c.pointer.current)
    };
  });
}
function w71(t, a) {
  var r, e, l;
  let c;
  for (let {
    track: i,
    kf: o
  } of t) {
    let n = ((l = (e = (r = a.byObjectKey[i.sheetObject.address.objectKey]) == null ? void 0 : r.byTrackId[i.id]) == null ? void 0 : e.byKeyframeId) == null ? void 0 : l[o.id]) === !0;
    c === void 0 ? n ? c = TZ : c = xp : n ? c === xp && (c = ZZ) : c === TZ && (c = ZZ);
  }
  return c;
}
function B71(t, a, c) {
  return Z1(t, {
    onOpen: c,
    displayName: "Aggregate Keyframe Track",
    menuItems: () => {
      var e;
      let r = (e = (0, Q2.pointerToPrism)(T().atomP.ahistoric.clipboard.keyframesWithRelativePaths).getValue()) != null ? e : [];
      return [y71(a, r)];
    }
  });
}
function y71(t, a) {
  return {
    label: "Paste Keyframes",
    enabled: a.length > 0,
    callback: () => {
      let r = (0, Q2.val)(t.layoutP.sheet).getSequence();
      t.viewModel.type === "sheet" ? S71(t.viewModel, a, r) : k71(t.viewModel, a, r);
    }
  };
}
function S71(t, a, c) {
  var o;
  let {
    projectId: r,
    sheetId: e,
    sheetInstanceId: l
  } = t.sheet.address;
  if (a.every(({
    pathToProp: n
  }) => n.length === 0)) for (let n of t.children.map(h => h.sheetObject)) {
    let h = (0, Q2.pointerToPrism)(T().atomP.historic.coreByProject[r].sheetsById[e].sequence.tracksByObject[n.address.objectKey]).getValue(),
      v = Object.keys((o = h == null ? void 0 : h.trackData) != null ? o : {});
    Cp(n.address, v, a, c);
  } else {
    let n = (0, Q2.pointerToPrism)(T().atomP.historic.coreByProject[r].sheetsById[e].sequence.tracksByObject).getValue(),
      h = a.map(({
        keyframe: v,
        pathToProp: g
      }) => {
        var p, m;
        let s = g[0],
          d = g.slice(1),
          z = h3([...d]),
          f = ((m = (p = n == null ? void 0 : n[s]) == null ? void 0 : p.trackIdByPropPath) != null ? m : {})[z];
        return f ? {
          keyframe: v,
          trackId: f,
          address: {
            objectKey: s,
            projectId: r,
            sheetId: e,
            sheetInstanceId: l
          }
        } : null;
      }).filter(v => v !== null);
    DZ(h, c);
  }
}
function k71(t, a, c) {
  var n;
  let {
      projectId: r,
      sheetId: e,
      objectKey: l
    } = t.sheetObject.address,
    i = (0, Q2.pointerToPrism)(T().atomP.historic.coreByProject[r].sheetsById[e].sequence.tracksByObject[l]).getValue();
  if (a.every(({
    pathToProp: h
  }) => h.length === 0)) {
    let h = Object.keys((n = i == null ? void 0 : i.trackData) != null ? n : {});
    if (t.type === "sheetObject") Cp(t.sheetObject.address, h, a, c);else {
      let v = (i == null ? void 0 : i.trackIdByPropPath) || {},
        g = Object.entries(v).filter(([s, d]) => d !== void 0 && mG(ut(s), t.pathToProp)).map(([s, d]) => d);
      Cp(t.sheetObject.address, g, a, c);
    }
  } else {
    let h = (i == null ? void 0 : i.trackIdByPropPath) || {},
      v = t.type === "propWithChildren" ? t.pathToProp : [],
      g = a.map(({
        keyframe: s,
        pathToProp: d
      }) => {
        let z = h3([...v, ...d]),
          u = h[z];
        return u ? {
          keyframe: s,
          trackId: u,
          address: t.sheetObject.address
        } : null;
      }).filter(s => s !== null);
    DZ(g, c);
  }
}
function Cp(t, a, c, r) {
  var l;
  r.position = r.closestGridPosition(r.position);
  let e = (l = WZ(c.map(({
    keyframe: i
  }) => i))) == null ? void 0 : l.position;
  T().transaction(({
    stateEditors: i
  }) => {
    for (let o of a) for (let {
      keyframe: n
    } of c) i.coreByProject.historic.sheetsById.sequence.setKeyframeAtPosition(D(S({}, t), {
      trackId: o,
      position: r.position + n.position - e,
      handles: n.handles,
      value: n.value,
      snappingFunction: r.closestGridPosition,
      type: n.type
    }));
  });
}
function DZ(t, a) {
  var r;
  a.position = a.closestGridPosition(a.position);
  let c = (r = WZ(t.map(({
    keyframe: e
  }) => e))) == null ? void 0 : r.position;
  T().transaction(({
    stateEditors: e
  }) => {
    for (let {
      keyframe: l,
      trackId: i,
      address: o
    } of t) e.coreByProject.historic.sheetsById.sequence.setKeyframeAtPosition(D(S({}, o), {
      trackId: i,
      position: a.position + l.position - c,
      handles: l.handles,
      value: l.value,
      snappingFunction: a.closestGridPosition,
      type: l.type
    }));
  });
}
function WZ(t) {
  let a = null;
  for (let c of t) (a === null || c.position < a.position) && (a = c);
  return a;
}
function A71(t, a, c) {
  let r = C0("useDragForAggregateKeyframeDot"),
    e = OG(),
    l = (0, D0.useMemo)(() => ({
      debugName: "AggregateKeyframeDot/useDragKeyframe",
      onDragStart(o) {
        r._debug("onDragStart", {
          target: o.target
        });
        let n = Number(o.target.dataset.pos),
          h = a(n);
        if (!h) return r._debug("no props found for ", {
          positionToFind: n
        }), !1;
        e(!0, n);
        let v = (0, Q2.prism)(mp(h)).getValue().cur.keyframes,
          g = h.viewModel.type === "sheet" ? h.viewModel.sheet.address : h.viewModel.sheetObject.address,
          s = (0, Q2.val)(T().atomP.historic.coreByProject[g.projectId].sheetsById[g.sheetId].sequence.tracksByObject),
          d = Zn(s, function (m, {
            trackId: M,
            objectKey: w
          }) {
            var H, y;
            return v.every(k => m.id !== k.kf.id) && !(h.selection && (y = (H = h.selection.byObjectKey[w]) == null ? void 0 : H.byTrackId[M]) != null && y.byKeyframeId[m.id]);
          });
        if (Tn(d), h.selection && h.aggregateKeyframes[h.index].selected === 0) {
          let {
              selection: p,
              viewModel: m
            } = h,
            M = p.getDragHandlers(D(S({}, g), {
              domNode: t,
              positionAtStartOfDrag: v[0].kf.position
            })).onDragStart(o);
          return M && D(S({}, M), {
            onClick: c.onClickFromDrag,
            onDragEnd: (...w) => {
              var H;
              (H = M.onDragEnd) == null || H.call(M, ...w), I3();
            }
          });
        }
        let z = h,
          u = (0, Q2.val)(z.layoutP.scaledSpace.toUnitSpace),
          f;
        return {
          onDrag(p, m, M) {
            var H;
            let w = Math.max((H = r2.checkIfMouseEventSnapToPos(M, {})) != null ? H : v[0].kf.position + u(p), 0);
            e(!0, w), f == null || f.discard(), f = void 0, f = T().tempTransaction(({
              stateEditors: y
            }) => {
              for (let k of v) {
                let F = k.kf;
                y.coreByProject.historic.sheetsById.sequence.replaceKeyframes(D(S({}, k.track.sheetObject.address), {
                  trackId: k.track.id,
                  keyframes: [D(S({}, F), {
                    position: w
                  })],
                  snappingFunction: (0, Q2.val)(z.layoutP.sheet).getSequence().closestGridPosition
                }));
              }
            });
          },
          onDragEnd(p) {
            e(!1, -1), p ? f == null || f.commit() : (f == null || f.discard(), c.onClickFromDrag(o)), I3();
          },
          onClick(p) {
            c.onClickFromDrag(p);
          }
        };
      }
    }), [a, c.onClickFromDrag]),
    [i] = S1(t, l);
  return s2(i, "draggingPositionInSequenceEditor", "ew-resize"), [i];
}
var Q2,
  D0,
  OZ,
  M71,
  x71,
  L71,
  Vt,
  EZ,
  TZ,
  ZZ,
  xp,
  lh = x(() => {
    "use strict";

    M1();
    Q2 = require("@theatre/dataverse"), D0 = I(G());
    c1();
    v0();
    P1();
    GZ();
    l7();
    L5();
    rh();
    b3();
    M2();
    E2();
    I0();
    f1();
    o4();
    c8();
    pu();
    c8();
    l7();
    M71 = B.div(OZ || (OZ = V(["\n  position: relative;\n  height: 100%;\n  width: 100%;\n"]))), x71 = Object.freeze({
      selectedPositions: new Map(),
      selection: void 0
    });
    L71 = D0.default.memo(C71), Vt = L71, EZ = (r => (r[r.AllSelected = 0] = "AllSelected", r[r.AtLeastOneUnselected = 1] = "AtLeastOneUnselected", r[r.NoneSelected = 2] = "NoneSelected", r))(EZ || {}), ({
      AllSelected: TZ,
      AtLeastOneUnselected: ZZ,
      NoneSelected: xp
    } = EZ);
  });
var wt,
  Lp,
  R71,
  _Z = x(() => {
    "use strict";

    M1();
    wt = I(G());
    dZ();
    Lr();
    lh();
    l7();
    L5();
    Lp = (t, a) => t.type === "propWithChildren" ? wt.default.createElement(R71, {
      layoutP: a,
      viewModel: t,
      key: "prop" + t.pathToProp[t.pathToProp.length - 1]
    }) : wt.default.createElement(gZ, {
      layoutP: a,
      leaf: t,
      key: "prop" + t.pathToProp[t.pathToProp.length - 1]
    }), R71 = ({
      viewModel: t,
      layoutP: a
    }) => {
      let c = C0("RightPropWithChildrenRow", t.pathToProp.join());
      return v1(() => {
        let r = t8(t);
        return wt.default.createElement(uo, {
          logger: c
        }, wt.default.createElement(A5, {
          leaf: t,
          node: wt.default.createElement(Vt, {
            layoutP: a,
            aggregatedKeyframes: r,
            viewModel: t
          }),
          isCollapsed: t.isCollapsed
        }, t.children.map(l => Lp(l, a))));
      }, [t, a]);
    };
  });
var Hp,
  b71,
  jZ,
  qZ = x(() => {
    "use strict";

    M1();
    Hp = I(G());
    _Z();
    Lr();
    l7();
    lh();
    b71 = ({
      leaf: t,
      layoutP: a
    }) => v1(() => {
      let c = t8(t);
      return Hp.default.createElement(A5, {
        leaf: t,
        node: Hp.default.createElement(Vt, {
          layoutP: a,
          aggregatedKeyframes: c,
          viewModel: t
        }),
        isCollapsed: t.isCollapsed
      }, t.children.map(e => Lp(e, a)));
    }, [t, a]), jZ = b71;
  });
var ih,
  F71,
  NZ,
  UZ = x(() => {
    "use strict";

    M1();
    ih = I(G());
    qZ();
    Lr();
    l7();
    lh();
    F71 = ({
      leaf: t,
      layoutP: a
    }) => v1(() => {
      let c = t8(t);
      return ih.default.createElement(A5, {
        leaf: t,
        node: ih.default.createElement(Vt, {
          layoutP: a,
          aggregatedKeyframes: c,
          viewModel: t
        }),
        isCollapsed: t.isCollapsed
      }, t.children.map(e => ih.default.createElement(jZ, {
        layoutP: a,
        key: "sheetObject-" + e.sheetObject.address.objectKey,
        leaf: e
      })));
    }, [t, a]), NZ = F71;
  });
var Tr,
  h7,
  oh,
  KZ,
  I71,
  P71,
  $Z,
  Vp = x(() => {
    "use strict";

    M1();
    Tr = require("@theatre/dataverse"), h7 = I(G());
    c1();
    kG();
    rp();
    UZ();
    oh = 1e6, I71 = B.ul(KZ || (KZ = V(["\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  position: absolute;\n  left: 0;\n  width: ", "px;\n"])), oh), P71 = ({
      layoutP: t
    }) => v1(() => {
      let a = (0, Tr.val)(t.tree),
        c = (0, Tr.val)(t.tree.top) + Math.max((0, Tr.val)(t.tree.heightIncludingChildren), (0, Tr.val)(t.dopeSheetDims.height));
      return h7.default.createElement(h7.default.Fragment, null, h7.default.createElement(On, {
        layoutP: t,
        height: c
      }, h7.default.createElement(SG, {
        layoutP: t,
        height: c
      }, h7.default.createElement(I71, {
        style: {
          top: a.top + "px"
        }
      }, h7.default.createElement(NZ, {
        leaf: a,
        layoutP: t
      })))));
    }, [t]), $Z = P71;
  });
function Zr(t, a, c, r) {
  let e = "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(t, "px)"),
    l = "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(a, ") * 1px)");
  c === 0 && (c = 1e-4);
  let i = "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(c, ")");
  r === 0 && (r = .001);
  let o = "calc(var(--graphEditorVerticalSpace) * ".concat(r * -1, ")");
  return "translate(".concat(e, ", ").concat(l, ") scale(").concat(i, ", ").concat(o, ")");
}
function O71(t, a) {
  let {
      index: c,
      trackData: r
    } = a,
    e = r.keyframes[c],
    l = r.keyframes[c + 1];
  return Z1(t, {
    menuItems: () => [{
      label: "Delete",
      callback: () => {
        T().transaction(({
          stateEditors: i
        }) => {
          let {
            deleteKeyframes: o
          } = i.coreByProject.historic.sheetsById.sequence;
          o(D(S({}, a.sheetObject.address), {
            trackId: a.trackId,
            keyframeIds: [e.id, l.id]
          }));
        });
      }
    }]
  });
}
var nh,
  QZ,
  G71,
  T71,
  Z71,
  XZ,
  hh = x(() => {
    "use strict";

    H5();
    f1();
    v0();
    P1();
    nh = I(G());
    c1();
    G71 = B.path(QZ || (QZ = V(["\n  stroke-width: 2;\n  stroke: var(--main-color);\n  fill: none;\n  vector-effect: non-scaling-stroke;\n"]))), T71 = "M 0 0 L 1 0 L 1 1", Z71 = t => {
      let {
          index: a,
          trackData: c
        } = t,
        r = c.keyframes[a],
        e = c.keyframes[a + 1],
        l = e.position - r.position,
        [i, o] = z1(null),
        [n] = O71(o, t),
        h = t.isScalar ? X8(r.value, t.propConfig) : 0,
        v = t.isScalar ? X8(e.value, t.propConfig) : 1,
        g = t.extremumSpace.fromValueSpace(h),
        d = t.extremumSpace.fromValueSpace(v) - g,
        z = Zr(r.position, g, l, d),
        u = r.handles[2],
        f = r.handles[3],
        p = e.handles[0],
        m = e.handles[1],
        M = "M 0 0 C ".concat(u, " ").concat(f, " ").concat(p, " ").concat(m, " 1 1");
      return nh.default.createElement(nh.default.Fragment, null, nh.default.createElement(G71, {
        ref: i,
        d: !r.type || r.type === "bezier" ? M : T71,
        style: {
          transform: z
        }
      }), n);
    };
    XZ = Z71;
  });
function _71(t, a) {
  let c = (0, b5.useRef)(a);
  c.current = a;
  let r = (0, b5.useMemo)(() => ({
    debugName: "CurveHandler/useOurDrags",
    lockCSSCursorTo: "move",
    onDragStart() {
      let e,
        l = c.current,
        i = (0, Or.val)(l.layoutP.scaledSpace.toUnitSpace),
        o = (0, Or.val)(l.layoutP.graphEditorVerticalSpace.toExtremumSpace),
        n = l.extremumSpace.lock();
      return {
        onDrag(h, v) {
          e && (e.discard(), e = void 0);
          let {
              index: g,
              trackData: s
            } = l,
            d = s.keyframes[g],
            z = s.keyframes[g + 1],
            f = i(h) / (z.position - d.position),
            p = -v,
            m = o(p),
            M = l.extremumSpace.deltaToValueSpace(m),
            w = a.isScalar ? d.value : 0,
            H = a.isScalar ? z.value : 1,
            y = M / (H - w);
          if (l.which === "left") {
            let k = b1(d.handles[2] + f, 0, 1),
              F = d.handles[3] + y;
            e = T().tempTransaction(({
              stateEditors: U
            }) => {
              U.coreByProject.historic.sheetsById.sequence.replaceKeyframes(D(S({}, l.sheetObject.address), {
                snappingFunction: (0, Or.val)(l.layoutP.sheet).getSequence().closestGridPosition,
                trackId: l.trackId,
                keyframes: [D(S({}, d), {
                  handles: [d.handles[0], d.handles[1], k, F]
                })]
              }));
            });
          } else {
            let k = b1(z.handles[0] + f, 0, 1),
              F = z.handles[1] + y;
            e = T().tempTransaction(({
              stateEditors: U
            }) => {
              U.coreByProject.historic.sheetsById.sequence.replaceKeyframes(D(S({}, l.sheetObject.address), {
                trackId: l.trackId,
                snappingFunction: (0, Or.val)(l.layoutP.sheet).getSequence().closestGridPosition,
                keyframes: [D(S({}, z), {
                  handles: [k, F, z.handles[2], z.handles[3]]
                })]
              }));
            });
          }
        },
        onDragEnd(h) {
          n(), h ? e && e.commit() : e && e.discard();
        }
      };
    }
  }), []);
  S1(t, r);
}
function j71(t, a) {
  return Z1(t, {
    menuItems: () => [{
      label: "Delete",
      callback: () => {
        T().transaction(({
          stateEditors: c
        }) => {
          c.coreByProject.historic.sheetsById.sequence.deleteKeyframes(D(S({}, a.sheetObject.address), {
            keyframeIds: [a.keyframe.id],
            trackId: a.trackId
          }));
        });
      }
    }]
  });
}
var Or,
  b5,
  YZ,
  aO,
  JZ,
  E71,
  tO,
  D71,
  W71,
  wp,
  cO = x(() => {
    "use strict";

    f1();
    v0();
    M2();
    P1();
    Or = require("@theatre/dataverse");
    H2();
    b5 = I(G());
    c1();
    hh();
    G1();
    aO = B.circle(YZ || (YZ = V(["\n  stroke-width: 1px;\n  vector-effect: non-scaling-stroke;\n  fill: var(--main-color);\n  r: 2px;\n  pointer-events: none;\n"]))), E71 = B.circle(JZ || (JZ = V(["\n  stroke-width: 6px;\n  vector-effect: non-scaling-stroke;\n  r: 6px;\n  fill: transparent;\n  cursor: move;\n  ", ";\n  &:hover {\n  }\n  &:hover + ", " {\n    r: 6px;\n  }\n"])), C1, aO), D71 = B.path(tO || (tO = V(["\n  stroke-width: 1;\n  stroke: var(--main-color);\n  /* stroke: gray; */\n  fill: none;\n  vector-effect: non-scaling-stroke;\n"]))), W71 = t => {
      let [a, c] = z1(null),
        {
          index: r,
          trackData: e
        } = t,
        l = e.keyframes[r],
        i = e.keyframes[r + 1],
        [o] = j71(c, t);
      _71(c, t);
      let n = t.which === "left" ? l.handles[2] : i.handles[0],
        h = l.position + (i.position - l.position) * n,
        v = t.which === "left" ? l.handles[3] : i.handles[1],
        g = t.isScalar ? l.value : 0,
        s = t.isScalar ? i.value : 1,
        d = g + (s - g) * v,
        z = t.extremumSpace.fromValueSpace(d),
        u = z - t.extremumSpace.fromValueSpace(t.which === "left" ? g : s),
        f = Zr(t.which === "left" ? l.position : i.position, t.extremumSpace.fromValueSpace(t.which === "left" ? g : s), h - (t.which === "left" ? l.position : i.position), u);
      return b5.default.createElement("g", null, b5.default.createElement(E71, {
        ref: a,
        style: {
          cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(h, " * 1px)"),
          cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(z, ") * 1px)")
        }
      }), b5.default.createElement(aO, {
        style: {
          cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(h, " * 1px)"),
          cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(z, ") * 1px)")
        }
      }), b5.default.createElement(D71, {
        d: "M 0 0 L 1 1",
        style: {
          transform: f
        }
      }), o);
    }, wp = W71;
  });
function U71(t) {
  let [a, c] = (0, g4.useState)(!1);
  g0(a, t.props.keyframe.position);
  let r = (0, g4.useRef)(t.props);
  r.current = t.props;
  let e = (0, g4.useMemo)(() => ({
    debugName: "GraphEditorDotScalar/useDragKeyframe",
    lockCSSCursorTo: "move",
    onDragStart(l) {
      c(!0);
      let i = !!l.altKey,
        o = r.current,
        n = (0, vh.val)(o.layoutP.scaledSpace.toUnitSpace),
        h = (0, vh.val)(o.layoutP.graphEditorVerticalSpace.toExtremumSpace),
        v = o.extremumSpace.lock(),
        g;
      return {
        onDrag(s, d) {
          let z = o.trackData.keyframes[o.index],
            u = n(s),
            f = -d,
            p = h(f),
            m = o.extremumSpace.deltaToValueSpace(p),
            M = [],
            w = D(S({}, z), {
              position: z.position + u,
              value: z.value + m,
              handles: [...z.handles]
            });
          if (M.push(w), i) {
            let H = o.trackData.keyframes[o.index - 1];
            if (H && Math.abs(z.value - H.value) > 0) {
              let k = D(S({}, H), {
                handles: [...H.handles]
              });
              M.push(k), k.handles[3] = $71(H.handles[3], H.value, H.value, z.value, w.value);
            }
            let y = o.trackData.keyframes[o.index + 1];
            if (y && Math.abs(z.value - y.value) > 0) {
              let k = D(S({}, y), {
                handles: [...y.handles]
              });
              M.push(k), k.handles[1] = Q71(k.handles[1], k.value, k.value, z.value, w.value);
            }
          }
          g == null || g.discard(), g = T().tempTransaction(({
            stateEditors: H
          }) => {
            H.coreByProject.historic.sheetsById.sequence.replaceKeyframes(D(S({}, o.sheetObject.address), {
              trackId: o.trackId,
              keyframes: M,
              snappingFunction: (0, vh.val)(o.layoutP.sheet).getSequence().closestGridPosition
            }));
          });
        },
        onDragEnd(s) {
          c(!1), v(), s ? g == null || g.commit() : (g == null || g.discard(), t.onDetectedClick(l));
        }
      };
    }
  }), []);
  return S1(t.node, e), s2(a, "draggingPositionInSequenceEditor", "move"), a;
}
function K71(t, a) {
  return Z1(t, {
    menuItems: () => [{
      label: "Delete",
      callback: () => {
        T().transaction(({
          stateEditors: c
        }) => {
          c.coreByProject.historic.sheetsById.sequence.deleteKeyframes(D(S({}, a.sheetObject.address), {
            keyframeIds: [a.keyframe.id],
            trackId: a.trackId
          }));
        });
      }
    }]
  });
}
function $71(t, a, c, r, e) {
  return (r - a) * t / (e - c);
}
function Q71(t, a, c, r, e) {
  return ((a - r) * t + r - a + c - e) / (c - e);
}
var vh,
  g4,
  rO,
  lO,
  eO,
  q71,
  N71,
  iO,
  oO = x(() => {
    "use strict";

    f1();
    v0();
    M2();
    P1();
    vh = require("@theatre/dataverse"), g4 = I(G());
    c1();
    E2();
    E2();
    G1();
    I0();
    b3();
    br();
    K6();
    lO = B.circle(rO || (rO = V(["\n  fill: var(--main-color);\n  stroke-width: 1px;\n  vector-effect: non-scaling-stroke;\n\n  r: 2px;\n"]))), q71 = B.circle(eO || (eO = V(["\n  stroke-width: 6px;\n  vector-effect: non-scaling-stroke;\n  r: 6px;\n  fill: transparent;\n  ", ";\n\n  &:hover + ", " {\n    r: 6px;\n  }\n\n  #pointer-root.normal & {\n    cursor: move;\n  }\n\n  #pointer-root.draggingPositionInSequenceEditor & {\n    pointer-events: auto;\n    cursor: var(", ");\n  }\n\n  &.beingDragged {\n    pointer-events: none !important;\n  }\n"])), C1, lO, F0), N71 = t => {
      let [a, c] = z1(null),
        {
          index: r,
          trackData: e
        } = t,
        l = e.keyframes[r],
        [i] = K71(c, t),
        o = i3(t.itemKey),
        n = l.value,
        h = t.extremumSpace.fromValueSpace(n),
        v = e8([{
          type: "primitiveProp",
          keyframe: t.keyframe,
          pathToProp: t.pathToProp,
          propConfig: t.propConfig,
          sheetObject: t.sheetObject,
          trackId: t.trackId
        }]),
        g = U71({
          node: c,
          props: t,
          onDetectedClick: s => v.toggle(s, s.target instanceof Element ? s.target : c)
        });
      return g4.default.createElement(g4.default.Fragment, null, g4.default.createElement(q71, D(S(S(S({
        ref: a,
        style: {
          cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(l.position, " * 1px)"),
          cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(h, ") * 1px)")
        }
      }, O2(l.position)), r2.includePositionSnapAttrs(l.position)), o.attrs), {
        className: g ? "beingDragged" : ""
      })), g4.default.createElement(lO, {
        style: {
          cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(l.position, " * 1px)"),
          cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(h, ") * 1px)"),
          fill: o.flag === 2 ? "white" : void 0
        }
      }), v.node, i);
    }, iO = N71;
  });
function J71(t) {
  let [a, c] = (0, d4.useState)(!1);
  g0(a, t.props.keyframe.position);
  let r = (0, d4.useRef)(t.props);
  r.current = t.props;
  let e = (0, d4.useMemo)(() => ({
    debugName: "GraphEditorDotNonScalar/useDragKeyframe",
    lockCSSCursorTo: "ew-resize",
    onDragStart(l) {
      c(!0);
      let i = r.current,
        o = (0, Bp.val)(i.layoutP.scaledSpace.toUnitSpace),
        n = i.extremumSpace.lock(),
        h;
      return {
        onDrag(v, g) {
          let s = i.trackData.keyframes[i.index],
            d = o(v),
            z = [],
            u = D(S({}, s), {
              position: s.position + d,
              value: s.value,
              handles: [...s.handles]
            });
          z.push(u), h == null || h.discard(), h = T().tempTransaction(({
            stateEditors: f
          }) => {
            f.coreByProject.historic.sheetsById.sequence.replaceKeyframes(D(S({}, i.sheetObject.address), {
              trackId: i.trackId,
              keyframes: z,
              snappingFunction: (0, Bp.val)(i.layoutP.sheet).getSequence().closestGridPosition
            }));
          });
        },
        onDragEnd(v) {
          c(!1), n(), v ? h == null || h.commit() : (h == null || h.discard(), t.onDetectedClick(l));
        }
      };
    }
  }), []);
  return S1(t.node, e), s2(a, "draggingPositionInSequenceEditor", "ew-resize"), a;
}
function t91(t, a) {
  return Z1(t, {
    menuItems: () => [{
      label: "Delete",
      callback: () => {
        T().transaction(({
          stateEditors: c
        }) => {
          c.coreByProject.historic.sheetsById.sequence.deleteKeyframes(D(S({}, a.sheetObject.address), {
            keyframeIds: [a.keyframe.id],
            trackId: a.trackId
          }));
        });
      }
    }]
  });
}
var Bp,
  d4,
  nO,
  vO,
  hO,
  X71,
  Y71,
  yp,
  gO = x(() => {
    "use strict";

    f1();
    v0();
    M2();
    P1();
    Bp = require("@theatre/dataverse"), d4 = I(G());
    c1();
    E2();
    E2();
    G1();
    I0();
    b3();
    br();
    K6();
    vO = B.circle(nO || (nO = V(["\n  fill: var(--main-color);\n  stroke-width: 1px;\n  vector-effect: non-scaling-stroke;\n\n  r: 2px;\n"]))), X71 = B.circle(hO || (hO = V(["\n  stroke-width: 6px;\n  vector-effect: non-scaling-stroke;\n  r: 6px;\n  fill: transparent;\n  ", ";\n\n  &:hover + ", " {\n    r: 6px;\n  }\n\n  #pointer-root.normal & {\n    cursor: ew-resize;\n  }\n\n  #pointer-root.draggingPositionInSequenceEditor & {\n    pointer-events: auto;\n    cursor: var(", ");\n  }\n\n  &.beingDragged {\n    pointer-events: none !important;\n  }\n"])), C1, vO, F0), Y71 = t => {
      let [a, c] = z1(null),
        {
          index: r,
          trackData: e,
          itemKey: l
        } = t,
        i = e.keyframes[r],
        [o] = t91(c, t),
        n = i3(l),
        h = t.which === "left" ? 0 : 1,
        v = e8([{
          type: "primitiveProp",
          keyframe: t.keyframe,
          pathToProp: t.pathToProp,
          propConfig: t.propConfig,
          sheetObject: t.sheetObject,
          trackId: t.trackId
        }]),
        g = J71({
          node: c,
          props: t,
          onDetectedClick: d => v.toggle(d, d.target instanceof Element ? d.target : c)
        }),
        s = t.extremumSpace.fromValueSpace(h);
      return d4.default.createElement(d4.default.Fragment, null, d4.default.createElement(X71, D(S(S(S({
        ref: a,
        style: {
          cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(i.position, " * 1px)"),
          cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(s, ") * 1px)")
        }
      }, n.attrs), O2(i.position)), r2.includePositionSnapAttrs(i.position)), {
        className: g ? "beingDragged" : ""
      })), d4.default.createElement(vO, {
        style: {
          cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(i.position, " * 1px)"),
          cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(s, ") * 1px)"),
          fill: n.flag === 2 ? "white" : void 0
        }
      }), v.node, o);
    }, yp = Y71;
  });
var gh,
  dO,
  a91,
  c91,
  sO,
  zO = x(() => {
    "use strict";

    gh = I(G());
    c1();
    hh();
    a91 = B.path(dO || (dO = V(["\n  stroke-width: 2;\n  stroke: var(--main-color);\n  stroke-dasharray: 3 2;\n  fill: none;\n  vector-effect: non-scaling-stroke;\n  opacity: 0.3;\n"]))), c91 = t => {
      let {
          index: a,
          trackData: c
        } = t,
        r = "M 0 0 L 1 1",
        e = Zr(c.keyframes[a].position, t.extremumSpace.fromValueSpace(0), 0, t.extremumSpace.fromValueSpace(1) - t.extremumSpace.fromValueSpace(0));
      return gh.default.createElement(gh.default.Fragment, null, gh.default.createElement(a91, {
        d: r,
        style: {
          transform: e
        }
      }));
    }, sO = c91;
  });
var X2,
  uO,
  r91,
  e91,
  l91,
  pO,
  mO = x(() => {
    "use strict";

    X2 = I(G());
    c1();
    hh();
    cO();
    oO();
    gO();
    zO();
    r91 = B.g(uO || (uO = V(["\n  /* position: absolute; */\n"]))), e91 = X2.default.createElement(X2.default.Fragment, null), l91 = t => {
      let {
          index: a,
          trackData: c,
          isScalar: r
        } = t,
        e = c.keyframes[a],
        l = c.keyframes[a + 1],
        o = e.connectedRight && !!l && l.value !== e.value;
      return X2.default.createElement(r91, null, o ? X2.default.createElement(X2.default.Fragment, null, X2.default.createElement(XZ, S({}, t)), !e.type || e.type === "bezier" && X2.default.createElement(X2.default.Fragment, null, X2.default.createElement(wp, D(S({}, t), {
        which: "left"
      })), X2.default.createElement(wp, D(S({}, t), {
        which: "right"
      })))) : e91, r ? X2.default.createElement(iO, S({}, t)) : X2.default.createElement(X2.default.Fragment, null, X2.default.createElement(yp, D(S({}, t), {
        which: "left"
      })), X2.default.createElement(yp, D(S({}, t), {
        which: "right"
      })), X2.default.createElement(sO, S({}, t))));
    }, pO = l91;
  });
function o91(t, a) {
  let c = 1 / 0,
    r = -1 / 0;
  function e(l) {
    c = Math.min(l, c), r = Math.max(l, r);
  }
  return t.forEach((l, i) => {
    let o = X8(l.value, a);
    if (e(o), !l.connectedRight) return;
    let n = t[i + 1];
    if (!n) return;
    let h = (typeof n.value == "number" ? n.value : 1) - o;
    e(o + l.handles[3] * h), e(o + n.handles[1] * h);
  }), [c, r];
}
function n91(t) {
  let a = 0,
    c = 1;
  function r(e) {
    a = Math.min(e, a), c = Math.max(e, c);
  }
  return t.forEach((e, l) => {
    if (!e.connectedRight) return;
    let i = t[l + 1];
    i && (r(e.handles[3]), r(i.handles[1]));
  }), [a, c];
}
var v3,
  i91,
  fO,
  MO = x(() => {
    "use strict";

    O4();
    v3 = I(G());
    Er();
    mO();
    H5();
    M1();
    i91 = v3.default.memo(({
      layoutP: t,
      trackData: a,
      sheetObject: c,
      trackId: r,
      color: e,
      pathToProp: l
    }) => {
      let i = U9(s1(c.template.configPointer), l);
      if (G0(i)) return console.error("Composite prop types cannot be keyframed"), v3.default.createElement(v3.default.Fragment, null);
      let [o, n] = (0, v3.useState)(!1),
        h = (0, v3.useMemo)(() => {
          let d = new Set();
          return function () {
            let u = d.size === 0;
            d.add(f), u && n(!0);
            function f() {
              let p = d.size > 0;
              d.delete(f), p && d.size === 0 && n(!1);
            }
            return f;
          };
        }, []),
        v = (0, v3.useMemo)(() => {
          let d = i.type === "number" ? o91(a.keyframes, i) : n91(a.keyframes),
            z = p => (p - d[0]) / (d[1] - d[0]),
            u = p => d[0] + f(p),
            f = p => p * (d[1] - d[0]);
          return {
            fromValueSpace: z,
            toValueSpace: u,
            deltaToValueSpace: f,
            lock: h
          };
        }, [a.keyframes]),
        g = (0, v3.useRef)(void 0);
      o || (g.current = v);
      let s = a.keyframes.map((d, z) => v3.default.createElement(pO, {
        pathToProp: l,
        propConfig: i,
        itemKey: c2.forTrackKeyframe(c, r, d.id),
        keyframe: d,
        index: z,
        trackData: a,
        layoutP: t,
        sheetObject: c,
        trackId: r,
        isScalar: i.type === "number",
        key: d.id,
        extremumSpace: g.current,
        color: e
      }));
      return v3.default.createElement("g", {
        style: {
          "--main-color": v7[e].iconColor
        }
      }, s);
    }), fO = i91;
  });
var xO,
  dh,
  h91,
  CO,
  LO = x(() => {
    "use strict";

    f1();
    M1();
    xO = require("@theatre/dataverse"), dh = I(G());
    MO();
    h91 = t => v1(() => {
      let {
          sheetObject: a,
          trackId: c
        } = t,
        r = (0, xO.val)(T().atomP.historic.coreByProject[a.address.projectId].sheetsById[a.address.sheetId].sequence.tracksByObject[a.address.objectKey].trackData[c]);
      return (r == null ? void 0 : r.type) !== "BasicKeyframedTrack" ? (console.error("trackData type ".concat(r == null ? void 0 : r.type, " is not yet supported on the graph editor")), dh.default.createElement(dh.default.Fragment, null)) : dh.default.createElement(fO, D(S({}, t), {
        trackData: r
      }));
    }, [t.trackId, t.layoutP]), CO = h91;
  });
function Dr({
  clippedSpaceRange: t,
  clippedSpaceWidth: a,
  fps: c,
  gapWidth: r = 120
}, e) {
  let l = 1 / c,
    i = t.end - t.start,
    o = a / (c * i),
    n = Math.floor(r / o),
    v = (n < c ? v91(c).find(d => d >= n) : c * Math.floor(n / c)) * l,
    g = Math.floor(t.start / v),
    s = Math.ceil(t.end / v);
  for (let d = g; d <= s; d++) {
    let z = d * v,
      u = z % 1 === 0;
    e(z, u);
  }
}
var v91,
  Sp = x(() => {
    "use strict";

    H2();
    v91 = sa(t => {
      let a = [];
      for (let c = 1; c <= t; c++) t % c === 0 && a.push(c);
      return a;
    });
  });
function m91(t) {
  let {
    clippedSpaceWidth: a,
    height: c,
    ctx: r,
    unitSpaceToClippedSpace: e,
    snapToGrid: l
  } = t;
  r.clearRect(0, 0, a, c), Dr(t, (i, o) => {
    let n = l(i),
      h = Math.floor(e(n));
    r.strokeStyle = o ? "rgba(225, 225, 225, 0.04)" : "rgba(255, 255, 255, 0.01)", r.beginPath(), r.moveTo(h, 0), r.lineTo(h, c), r.stroke(), r.closePath();
  });
}
var i8,
  s4,
  HO,
  g91,
  VO,
  d91,
  s91,
  z91,
  u91,
  p91,
  sh,
  kp = x(() => {
    "use strict";

    i8 = require("@theatre/dataverse"), s4 = I(G());
    c1();
    Sp();
    f1();
    g91 = B.div(HO || (HO = V(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  pointer-events: none;\n"]))), d91 = B.canvas(VO || (VO = V(["\n  position: relative;\n  left: 0;\n"]))), s91 = t => {
      let a = t;
      return a.webkitBackingStorePixelRatio || a.mozBackingStorePixelRatio || a.msBackingStorePixelRatio || a.oBackingStorePixelRatio || a.backingStorePixelRatio || 1;
    }, z91 = () => window.devicePixelRatio || 1, u91 = t => z91() / s91(t), p91 = ({
      layoutP: t,
      width: a,
      height: c
    }) => {
      let r = (0, s4.useRef)(null),
        [e, l] = (0, s4.useState)(null),
        {
          ctx: i,
          ratio: o
        } = (0, s4.useMemo)(() => {
          if (!e) return {};
          let n = e.getContext("2d"),
            h = u91(n);
          return {
            ctx: n,
            ratio: h
          };
        }, [e]);
      return (0, s4.useLayoutEffect)(() => {
        if (!i) return;
        e.width = a * o, e.height = c * o;
        let n = (0, i8.prism)(() => {
          let h = (0, i8.val)(t.sheet).getSequence();
          return {
            ctx: i,
            clippedSpaceRange: (0, i8.val)(t.clippedSpace.range),
            clippedSpaceWidth: (0, i8.val)(t.clippedSpace.width),
            unitSpaceToClippedSpace: (0, i8.val)(t.clippedSpace.fromUnitSpace),
            height: c,
            leftPadding: (0, i8.val)(t.scaledSpace.leftPadding),
            fps: h.subUnitsPerUnit,
            snapToGrid: v => h.closestGridPosition(v)
          };
        }).onChange(T().ticker, h => {
          i.save(), i.scale(o, o), m91(h), i.restore();
        }, !0);
        return () => {
          n();
        };
      }, [i, a, c, t]), s4.default.createElement(g91, {
        ref: r,
        style: {
          width: a + "px"
        }
      }, s4.default.createElement(d91, {
        ref: l,
        style: {
          width: a + "px",
          height: c + "px"
        }
      }));
    }, sh = p91;
  });
var N4,
  g7,
  v7,
  wO,
  f91,
  BO,
  M91,
  x91,
  yO,
  Er = x(() => {
    "use strict";

    f1();
    o4();
    rr();
    M1();
    N4 = require("@theatre/dataverse"), g7 = I(G());
    c1();
    Vp();
    rp();
    LO();
    kp();
    R0();
    v7 = {
      1: {
        iconColor: "#b98b08"
      },
      2: {
        iconColor: "#70a904"
      },
      3: {
        iconColor: "#2e928a"
      },
      4: {
        iconColor: "#a943bb"
      },
      5: {
        iconColor: "#b90808"
      },
      6: {
        iconColor: "#b4bf0e"
      }
    }, f91 = B.div(wO || (wO = V(["\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  background: ", ";\n"])), N2(.03, "#1a1c1e")), M91 = B.svg(BO || (BO = V(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  margin: 0;\n  pointer-events: none;\n"]))), x91 = ({
      layoutP: t
    }) => v1(() => {
      let a = (0, N4.val)(t.sheet),
        c = (0, N4.val)(T().atomP.historic.projects.stateByProjectId[a.address.projectId].stateBySheetId[a.address.sheetId].sequenceEditor.selectedPropsByObject),
        r = (0, N4.val)(t.graphEditorDims.height),
        e = (0, N4.val)(t.scaledSpace.fromUnitSpace)(1),
        l = [];
      if (c) for (let [o, n] of Object.entries(c)) {
        let h = a.getObject(o);
        if (!h) continue;
        let v = (0, N4.val)(h.template.getMapOfValidSequenceTracks_forStudio());
        for (let [g, s] of Object.entries(n)) {
          let d = ut(g),
            z = l3(v, d);
          z && l.push(g7.default.createElement(CO, {
            key: "graph-".concat(o, "-").concat(g),
            sheetObject: h,
            pathToProp: d,
            layoutP: t,
            trackId: z,
            color: s
          }));
        }
      }
      let i = (0, N4.val)(t.rightDims.width);
      return g7.default.createElement(f91, {
        style: {
          width: i + "px",
          height: r + "px",
          "--unitSpaceToScaledSpaceMultiplier": e,
          "--graphEditorVerticalSpace": "".concat((0, N4.val)(t.graphEditorVerticalSpace.space))
        }
      }, g7.default.createElement(sh, {
        layoutP: t,
        width: i,
        height: r
      }), g7.default.createElement(On, {
        layoutP: t,
        height: r
      }, g7.default.createElement(M91, {
        width: oh,
        height: r,
        viewBox: "0 0 ".concat(oh, " ").concat(r)
      }, g7.default.createElement("g", {
        style: {
          transform: "translate(".concat((0, N4.val)(t.scaledSpace.leftPadding), "px, ").concat((0, N4.val)(t.graphEditorDims.padding.top), "px)")
        }
      }, l))));
    }, [t]), yO = x91;
  });
var bO,
  W0,
  C91,
  SO,
  L91,
  kO,
  FO,
  AO,
  H91,
  V91,
  RO,
  w91,
  B91,
  IO,
  PO = x(() => {
    "use strict";

    f1();
    o4();
    er();
    M1();
    bO = require("@theatre/dataverse"), W0 = I(G());
    c1();
    Xo();
    ir();
    Er();
    Mr();
    N6();
    _u();
    C91 = {
      label: {
        color: "#9a9a9a"
      }
    }, L91 = B(ju)(SO || (SO = V([""]))), FO = B(qu)(kO || (kO = V(["\n  display: flex;\n  color: ", ";\n  padding-right: 12px;\n  align-items: center;\n  justify-content: flex-end;\n  box-sizing: border-box;\n"])), C91.label.color), H91 = B.button(AO || (AO = V(["\n  background: none;\n  border: none;\n  outline: none;\n  display: flex;\n  box-sizing: border-box;\n  font-size: 14px;\n  align-items: center;\n  height: 100%;\n  margin-left: 12px;\n  color: ", ";\n\n  &:not([disabled]):hover {\n    color: white;\n  }\n"])), t => t.isSelected ? v7[t.graphEditorColor].iconColor : V5.offColor), V91 = () => W0.default.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "10",
      height: "12",
      viewBox: "0 0 640 512"
    }, W0.default.createElement("g", {
      transform: "translate(0 100)"
    }, W0.default.createElement("path", {
      fill: "currentColor",
      d: "M368 32h-96c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32V64c0-17.67-14.33-32-32-32zM208 88h-84.75C113.75 64.56 90.84 48 64 48 28.66 48 0 76.65 0 112s28.66 64 64 64c26.84 0 49.75-16.56 59.25-40h79.73c-55.37 32.52-95.86 87.32-109.54 152h49.4c11.3-41.61 36.77-77.21 71.04-101.56-3.7-8.08-5.88-16.99-5.88-26.44V88zm-48 232H64c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32v-96c0-17.67-14.33-32-32-32zM576 48c-26.84 0-49.75 16.56-59.25 40H432v72c0 9.45-2.19 18.36-5.88 26.44 34.27 24.35 59.74 59.95 71.04 101.56h49.4c-13.68-64.68-54.17-119.48-109.54-152h79.73c9.5 23.44 32.41 40 59.25 40 35.34 0 64-28.65 64-64s-28.66-64-64-64zm0 272h-96c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32v-96c0-17.67-14.33-32-32-32z"
    }))), w91 = B.span(RO || (RO = V(["\n  margin-right: 4px;\n  ", ";\n\n  ", ":hover & {\n    color: #ccc;\n  }\n"])), T0, FO), B91 = ({
      leaf: t
    }) => {
      var g;
      let a = Z4(t.sheetObject.propsP, t.pathToProp),
        c = t.sheetObject,
        {
          controlIndicators: r
        } = rt(a, c, t.propConf),
        e = v1(() => {
          let s = t.sheetObject.address,
            d = h3(t.pathToProp);
          return (0, bO.val)(T().atomP.historic.projects.stateByProjectId[s.projectId].stateBySheetId[s.sheetId].sequenceEditor.selectedPropsByObject[s.objectKey][d]);
        }, [t]),
        l = (0, W0.useRef)(!1),
        i = typeof e == "string";
      l.current = i;
      let o = (0, W0.useCallback)(() => {
          let s = t.sheetObject.address;
          T().transaction(({
            stateEditors: d
          }) => {
            l.current ? d.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removePropFromGraphEditor(D(S({}, s), {
              pathToProp: t.pathToProp
            })) : (d.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.addPropToGraphEditor(D(S({}, s), {
              pathToProp: t.pathToProp
            })), d.studio.historic.panels.sequenceEditor.graphEditor.setIsOpen({
              isOpen: !0
            }));
          });
        }, [t]),
        n = (g = t.propConf.label) != null ? g : t.pathToProp[t.pathToProp.length - 1],
        h = !0,
        v = (0, W0.useRef)(null);
      return wn(v.current, t), W0.default.createElement(L91, {
        depth: t.depth
      }, W0.default.createElement(FO, {
        ref: v,
        isEven: t.n % 2 === 0,
        style: {
          height: t.nodeHeight + "px"
        },
        isSelected: i === !0
      }, W0.default.createElement(w91, null, n), r, W0.default.createElement(H91, {
        onClick: o,
        isSelected: i === !0,
        graphEditorColor: e != null ? e : "1",
        style: {
          opacity: h ? 1 : .25
        },
        disabled: !h
      }, W0.default.createElement(V91, null))));
    }, IO = B91;
  });
function Bt(t, a) {
  T().transaction(({
    stateEditors: c
  }) => {
    c.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.sequenceEditorCollapsableItems.set(D(S({}, a.sheetAddress), {
      studioSheetItemKey: a.sheetItemKey,
      isCollapsed: t
    }));
  });
}
var zh = x(() => {
  "use strict";

  f1();
});
var yt,
  Ap,
  y91,
  GO = x(() => {
    "use strict";

    yt = I(G());
    Mr();
    PO();
    zh();
    Ap = t => {
      let a = "prop" + t.pathToProp[t.pathToProp.length - 1];
      return t.shouldRender ? t.type === "propWithChildren" ? yt.default.createElement(y91, {
        leaf: t,
        key: a
      }) : yt.default.createElement(IO, {
        leaf: t,
        key: a
      }) : yt.default.createElement(yt.default.Fragment, {
        key: a
      });
    }, y91 = ({
      leaf: t
    }) => yt.default.createElement(zt, {
      leaf: t,
      label: t.pathToProp[t.pathToProp.length - 1],
      isCollapsed: t.isCollapsed,
      toggleCollapsed: () => Bt(!t.isCollapsed, {
        sheetAddress: t.sheetObject.address,
        sheetItemKey: t.sheetItemKey
      })
    }, t.children.map(a => Ap(a)));
  });
var TO,
  S91,
  ZO,
  OO = x(() => {
    "use strict";

    TO = I(G());
    Mr();
    GO();
    zh();
    f1();
    S91 = ({
      leaf: t
    }) => TO.default.createElement(zt, {
      leaf: t,
      label: t.sheetObject.address.objectKey,
      isCollapsed: t.isCollapsed,
      toggleSelect: () => {
        T().transaction(({
          stateEditors: a
        }) => {
          a.studio.historic.panels.outline.selection.set([t.sheetObject]);
        });
      },
      toggleCollapsed: () => Bt(!t.isCollapsed, {
        sheetAddress: t.sheetObject.address,
        sheetItemKey: t.sheetItemKey
      })
    }, t.children.map(a => Ap(a))), ZO = S91;
  });
var Rp,
  k91,
  EO,
  DO = x(() => {
    "use strict";

    M1();
    Rp = I(G());
    OO();
    Mr();
    zh();
    wu();
    k91 = ({
      leaf: t
    }) => v1(() => Rp.default.createElement(zt, {
      leaf: t,
      label: t.sheet.address.sheetId,
      isCollapsed: t.isCollapsed,
      toggleCollapsed: () => {
        Bt(!t.isCollapsed, {
          sheetAddress: t.sheet.address,
          sheetItemKey: t.sheetItemKey
        });
      }
    }, t.children.map(a => Rp.default.createElement(ZO, {
      key: "sheetObject-" + hr(a.sheetObject),
      leaf: a
    }))), [t]), EO = k91;
  });
var bp,
  uh,
  WO,
  A91,
  _O,
  R91,
  b91,
  jO,
  qO = x(() => {
    "use strict";

    M1();
    bp = require("@theatre/dataverse"), uh = I(G());
    c1();
    DO();
    A91 = B.div(WO || (WO = V(["\n  position: absolute;\n  left: 0;\n  overflow-x: visible;\n"]))), R91 = B.ul(_O || (_O = V(["\n  margin: 0;\n  padding: 0;\n  list-style: none;\n"]))), b91 = ({
      layoutP: t
    }) => v1(() => {
      let a = (0, bp.val)(t.tree),
        c = (0, bp.val)(t.leftDims.width);
      return uh.default.createElement(A91, {
        style: {
          width: c + "px",
          top: a.top + "px"
        }
      }, uh.default.createElement(R91, null, uh.default.createElement(EO, {
        leaf: a
      })));
    }, [t]), jO = b91;
  });
var Fp,
  NO,
  F91,
  I91,
  UO,
  KO = x(() => {
    "use strict";

    G1();
    W4();
    M1();
    R0();
    Fp = I(G());
    c1();
    kp();
    F91 = B.div(NO || (NO = V(["\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  z-index: ", ";\n  overflow: hidden;\n  background: ", ";\n  pointer-events: none;\n"])), () => K2.rightBackground, N2(.01, A6(1 * .03, Z6.panel.bg))), I91 = ({
      layoutP: t
    }) => {
      let a = s1(t.rightDims.width),
        c = s1(t.panelDims.height);
      return Fp.default.createElement(F91, {
        style: {
          width: a + "px"
        }
      }, Fp.default.createElement(sh, {
        width: a,
        height: c,
        layoutP: t
      }));
    }, UO = I91;
  });
var St,
  $O,
  P91,
  G91,
  QO,
  XO = x(() => {
    "use strict";

    M1();
    St = I(G());
    c1();
    qO();
    KO();
    Vp();
    Yu();
    P91 = B.div($O || ($O = V(["\n  position: absolute;\n  left: 0;\n  right: 0;\n"]))), G91 = ({
      layoutP: t
    }) => {
      let a = s1(t.dopeSheetDims.height);
      return St.default.createElement(P91, {
        style: {
          height: a + "px"
        }
      }, St.default.createElement(UO, {
        layoutP: t
      }), St.default.createElement(FG, null, St.default.createElement(jO, {
        layoutP: t
      }), St.default.createElement($Z, {
        layoutP: t
      })));
    }, QO = G91;
  });
function Pp(t, a, c) {
  return Ip.prism.memo(t, () => (0, Ip.prism)(a), c).getValue();
}
var Ip,
  YO = x(() => {
    "use strict";

    Ip = require("@theatre/dataverse");
  });
function Q1(t) {
  return function (c, r) {
    return t(c, r());
  };
}
function d3(t) {
  return Object.freeze({
    audience: d7(t, 8) ? "internal" : d7(t, 16) ? "dev" : "public",
    category: d7(t, 4) ? "troubleshooting" : d7(t, 2) ? "todo" : "general",
    level: d7(t, 512) ? 512 : d7(t, 256) ? 256 : d7(t, 128) ? 128 : 64
  });
}
function d7(t, a) {
  return (t & a) === a;
}
function X1(t, a) {
  return ((a & 32) === 32 ? !0 : (a & 16) === 16 ? t.dev : (a & 8) === 8 ? t.internal : !1) && t.min <= a;
}
function Wr(t = console, a = {}) {
  let c = D(S({}, F5), {
      includes: S({}, F5.includes)
    }),
    r = {
      styled: O91.bind(c, t),
      noStyle: D91.bind(c, t)
    },
    e = Z91.bind(c);
  function l() {
    return c.loggingConsoleStyle && c.loggerConsoleStyle ? r.styled : r.noStyle;
  }
  return c.create = l(), {
    configureLogger(i) {
      var o;
      i === "console" ? (c.loggerConsoleStyle = F5.loggerConsoleStyle, c.create = l()) : i.type === "console" ? (c.loggerConsoleStyle = (o = i.style) != null ? o : F5.loggerConsoleStyle, c.create = l()) : i.type === "keyed" ? (c.creatExt = n => i.keyed(n.names), c.create = e) : i.type === "named" && (c.creatExt = T91.bind(null, i.named), c.create = e);
    },
    configureLogging(i) {
      var o, n, h, v, g;
      c.includes.dev = (o = i.dev) != null ? o : F5.includes.dev, c.includes.internal = (n = i.internal) != null ? n : F5.includes.internal, c.includes.min = (h = i.min) != null ? h : F5.includes.min, c.include = (v = i.include) != null ? v : F5.include, c.loggingConsoleStyle = (g = i.consoleStyle) != null ? g : F5.loggingConsoleStyle, c.create = l();
    },
    getLogger() {
      return c.create({
        names: []
      });
    }
  };
}
function T91(t, a) {
  let c = [];
  for (let {
    name: r,
    key: e
  } of a.names) c.push(e == null ? r : "".concat(r, " (").concat(e, ")"));
  return t(c);
}
function Z91(t) {
  let a = S(S({}, this.includes), this.include(t)),
    c = this.filtered,
    r = this.named.bind(this, t),
    e = this.creatExt(t),
    l = X1(a, 524),
    i = X1(a, 522),
    o = X1(a, 521),
    n = X1(a, 529),
    h = X1(a, 545),
    v = X1(a, 265),
    g = X1(a, 268),
    s = X1(a, 273),
    d = X1(a, 289),
    z = X1(a, 137),
    u = X1(a, 145),
    f = X1(a, 73),
    p = X1(a, 81),
    m = l ? e.error.bind(e, g3._hmm) : c.bind(t, 524),
    M = i ? e.error.bind(e, g3._todo) : c.bind(t, 522),
    w = o ? e.error.bind(e, g3._error) : c.bind(t, 521),
    H = n ? e.error.bind(e, g3.errorDev) : c.bind(t, 529),
    y = h ? e.error.bind(e, g3.errorPublic) : c.bind(t, 545),
    k = g ? e.warn.bind(e, g3._kapow) : c.bind(t, 268),
    F = v ? e.warn.bind(e, g3._warn) : c.bind(t, 265),
    U = s ? e.warn.bind(e, g3.warnDev) : c.bind(t, 273),
    A = d ? e.warn.bind(e, g3.warnPublic) : c.bind(t, 273),
    P = z ? e.debug.bind(e, g3._debug) : c.bind(t, 137),
    C = u ? e.debug.bind(e, g3.debugDev) : c.bind(t, 145),
    E = f ? e.trace.bind(e, g3._trace) : c.bind(t, 73),
    a1 = p ? e.trace.bind(e, g3.traceDev) : c.bind(t, 81),
    j = {
      _hmm: m,
      _todo: M,
      _error: w,
      errorDev: H,
      errorPublic: y,
      _kapow: k,
      _warn: F,
      warnDev: U,
      warnPublic: A,
      _debug: P,
      debugDev: C,
      _trace: E,
      traceDev: a1,
      lazy: {
        _hmm: l ? Q1(m) : m,
        _todo: i ? Q1(M) : M,
        _error: o ? Q1(w) : w,
        errorDev: n ? Q1(H) : H,
        errorPublic: h ? Q1(y) : y,
        _kapow: g ? Q1(k) : k,
        _warn: v ? Q1(F) : F,
        warnDev: s ? Q1(U) : U,
        warnPublic: d ? Q1(A) : A,
        _debug: z ? Q1(P) : P,
        debugDev: u ? Q1(C) : C,
        _trace: f ? Q1(E) : E,
        traceDev: p ? Q1(a1) : a1
      },
      named: r,
      utilFor: {
        internal() {
          return {
            debug: j._debug,
            error: j._error,
            warn: j._warn,
            trace: j._trace,
            named(K, Z) {
              return j.named(K, Z).utilFor.internal();
            }
          };
        },
        dev() {
          return {
            debug: j.debugDev,
            error: j.errorDev,
            warn: j.warnDev,
            trace: j.traceDev,
            named(K, Z) {
              return j.named(K, Z).utilFor.dev();
            }
          };
        },
        public() {
          return {
            error: j.errorPublic,
            warn: j.warnPublic,
            debug(K, Z) {
              j._warn('(public "debug" filtered out) '.concat(K), Z);
            },
            trace(K, Z) {
              j._warn('(public "trace" filtered out) '.concat(K), Z);
            },
            named(K, Z) {
              return j.named(K, Z).utilFor.public();
            }
          };
        }
      }
    };
  return j;
}
function O91(t, a) {
  let c = S(S({}, this.includes), this.include(a)),
    r = [],
    e = "";
  for (let n = 0; n < a.names.length; n++) {
    let {
      name: h,
      key: v
    } = a.names[n];
    if (e += " %c".concat(h), r.push(this.style.css(h)), v != null) {
      let g = "%c#".concat(v);
      e += g, r.push(this.style.css(g));
    }
  }
  let l = this.filtered,
    i = this.named.bind(this, a),
    o = [e, ...r];
  return JO(l, a, c, t, o, E91(o), i);
}
function E91(t) {
  let a = t.slice(0);
  for (let c = 1; c < a.length; c++) a[c] += ";background-color:#e0005a;padding:2px;color:white";
  return a;
}
function D91(t, a) {
  let c = S(S({}, this.includes), this.include(a)),
    r = "";
  for (let o = 0; o < a.names.length; o++) {
    let {
      name: n,
      key: h
    } = a.names[o];
    r += " ".concat(n), h != null && (r += "#".concat(h));
  }
  let e = this.filtered,
    l = this.named.bind(this, a),
    i = [r];
  return JO(e, a, c, t, i, i, l);
}
function JO(t, a, c, r, e, l, i) {
  let o = X1(c, 524),
    n = X1(c, 522),
    h = X1(c, 521),
    v = X1(c, 529),
    g = X1(c, 545),
    s = X1(c, 265),
    d = X1(c, 268),
    z = X1(c, 273),
    u = X1(c, 289),
    f = X1(c, 137),
    p = X1(c, 145),
    m = X1(c, 73),
    M = X1(c, 81),
    w = o ? r.error.bind(r, ...e) : t.bind(a, 524),
    H = n ? r.error.bind(r, ...e) : t.bind(a, 522),
    y = h ? r.error.bind(r, ...e) : t.bind(a, 521),
    k = v ? r.error.bind(r, ...e) : t.bind(a, 529),
    F = g ? r.error.bind(r, ...e) : t.bind(a, 545),
    U = d ? r.warn.bind(r, ...l) : t.bind(a, 268),
    A = s ? r.warn.bind(r, ...e) : t.bind(a, 265),
    P = z ? r.warn.bind(r, ...e) : t.bind(a, 273),
    C = u ? r.warn.bind(r, ...e) : t.bind(a, 273),
    E = f ? r.info.bind(r, ...e) : t.bind(a, 137),
    a1 = p ? r.info.bind(r, ...e) : t.bind(a, 145),
    j = m ? r.debug.bind(r, ...e) : t.bind(a, 73),
    K = M ? r.debug.bind(r, ...e) : t.bind(a, 81),
    Z = {
      _hmm: w,
      _todo: H,
      _error: y,
      errorDev: k,
      errorPublic: F,
      _kapow: U,
      _warn: A,
      warnDev: P,
      warnPublic: C,
      _debug: E,
      debugDev: a1,
      _trace: j,
      traceDev: K,
      lazy: {
        _hmm: o ? Q1(w) : w,
        _todo: n ? Q1(H) : H,
        _error: h ? Q1(y) : y,
        errorDev: v ? Q1(k) : k,
        errorPublic: g ? Q1(F) : F,
        _kapow: d ? Q1(U) : U,
        _warn: s ? Q1(A) : A,
        warnDev: z ? Q1(P) : P,
        warnPublic: u ? Q1(C) : C,
        _debug: f ? Q1(E) : E,
        debugDev: p ? Q1(a1) : a1,
        _trace: m ? Q1(j) : j,
        traceDev: M ? Q1(K) : K
      },
      named: i,
      utilFor: {
        internal() {
          return {
            debug: Z._debug,
            error: Z._error,
            warn: Z._warn,
            trace: Z._trace,
            named(J, W) {
              return Z.named(J, W).utilFor.internal();
            }
          };
        },
        dev() {
          return {
            debug: Z.debugDev,
            error: Z.errorDev,
            warn: Z.warnDev,
            trace: Z.traceDev,
            named(J, W) {
              return Z.named(J, W).utilFor.dev();
            }
          };
        },
        public() {
          return {
            error: Z.errorPublic,
            warn: Z.warnPublic,
            debug(J, W) {
              Z._warn('(public "debug" filtered out) '.concat(J), W);
            },
            trace(J, W) {
              Z._warn('(public "trace" filtered out) '.concat(J), W);
            },
            named(J, W) {
              return Z.named(J, W).utilFor.public();
            }
          };
        }
      }
    };
  return Z;
}
var g3,
  F5,
  Gp = x(() => {
    "use strict";

    g3 = {
      _hmm: d3(524),
      _todo: d3(522),
      _error: d3(521),
      errorDev: d3(529),
      errorPublic: d3(545),
      _kapow: d3(268),
      _warn: d3(265),
      warnDev: d3(273),
      warnPublic: d3(289),
      _debug: d3(137),
      debugDev: d3(145),
      _trace: d3(73),
      traceDev: d3(81)
    };
    F5 = {
      loggingConsoleStyle: !0,
      loggerConsoleStyle: !0,
      includes: Object.freeze({
        internal: !1,
        dev: !1,
        min: 256
      }),
      filtered: function () {},
      include: function () {
        return {};
      },
      create: null,
      creatExt: null,
      named(t, a, c) {
        return this.create({
          names: [...t.names, {
            name: a,
            key: c
          }]
        });
      },
      style: {
        bold: void 0,
        italic: void 0,
        cssMemo: new Map([["", ""]]),
        collapseOnRE: /[a-z- ]+/g,
        color: void 0,
        collapsed(t) {
          if (t.length < 5) return t;
          let a = t.replace(this.collapseOnRE, "");
          return this.cssMemo.has(a) || this.cssMemo.set(a, this.css(t)), a;
        },
        css(t) {
          var r, e, l, i;
          let a = this.cssMemo.get(t);
          if (a) return a;
          let c = "color:".concat((e = (r = this.color) == null ? void 0 : r.call(this, t)) != null ? e : "hsl(".concat((t.charCodeAt(0) + t.charCodeAt(t.length - 1)) % 360, ", 100%, 60%)"));
          return (l = this.bold) != null && l.test(t) && (c += ";font-weight:600"), (i = this.italic) != null && i.test(t) && (c += ";font-style:italic"), this.cssMemo.set(t, c), c;
        }
      }
    };
  });
var aE,
  kt,
  _r = x(() => {
    "use strict";

    Gp();
    Gp();
    aE = Wr(console, {
      _debug: function () {},
      _error: function () {}
    });
    aE.configureLogging({
      dev: !0,
      min: 64
    });
    kt = aE.getLogger().named("Theatre.js (default logger)").utilFor.dev();
  });
var U4,
  At,
  cE,
  rE = x(() => {
    "use strict";

    O4();
    U4 = require("@theatre/dataverse");
    _r();
    b4();
    At = 28, cE = (t, a) => {
      var z;
      U4.prism.ensurePrism();
      let c = !0,
        r = io + (c ? At : 0),
        e = 0,
        l = a.atomP.ahistoric.projects.stateByProjectId[t.address.projectId].stateBySheetId[t.address.sheetId].sequence.collapsableItems,
        i = l.byId[c2.forSheet()].isCollapsed,
        o = (z = (0, U4.pointerToPrism)(i).getValue()) != null ? z : !1,
        n = {
          type: "sheet",
          isCollapsed: o,
          sheet: t,
          children: [],
          sheetItemKey: c2.forSheet(),
          shouldRender: c,
          top: io,
          depth: 0,
          n: e,
          nodeHeight: c ? At : 0,
          heightIncludingChildren: -1
        };
      c && (e += 1);
      for (let u of Object.values((0, U4.val)(t.objectsP))) u && h(u, n.children, n.depth + 1, c && !o);
      n.heightIncludingChildren = r - n.top;
      function h(u, f, p, m) {
        var F;
        let M = (0, U4.val)(u.template.getMapOfValidSequenceTracks_forStudio()),
          w = (0, U4.val)(u.template.configPointer);
        if (Object.keys(M).length === 0) return;
        let H = l.byId[c2.forSheetObject(u)].isCollapsed,
          y = (F = (0, U4.pointerToPrism)(H).getValue()) != null ? F : !1,
          k = {
            type: "sheetObject",
            isCollapsed: y,
            sheetItemKey: c2.forSheetObject(u),
            shouldRender: m,
            top: r,
            children: [],
            depth: p,
            n: e,
            sheetObject: u,
            nodeHeight: m ? At : 0,
            heightIncludingChildren: -1
          };
        f.push(k), m && (e += 1, r += k.nodeHeight), v(u, M, [], w, k.children, p + 1, m && !y), k.heightIncludingChildren = r - k.top;
      }
      function v(u, f, p, m, M, w, H) {
        for (let [y, k] of Object.entries(f)) {
          let F = m.props[y];
          g(u, k, [...p, y], F, M, w, H);
        }
      }
      function g(u, f, p, m, M, w, H) {
        m.type === "compound" ? s(u, f, m, p, m, M, w, H) : m.type === "enum" ? kt.warn("Prop type enum is not yet supported in the sequence editor") : d(u, f, p, m, M, w, H);
      }
      function s(u, f, p, m, M, w, H, y) {
        var A;
        let k = l.byId[c2.forSheetObjectProp(u, m)].isCollapsed,
          F = (A = (0, U4.pointerToPrism)(k).getValue()) != null ? A : !1,
          U = {
            type: "propWithChildren",
            isCollapsed: F,
            propConf: p,
            pathToProp: m,
            sheetItemKey: c2.forSheetObjectProp(u, m),
            sheetObject: u,
            shouldRender: y,
            top: r,
            children: [],
            nodeHeight: y ? At : 0,
            heightIncludingChildren: -1,
            depth: H,
            trackMapping: f,
            n: e
          };
        w.push(U), y && (r += U.nodeHeight, e += 1), v(u, f, m, M, U.children, H + 1, y && !F), U.heightIncludingChildren = r - U.top;
      }
      function d(u, f, p, m, M, w, H) {
        let y = {
          type: "primitiveProp",
          propConf: m,
          depth: w,
          sheetItemKey: c2.forSheetObjectProp(u, p),
          sheetObject: u,
          pathToProp: p,
          shouldRender: H,
          top: r,
          nodeHeight: H ? At : 0,
          heightIncludingChildren: H ? At : 0,
          trackId: f,
          n: e
        };
        M.push(y), e += 1, r += y.nodeHeight;
      }
      return n;
    };
  });
function eE(t, a) {
  let c = T(),
    r = c.atomP.ahistoric.projects.stateByProjectId[t.address.projectId].stateBySheetId[t.address.sheetId],
    e = c.atomP.historic.projects.stateByProjectId[t.address.projectId].stateBySheetId[t.address.sheetId];
  return (0, s0.prism)(() => {
    var A;
    let l = Pp("tree", () => cE(t, c), []),
      i = (0, s0.val)(a),
      o = (0, s0.val)(c.atomP.historic.panels.sequenceEditor.graphEditor),
      n = (0, s0.val)(e.sequenceEditor.selectedPropsByObject),
      h = !!n && Object.keys(n).length > 0,
      {
        leftDims: v,
        rightDims: g,
        graphEditorDims: s,
        dopeSheetDims: d,
        horizontalScrollbarDims: z
      } = s0.prism.memo("leftDims", () => {
        var _;
        let P = {
            width: Math.floor(i.width * W91),
            height: i.height,
            screenX: i.screenX,
            screenY: i.screenY
          },
          C = {
            width: i.width - P.width,
            height: i.height,
            screenX: i.screenX + P.width,
            screenY: i.screenY
          },
          E = h && (o == null ? void 0 : o.isOpen) === !0,
          a1 = Math.floor((E ? b1((_ = o == null ? void 0 : o.height) != null ? _ : .5, .1, .7) : 0) * i.heightWithoutBorder),
          j = 0 + a1,
          K = i.height - j,
          Z = {
            width: i.width,
            height: K,
            screenX: i.screenX,
            screenY: i.screenY
          },
          J = {
            isAvailable: h,
            isOpen: E,
            width: C.width,
            height: a1,
            screenX: i.screenX,
            screenY: i.screenY + K,
            padding: {
              top: 20,
              bottom: 20
            }
          };
        return {
          leftDims: P,
          rightDims: C,
          graphEditorDims: J,
          dopeSheetDims: Z,
          horizontalScrollbarDims: {
            bottom: 0
          }
        };
      }, [i, o, h]),
      u = s0.prism.memo("graphEditorVerticalSpace", () => {
        let P = s.height - s.padding.top - s.padding.bottom;
        return {
          space: P,
          fromExtremumSpace(C) {
            return C * P;
          },
          toExtremumSpace(C) {
            return C / P;
          }
        };
      }, [s]),
      [f, p] = s0.prism.state("isSeeking", !1),
      m = {
        isSeeking: f,
        setIsSeeking: p
      },
      M = {},
      w = (A = (0, s0.val)(r.sequence.clippedSpaceRange)) != null ? A : _91,
      H = s0.prism.memo("scaledSpace", () => {
        let P = w.end - w.start,
          C = g.width,
          E = P / C,
          a1 = C / P;
        return {
          fromUnitSpace(j) {
            return j * a1;
          },
          toUnitSpace(j) {
            return j * E;
          },
          leftPadding: 10
        };
      }, [w, g.width]),
      y = s0.prism.memo("setClippedSpaceRange", () => function (C) {
        c.transaction(({
          stateEditors: E
        }) => {
          let a1 = S({}, C);
          if (a1.end <= a1.start && (a1.end = a1.start + 1), a1.start < 0) {
            let j = a1.end - a1.start;
            a1.start = 0, a1.end = j;
          }
          E.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.clippedSpaceRange.set(D(S({}, t.address), {
            range: a1
          }));
        });
      }, []),
      k = s0.prism.memo("clippedSpace", () => ({
        range: w,
        width: g.width,
        fromUnitSpace(P) {
          return H.fromUnitSpace(P - w.start) + H.leftPadding;
        },
        toUnitSpace(P) {
          return H.toUnitSpace(P - H.leftPadding) + w.start;
        },
        setRange: y
      }), [w, g.width, H, y]),
      F = s0.prism.memo("selection.current", () => new s0.Atom({}), []);
    return Vn("finalAtom", {
      sheet: t,
      tree: l,
      panelDims: i,
      leftDims: v,
      rightDims: g,
      dopeSheetDims: d,
      horizontalScrollbarDims: z,
      seeker: m,
      unitSpace: M,
      scaledSpace: H,
      clippedSpace: k,
      graphEditorDims: s,
      graphEditorVerticalSpace: u,
      selectionAtom: F
    }).pointer;
  });
}
var s0,
  W91,
  _91,
  lE = x(() => {
    "use strict";

    f1();
    YO();
    Wu();
    s0 = require("@theatre/dataverse");
    rE();
    H2();
    W91 = .2, _91 = {
      start: 0,
      end: 10
    };
  });
function K91(t) {
  let {
      fullSecondStampsContainer: a,
      sequencePositionFormatter: c,
      snapToGrid: r,
      unitSpaceToClippedSpace: e
    } = t,
    l = "";
  Dr(t, (i, o) => {
    let n = r(i),
      h = e(n);
    o ? l += iE(c.formatFullUnitForGrid(n), h, "full-unit") : l += iE(c.formatSubUnitForGrid(n), h, "sub-unit");
  }), a.innerHTML = l;
}
function iE(t, a, c) {
  return '<span class="'.concat(c, '" style="transform: translate3d(').concat(a.toFixed(1), 'px, -50%, 0);">').concat(t, "</span>");
}
var o8,
  K4,
  oE,
  j91,
  n8,
  nE,
  q91,
  hE,
  N91,
  U91,
  vE,
  Tp = x(() => {
    "use strict";

    o8 = require("@theatre/dataverse");
    R0();
    K4 = I(G());
    c1();
    Sp();
    f1();
    j91 = B.div(oE || (oE = V(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  pointer-events: none;\n"]))), n8 = {
      fullUnitStampColor: "#6a6a6a",
      stampFontSize: "10px",
      get subUnitStampColor() {
        return A6(.2, n8.fullUnitStampColor);
      }
    }, q91 = B.div(nE || (nE = V(["\n  position: absolute;\n  top: 0;\n  height: 100%;\n  left: 0;\n  overflow: hidden;\n  z-index: 2;\n  will-change: transform;\n  pointer-events: none;\n"]))), N91 = B.div(hE || (hE = V(["\n  position: absolute;\n  top: 0;\n  left: 0;\n\n  & > span {\n    position: absolute;\n    display: block;\n    top: 9px;\n    left: -10px;\n    color: ", ";\n    text-align: center;\n    font-size: ", ";\n    width: 20px;\n\n    &.full-unit {\n      color: ", ";\n    }\n\n    &.sub-unit {\n      color: ", ";\n    }\n  }\n\n  pointer-events: none;\n"])), n8.fullUnitStampColor, n8.stampFontSize, n8.fullUnitStampColor, n8.subUnitStampColor), U91 = ({
      layoutP: t,
      width: a
    }) => {
      let c = (0, K4.useRef)(null),
        [r, e] = (0, K4.useState)(null);
      return (0, K4.useLayoutEffect)(() => {
        if (r) return (0, o8.prism)(() => {
          let l = (0, o8.val)(t.sheet).getSequence();
          return {
            fullSecondStampsContainer: r,
            clippedSpaceRange: (0, o8.val)(t.clippedSpace.range),
            clippedSpaceWidth: (0, o8.val)(t.clippedSpace.width),
            unitSpaceToClippedSpace: (0, o8.val)(t.clippedSpace.fromUnitSpace),
            leftPadding: (0, o8.val)(t.scaledSpace.leftPadding),
            fps: l.subUnitsPerUnit,
            sequencePositionFormatter: l.positionFormatter,
            snapToGrid: i => l.closestGridPosition(i)
          };
        }).onChange(T().ticker, K91, !0);
      }, [r, a, t]), K4.default.createElement(j91, {
        ref: c,
        style: {
          width: a + "px"
        }
      }, K4.default.createElement(q91, {
        style: {
          width: a + "px"
        }
      }, K4.default.createElement(N91, {
        ref: e
      })));
    }, vE = U91;
  });
function Zp(t) {
  let [a, c] = (0, ph.useState)(!1);
  return (0, ph.useEffect)(() => {
    if (c(!1), !t) return;
    let r = l => {
        l.target === t ? c(!0) : c(!1);
      },
      e = () => {
        c(!1);
      };
    return t.addEventListener("mouseenter", r), t.addEventListener("mousemove", r), t.addEventListener("mouseleave", e), () => {
      c(!1), t.removeEventListener("mouseenter", r), t.removeEventListener("mousemove", r), t.removeEventListener("mouseleave", e);
    };
  }, [t]), a;
}
var ph,
  gE = x(() => {
    "use strict";

    ph = I(G());
  });
function $91(t, a) {
  let c = 0,
    [r, e] = t,
    [l, i] = a;
  return e - r > i - l ? [l, i] : (r < l && (c = 0 - r), e > i && (c = i - e), [r + c, e + c]);
}
var z4,
  I5,
  L2,
  sE,
  dE,
  mh,
  Q91,
  zE,
  Op = x(() => {
    "use strict";

    z4 = require("@theatre/dataverse");
    M1();
    G1();
    f1();
    h8();
    v0();
    M2();
    P1();
    I5 = I(G());
    c1();
    E2();
    L2 = {
      enabled: {
        backgroundColor: "#2C2F34",
        stroke: "#646568"
      },
      disabled: {
        backgroundColor: "#282a2cc5",
        stroke: "#595a5d"
      },
      hover: {
        backgroundColor: "#34373D",
        stroke: "#C8CAC0"
      },
      dragging: {
        backgroundColor: "#3F444A",
        stroke: "#C8CAC0"
      },
      thumbWidth: 9,
      hitZoneWidth: 26,
      rangeStripMinWidth: 30
    }, sE = 1e3, mh = B.div(dE || (dE = V(["\n  position: absolute;\n  height: ", "px;\n  background-color: ", ";\n  cursor: grab;\n  top: 0;\n  left: 0;\n  width: ", "px;\n  transform-origin: left top;\n  &:hover {\n    background-color: ", ";\n  }\n  &.dragging {\n    background-color: ", ";\n    cursor: grabbing !important;\n  }\n  ", ";\n\n  /* covers the one pixel space between the focus range strip and the top strip\n  of the sequence editor panel, which would have caused that one pixel to act\n  like a panel drag zone */\n  &:after {\n    display: block;\n    content: ' ';\n    position: absolute;\n    bottom: -1px;\n    height: 1px;\n    left: 0;\n    right: 0;\n    background: transparent;\n    pointer-events: normal;\n    z-index: -1;\n  }\n"])), () => _0 - 1, t => t.enabled ? L2.enabled.backgroundColor : L2.disabled.backgroundColor, sE, L2.hover.backgroundColor, L2.dragging.backgroundColor, C1);
    Q91 = ({
      layoutP: t
    }) => {
      let a = (0, I5.useMemo)(() => (0, z4.prism)(() => {
          let {
            projectId: h,
            sheetId: v
          } = (0, z4.val)(t.sheet).address;
          return (0, z4.val)(T().atomP.ahistoric.projects.stateByProjectId[h].stateBySheetId[v].sequence.focusRange);
        }), [t]),
        [c, r] = z1(null),
        [e] = Z1(r, {
          menuItems: () => {
            let h = (0, z4.val)(t.sheet),
              v = a.getValue();
            return [{
              label: "Delete focus range",
              callback: () => {
                T().tempTransaction(({
                  stateEditors: g
                }) => {
                  g.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.unset(S({}, h.address));
                }).commit();
              }
            }, {
              label: v != null && v.enabled ? "Disable focus range" : "Enable focus range",
              callback: () => {
                v !== void 0 && T().tempTransaction(({
                  stateEditors: g
                }) => {
                  g.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.set(D(S({}, h.address), {
                    range: v.range,
                    enabled: !v.enabled
                  }));
                }).commit();
              }
            }];
          }
        }),
        l = s1(t.scaledSpace.toUnitSpace),
        i = s1(t.sheet),
        o = (0, I5.useMemo)(() => {
          let h, v;
          return {
            debugName: "FocusRangeStrip",
            onDragStart(g) {
              let s,
                d = a.getValue();
              if (!d) return !1;
              let z = d.range.start,
                u = d.range.end,
                f = !1,
                p = (0, z4.val)(t.sheet).getSequence();
              return {
                onDrag(m) {
                  if (d = a.getValue(), d) {
                    f = !0;
                    let M = l(m),
                      w = z + M,
                      H = u + M;
                    H < w && (H = w), [h, v] = $91([w, H], [0, p.length]).map(y => p.closestGridPosition(y)), s && s.discard(), s = T().tempTransaction(({
                      stateEditors: y
                    }) => {
                      var k;
                      y.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.set(D(S({}, i.address), {
                        range: {
                          start: h,
                          end: v
                        },
                        enabled: (k = d == null ? void 0 : d.enabled) != null ? k : !0
                      }));
                    });
                  }
                },
                onDragEnd() {
                  d && (f && s !== void 0 ? s.commit() : s && s.discard());
                }
              };
            },
            lockCSSCursorTo: "grabbing"
          };
        }, [i, l]),
        [n] = S1(r, o);
      return g0(n, -1), v1(() => {
        let h = a.getValue(),
          v = (h == null ? void 0 : h.range) || {
            start: 0,
            end: 0
          },
          g = (0, z4.val)(t.clippedSpace.fromUnitSpace)(v.start),
          s = (0, z4.val)(t.clippedSpace.fromUnitSpace)(v.end),
          d,
          z;
        return g < 0 && (g = 0), s > (0, z4.val)(t.clippedSpace.width) && (s = (0, z4.val)(t.clippedSpace.width)), g > s ? (z = 0, d = 0) : (z = g, d = (s - g) / sE), h ? I5.default.createElement(I5.default.Fragment, null, e, I5.default.createElement(mh, {
          id: "range-strip",
          enabled: h.enabled,
          className: "".concat(n ? "dragging" : "", " ").concat(h.enabled ? "enabled" : ""),
          ref: c,
          style: {
            transform: "translateX(".concat(z, "px) scale(").concat(d, ", 1)")
          }
        })) : I5.default.createElement(I5.default.Fragment, null);
      }, [t, c, a, e, n]);
    }, zE = Q91;
  });
var P5,
  $4,
  uE,
  X91,
  pE,
  Y91,
  mE,
  J91,
  tt1,
  Ep,
  fE = x(() => {
    "use strict";

    P5 = require("@theatre/dataverse");
    M1();
    f1();
    h8();
    I0();
    M2();
    P1();
    $4 = I(G());
    c1();
    E2();
    Op();
    b3();
    X91 = B.div(uE || (uE = V(["\n  position: absolute;\n  top: 0;\n  // the right handle has to be pulled back by its width since its right side indicates its position, not its left side\n  left: ", "px;\n  transform-origin: left top;\n  width: ", "px;\n  height: ", "px;\n  z-index: 3;\n\n  --bg: ", ";\n\n  stroke: ", ";\n  user-select: none;\n\n  cursor: ", ";\n\n  // no pointer events unless pointer-root is in normal mode _and_ the\n  // focus range is enabled\n  #pointer-root & {\n    pointer-events: none;\n  }\n\n  #pointer-root.normal & {\n    pointer-events: auto;\n  }\n\n  #pointer-root.draggingPositionInSequenceEditor & {\n    pointer-events: auto;\n    cursor: var(", ");\n  }\n\n  &.dragging {\n    pointer-events: none !important;\n  }\n\n  // highlight the handle if it's hovered, or the whole strip is hovverd\n  ", ":hover ~ &, &:hover {\n    --bg: ", ";\n    stroke: ", ";\n  }\n\n  // highlight the handle when it's being dragged or the whole strip is being dragged.\n  // using dragging.dragging to give this selector priority, as it seems to be overridden\n  // by the hover selector above\n  &.dragging,\n  ", ".dragging.dragging ~ & {\n    --bg: ", ";\n    stroke: ", ";\n  }\n\n  #pointer-root.draggingPositionInSequenceEditor &:hover {\n    --bg: ", ";\n    stroke: #40aaa4;\n  }\n\n  background-color: var(--bg);\n\n  // a larger hit zone\n  &:before {\n    display: block;\n    content: ' ';\n    position: absolute;\n    inset: -8px;\n  }\n"])), t => t.type === "start" ? 0 : -L2.thumbWidth, L2.thumbWidth, () => _0 - 1, ({
      enabled: t
    }) => t ? L2.enabled.backgroundColor : L2.disabled.backgroundColor, L2.enabled.stroke, t => t.type === "start" ? "w-resize" : "e-resize", F0, () => mh, L2.hover.backgroundColor, L2.hover.stroke, () => mh, L2.dragging.backgroundColor, L2.dragging.stroke, L2.dragging.backgroundColor), Y91 = B.div(pE || (pE = V(["\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  pointer-events: none;\n\n  background: linear-gradient(\n    ", "deg,\n    var(--bg) 0%,\n    #ffffff00 100%\n  );\n\n  width: 12px;\n  left: ", "px;\n"])), t => t.type === "start" ? 90 : -90, t => t.type === "start" ? L2.thumbWidth : -L2.thumbWidth + 1), J91 = B.div(mE || (mE = V(["\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  pointer-events: none;\n\n  background: linear-gradient(\n    ", "deg,\n    ", " 0%,\n    #ffffff00 100%\n  );\n\n  width: 12px;\n  left: ", "px;\n"])), t => t.type === "start" ? -90 : 90, () => Rt.backgroundColor, t => t.type === "start" ? -12 : L2.thumbWidth), tt1 = ({
      layoutP: t,
      thumbType: a
    }) => {
      var n;
      let [c, r] = z1(null),
        e = (0, $4.useMemo)(() => (0, P5.prism)(() => {
          let {
            projectId: h,
            sheetId: v
          } = (0, P5.val)(t.sheet).address;
          return (0, P5.val)(T().atomP.ahistoric.projects.stateByProjectId[h].stateBySheetId[v].sequence.focusRange);
        }), [t]),
        l = (0, $4.useMemo)(() => ({
          debugName: "FocusRangeThumb",
          onDragStart() {
            let h,
              v,
              g = (0, P5.val)(t.sheet),
              d = {
                start: 0,
                end: g.getSequence().length
              },
              z = e.getValue() || {
                range: d,
                enabled: !1
              },
              u = z.enabled,
              f = z.range[a],
              p = (0, P5.val)(t.scaledSpace.toUnitSpace),
              m = p(L2.rangeStripMinWidth);
            return {
              onDrag(M, w, H) {
                var U;
                let y,
                  k = r2.checkIfMouseEventSnapToPos(H, {
                    ignore: r
                  });
                if (k == null) {
                  let A = p(M);
                  y = f + A;
                } else y = k;
                v = ((U = e.getValue()) == null ? void 0 : U.range) || d, a === "start" ? y = Math.max(Math.min(y, v.end - m), 0) : y = Math.min(Math.max(y, v.start + m), g.getSequence().length);
                let F = g.getSequence().closestGridPosition(y);
                h !== void 0 && h.discard(), h = T().tempTransaction(({
                  stateEditors: A
                }) => {
                  A.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.set(D(S({}, g.address), {
                    range: D(S({}, v), {
                      [a]: F
                    }),
                    enabled: u
                  }));
                });
              },
              onDragEnd(M) {
                M ? h == null || h.commit() : h == null || h.discard();
              }
            };
          }
        }), [t]),
        [i] = S1(r, l);
      s2(i, "draggingPositionInSequenceEditor", a === "start" ? "w-resize" : "e-resize");
      let o = s1(e);
      return g0(i, (n = o == null ? void 0 : o.range[a]) != null ? n : 0), v1(() => {
        let h = e.getValue();
        if (!h) return null;
        let {
            enabled: v
          } = h,
          g = h.range[a],
          s = (0, P5.val)(t.clippedSpace.fromUnitSpace)(g);
        return (s < 0 || (0, P5.val)(t.clippedSpace.width) < s) && (s = -1e4), $4.default.createElement(X91, D(S(S({
          ref: c
        }, r2.includePositionSnapAttrs(g)), O2(g)), {
          className: "".concat(i && "dragging", " ").concat(v && "enabled"),
          enabled: v,
          type: a,
          style: {
            transform: "translate3d(".concat(s, "px, 0, 0)")
          }
        }), $4.default.createElement(Y91, {
          type: a,
          enabled: v
        }), $4.default.createElement(J91, {
          type: a
        }), $4.default.createElement("svg", {
          viewBox: "0 0 9 18",
          xmlns: "http://www.w3.org/2000/svg"
        }, $4.default.createElement("line", {
          x1: "4",
          y1: "6",
          x2: "4",
          y2: "12"
        }), $4.default.createElement("line", {
          x1: "6",
          y1: "6",
          x2: "6",
          y2: "12"
        })));
      }, [t, c, e, i]);
    }, Ep = tt1;
  });
function rt1(t, a) {
  let [c, r] = (0, j0.useState)("none");
  return s2(c !== "none", "dragging", c === "creating" ? "ew-resize" : "move"), (0, j0.useMemo)(() => {
    let e = () => ({
        debugName: "FocusRangeZone/focusRangeCreationGestureHandlers",
        onDragStart(i) {
          let o,
            n = (0, v8.val)(t.clippedSpace.toUnitSpace),
            h = (0, v8.val)(t.scaledSpace.toUnitSpace),
            v = (0, v8.val)(t.sheet),
            g = v.getSequence(),
            d = i.target.getBoundingClientRect(),
            z = n(i.clientX - d.left),
            u = h(L2.rangeStripMinWidth);
          return {
            onDrag(f) {
              let p = h(f),
                m = z,
                M = z + p;
              [m, M] = [b1(m, 0, g.length), b1(M, 0, g.length)].map(w => g.closestGridPosition(w)), M < m ? [m, M] = [Math.max(Math.min(M, m - u), 0), m] : f > 0 && (M = Math.min(Math.max(M, m + u), g.length)), o && o.discard(), o = T().tempTransaction(({
                stateEditors: w
              }) => {
                w.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.set(D(S({}, v.address), {
                  range: {
                    start: m,
                    end: M
                  },
                  enabled: !0
                }));
              });
            },
            onDragEnd(f) {
              f && o !== void 0 ? o.commit() : o && o.discard();
            }
          };
        },
        lockCSSCursorTo: "ew-resize"
      }),
      l = () => ({
        debugName: "FocusRangeZone/panelMoveGestureHandlers",
        onDragStart() {
          let i,
            o = a.current,
            n = a.current.addBoundsHighlightLock();
          return {
            onDrag(h, v) {
              let g = D(S({}, o.dims), {
                  top: b1(o.dims.top + v, 0, window.innerHeight - S3),
                  left: b1(o.dims.left + h, -o.dims.width + S3, window.innerWidth - S3)
                }),
                s = dt(g, {
                  width: window.innerWidth,
                  height: window.innerHeight
                });
              i == null || i.discard(), i = T().tempTransaction(({
                stateEditors: d
              }) => {
                d.studio.historic.panelPositions.setPanelPosition({
                  position: s,
                  panelId: o.panelId
                });
              });
            },
            onDragEnd(h) {
              n(), h ? i == null || i.commit() : i == null || i.discard();
            }
          };
        },
        lockCSSCursorTo: "move"
      });
    return {
      debugName: "FocusRangeZone",
      onDragStart(i) {
        let [o, n] = i.shiftKey ? ["creating", e().onDragStart(i)] : ["moving-panel", l().onDragStart(i)];
        return r(o), n === !1 ? !1 : {
          onDrag(h, v, g, s, d) {
            n.onDrag(h, v, g, s, d);
          },
          onDragEnd(h) {
            var v;
            r("none"), (v = n.onDragEnd) == null || v.call(n, h);
          }
        };
      }
    };
  }, [t, a]);
}
var v8,
  j0,
  ME,
  at1,
  ct1,
  xE,
  CE = x(() => {
    "use strict";

    v8 = require("@theatre/dataverse");
    M1();
    f1();
    r7();
    h8();
    I0();
    M2();
    gE();
    Uu();
    P1();
    H2();
    j0 = I(G());
    c1();
    Op();
    fE();
    b4();
    at1 = B.div(ME || (ME = V(["\n  position: absolute;\n  height: ", 'px;\n  left: 0;\n  right: 0;\n  box-sizing: border-box;\n  /* Use the "grab" cursor if the shift key is up, which is the one used on the top strip of the sequence editor */\n  cursor: ', ";\n"])), () => _0, t => t.isShiftDown ? "ew-resize" : "move"), ct1 = ({
      layoutP: t
    }) => {
      let [a, c] = z1(null),
        r = D4(),
        e = (0, j0.useRef)(r);
      e.current = r;
      let l = (0, j0.useMemo)(() => (0, v8.prism)(() => {
        let {
          projectId: n,
          sheetId: h
        } = (0, v8.val)(t.sheet).address;
        return (0, v8.val)(T().atomP.ahistoric.projects.stateByProjectId[n].stateBySheetId[h].sequence.focusRange);
      }), [t]);
      S1(c, rt1(t, e));
      let i = xr("Shift"),
        o = Zp(c);
      return (0, j0.useEffect)(() => {
        if (!i && o) return e.current.addBoundsHighlightLock();
      }, [!i && o]), v1(() => j0.default.createElement(at1, {
        ref: a,
        isShiftDown: i
      }, j0.default.createElement(zE, {
        layoutP: t
      }), j0.default.createElement(Ep, {
        thumbType: "start",
        layoutP: t
      }), j0.default.createElement(Ep, {
        thumbType: "end",
        layoutP: t
      })), [t, l, i]);
    }, xE = ct1;
  });
var bt,
  _0,
  Rt,
  LE,
  et1,
  lt1,
  HE,
  h8 = x(() => {
    "use strict";

    M1();
    bt = I(G());
    c1();
    Tp();
    E2();
    G1();
    CE();
    _0 = 18, Rt = {
      backgroundColor: "#1f2120eb",
      borderColor: "#1c1e21"
    }, et1 = B.div(LE || (LE = V(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: ", "px;\n  box-sizing: border-box;\n  background: ", ";\n  border-bottom: 1px solid ", ";\n  ", ";\n"])), _0, Rt.backgroundColor, Rt.borderColor, C1), lt1 = ({
      layoutP: t
    }) => {
      let a = s1(t.rightDims.width);
      return bt.default.createElement(bt.default.Fragment, null, bt.default.createElement(et1, S({}, O2("hide")), bt.default.createElement(vE, {
        layoutP: t,
        width: a,
        height: _0
      }), bt.default.createElement(xE, {
        layoutP: t
      })));
    }, HE = lt1;
  });
var Q4,
  it1,
  VE,
  ot1,
  wE,
  nt1,
  ht1,
  vt1,
  BE,
  yE = x(() => {
    "use strict";

    Q4 = I(G());
    c1();
    M1();
    f1();
    fo();
    N6();
    it1 = t => isFinite(t) && t > 0, ot1 = B.div(VE || (VE = V(["\n  display: flex;\n  gap: 8px;\n  padding: 4px 8px;\n  height: 28px;\n  align-items: center;\n"]))), nt1 = B.div(wE || (wE = V(["\n  ", ";\n  white-space: nowrap;\n"])), T0), ht1 = ({
      deltaX: t
    }) => t * .25, vt1 = ({
      layoutP: t
    }) => {
      let a = s1(t.sheet),
        c = (0, Q4.useMemo)(() => {
          let e;
          return {
            temporarilySetValue(l) {
              e && (e.discard(), e = void 0), e = T().tempTransaction(({
                stateEditors: i
              }) => {
                i.coreByProject.historic.sheetsById.sequence.setLength(D(S({}, a.address), {
                  length: l
                }));
              });
            },
            discardTemporaryValue() {
              e && (e.discard(), e = void 0);
            },
            permanentlySetValue(l) {
              e && (e.discard(), e = void 0), T().transaction(({
                stateEditors: i
              }) => {
                i.coreByProject.historic.sheetsById.sequence.setLength(D(S({}, a.address), {
                  length: l
                }));
              });
            }
          };
        }, [t, a]),
        r = (0, Q4.useRef)(null);
      return (0, Q4.useLayoutEffect)(() => {
        r.current.focus();
      }, []), v1(() => {
        let l = a.getSequence().length;
        return Q4.default.createElement(ot1, null, Q4.default.createElement(nt1, null, "Sequence length"), Q4.default.createElement(G9, D(S({
          value: l
        }, c), {
          isValid: it1,
          inputRef: r,
          nudge: ht1
        })));
      }, [a, c, r]);
    }, BE = vt1;
  });
function mt1(t, a) {
  let c = (0, z0.useRef)(a);
  c.current = a;
  let r = (0, z0.useMemo)(() => ({
      debugName: "LengthIndicator/useDragBulge",
      lockCSSCursorTo: "ew-resize",
      onDragStart(l) {
        let i,
          o = c.current,
          n = (0, s7.val)(c.current.layoutP.sheet),
          h = n.getSequence().length,
          v = (0, s7.val)(o.layoutP.scaledSpace.toUnitSpace);
        return {
          onDrag(g, s, d) {
            let z = v(g);
            i && (i.discard(), i = void 0), i = T().tempTransaction(({
              stateEditors: u
            }) => {
              u.coreByProject.historic.sheetsById.sequence.setLength(D(S({}, n.address), {
                length: h + z
              }));
            });
          },
          onDragEnd(g) {
            g ? i && i.commit() : i && i.discard();
          }
        };
      }
    }), []),
    [e] = S1(t, r);
  return g0(e, -1), [e];
}
var s7,
  z0,
  FE,
  fh,
  SE,
  z7,
  kE,
  gt1,
  AE,
  dt1,
  RE,
  st1,
  bE,
  zt1,
  ut1,
  pt1,
  IE,
  PE = x(() => {
    "use strict";

    M1();
    s7 = require("@theatre/dataverse"), z0 = I(G());
    c1();
    W4();
    h8();
    P1();
    M2();
    f1();
    c4();
    E2();
    K8();
    yE();
    G1();
    e4();
    FE = 1e3, fh = {
      stripNormal: "#0000006c",
      stripActive: "#000000"
    }, z7 = B.div(SE || (SE = V(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 4px;\n  z-index: ", ";\n  pointer-events: none;\n\n  &:after {\n    display: block;\n    content: ' ';\n    position: absolute;\n    /* top: ", "px; */\n    top: 0;\n    bottom: 0;\n    left: -1px;\n    width: 1px;\n    background-color: ", ";\n  }\n\n  &:hover:after,\n  &.dragging:after {\n    background-color: ", ";\n  }\n"])), () => K2.lengthIndicatorStrip, _0, fh.stripNormal, fh.stripActive), gt1 = B.div(kE || (kE = V(["\n  position: absolute;\n  top: ", "px;\n  width: 100px;\n  left: -50px;\n  pointer-events: none;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  z-index: 1;\n"])), _0 - 15), dt1 = B.div(AE || (AE = V(["\n  margin-top: 8px;\n  font-size: 10px;\n  white-space: nowrap;\n  padding: 2px 8px;\n  border-radius: 2px;\n  ", ";\n  cursor: ew-resize;\n  color: #464646;\n  background-color: #0000004d;\n  display: none;\n\n  ", ":hover &, ", ".dragging & {\n    display: block;\n    color: white;\n    background-color: ", ";\n  }\n"])), C1, z7, z7, fh.stripActive), st1 = B.div(RE || (RE = V(["\n  font-size: 10px;\n  white-space: nowrap;\n  padding: 1px 2px;\n  border-radius: 2px;\n  ", ";\n  justify-content: center;\n  align-items: center;\n  cursor: ew-resize;\n  color: #5d5d5d;\n  background-color: #191919;\n\n  ", ":hover &, ", ".dragging & {\n    color: white;\n    background-color: ", ";\n\n    & > svg:first-child {\n      margin-right: -1px;\n    }\n  }\n\n  & > svg:first-child {\n    margin-right: -4px;\n  }\n"])), C1, z7, z7, fh.stripActive), zt1 = B.div(bE || (bE = V(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  background-color: rgb(23 23 23 / 43%);\n  width: ", "px;\n  z-index: ", ";\n  transform-origin: left top;\n\n  ", ".dragging ~ &, ", ":hover ~ & {\n    background-color: rgb(23 23 23 / 60%);\n  }\n"])), FE, () => K2.lengthIndicatorCover, z7, z7), ut1 = -1e4, pt1 = ({
      layoutP: t
    }) => {
      let [a, c] = z1(null),
        [r] = mt1(c, {
          layoutP: t
        }),
        {
          node: e,
          toggle: l,
          close: i
        } = x2({
          debugName: "LengthIndicator"
        }, () => z0.default.createElement(T2, null, z0.default.createElement(BE, {
          layoutP: t,
          onRequestClose: i
        })));
      return v1(() => {
        let o = (0, s7.val)(t.sheet),
          n = (0, s7.val)(t.rightDims.height),
          h = o.getSequence(),
          v = h.length,
          g = v,
          s = (0, s7.val)(t.clippedSpace.fromUnitSpace)(g),
          d = (0, s7.val)(t.clippedSpace.width),
          z,
          u;
        return s > d ? (u = 0, z = 0) : (s < 0 && (s = 0), u = s, z = (d - s) / FE), z0.default.createElement(z0.default.Fragment, null, e, z0.default.createElement(z7, {
          style: {
            height: n + "px",
            transform: "translateX(".concat(u === 0 ? ut1 : u, "px)")
          },
          className: r ? "dragging" : ""
        }, z0.default.createElement(gt1, null, z0.default.createElement(st1, S({
          ref: a,
          onClick: f => {
            l(f, c);
          }
        }, O2("hide")), z0.default.createElement(IA, null), z0.default.createElement(PA, null)), z0.default.createElement(dt1, null, "Sequence length:", " ", h.positionFormatter.formatBasic(v)))), z0.default.createElement(zt1, {
          title: "Length",
          style: {
            height: n + "px",
            transform: "translateX(".concat(u, "px) scale(").concat(z, ", 1)")
          }
        }));
      }, [t, a, r, e]);
    };
    IE = pt1;
  });
var Dp,
  G5,
  GE,
  ft1,
  TE,
  Mt1,
  ZE,
  xt1,
  Ct1,
  OE,
  EE = x(() => {
    "use strict";

    M1();
    Dp = require("@theatre/dataverse"), G5 = I(G());
    c1();
    Tp();
    W4();
    h8();
    E2();
    ft1 = B.div(GE || (GE = V(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  margin-top: 0px;\n"]))), Mt1 = B.div(TE || (TE = V(["\n  position: absolute;\n  top: 16px;\n  font-size: ", ";\n  color: ", ";\n  text-align: center;\n  transform: translateX(-50%);\n  background: ", ";\n  padding: 1px 8px;\n  font-variant-numeric: tabular-nums;\n  pointer-events: none;\n  z-index: ", ";\n"])), n8.stampFontSize, n8.fullUnitStampColor, Rt.backgroundColor, () => K2.currentFrameStamp), xt1 = B.div(ZE || (ZE = V(["\n  position: absolute;\n  top: 5px;\n  left: -0px;\n  bottom: 0;\n  width: 0.5px;\n  background: rgba(100, 100, 100, 0.2);\n  pointer-events: none;\n"]))), Ct1 = G5.default.memo(({
      layoutP: t
    }) => {
      let [a, c] = s1(ZG()),
        r = s1(t.clippedSpace.fromUnitSpace),
        {
          sequence: e,
          formatter: l,
          clippedSpaceWidth: i
        } = v1(() => {
          let v = (0, Dp.val)(t.sheet).getSequence(),
            g = (0, Dp.val)(t.clippedSpace.width);
          return {
            sequence: v,
            formatter: v.positionFormatter,
            clippedSpaceWidth: g
          };
        }, [t]);
      if (a == -1) return G5.default.createElement(G5.default.Fragment, null);
      let o = c === 3 ? e.closestGridPosition(a) : a,
        n = r(o),
        h = n >= 0 && n <= i;
      return G5.default.createElement(G5.default.Fragment, null, G5.default.createElement(ft1, null, G5.default.createElement(Mt1, {
        style: {
          opacity: h ? 1 : 0,
          transform: "translate3d(calc(".concat(n, "px - 50%), 0, 0)")
        }
      }, l.formatForPlayhead(o)), G5.default.createElement(xt1, {
        posType: c,
        style: {
          opacity: h ? 1 : 0,
          transform: "translate3d(".concat(n, "px, 0, 0)")
        }
      })), " ");
    }), OE = Ct1;
  });
var P3,
  D2,
  WE,
  Lt1,
  _E,
  Ht1,
  jE,
  Wp,
  qE,
  $E,
  NE,
  _p,
  UE,
  jp,
  KE,
  DE,
  Vt1,
  QE,
  XE = x(() => {
    "use strict";

    M1();
    P3 = require("@theatre/dataverse");
    Qv();
    R0();
    D2 = I(G());
    c1();
    W4();
    E2();
    G1();
    M2();
    Lt1 = B.div(WE || (WE = V(["\n  --threadHeight: 6px;\n  --bg-inactive: #32353b;\n  --bg-active: #5b5c5d;\n  position: absolute;\n  height: 0;\n  width: 100%;\n  left: 12px;\n  /* bottom: 8px; */\n  z-index: ", ";\n  ", "\n"])), () => K2.horizontalScrollbar, C1), Ht1 = B.div(_E || (_E = V(["\n  position: relative;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--threadHeight);\n"]))), Wp = B.div(jE || (jE = V(["\n  position: absolute;\n  height: 5px;\n  background: var(--bg-inactive);\n  cursor: ew-resize;\n  z-index: 2;\n\n  &:hover,\n  &:active {\n    background: var(--bg-active);\n  }\n\n  &:after {\n    ", ";\n    display: block;\n    content: ' ';\n  }\n"])), ji("absolute", "-4px")), $E = B.div(qE || (qE = V(["\n  position: absolute;\n  height: 5px;\n  width: 7px;\n  left: 0;\n  z-index: 2;\n  top: 0;\n  bottom: 0;\n  display: block;\n\n  &:hover:before {\n    background: var(--bg-active);\n  }\n\n  &:before {\n    ", ";\n    display: block;\n    content: ' ';\n    background: var(--bg-inactive);\n    border-radius: 0 2px 2px 0;\n  }\n\n  &:after {\n    ", ";\n    display: block;\n    content: ' ';\n  }\n"])), ji("absolute", "0"), ji("absolute", "-4px")), _p = B($E)(NE || (NE = V(["\n  left: calc(-1 * 7px);\n  cursor: w-resize;\n  &:before {\n    transform: scaleX(-1);\n  }\n"]))), jp = B($E)(UE || (UE = V(["\n  cursor: e-resize;\n  left: 0px;\n"]))), DE = B.div(KE || (KE = V(["\n  display: ", ";\n  position: absolute;\n  top: -20px;\n  left: 4px;\n  padding: 0 4px;\n  transform: translateX(-50%);\n  background: #131d1f;\n  border-radius: 4px;\n  color: #fff;\n  font-size: 10px;\n  line-height: 18px;\n  text-align: center;\n\n  ", ":hover &,\n  ", ":hover &,\n  ", ":hover ~ ", " &,\n  ", ":hover ~ ", " & {\n    display: block;\n  }\n"])), t => t.active ? "block" : "none", _p, jp, Wp, _p, Wp, jp), Vt1 = ({
      layoutP: t
    }) => {
      let a = (0, D2.useCallback)(f => f.toFixed(2), []),
        c = (0, D2.useMemo)(() => (0, P3.prism)(() => {
          let f = (0, P3.val)(t.rightDims.width) - 25,
            p = (0, P3.val)(t.clippedSpace.range),
            m = (0, P3.val)(t.sheet).getSequence().length,
            M = Math.max(p.end, m),
            w = p.start / M * f,
            H = p.end / M * f;
          return {
            rightWidth: f,
            clippedSpaceRange: p,
            sequenceLength: m,
            assumedLengthOfSequence: M,
            rangeStartX: w,
            rangeEndX: H,
            bottom: (0, P3.val)(t.horizontalScrollbarDims.bottom)
          };
        }), [t]),
        {
          rangeStartX: r,
          rangeEndX: e,
          clippedSpaceRange: l,
          bottom: i
        } = s1(c),
        [o, n] = (0, D2.useState)("nothing"),
        h = (0, D2.useMemo)(() => {
          let f = (0, P3.val)(c),
            p = () => {
              f = (0, P3.val)(c);
            },
            m = w => w / f.rightWidth * f.assumedLengthOfSequence;
          return {
            onRangeDragStart() {
              return p(), {
                onDrag(w) {
                  n("both");
                  let H = m(w),
                    y = l5(f.clippedSpaceRange, k => k + H);
                  (0, P3.val)(t.clippedSpace.setRange)(y);
                },
                onDragEnd() {
                  n("nothing");
                }
              };
            },
            onRangeStartDragStart() {
              return p(), {
                onDrag(w) {
                  n("start");
                  let H = m(w),
                    y = {
                      start: f.clippedSpaceRange.start + H,
                      end: f.clippedSpaceRange.end
                    };
                  y.start > y.end - 1 && (y.start = y.end - 1), y.start <= 0 && (y.start = 0), (0, P3.val)(t.clippedSpace.setRange)(y);
                },
                onDragEnd() {
                  n("nothing");
                }
              };
            },
            onRangeEndDragStart() {
              return p(), {
                onDrag(w) {
                  n("end");
                  let H = m(w),
                    y = {
                      start: f.clippedSpaceRange.start,
                      end: f.clippedSpaceRange.end + H
                    };
                  y.end < y.start + 1 && (y.end = y.start + 1), y.end >= f.assumedLengthOfSequence && (y.end = f.assumedLengthOfSequence), (0, P3.val)(t.clippedSpace.setRange)(y);
                },
                onDragEnd() {
                  n("nothing");
                }
              };
            }
          };
        }, [t, c]),
        [v, g] = (0, D2.useState)(null);
      S1(v, {
        debugName: "HorizontalScrollbar/onRangeDrag",
        onDragStart: h.onRangeDragStart,
        lockCSSCursorTo: "ew-resize"
      });
      let [s, d] = (0, D2.useState)(null);
      S1(s, {
        debugName: "HorizontalScrollbar/onRangeStartDrag",
        onDragStart: h.onRangeStartDragStart,
        lockCSSCursorTo: "w-resize"
      });
      let [z, u] = (0, D2.useState)(null);
      return S1(z, {
        debugName: "HorizontalScrollbar/onRangeEndDrag",
        onDragStart: h.onRangeEndDragStart,
        lockCSSCursorTo: "e-resize"
      }), D2.default.createElement(Lt1, S({
        style: {
          bottom: i + 8 + "px"
        }
      }, O2("hide")), D2.default.createElement(Ht1, null, D2.default.createElement(Wp, {
        ref: g,
        style: {
          width: "".concat(e - r, "px"),
          transform: "translate3d(".concat(r, "px, 0, 0)")
        }
      }), D2.default.createElement(_p, {
        ref: d,
        style: {
          transform: "translate3d(".concat(r, "px, 0, 0)")
        }
      }, D2.default.createElement(DE, {
        active: o === "both" || o === "start"
      }, a(l.start))), D2.default.createElement(jp, {
        ref: u,
        style: {
          transform: "translate3d(".concat(e, "px, 0, 0)")
        }
      }, D2.default.createElement(DE, {
        active: o === "both" || o === "end"
      }, a(l.end)))));
    }, QE = Vt1;
  });
var JE,
  YE,
  wt1,
  Bt1,
  tD,
  aD = x(() => {
    "use strict";

    JE = I(G());
    c1();
    wt1 = B.div(YE || (YE = V(["\n  position: absolute;\n  inset: ", "px;\n"])), t => t.room * -1), Bt1 = t => JE.default.createElement(wt1, {
      room: t.room
    }), tD = Bt1;
  });
var Ft,
  Mh,
  qp,
  yt1,
  cD,
  St1,
  rD,
  kt1,
  At1,
  Rt1,
  eD,
  lD = x(() => {
    "use strict";

    c1();
    M1();
    fo();
    N6();
    Ft = I(G()), Mh = I(G()), qp = require("@theatre/dataverse");
    ua();
    yt1 = t => isFinite(t) && t >= 0, St1 = B.div(cD || (cD = V(["\n  display: flex;\n  gap: 8px;\n  padding: 4px 8px;\n  height: 28px;\n  align-items: center;\n"]))), kt1 = B.div(rD || (rD = V(["\n  ", ";\n  white-space: nowrap;\n"])), T0), At1 = ({
      deltaX: t
    }) => t * .25, Rt1 = ({
      layoutP: t,
      onRequestClose: a
    }) => {
      let c = (0, qp.val)(t.sheet),
        r = c.getSequence(),
        e = (0, Ft.useMemo)(() => {
          let i,
            o = r.position;
          return {
            temporarilySetValue(n) {
              i && (i = void 0), i = b1(n, 0, r.length), r.position = i;
            },
            discardTemporaryValue() {
              i && (i = void 0, r.position = o, a("discardTemporaryValue"));
            },
            permanentlySetValue(n) {
              i && (i = void 0), r.position = b1(n, 0, r.length), a("permanentlySetValue");
            }
          };
        }, [t, r]),
        l = (0, Ft.useRef)(null);
      return (0, Ft.useLayoutEffect)(() => {
        l.current.focus();
      }, []), v1(() => {
        let i = c.getSequence(),
          o = Number((0, qp.val)(i.pointer.position).toFixed(3));
        return Mh.default.createElement(St1, null, Mh.default.createElement(kt1, null, "Sequence position"), Mh.default.createElement(G9, D(S({
          value: o
        }, e), {
          isValid: yt1,
          inputRef: l,
          nudge: At1
        })));
      }, [c, e, l]);
    }, eD = Rt1;
  });
var iD,
  oD = x(() => {
    "use strict";

    iD = typeof navigator != "undefined" && navigator.platform.toUpperCase().indexOf("MAC") >= 0;
  });
var nD,
  hD = x(() => {
    "use strict";

    oD();
    nD = t => iD ? t.metaKey === !0 : t.ctrlKey === !0;
  });
function gD() {
  Np = !1;
}
function dD() {
  Np = !0;
}
function Up() {
  let t = T();
  (0, vD.useEffect)(() => {
    let a = c => {
      let r = c.composedPath()[0];
      if (!(r && (r.tagName === "INPUT" || r.tagName === "TEXTAREA"))) {
        if (c.key === "z" || c.key === "Z" || c.code === "KeyZ") {
          if (nD(c)) c.shiftKey === !0 ? t.redo() : t.undo();else return;
        } else if (c.code === "Space" && !c.shiftKey && !c.metaKey && !c.altKey && !c.ctrlKey) {
          if (!Np) return;
          let e = uk();
          if (e) {
            if (e.playing) e.pause();else {
              let {
                  projectId: l,
                  sheetId: i
                } = e.address,
                o = (0, s3.prism)(() => {
                  let v = (0, s3.val)(T().atomP.ahistoric.projects.stateByProjectId[l].stateBySheetId[i].sequence.focusRange);
                  return s3.prism.memo("shouldFollowFocusRange", () => {
                    let s = e.position;
                    if (v) {
                      let d = s >= v.range.start && s <= v.range.end;
                      return v.enabled ? !!d : !0;
                    } else return !0;
                  }, []) && v && v.enabled ? {
                    range: [v.range.start, v.range.end],
                    isFollowingARange: !0
                  } : {
                    range: [0, (0, s3.val)(e.pointer.length)],
                    isFollowingARange: !1
                  };
                }),
                n = e.playDynamicRange((0, s3.prism)(() => (0, s3.val)(o).range), T().ticker),
                h = sD(e);
              n.finally(() => {
                h.set(void 0);
              }), h.set(o);
            }
          } else return;
        } else if (c.altKey && (c.key === "\\" || c.code === "Backslash" || c.code === "IntlBackslash")) t.transaction(({
          stateEditors: e,
          drafts: l
        }) => {
          e.studio.ahistoric.setVisibilityState(l.ahistoric.visibilityState === "everythingIsHidden" ? "everythingIsVisible" : "everythingIsHidden");
        });else return;
        c.preventDefault(), c.stopPropagation();
      }
    };
    return window.addEventListener("keydown", a), () => {
      window.removeEventListener("keydown", a);
    };
  }, []);
}
var vD,
  s3,
  Np,
  sD,
  zD,
  xh = x(() => {
    "use strict";

    vD = I(G());
    f1();
    hD();
    C5();
    s3 = require("@theatre/dataverse");
    tr();
    Np = !0;
    sD = T4(t => new s3.Atom(void 0)), zD = T4(t => (0, s3.prism)(() => {
      let a = sD(t).prism.getValue();
      if (a) return a.getValue().isFollowingARange;
      {
        let {
            projectId: c,
            sheetId: r
          } = t.address,
          e = (0, s3.val)(T().atomP.ahistoric.projects.stateByProjectId[c].stateBySheetId[r].sequence.focusRange);
        if (!e || !e.enabled) return !1;
        let l = (0, s3.val)(t.pointer.position);
        return l >= e.range.start && l <= e.range.end;
      }
    }));
  });
function Gt1(t, a) {
  return Z1(t, {
    menuItems() {
      return [{
        label: "Place marker",
        callback: () => {
          T().transaction(({
            stateEditors: c
          }) => {
            let r = (0, X4.val)(a.layoutP.sheet),
              e = r.getSequence();
            c.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceMarkers({
              sheetAddress: r.address,
              markers: [{
                id: VF(),
                position: e.position
              }],
              snappingFunction: e.closestGridPosition
            });
          });
        }
      }];
    }
  });
}
var X4,
  z3,
  uD,
  It,
  pD,
  bt1,
  mD,
  xD,
  fD,
  Ft1,
  MD,
  It1,
  Pt1,
  CD,
  LD = x(() => {
    "use strict";

    aD();
    M2();
    P1();
    M1();
    X4 = require("@theatre/dataverse");
    ua();
    z3 = I(G());
    c1();
    W4();
    E2();
    G1();
    c4();
    e4();
    lD();
    xh();
    I0();
    v0();
    f1();
    O4();
    b3();
    c8();
    It = B.div(uD || (uD = V(["\n  --thumbColor: #00e0ff;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 5px;\n  height: 100%;\n  z-index: ", ";\n  pointer-events: none;\n\n  display: ", ";\n"])), () => K2.playhead, t => t.isVisible ? "block" : "none"), bt1 = B.div(pD || (pD = V(["\n  position: absolute;\n  top: 8px;\n  width: 0;\n  height: calc(100% - 8px);\n  border-left: 1px solid #27e0fd;\n  z-index: 10;\n  pointer-events: none;\n\n  #pointer-root.draggingPositionInSequenceEditor &:not(.seeking) {\n    /* pointer-events: auto; */\n    /* cursor: var(", "); */\n\n    &:after {\n      position: absolute;\n      inset: -8px;\n      display: block;\n      content: ' ';\n    }\n  }\n"])), F0), xD = B.div(mD || (mD = V(["\n  background-color: var(--thumbColor);\n  position: absolute;\n  width: 5px;\n  height: 13px;\n  top: -4px;\n  left: -2px;\n  z-index: 11;\n  cursor: ew-resize;\n  --sunblock-color: #1f2b2b;\n\n  ", ";\n\n  ", ".seeking > & {\n    pointer-events: none !important;\n  }\n\n  #pointer-root.draggingPositionInSequenceEditor\n    ", ":not(.seeking)\n    > & {\n    pointer-events: auto;\n    cursor: var(", ");\n  }\n\n  ", ".playheadattachedtofocusrange > & {\n    top: -8px;\n    --sunblock-color: #005662;\n    &:before,\n    &:after {\n      border-bottom-width: 8px;\n    }\n  }\n\n  &:before {\n    position: absolute;\n    display: block;\n    content: ' ';\n    left: -2px;\n    width: 0;\n    height: 0;\n    border-bottom: 4px solid var(--sunblock-color);\n    border-left: 2px solid transparent;\n  }\n\n  &:after {\n    position: absolute;\n    display: block;\n    content: ' ';\n    right: -2px;\n    width: 0;\n    height: 0;\n    border-bottom: 4px solid var(--sunblock-color);\n    border-right: 2px solid transparent;\n  }\n"])), C1, It, It, F0, It), Ft1 = B.div(fD || (fD = V(["\n  position: absolute;\n  left: 1px;\n  right: 1px;\n  top: 13px;\n  border-top: 3px solid var(--thumbColor);\n  border-right: 1px solid transparent;\n  border-left: 1px solid transparent;\n  pointer-events: none;\n\n  /* ", ".playheadattachedtofocusrange & {\n    top: 10px;\n    &:before,\n    &:after {\n      height: 15px;\n    }\n  } */\n\n  &:before {\n    position: absolute;\n    display: block;\n    content: ' ';\n    top: -4px;\n    left: -2px;\n    height: 8px;\n    width: 2px;\n    background: none;\n    border-radius: 0 100% 0 0;\n    border-top: 1px solid var(--thumbColor);\n    border-right: 1px solid var(--thumbColor);\n  }\n\n  &:after {\n    position: absolute;\n    display: block;\n    content: ' ';\n    top: -4px;\n    right: -2px;\n    height: 8px;\n    width: 2px;\n    background: none;\n    border-radius: 100% 0 0 0;\n    border-top: 1px solid var(--thumbColor);\n    border-left: 1px solid var(--thumbColor);\n  }\n"])), It), It1 = B.div(MD || (MD = V(["\n  display: none;\n  position: absolute;\n  top: -20px;\n  left: 4px;\n  padding: 0 2px;\n  transform: translateX(-50%);\n  background: #1a1a1a;\n  border-radius: 4px;\n  color: #fff;\n  font-size: 10px;\n  line-height: 18px;\n  text-align: center;\n  ", ":hover &, ", ".seeking & {\n    display: block;\n  }\n"])), xD, It), Pt1 = ({
      layoutP: t
    }) => {
      let [a, c] = z1(null),
        {
          node: r,
          toggle: e,
          close: l
        } = x2({
          debugName: "Playhead"
        }, () => z3.default.createElement(T2, null, z3.default.createElement(eD, {
          layoutP: t,
          onRequestClose: l
        }))),
        i = (0, z3.useMemo)(() => ({
          debugName: "RightOverlay/Playhead",
          onDragStart() {
            let h = (0, X4.val)(t.sheet).getSequence(),
              v = h.position,
              g = (0, X4.val)(t.scaledSpace.toUnitSpace),
              s = (0, X4.val)(t.seeker.setIsSeeking);
            return s(!0), mt(), {
              onDrag(d, z, u) {
                var p;
                let f = g(d);
                h.position = (p = r2.checkIfMouseEventSnapToPos(u, {
                  ignore: c
                })) != null ? p : b1(v + f, 0, h.length);
              },
              onDragEnd(d) {
                s(!1), I3();
              },
              onClick(d) {
                e(d, a.current);
              }
            };
          }
        }), [t, c]),
        [o] = S1(c, i);
      s2(o, "draggingPositionInSequenceEditor", "ew-resize"), g0(s1(t.seeker.isSeeking) || o, -1);
      let [n] = Gt1(c, {
        layoutP: t
      });
      return v1(() => {
        let h = (0, X4.val)(t.seeker.isSeeking),
          v = (0, X4.val)(t.sheet).getSequence(),
          g = (0, X4.val)(zD(v)),
          s = v.positionPrism.getValue(),
          d = (0, X4.val)(t.clippedSpace.fromUnitSpace)(s),
          z = d >= 0 && d <= (0, X4.val)(t.clippedSpace.width);
        return z3.default.createElement(z3.default.Fragment, null, n, r, z3.default.createElement(It, S({
          isVisible: z,
          style: {
            transform: "translate3d(".concat(d, "px, 0, 0)")
          },
          className: "".concat(h && "seeking", " ").concat(g && "playheadattachedtofocusrange")
        }, O2("hide")), z3.default.createElement(xD, S({
          ref: a
        }, r2.includePositionSnapAttrs(s)), z3.default.createElement(tD, {
          room: 8
        }), z3.default.createElement(Ft1, null), z3.default.createElement(It1, null, v.positionFormatter.formatForPlayhead(v.closestGridPosition(s)))), z3.default.createElement(bt1, D(S({}, r2.includePositionSnapAttrs(s)), {
          className: h ? "seeking" : ""
        }))));
      }, [t, a, r]);
    }, CD = Pt1;
  });
var g8,
  Pt,
  Kp,
  HD,
  Tt1,
  Zt1,
  VD,
  wD = x(() => {
    "use strict";

    g8 = require("@theatre/dataverse");
    M1();
    f1();
    h8();
    Pt = I(G());
    c1();
    Kp = 1e3, Tt1 = B.div(HD || (HD = V(["\n  position: absolute;\n  top: ", "px;\n  left: 0;\n  opacity: 0.15;\n  width: ", "px;\n  transform-origin: top left;\n  pointer-events: none;\n  background-color: ", ";\n"])), _0, Kp, t => t.enabled ? "#000000" : "transparent"), Zt1 = ({
      layoutP: t
    }) => {
      let a = (0, Pt.useMemo)(() => (0, g8.prism)(() => {
        let {
          projectId: c,
          sheetId: r
        } = (0, g8.val)(t.sheet).address;
        return (0, g8.val)(T().atomP.ahistoric.projects.stateByProjectId[c].stateBySheetId[r].sequence.focusRange);
      }), [t]);
      return v1(() => {
        let c = a.getValue();
        if (!c || !c.enabled) return null;
        let {
            range: r
          } = c,
          e = (0, g8.val)(t.rightDims.height) - _0,
          l = (0, g8.val)(t.clippedSpace.fromUnitSpace),
          i = (0, g8.val)(t.clippedSpace.width),
          o = [];
        {
          let n = 0,
            h = l(c.range.start),
            v,
            g;
          n > h ? (g = 0, v = 0) : (h > i && (h = i), g = n, v = (h - n) / Kp), o.push({
            translateX: g,
            scaleX: v
          });
        }
        {
          let n = l(c.range.end),
            h = i,
            v,
            g;
          n > h ? (g = 0, v = 0) : (n < 0 && (n = 0), g = n, v = (h - n) / Kp), o.push({
            translateX: g,
            scaleX: v
          });
        }
        return Pt.default.createElement(Pt.default.Fragment, null, o.map(({
          translateX: n,
          scaleX: h
        }, v) => Pt.default.createElement(Tt1, {
          key: "curtain-".concat(v),
          enabled: !0,
          style: {
            height: "".concat(e, "px"),
            transform: "translateX(".concat(n, "px) scaleX(").concat(h, ")")
          }
        })));
      }, [t, a]);
    }, VD = Zt1;
  });
var T5,
  BD,
  Ot1,
  yD,
  yE1,
  Et1,
  SD,
  kD = x(() => {
    "use strict";

    T5 = I(G());
    c1();
    M1();
    f1();
    N6();
    Lo();
    Ot1 = B.div(BD || (BD = V(["\n  display: flex;\n  gap: 8px;\n  /* padding: 4px 8px; */\n  height: 28px;\n  align-items: center;\n"]))), yE1 = B.div(yD || (yD = V(["\n  ", ";\n  white-space: nowrap;\n"])), T0), Et1 = ({
      layoutP: t,
      marker: a
    }) => {
      var l;
      let c = s1(t.sheet),
        r = (0, T5.useMemo)(() => {
          let i;
          return {
            temporarilySetValue(o) {
              i && (i.discard(), i = void 0), i = T().tempTransaction(({
                stateEditors: n
              }) => {
                n.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateMarker({
                  sheetAddress: c.address,
                  markerId: a.id,
                  label: o
                });
              });
            },
            discardTemporaryValue() {
              i && (i.discard(), i = void 0);
            },
            permanentlySetValue(o) {
              i && (i.discard(), i = void 0), T().transaction(({
                stateEditors: n
              }) => {
                n.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateMarker({
                  sheetAddress: c.address,
                  markerId: a.id,
                  label: o
                });
              });
            }
          };
        }, [t, c]),
        e = (0, T5.useRef)(null);
      return (0, T5.useLayoutEffect)(() => {
        e.current.focus();
      }, []), T5.default.createElement(Ot1, null, T5.default.createElement(O9, D(S({
        value: (l = a.label) != null ? l : ""
      }, r), {
        isValid: () => !0,
        inputRef: e
      })));
    }, SD = Et1;
  });
function Kt1(t, a) {
  return Z1(t, {
    menuItems() {
      return [{
        label: "Remove marker",
        callback: () => {
          T().transaction(({
            stateEditors: c
          }) => {
            c.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removeMarker({
              sheetAddress: a.sheetAddress,
              markerId: a.markerId
            });
          });
        }
      }];
    }
  });
}
function $t1(t, a) {
  let c = (0, Y2.useRef)(a);
  c.current = a;
  let r = (0, Y2.useMemo)(() => ({
      debugName: "MarkerDot/useDragMarker (".concat(a.marker.id, ")"),
      onDragStart(l) {
        let i = c.current.marker,
          o = (0, Ch.val)(a.layoutP.scaledSpace.toUnitSpace),
          n;
        return mt(), {
          onDrag(h, v, g) {
            var z;
            let s = i,
              d = Math.max((z = r2.checkIfMouseEventSnapToPos(g, {
                ignore: t
              })) != null ? z : s.position + o(h), 0);
            n == null || n.discard(), n = T().tempTransaction(({
              stateEditors: u
            }) => {
              u.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceMarkers({
                sheetAddress: (0, Ch.val)(a.layoutP.sheet.address),
                markers: [D(S({}, s), {
                  position: d
                })],
                snappingFunction: (0, Ch.val)(a.layoutP.sheet).getSequence().closestGridPosition
              });
            });
          },
          onDragEnd(h) {
            h ? n == null || n.commit() : n == null || n.discard(), I3();
          }
        };
      }
    }), []),
    [e] = S1(t, r);
  return g0(e, a.marker.position), s2(e, "draggingPositionInSequenceEditor draggingMarker", "ew-resize"), [e];
}
var Ch,
  Y2,
  FD,
  ID,
  Dt1,
  Wt1,
  AD,
  _t1,
  RD,
  $p,
  jt1,
  bD,
  qt1,
  Nt1,
  PD,
  Ut1,
  GD = x(() => {
    "use strict";

    Ch = require("@theatre/dataverse");
    M1();
    f1();
    I0();
    v0();
    P1();
    Y2 = I(G());
    c1();
    E2();
    M2();
    W4();
    b3();
    Cr();
    tp();
    c8();
    c4();
    e4();
    kD();
    FD = 12, ID = 12, Dt1 = FD * 2, Wt1 = ID * 2, _t1 = B.div(AD || (AD = V(['\n  position: absolute;\n  // below the sequence ruler "top bar"\n  top: 18px;\n  z-index: ', ";\n"])), () => K2.marker), $p = B.div(RD || (RD = V(["\n  position: absolute;\n  ", "\n  pointer-events: none;\n"])), H0(FD, ID)), jt1 = Y2.default.memo(() => Y2.default.createElement($p, {
      children: Y2.default.createElement("svg", {
        width: "100%",
        height: "100%",
        viewBox: "0 0 12 12",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, Y2.default.createElement("path", {
        d: "M12 5H0V7H2.71973L5.96237 10.2426L9.20501 7H12V5Z",
        fill: "#40AAA4"
      }))
    })), qt1 = B.div(bD || (bD = V(["\n  z-index: 1;\n  cursor: ew-resize;\n\n  ", "\n\n  // :not dragging marker to ensure that markers don't snap to other markers\n  // this works because only one marker track (so this technique is not used by keyframes...)\n  #pointer-root.draggingPositionInSequenceEditor:not(.draggingMarker) & {\n    ", '\n  }\n\n  // "All instances of this component <Mark/> inside #pointer-root when it has the .draggingPositionInSequenceEditor class"\n  // ref: https://styled-components.com/docs/basics#pseudoelements-pseudoselectors-and-nesting\n  #pointer-root.draggingPositionInSequenceEditor:not(.draggingMarker) &,\n  #pointer-root.draggingPositionInSequenceEditor\n    &.', " {\n    pointer-events: auto;\n    cursor: var(", ");\n  }\n\n  &:hover\n    + ", ',\n    // notice , "or" in CSS\n    &.', "\n    + ", " {\n    ", "\n  }\n"])), v4.CSS, v4.CSS_WHEN_SOMETHING_DRAGGING, v4.BEING_DRAGGED_CLASS, F0, $p, v4.BEING_DRAGGED_CLASS, $p, H0(Dt1, Wt1)), Nt1 = ({
      layoutP: t,
      markerId: a
    }) => {
      let c = s1(t.sheet.address),
        r = s1(T().atomP.historic.projects.stateByProjectId[c.projectId].stateBySheetId[c.sheetId].sequenceEditor.markerSet.byId[a]);
      if (!r) return null;
      let e = s1(t.clippedSpace.width),
        i = s1(t.clippedSpace.fromUnitSpace)(r.position),
        o = i <= 0 || i > e,
        n = o ? -1e4 : i,
        h = o ? 0 : 1;
      return Y2.default.createElement(_t1, {
        style: {
          transform: "translateX(".concat(n, "px) scale(").concat(h, ")")
        }
      }, Y2.default.createElement(Ut1, {
        marker: r,
        layoutP: t
      }));
    }, PD = Nt1, Ut1 = ({
      layoutP: t,
      marker: a
    }) => {
      let c = s1(t.sheet.address),
        [r, e] = z1(null),
        [l] = Kt1(e, {
          sheetAddress: c,
          markerId: a.id
        }),
        [i] = $t1(e, {
          layoutP: t,
          marker: a
        }),
        {
          node: o,
          toggle: n,
          close: h
        } = x2({
          debugName: "MarkerPopover"
        }, () => Y2.default.createElement(T2, null, Y2.default.createElement(SD, {
          marker: a,
          layoutP: t,
          onRequestClose: h
        })));
      return Y2.default.createElement(Y2.default.Fragment, null, l, o, Y2.default.createElement(qt1, S({
        title: a.label ? "Marker: ".concat(a.label) : "Marker",
        ref: r,
        onClick: v => {
          n(v, r.current);
        }
      }, v4.reactProps({
        isDragging: i,
        position: a.position
      }))), Y2.default.createElement(jt1, null));
    };
  });
var Lh,
  Qt1,
  TD,
  ZD = x(() => {
    "use strict";

    M1();
    f1();
    Lh = I(G());
    GD();
    Qt1 = ({
      layoutP: t
    }) => {
      let a = s1(t.sheet.address),
        c = T().atomP.historic.projects.stateByProjectId[a.projectId].stateBySheetId[a.sheetId].sequenceEditor.markerSet,
        r = s1(c.allIds);
      return Lh.default.createElement(Lh.default.Fragment, null, r && Object.keys(r).map(e => Lh.default.createElement(PD, {
        key: e,
        layoutP: t,
        markerId: e
      })));
    }, TD = Qt1;
  });
var ED,
  Z5,
  OD,
  Xt1,
  Yt1,
  DD,
  WD = x(() => {
    "use strict";

    W4();
    M1();
    ED = require("@theatre/dataverse"), Z5 = I(G());
    c1();
    PE();
    EE();
    XE();
    LD();
    h8();
    wD();
    ZD();
    Xt1 = B.div(OD || (OD = V(["\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  z-index: ", ";\n  overflow: visible;\n  pointer-events: none;\n"])), () => K2.rightOverlay), Yt1 = ({
      layoutP: t
    }) => v1(() => {
      let a = (0, ED.val)(t.rightDims.width);
      return Z5.default.createElement(Xt1, {
        style: {
          width: a + "px"
        }
      }, Z5.default.createElement(CD, {
        layoutP: t
      }), Z5.default.createElement(QE, {
        layoutP: t
      }), Z5.default.createElement(OE, {
        layoutP: t
      }), Z5.default.createElement(HE, {
        layoutP: t
      }), Z5.default.createElement(TD, {
        layoutP: t
      }), Z5.default.createElement(IE, {
        layoutP: t
      }), Z5.default.createElement(VD, {
        layoutP: t
      }));
    }, [t]), DD = Yt1;
  });
var jD,
  jr,
  _D,
  Jt1,
  ta1,
  qD,
  ND = x(() => {
    "use strict";

    jD = require("@theatre/dataverse");
    M1();
    f1();
    jr = I(G());
    c1();
    K8();
    E2();
    Jt1 = B.button(_D || (_D = V(["\n  outline: none;\n  background-color: #1c1d21;\n  border: 1px solid #191919;\n  border-radius: 2px;\n  display: flex;\n  bottom: 14px;\n  right: 8px;\n  z-index: 1;\n  position: absolute;\n\n  padding: 4px 8px;\n  display: flex;\n  color: #656d77;\n  line-height: 20px;\n  font-size: 10px;\n\n  &:hover {\n    color: white;\n  }\n\n  & > svg {\n    transition: transform 0.3s;\n    transform: rotateZ(0deg);\n  }\n\n  &:hover > svg {\n    transform: rotateZ(-20deg);\n  }\n\n  &.open > svg {\n    transform: rotateZ(-180deg);\n  }\n\n  &.open:hover > svg {\n    transform: rotateZ(-160deg);\n  }\n"]))), ta1 = ({
      layoutP: t
    }) => {
      let a = s1(t.graphEditorDims.isOpen),
        c = (0, jr.useCallback)(() => {
          let r = (0, jD.val)(t.graphEditorDims.isOpen);
          T().transaction(({
            stateEditors: e
          }) => {
            e.studio.historic.panels.sequenceEditor.graphEditor.setIsOpen({
              isOpen: !r
            });
          });
        }, [t]);
      return jr.default.createElement(Jt1, S({
        onClick: c,
        title: "Toggle graph editor",
        className: a ? "open" : ""
      }, O2("hide")), jr.default.createElement(YA, null));
    }, qD = ta1;
  });
var G3,
  Y1,
  UD,
  aa1,
  KD,
  ca1,
  K2,
  $D,
  ra1,
  ea1,
  la1,
  ia1,
  oa1,
  na1,
  QD,
  ha1,
  W4 = x(() => {
    "use strict";

    C5();
    M1();
    Wu();
    G3 = require("@theatre/dataverse"), Y1 = I(G());
    c1();
    XO();
    Er();
    lE();
    WD();
    r7();
    Eu();
    Du();
    E2();
    N5();
    H2();
    ND();
    b4();
    K6();
    aa1 = B(Cn)(UD || (UD = V(["\n  z-index: ", ";\n  box-shadow: 2px 2px 0 rgb(0 0 0 / 11%);\n"])), M5.sequenceEditorPanel), ca1 = B.div(KD || (KD = V(["\n  background-color: rgba(40, 43, 47, 0.99);\n  position: absolute;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  z-index: -1;\n  pointer-events: none;\n"]))), K2 = (() => {
      let t = {
          rightBackground: 0,
          scrollableArea: 0,
          rightOverlay: 0,
          lengthIndicatorCover: 0,
          lengthIndicatorStrip: 0,
          playhead: 0,
          currentFrameStamp: 0,
          marker: 0,
          horizontalScrollbar: 0
        },
        a = -1;
      for (let c of Object.keys(t)) t[c] = a, a++;
      return t;
    })(), ra1 = B(fn)($D || ($D = V(["\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 1;\n"]))), ea1 = {
      edges: {
        left: {
          from: "screenLeft",
          distance: .1
        },
        right: {
          from: "screenRight",
          distance: .2
        },
        top: {
          from: "screenBottom",
          distance: .4
        },
        bottom: {
          from: "screenBottom",
          distance: .01
        }
      }
    }, la1 = {
      width: 800,
      height: 200
    }, ia1 = t => Y1.default.createElement(mn, {
      panelId: "sequenceEditor",
      defaultPosition: ea1,
      minDims: la1
    }, Y1.default.createElement(oa1, null)), oa1 = () => {
      let {
          dims: t
        } = D4(),
        [a, c] = (0, Y1.useState)(null);
      return _o(a), v1(() => {
        let r = G3.prism.memo("panelSize", () => {
            let d = t.width,
              z = t.height;
            return {
              width: d,
              height: z,
              widthWithoutBorder: d - 2,
              heightWithoutBorder: z - 4,
              screenX: t.left,
              screenY: t.top
            };
          }, [t]),
          e = x3(c3().filter(d => H7(d) || c0(d)).map(d => c0(d) ? d.sheet : d));
        if (x3(e.map(d => d.template)).length !== 1) return Y1.default.createElement(Y1.default.Fragment, null);
        let i = e[0];
        if (!i) return Y1.default.createElement(Y1.default.Fragment, null);
        let o = Vn("panelSizeP", r).pointer,
          n = G3.prism.memo("key", () => JSON.stringify(i.address), [i]),
          h = G3.prism.memo("layout", () => eE(i, o), [i, o]).getValue();
        if ((0, G3.val)(h.tree.children).length === 0) return Y1.default.createElement(Y1.default.Fragment, null);
        let v = G3.prism.memo("containerRef", ha1, []),
          g = (0, G3.val)(h.graphEditorDims.isAvailable),
          s = (0, G3.val)(h.graphEditorDims.isOpen);
        return Y1.default.createElement(aa1, {
          ref: d => {
            v(d), d !== a && c(d);
          }
        }, Y1.default.createElement(ca1, {
          style: {
            width: "".concat((0, G3.val)(h.leftDims.width), "px")
          }
        }), Y1.default.createElement(EG, {
          layoutP: h
        }, Y1.default.createElement(na1, {
          layoutP: h
        }), Y1.default.createElement(QO, {
          key: n + "-dopeSheet",
          layoutP: h
        }), s && Y1.default.createElement(yO, {
          key: n + "-graphEditor",
          layoutP: h
        }), g && Y1.default.createElement(qD, {
          layoutP: h
        }), Y1.default.createElement(DD, {
          layoutP: h
        })));
      }, [t, a]);
    }, na1 = ({
      layoutP: t
    }) => v1(() => {
      let a = (0, G3.val)(t.sheet);
      return Y1.default.createElement(ra1, {
        style: {
          width: (0, G3.val)(t.leftDims.width)
        }
      }, Y1.default.createElement(oo, null, Y1.default.createElement(x5, null, a.address.sheetId, " "), Y1.default.createElement(R9, null, ":", "\xA0"), Y1.default.createElement(x5, null, a.address.sheetInstanceId, " "), Y1.default.createElement(R9, null, "\xA0", ">", "\xA0"), Y1.default.createElement(x5, null, "Sequence")));
    }, [t]), QD = ia1, ha1 = () => {
      let t = null,
        a = {
          passive: !1,
          capture: !1
        },
        c = r => {
          Math.abs(r.deltaY) < Math.abs(r.deltaX) && (r.preventDefault(), r.stopPropagation());
        };
      return r => {
        t !== r && t && t.removeEventListener("wheel", c, a), t = r, r && r.addEventListener("wheel", c, a);
      };
    };
  });
var u7,
  va1,
  XD,
  YD = x(() => {
    "use strict";

    Qk();
    Io();
    u7 = I(G());
    f1();
    M1();
    nG();
    W4();
    va1 = () => {
      let t = s1(T().paneManager.allPanesD),
        a = Object.entries(t).map(([c, r]) => u7.default.createElement(oG, {
          key: "pane-".concat(c),
          paneInstance: r
        }));
      return u7.default.createElement(u7.default.Fragment, null, a, u7.default.createElement($k, null), u7.default.createElement(yP, null), u7.default.createElement(QD, null));
    }, XD = va1;
  });
var JD,
  ga1,
  tW,
  aW = x(() => {
    "use strict";

    c1();
    gr();
    ga1 = B(w5)(JD || (JD = V(["\n  --popover-outer-stroke: #e11c1c;\n  --popover-inner-stroke: #2c1c1c;\n  --popover-bg: #2c1c1c;\n  pointer-events: none !important;\n"]))), tW = ga1;
  });
var rW = L1((UD1, cW) => {
  var Hh, Qp;
  Hh = [];
  Qp = [];
  function da1(t, a, c) {
    var r, e, l, i, o, n, h, v;
    if (t === a) return 0;
    if (r = t.length, e = a.length, r === 0) return e;
    if (e === 0) return r;
    for (c && (t = t.toLowerCase(), a = a.toLowerCase()), h = 0; h < r;) Qp[h] = t.charCodeAt(h), Hh[h] = ++h;
    for (v = 0; v < e;) for (l = a.charCodeAt(v), i = o = v++, h = -1; ++h < r;) n = l === Qp[h] ? o : o + 1, o = Hh[h], Hh[h] = i = o > i ? n > i ? i + 1 : n : n > o ? o + 1 : n;
    return i;
  }
  cW.exports = da1;
});
var iW = L1((KD1, lW) => {
  var eW = rW();
  function sa1() {
    var t,
      a,
      c,
      r,
      e,
      l = 0,
      i = arguments[0],
      o = arguments[1],
      n = o.length,
      h = arguments[2];
    h && (r = h.threshold, e = h.ignoreCase), r === void 0 && (r = 0);
    for (var v = 0; v < n; ++v) e ? a = eW(i, o[v], !0) : a = eW(i, o[v]), a > i.length ? t = 1 - a / o[v].length : t = 1 - a / i.length, t > l && (l = t, c = o[v]);
    return l >= r ? c : null;
  }
  lW.exports = sa1;
});
function Xp(t, a, c = "Did you mean ", r = "?") {
  let e = (0, oW.default)(t, a, {
    threshold: .7
  });
  return e ? c + JSON.stringify(e) + r : "";
}
var oW,
  nW = x(() => {
    "use strict";

    oW = I(iW());
  });
function Vh(t, a) {
  return t.length <= a ? t : t.substr(0, a - 3) + "...";
}
var hW = x(() => {
  "use strict";
});
var za1,
  wh,
  Yp = x(() => {
    "use strict";

    hW();
    za1 = t => typeof t == "string" ? 'string("'.concat(Vh(t, 10), '")') : typeof t == "number" ? "number(".concat(Vh(String(t), 10), ")") : t === null ? "null" : t === void 0 ? "undefined" : typeof t == "boolean" ? String(t) : Array.isArray(t) ? "array" : typeof t == "object" ? "object" : "unknown", wh = za1;
  });
var vW,
  ua1,
  Bh,
  Jp = x(() => {
    "use strict";

    c1();
    T6();
    ua1 = B(uz)(vW || (vW = V(["\n  display: flex;\n  height: fit-content;\n  backdrop-filter: blur(14px);\n  border-radius: 2px;\n"]))), Bh = ua1;
  });
var Gt,
  gW,
  pa1,
  ma1,
  Y4,
  Tt = x(() => {
    "use strict";

    c1();
    G1();
    Gt = I(G());
    nt();
    Wc();
    bu();
    Jp();
    pa1 = B.button(gW || (gW = V(["\n  ", ";\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 14px;\n  font-weight: 600;\n  width: 32px;\n  height: 32px;\n  outline: none;\n\n  color: #a8a8a9;\n\n  background: rgba(40, 43, 47, 0.8);\n  backdrop-filter: blur(14px);\n  border: none;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.08);\n  border-radius: 2px;\n\n  svg {\n    display: block;\n  }\n\n  &:hover {\n    background: rgba(59, 63, 69, 0.8);\n  }\n\n  &:active {\n    background: rgba(82, 88, 96, 0.8);\n  }\n\n  &.selected {\n    color: rgba(255, 255, 255, 0.8);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.7);\n  }\n\n  // Don't blur if in a button group, because it already blurs. We need to blur\n  // on the group-level, otherwise we get seams.\n  ", " > & {\n    backdrop-filter: none;\n    filter: none;\n    border-radius: 0;\n\n    &:first-child {\n      border-top-left-radius: 2px;\n      border-bottom-left-radius: 2px;\n    }\n\n    &:last-child {\n      border-bottom-right-radius: 2px;\n      border-top-right-radius: 2px;\n    }\n  }\n\n  @supports not (backdrop-filter: blur()) {\n    background: rgba(40, 43, 47, 0.95);\n  }\n"])), C1, Bh), ma1 = Gt.default.forwardRef((r, c) => {
      var e = r,
        {
          title: t
        } = e,
        a = m4(e, ["title"]);
      let [l, i] = R3({
        enabled: typeof t == "string"
      }, () => Gt.default.createElement(dn, null, t));
      return Gt.default.createElement(Gt.default.Fragment, null, l, Gt.default.createElement(pa1, S({
        ref: D6([i, c])
      }, a)), " ");
    }), Y4 = ma1;
  });
var sW,
  dW,
  fa1,
  Ma1,
  zW,
  uW = x(() => {
    "use strict";

    sW = I(G());
    Tt();
    c1();
    G1();
    fa1 = B(Y4)(dW || (dW = V(["\n  ", ";\n  & > svg {\n    width: 1em;\n    height: 1em;\n    pointer-events: none;\n  }\n"])), C1), Ma1 = ({
      config: t,
      testId: a
    }) => {
      var c;
      return sW.default.createElement(fa1, {
        onClick: t.onClick,
        "data-testid": a,
        title: t.title,
        dangerouslySetInnerHTML: {
          __html: (c = t.svgSource) != null ? c : ""
        }
      });
    }, zW = Ma1;
  });
function xa1({
  value: t,
  label: a,
  icon: c,
  onClick: r,
  isSelected: e
}) {
  return Zt.default.createElement(Zt.default.Fragment, null, Zt.default.createElement(Y4, {
    forwardedAs: zz,
    className: e ? "selected" : void 0,
    "aria-label": a,
    onClick: r,
    title: a
  }, c));
}
var Zt,
  Ca1,
  pW,
  mW = x(() => {
    "use strict";

    Zt = I(G());
    T6();
    Tt();
    Jp();
    Ca1 = ({
      value: t,
      onChange: a,
      options: c
    }) => Zt.default.createElement(Bh, null, c.map(({
      label: r,
      icon: e,
      value: l
    }) => Zt.default.createElement(xa1, {
      key: l,
      value: l,
      isSelected: t === l,
      label: r,
      icon: e,
      onClick: () => a(l)
    }))), pW = Ca1;
  });
var tm,
  fW,
  La1,
  Ha1,
  MW,
  xW = x(() => {
    "use strict";

    tm = I(G());
    c1();
    G1();
    mW();
    La1 = B.div(fW || (fW = V(["\n  ", ";\n  & > svg {\n    width: 1em;\n    height: 1em;\n    pointer-events: none;\n  }\n"])), C1), Ha1 = ({
      config: t
    }) => tm.default.createElement(pW, {
      onChange: t.onChange,
      options: t.options.map(({
        label: a,
        value: c,
        svgSource: r
      }) => ({
        label: a,
        value: c,
        icon: tm.default.createElement(La1, {
          dangerouslySetInnerHTML: {
            __html: r
          }
        })
      })),
      value: t.value
    }), MW = Ha1;
  });
var Ot,
  CW,
  Va1,
  wa1,
  LW,
  HW = x(() => {
    "use strict";

    Ot = I(G());
    c1();
    G1();
    Tt();
    iu();
    c4();
    Va1 = B.div(CW || (CW = V(["\n  ", ";\n  & > svg {\n    width: 1em;\n    height: 1em;\n    pointer-events: none;\n  }\n"])), C1), wa1 = ({
      config: t
    }) => {
      let a = (0, Ot.useRef)(null),
        c = x2(() => {
          let r = a.current.getBoundingClientRect();
          return {
            debugName: "ExtensionFlyoutMenu:" + t.label,
            constraints: {
              maxX: r.right,
              maxY: 8,
              minX: r.left,
              minY: 8
            },
            verticalGap: 2
          };
        }, () => Ot.default.createElement(Eo, {
          items: t.items.map((r, e) => ({
            label: r.label,
            callback: () => {
              var l;
              try {
                (l = r.onClick) == null || l.call(r);
              } catch (i) {
                console.error(i);
              }
            }
          })),
          onRequestClose: () => {
            c.close("clicked");
          }
        }));
      return Ot.default.createElement(Va1, null, c.node, Ot.default.createElement(Y4, {
        ref: a,
        onClick: r => {
          c.open(r, a.current);
        }
      }, t.label));
    }, LW = wa1;
  });
function ya1(t) {
  return VW[t];
}
var qr,
  Ba1,
  VW,
  Sa1,
  wW,
  BW = x(() => {
    "use strict";

    nW();
    Yp();
    qr = I(G());
    uW();
    xW();
    HW();
    Ba1 = t => qr.default.createElement(qr.default.Fragment, null, t.config.map((a, c) => qr.default.createElement(Sa1, {
      config: a,
      key: c
    }))), VW = {
      Icon: zW,
      Switch: MW,
      Flyout: LW
    };
    Sa1 = ({
      config: t
    }) => {
      let a = ya1(t.type);
      if (!a) throw new Error("No tool with tool.type ".concat(wh(t.type), " exists. Did you mean ").concat(Xp(t.type, Object.keys(VW))));
      return qr.default.createElement(a, {
        config: t
      });
    }, wW = Ba1;
  });
var AW,
  T3,
  SW,
  ka1,
  kW,
  yW,
  Aa1,
  Ra1,
  yh,
  am = x(() => {
    "use strict";

    AW = require("@theatre/dataverse");
    M1();
    f1();
    T3 = I(G());
    c1();
    BW();
    ka1 = B.div(SW || (SW = V(["\n  height: 36px;\n  /* pointer-events: none; */\n\n  display: flex;\n  gap: 0.5rem;\n  justify-content: center;\n"]))), yW = B.div(kW || (kW = V(["\n  position: abolute;\n  height: 32px;\n  width: 1px;\n  background: #373b40;\n  opacity: 0.4;\n"]))), Aa1 = ({
      extension: t,
      toolbarId: a
    }) => {
      var l;
      let c = (0, T3.useMemo)(() => new AW.Atom([]), []),
        r = (l = t.toolbars) == null ? void 0 : l[a];
      (0, T3.useLayoutEffect)(() => {
        let i = r == null ? void 0 : r(c.set.bind(c), T().publicApi);
        if (typeof i == "function") return i;
      }, [t, a, r]);
      let e = s1(c.prism);
      return T3.default.createElement(wW, {
        config: e
      });
    }, Ra1 = ({
      toolbarId: t,
      showLeftDivider: a
    }) => {
      var l;
      let c = [],
        r = s1(T().atomP.ephemeral.extensions.byId),
        e = !1;
      for (let [, i] of Object.entries(r)) !i || !((l = i.toolbars) != null && l[t]) || (c.push(T3.default.createElement(T3.default.Fragment, {
        key: "extensionToolbar-" + i.id
      }, e ? T3.default.createElement(yW, null) : void 0, T3.default.createElement(Aa1, {
        extension: i,
        toolbarId: t
      }))), e = !0);
      return c.length === 0 ? null : T3.default.createElement(ka1, {
        "data-testid": "theatre-extensionToolbar-".concat(t)
      }, a ? T3.default.createElement(yW, null) : void 0, c);
    }, yh = Ra1;
  });
var p7,
  RW,
  ba1,
  Fa1,
  Sh,
  bW = x(() => {
    "use strict";

    c1();
    p7 = I(G());
    Tt();
    ba1 = B(Y4)(RW || (RW = V(["\n  color: ", ";\n\n  border-bottom: 1px solid\n    ", ";\n"])), ({
      pinned: t
    }) => t ? "rgba(255, 255, 255, 0.8)" : "#A8A8A9", ({
      pinned: t
    }) => t ? "rgba(255, 255, 255, 0.7)" : "rgba(255, 255, 255, 0.08)"), Fa1 = (0, p7.forwardRef)((n, o) => {
      var h = n,
        {
          children: t,
          hint: a,
          pinned: c,
          icon: r,
          pinHintIcon: e,
          unpinHintIcon: l
        } = h,
        i = m4(h, ["children", "hint", "pinned", "icon", "pinHintIcon", "unpinHintIcon"]);
      let [v, g] = (0, p7.useState)(!1),
        s = v || a;
      return p7.default.createElement(ba1, D(S({}, i), {
        pinned: c,
        ref: o,
        onMouseOver: () => g(!0),
        onMouseOut: () => g(!1)
      }), p7.default.createElement("div", {
        style: {
          pointerEvents: "none",
          width: "fit-content",
          height: "fit-content",
          inset: 0
        }
      }, s && !c ? e : s && c ? l : r), t);
    }), Sh = Fa1;
  });
function Ia1(t) {
  return cm.createElement("svg", S({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), cm.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12.732 4.048l-.792-.792L7.2 8l4.74 4.744.792-.792L8.781 8l3.951-3.952zm-3.932 0l-.792-.792L3.268 8l4.74 4.744.792-.792L4.848 8 8.8 4.048z",
    fill: "currentColor"
  }));
}
var cm,
  rm,
  FW = x(() => {
    "use strict";

    cm = I(G());
    rm = Ia1;
  });
function Pa1(t) {
  return em.createElement("svg", S({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, t), em.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3.694 3.765l.792-.792 4.74 4.744-4.74 4.744-.792-.793 3.951-3.951-3.951-3.952zm3.932 0l.792-.792 4.74 4.744-4.74 4.744-.792-.793 3.952-3.951-3.952-3.952z",
    fill: "currentColor"
  }));
}
var em,
  lm,
  IW = x(() => {
    "use strict";

    em = I(G());
    lm = Pa1;
  });
var y2,
  GW,
  Ga1,
  TW,
  qW,
  ZW,
  m7,
  OW,
  Ta1,
  EW,
  Za1,
  DW,
  Oa1,
  WW,
  Ea1,
  _W,
  im,
  jW,
  Da1,
  NW,
  PW,
  Wa1,
  UW,
  KW = x(() => {
    "use strict";

    M1();
    f1();
    y2 = I(G());
    c1();
    Ga1 = B.div(GW || (GW = V(["\n  width: 138px;\n  border-radius: 2px;\n  background-color: rgba(42, 45, 50, 0.9);\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n  justify-content: flex-start;\n  box-shadow: 0px 1px 1px rgba(0, 0, 0, 0.25), 0px 2px 6px rgba(0, 0, 0, 0.15);\n  backdrop-filter: blur(14px);\n  pointer-events: auto;\n  // makes the edges of the item highlights match the rounded corners\n  overflow: hidden;\n\n  @supports not (backdrop-filter: blur()) {\n    background-color: rgba(42, 45, 50, 0.98);\n  }\n\n  color: rgba(255, 255, 255, 0.9);\n\n  & a {\n    // Fix colors of links to not be default\n    color: inherit;\n  }\n"]))), qW = B.div(TW || (TW = V(["\n  position: relative;\n  padding: 0px 12px;\n  font-weight: 400;\n  font-size: 11px;\n  height: 32px;\n  text-decoration: none;\n  user-select: none;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  cursor: default;\n"]))), m7 = B(qW)(ZW || (ZW = V(["\n  &:before {\n    position: absolute;\n    display: block;\n    content: ' ';\n    inset: 3px;\n    border-radius: 3px;\n    background: rgba(255, 255, 255, 0.1);\n    opacity: 0;\n  }\n\n  &.secondary {\n    color: rgba(255, 255, 255, 0.5);\n  }\n\n  &:hover {\n    /* background-color: #398995; */\n    color: white !important;\n    &:before {\n      opacity: 1;\n    }\n  }\n"]))), Ta1 = B(qW)(OW || (OW = V(["\n  height: auto;\n  min-height: 32px;\n  padding-top: 12px;\n  padding-bottom: 10px;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  gap: 8px;\n  color: rgba(255, 255, 255, 0.5);\n"]))), Za1 = B.div(EW || (EW = V(["\n  font-weight: 600;\n"]))), Oa1 = B.div(DW || (DW = V(["\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n"]))), Ea1 = B.div(WW || (WW = V(["\n  margin-left: 2px;\n"]))), im = B.div(_W || (_W = V(["\n  height: 1px;\n  margin: 0 2px;\n  background: rgba(255, 255, 255, 0.02);\n"]))), Da1 = B.div(jW || (jW = V(["\n  position: absolute;\n  width: 8px;\n  height: 8px;\n  background: #40aaa4;\n  right: 14px;\n  top: 12px;\n  border-radius: 50%;\n"]))), NW = "0.7.2", PW = NW.match(/^[^\-]+/)[0], Wa1 = y2.default.forwardRef((t, a) => {
      let c = s1(T().atomP.ahistoric.updateChecker.result.hasUpdates);
      return y2.default.createElement(Ga1, {
        ref: a
      }, y2.default.createElement(m7, {
        as: "a",
        href: "https://www.theatrejs.com/docs/latest",
        className: "",
        target: "_blank"
      }, "Docs"), y2.default.createElement(m7, {
        as: "a",
        href: "https://www.theatrejs.com/docs/latest/releases",
        className: "",
        target: "_blank"
      }, "Changelog"), y2.default.createElement(im, null), y2.default.createElement(m7, {
        as: "a",
        href: "https://github.com/theatre-js/theatre",
        className: "",
        target: "_blank"
      }, "Github"), y2.default.createElement(m7, {
        as: "a",
        href: "https://twitter.com/theatre_js",
        className: "",
        target: "_blank"
      }, "Twitter"), y2.default.createElement(m7, {
        className: "",
        as: "a",
        href: "https://discord.gg/bm9f8F9Y9N",
        target: "_blank"
      }, "Discord"), y2.default.createElement(im, null), y2.default.createElement(Ta1, null, y2.default.createElement(Za1, null, "Version"), y2.default.createElement(Oa1, null, y2.default.createElement(Ea1, null, NW, " ", c === !0 ? "(outdated)" : c === !1 ? "(latest)" : ""))), c === !0 && y2.default.createElement(y2.default.Fragment, null, y2.default.createElement(im, null), y2.default.createElement(m7, {
        as: "a",
        href: "https://www.theatrejs.com/docs/latest/releases".concat(encodeURIComponent(PW)),
        className: "",
        target: "_blank"
      }, "Update", y2.default.createElement(Da1, null)), y2.default.createElement(m7, {
        as: "a",
        href: "https://www.theatrejs.com/docs/latest/releases#".concat(encodeURIComponent(PW)),
        className: "",
        target: "_blank"
      }, "What's new?")));
    }), UW = Wa1;
  });
var E1,
  r_,
  YW,
  _a1,
  JW,
  ja1,
  t_,
  $W,
  a_,
  QW,
  c_,
  f_1,
  XW,
  qa1,
  e_,
  l_ = x(() => {
    "use strict";

    M1();
    f1();
    E1 = I(G());
    c1();
    nt();
    aW();
    gr();
    r_ = require("@theatre/dataverse");
    am();
    bW();
    b9();
    FW();
    IW();
    Tt();
    c4();
    KW();
    vt();
    _a1 = B.div(YW || (YW = V(["\n  height: 36px;\n  pointer-events: none;\n\n  display: flex;\n  justify-content: space-between;\n  padding: 12px;\n"]))), ja1 = B.div(JW || (JW = V(["\n  color: white;\n  width: 14px;\n  height: 14px;\n  background: #d00;\n  border-radius: 4px;\n  text-align: center;\n  line-height: 14px;\n  font-weight: 600;\n  font-size: 8px;\n  position: relative;\n  left: -6px;\n  top: -11px;\n  margin-right: -14px;\n  box-shadow: 0 4px 6px -4px #00000059;\n"]))), $W = B.div(t_ || (t_ = V(["\n  display: flex;\n  gap: 8px;\n"]))), QW = B.div(a_ || (a_ = V(["\n  position: absolute;\n  background: ", ";\n  width: 6px;\n  height: 6px;\n  border-radius: 50%;\n  right: -2px;\n  top: -2px;\n"])), ({
      type: t
    }) => t === "info" ? "#40aaa4" : "#f59e0b"), f_1 = B.div(c_ || (c_ = V(["\n  position: absolute;\n  height: 32px;\n  width: 1px;\n  background: #373b40;\n  opacity: 0.4;\n"]))), XW = !1, qa1 = () => {
      var s, d, z;
      let t = v1(() => {
          let u = (0, r_.val)(T().atomP.ephemeral.coreByProject);
          return Object.entries(u).map(([f, p]) => ({
            projectId: f,
            state: p
          })).filter(({
            state: f
          }) => f.loadingState.type === "browserStateIsNotBasedOnDiskState");
        }, []),
        [a, c] = R3({
          enabled: t.length > 0,
          enterDelay: t.length > 0 ? 0 : 200
        }, () => t.length > 0 ? E1.default.createElement(tW, null, t.length === 1 ? 'There is a state conflict in project "'.concat(t[0].projectId, '". Select the project in the outline below in order to fix it.') : "There are ".concat(t.length, " projects that have state conflicts. They are highlighted in the outline below. ")) : E1.default.createElement(w5, null, E1.default.createElement(E1.default.Fragment, null, "Outline"))),
        r = (s = s1(T().atomP.ahistoric.pinOutline)) != null ? s : !0,
        e = (d = s1(T().atomP.ahistoric.pinDetails)) != null ? d : !0,
        l = s1(T().atomP.ahistoric.updateChecker.result.hasUpdates) === !0,
        i = x2(() => {
          let u = o.current.getBoundingClientRect();
          return {
            debugName: "More Menu",
            constraints: {
              maxX: u.right,
              maxY: 8,
              minX: u.left - 140,
              minY: 8
            },
            verticalGap: 2
          };
        }, () => E1.default.createElement(UW, null)),
        o = (0, E1.useRef)(null),
        n = (0, E1.useMemo)(() => (window.__IS_VISUAL_REGRESSION_TESTING && (XW || (XW = !0, console.warn("Visual regression testing enabled, so we're showing the updates badge unconditionally"))), l || window.__IS_VISUAL_REGRESSION_TESTING ? !0 : l), [l]),
        {
          hasNotifications: h
        } = Pu(),
        [v, g] = eP();
      return E1.default.createElement(_a1, null, E1.default.createElement($W, null, a, E1.default.createElement(Sh, {
        ref: c,
        "data-testid": "OutlinePanel-TriggerButton",
        onClick: () => {
          T().transaction(({
            stateEditors: u,
            drafts: f
          }) => {
            var p;
            u.studio.ahistoric.setPinOutline(!((p = f.ahistoric.pinOutline) == null || p));
          });
        },
        icon: E1.default.createElement(Gc, null),
        pinHintIcon: E1.default.createElement(lm, null),
        unpinHintIcon: E1.default.createElement(rm, null),
        pinned: r
      }), t.length > 0 ? E1.default.createElement(ja1, null, t.length) : null, E1.default.createElement(yh, {
        showLeftDivider: !0,
        toolbarId: "global"
      })), E1.default.createElement($W, null, v, E1.default.createElement(Sh, {
        ref: g,
        onClick: () => {
          T().transaction(({
            stateEditors: u,
            drafts: f
          }) => {
            var p;
            u.studio.ahistoric.setPinNotifications(!((p = f.ahistoric.pinNotifications) != null && p));
          });
        },
        icon: E1.default.createElement(Zc, null),
        pinHintIcon: E1.default.createElement(Zc, null),
        unpinHintIcon: E1.default.createElement(Zc, null),
        pinned: (z = s1(T().atomP.ahistoric.pinNotifications)) != null ? z : !1
      }, h && E1.default.createElement(QW, {
        type: "warning"
      })), i.node, E1.default.createElement(Y4, {
        ref: o,
        onClick: u => {
          i.toggle(u, o.current);
        }
      }, E1.default.createElement(wz, null), n && E1.default.createElement(QW, {
        type: "info"
      })), E1.default.createElement(Sh, {
        ref: c,
        onClick: () => {
          T().transaction(({
            stateEditors: u,
            drafts: f
          }) => {
            var p;
            u.studio.ahistoric.setPinDetails(!((p = f.ahistoric.pinDetails) == null || p));
          });
        },
        icon: E1.default.createElement(Hz, null),
        pinHintIcon: E1.default.createElement(rm, null),
        unpinHintIcon: E1.default.createElement(lm, null),
        pinned: e
      })));
    }, e_ = qa1;
  });
var i_,
  Nr,
  o_,
  kh,
  Na1,
  n_,
  h_,
  Ua1,
  om = x(() => {
    "use strict";

    i_ = require("@theatre/dataverse");
    M1();
    Nr = I(G()), o_ = I(B4()), kh = new i_.Atom({
      set: {},
      byId: {}
    }), Na1 = 1, n_ = () => {
      let t = Na1++;
      function a(r, e, l) {
        kh.reduce(i => ({
          byId: D(S({}, i.byId), {
            [t]: {
              comp: r,
              props: e,
              portalNode: l
            }
          }),
          set: D(S({}, i.set), {
            [t]: !0
          })
        }));
      }
      function c() {
        kh.reduce(r => {
          let e = S({}, r.set),
            l = S({}, r.byId);
          return delete e[t], {
            byId: l,
            set: e
          };
        });
      }
      return {
        mountOrRender: a,
        unmount: c
      };
    }, h_ = () => {
      let t = Object.keys(s1(kh.pointer.set));
      return Nr.default.createElement(Nr.default.Fragment, null, t.map(a => Nr.default.createElement(Ua1, {
        key: "id-" + a,
        id: a
      })));
    }, Ua1 = ({
      id: t
    }) => {
      let {
        comp: a,
        portalNode: c,
        props: r
      } = s1(kh.pointer.byId[t]);
      return (0, o_.createPortal)(Nr.default.createElement(a, S({}, r)), c);
    };
  });
function hm(t) {
  let a = T(),
    [c, r] = z1(void 0),
    e = Wr();
  e.configureLogging({
    min: 128,
    dev: v_,
    internal: v_
  });
  let l = e.getLogger().named("Theatre.js UIRoot");
  Up();
  let i = s1(a.atomP.ahistoric.visibilityState);
  return (0, W2.useEffect)(() => (i === "everythingIsHidden" && console.warn("Theatre.js Studio is hidden. Use the keyboard shortcut 'alt + \\' to restore the studio, or call studio.ui.restore()."), () => {}), [i]), v1(() => {
    let n = (0, nm.val)(a.atomP.ahistoric.visibilityState);
    return (0, nm.val)(a.atomP.ephemeral.initialised) ? W2.default.createElement(uo, {
      logger: l
    }, W2.default.createElement(MI, null, W2.default.createElement(vA, null, W2.default.createElement(Qa1, null), W2.default.createElement(a3.Provider, {
      value: r
    }, W2.default.createElement(fz, {
      target: window.__IS_VISUAL_REGRESSION_TESTING === !0 ? void 0 : t.containerShadow
    }, W2.default.createElement(W2.default.Fragment, null, W2.default.createElement(Ka1, null), W2.default.createElement($a1, {
      className: n === "everythingIsHidden" ? "invisible" : ""
    }, W2.default.createElement(mz, {
      ref: c
    }), W2.default.createElement(e_, null), W2.default.createElement(XD, null), W2.default.createElement(lP, null)))))))) : null;
  }, [a, c, r]);
}
var nm,
  W2,
  g_,
  Ka1,
  d_,
  $a1,
  s_,
  v_,
  Qa1,
  z_ = x(() => {
    "use strict";

    f1();
    M1();
    nm = require("@theatre/dataverse"), W2 = I(G());
    c1();
    YD();
    l_();
    P1();
    T6();
    xh();
    I0();
    Su();
    mo();
    om();
    G1();
    _r();
    L5();
    vt();
    Ka1 = typeof window != "undefined" ? Zi(g_ || (g_ = V(["\n  :host {\n    contain: strict;\n  }\n"]))) : {}, $a1 = B(oA)(d_ || (d_ = V(["\n  z-index: 50;\n  position: fixed;\n  inset: 0;\n\n  &.invisible {\n    pointer-events: none !important;\n    opacity: 0;\n    transform: translateX(1000000px);\n  }\n"]))), v_ = /Playground.+Theatre\.js/.test((s_ = typeof document != "undefined" ? document == null ? void 0 : document.title : null) != null ? s_ : "");
    Qa1 = () => W2.default.createElement(h_, null);
  });
var p_ = L1(vm => {
  "use strict";

  var u_ = B4();
  vm.createRoot = u_.createRoot, vm.hydrateRoot = u_.hydrateRoot;
  var W_1;
});
var M_ = {};
Lf(M_, {
  default: () => Ah
});
var m_,
  f_,
  Ah,
  x_ = x(() => {
    "use strict";

    z_();
    m_ = I(G()), f_ = I(p_());
    om();
    G1();
    am();
    Ah = class {
      constructor() {
        y1(this, "containerEl", document.createElement("div"));
        y1(this, "_renderTimeout");
        y1(this, "_documentBodyUIIsRenderedIn");
        y1(this, "containerShadow");
        this.containerEl.id = "theatrejs-studio-root", this.containerEl.style.cssText = "\n      position: fixed;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      pointer-events: none;\n      z-index: 100;\n    ";
        let a = () => {
          if (window.__IS_VISUAL_REGRESSION_TESTING === !0) {
            let c = document.createElement("div");
            return c.id = "theatrejs-faux-shadow-root", document.body.appendChild(c), c;
          } else return this.containerEl.attachShadow({
            mode: "open"
          });
        };
        this.containerShadow = a();
      }
      render() {
        let a = () => {
          if (!document.body) {
            this._renderTimeout = setTimeout(a, 5);
            return;
          }
          this._renderTimeout = void 0, this._documentBodyUIIsRenderedIn = document.body, this._documentBodyUIIsRenderedIn.appendChild(this.containerEl), f_.default.createRoot(this.containerShadow).render(m_.default.createElement(hm, {
            containerShadow: this.containerShadow
          }));
        };
        this._renderTimeout = setTimeout(a, 10);
      }
      renderToolset(a, c) {
        let r = n_();
        return r.mountOrRender(US(yh), {
          toolbarId: a
        }, c), r.unmount;
      }
    };
  });
var H_ = L1(Dt => {
  Dt.compare = ac1;
  Dt.reduce = cc1;
  var Ja1, Rh, tc1, bh, Et;
  Dt.REMOVE = Ja1 = Rh = -1;
  Dt.ADD = tc1 = bh = 1;
  Dt.EQUAL = Et = 0;
  function ac1(t, a) {
    var c = t.length,
      r = a.length,
      e = rc1(t, a),
      l = e < c && e < r ? ec1(t, a, e) : 0,
      i = l + e - 1;
    c -= i, r -= i;
    for (var o = ic1(c, r), n = c - 1; n >= 0; --n) for (var h = r - 1; h >= 0; --h) o[h][n] = lc1(o, t, a, e, n, h);
    return {
      prefix: e,
      matrix: o,
      suffix: l
    };
  }
  function cc1(t, a, c) {
    var r,
      e,
      l,
      i,
      o = c.matrix,
      n = c.prefix;
    for (r = 0; r < n; ++r) a = t(a, Et, r, r);
    for (l = r, n = o.length, r = 0, e = 0; r < n;) switch (i = o[r][e].type, a = t(a, i, r + l, e + l), i) {
      case Et:
        ++r, ++e;
        break;
      case Rh:
        ++e;
        break;
      case bh:
        ++r;
        break;
    }
    for (r += l, e += l, n = c.suffix, l = 0; l < n; ++l) a = t(a, Et, r + l, e + l);
    return a;
  }
  function rc1(t, a) {
    for (var c = 0, r = Math.min(t.length, a.length); c < r && t[c] === a[c];) ++c;
    return c;
  }
  function ec1(t, a) {
    for (var c = t.length - 1, r = a.length - 1, e = Math.min(c, r), l = 0; l < e && t[c - l] === a[r - l];) ++l;
    return l;
  }
  function lc1(t, a, c, r, e, l) {
    return a[e + r] === c[l + r] ? {
      value: t[l + 1][e + 1].value,
      type: Et
    } : t[l][e + 1].value < t[l + 1][e].value ? {
      value: t[l][e + 1].value + 1,
      type: Rh
    } : {
      value: t[l + 1][e].value + 1,
      type: bh
    };
  }
  function ic1(t, a) {
    var c = [],
      r,
      e,
      l;
    for (l = c[a] = [], e = 0; e < t; ++e) l[e] = {
      value: t - e,
      type: Rh
    };
    for (r = 0; r < a; ++r) c[r] = [], c[r][t] = {
      value: a - r,
      type: bh
    };
    return c[a][t] = {
      value: 0,
      type: Et
    }, c;
  }
});
var gm = L1(Fh => {
  Fh.cons = oc1;
  Fh.tail = nc1;
  Fh.map = hc1;
  function oc1(t, a) {
    var c = a.length,
      r = new Array(c + 1);
    r[0] = t;
    for (var e = 0; e < c; ++e) r[e + 1] = a[e];
    return r;
  }
  function nc1(t) {
    for (var a = t.length - 1, c = new Array(a), r = 0; r < a; ++r) c[r] = t[r + 1];
    return c;
  }
  function hc1(t, a) {
    for (var c = new Array(a.length), r = 0; r < a.length; ++r) c[r] = t(a[r]);
    return c;
  }
});
var w_ = L1((tj1, V_) => {
  V_.exports = dc1;
  var Ih = /\/|~1|~0/g,
    dm = "/",
    vc1 = "~",
    gc1 = "~1";
  function dc1(t, a) {
    var c, r, e, l;
    for (c = t.charAt(0) === dm ? 1 : 0, r = "", Ih.lastIndex = c; e = Ih.exec(t);) if (l = e[0], r += t.slice(c, Ih.lastIndex - l.length), c = Ih.lastIndex, l === dm) {
      if (a(r) === !1) return t;
      r = "";
    } else r += l === gc1 ? dm : vc1;
    return r += t.slice(c), a(r), t;
  }
});
var Ph = L1(J4 => {
  var B_ = w_();
  J4.find = xc1;
  J4.join = Lc1;
  J4.absolute = Cc1;
  J4.parse = Hc1;
  J4.contains = Vc1;
  J4.encodeSegment = Bc1;
  J4.decodeSegment = wc1;
  J4.parseArrayIndex = sm;
  J4.isValidArrayIndex = y_;
  var Wt = "/",
    sc1 = /\//g,
    zc1 = "~1",
    uc1 = /~1/g,
    pc1 = "~",
    mc1 = /~/g,
    fc1 = "~0",
    Mc1 = /~0/g;
  function xc1(t, a, c, r) {
    if (typeof a == "string") {
      if (a === "") return {
        target: t,
        key: void 0
      };
      if (a === Wt) return {
        target: t,
        key: ""
      };
      var e = t,
        l,
        i = r !== void 0;
      return B_(a, function (o) {
        if (t == null) return e = null, !1;
        Array.isArray(t) ? l = i ? Sc1(c, sm(o), t, r) : o === "-" ? o : sm(o) : l = o, e = t, t = t[l];
      }), e === null ? void 0 : {
        target: e,
        key: l
      };
    }
  }
  function Cc1(t) {
    return t[0] === Wt ? t : Wt + t;
  }
  function Lc1(t) {
    return t.join(Wt);
  }
  function Hc1(t) {
    var a = [];
    return B_(t, a.push.bind(a)), a;
  }
  function Vc1(t, a) {
    return a.indexOf(t) === 0 && a[t.length] === Wt;
  }
  function wc1(t) {
    return t.replace(uc1, Wt).replace(Mc1, pc1);
  }
  function Bc1(t) {
    return t.replace(mc1, fc1).replace(sc1, zc1);
  }
  var yc1 = /^(0|[1-9]\d*)$/;
  function y_(t) {
    return yc1.test(t);
  }
  function sm(t) {
    if (y_(t)) return +t;
    throw new SyntaxError("invalid array index " + t);
  }
  function Sc1(t, a, c, r) {
    var e = a;
    if (e < 0) throw new Error("array index out of bounds " + e);
    if (r !== void 0 && typeof t == "function" && (e = t(a, c, r), e < 0)) throw new Error("could not find patch context " + r);
    return e;
  }
});
var um = L1((cj1, S_) => {
  S_.exports = zm;
  function zm(t) {
    return t == null || typeof t != "object" ? t : Array.isArray(t) ? kc1(t) : Ac1(t);
  }
  function kc1(t) {
    for (var a = t.length, c = new Array(a), r = 0; r < a; ++r) c[r] = zm(t[r]);
    return c;
  }
  function Ac1(t) {
    for (var a = Object.keys(t), c = {}, r, e = 0, l = a.length; e < l; ++e) r = a[e], c[r] = zm(t[r]);
    return c;
  }
});
var A_ = L1((rj1, k_) => {
  k_.exports = pm;
  function pm(t, a) {
    return t === a ? !0 : Array.isArray(t) && Array.isArray(a) ? Rc1(t, a) : typeof t == "object" && typeof a == "object" ? bc1(t, a) : !1;
  }
  function Rc1(t, a) {
    if (t.length !== a.length) return !1;
    for (var c = 0; c < t.length; ++c) if (!pm(t[c], a[c])) return !1;
    return !0;
  }
  function bc1(t, a) {
    if (t === null && a !== null || t !== null && a === null) return !1;
    var c = Object.keys(t),
      r = Object.keys(a);
    if (c.length !== r.length) return !1;
    for (var e = 0, l; e < c.length; ++e) if (l = c[e], !(l in a && pm(t[l], a[l]))) return !1;
    return !0;
  }
});
var I_ = L1((ej1, F_) => {
  var u0 = Ph();
  F_.exports = function (a, c) {
    var r = u0.parse(a.path),
      e = u0.parse(c.path),
      l = Tc1(r, e),
      i = Pc1(r, e, l.length),
      o = b_(a),
      n = b_(c);
    return l.length === 0 && !i ? [n, o] : i ? Ic1(o, r, n, e) : Fc1(o, r, n, e);
  };
  function Fc1(t, a, c, r) {
    if (t.path === c.path) throw new TypeError("cannot commute " + t.op + "," + c.op + " with identical object paths");
    return [c, t];
  }
  function Ic1(t, a, c, r) {
    return a.length === r.length ? Gc1(t, a, c, r) : (a.length > r.length ? (a = R_(c, r, t, a, -1), t.path = u0.absolute(u0.join(a))) : (r = R_(t, a, c, r, 1), c.path = u0.absolute(u0.join(r))), [c, t]);
  }
  function Pc1(t, a, c) {
    return u0.isValidArrayIndex(t[c]) && u0.isValidArrayIndex(a[c]);
  }
  function Gc1(t, a, c, r) {
    var e = a.length - 1,
      l = +a[e],
      i = +r[e],
      o;
    return l < i ? t.op === "add" || t.op === "copy" ? (o = r.slice(), o[e] = Math.max(0, i - 1), c.path = u0.absolute(u0.join(o))) : t.op === "remove" && (o = r.slice(), o[e] = i + 1, c.path = u0.absolute(u0.join(o))) : c.op === "add" || c.op === "copy" ? (o = a.slice(), o[e] = l + 1, t.path = u0.absolute(u0.join(o))) : l > i && c.op === "remove" && (o = a.slice(), o[e] = Math.max(0, l - 1), t.path = u0.absolute(u0.join(o))), [c, t];
  }
  function R_(t, a, c, r, e) {
    var l = a.length - 1,
      i = +a[l],
      o = +r[l],
      n = r.slice();
    return i > o || (t.op === "add" || t.op === "copy" ? n[l] = Math.max(0, o - e) : t.op === "remove" && (n[l] = Math.max(0, o + e))), n;
  }
  function Tc1(t, a) {
    var c = t.length,
      r = a.length;
    if (c === 0 || r === 0 || c < 2 && r < 2) return [];
    for (var e = c === r ? c - 1 : Math.min(c, r), l = 0; l < e && t[l] === a[l];) ++l;
    return t.slice(0, l);
  }
  function b_(t) {
    return t.op === "remove" ? {
      op: t.op,
      path: t.path
    } : t.op === "copy" || t.op === "move" ? {
      op: t.op,
      path: t.path,
      from: t.from
    } : {
      op: t.op,
      path: t.path,
      value: t.value
    };
  }
});
var mm = L1((lj1, P_) => {
  P_.exports = Gh;
  function Gh(t) {
    Error.call(this), this.name = this.constructor.name, this.message = t, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
  Gh.prototype = Object.create(Error.prototype);
  Gh.prototype.constructor = Gh;
});
var Zh = L1((ij1, G_) => {
  G_.exports = Th;
  function Th(t) {
    Error.call(this), this.name = this.constructor.name, this.message = t, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
  Th.prototype = Object.create(Error.prototype);
  Th.prototype.constructor = Th;
});
var fm = L1((oj1, T_) => {
  T_.exports = Oh;
  function Oh(t) {
    Error.call(this), this.name = this.constructor.name, this.message = t, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
  Oh.prototype = Object.create(Error.prototype);
  Oh.prototype.constructor = Oh;
});
var Hm = L1(f7 => {
  var Mm = Ph(),
    xm = um(),
    Zc1 = A_(),
    Kr = I_(),
    Eh = gm(),
    Oc1 = mm(),
    t5 = Zh(),
    Cm = fm(),
    d8 = Mm.find,
    Dh = Mm.parseArrayIndex;
  f7.test = {
    apply: Ec1,
    inverse: Dc1,
    commute: Wc1
  };
  f7.add = {
    apply: _c1,
    inverse: jc1,
    commute: Z_
  };
  f7.remove = {
    apply: Kc1,
    inverse: $c1,
    commute: Qc1
  };
  f7.replace = {
    apply: qc1,
    inverse: Nc1,
    commute: Uc1
  };
  f7.move = {
    apply: Xc1,
    inverse: Yc1,
    commute: Jc1
  };
  f7.copy = {
    apply: tr1,
    inverse: ar1,
    commute: Z_
  };
  function Ec1(t, a, c) {
    var r = d8(t, a.path, c.findContext, a.context),
      e = r.target,
      l,
      i;
    if (Array.isArray(e) ? (l = Dh(r.key), i = e[l]) : i = r.key === void 0 ? r.target : r.target[r.key], !Zc1(i, a.value)) throw new Oc1("test failed " + JSON.stringify(a));
    return t;
  }
  function Dc1(t, a) {
    return t.push(a), 1;
  }
  function Wc1(t, a) {
    if (t.path === a.path && a.op === "remove") throw new TypeError("Can't commute test,remove -> remove,test for same path");
    return a.op === "test" || a.op === "replace" ? [a, t] : Kr(t, a);
  }
  function _c1(t, a, c) {
    var r = d8(t, a.path, c.findContext, a.context);
    if (Wh(r)) throw new t5("path does not exist " + a.path);
    if (a.value === void 0) throw new t5("missing value");
    var e = xm(a.value);
    return r.key === void 0 ? e : (Lm(r, e), t);
  }
  function Lm(t, a) {
    var c = t.target;
    if (Array.isArray(c)) {
      if (t.key === "-") c.push(a);else {
        if (t.key > c.length) throw new t5("target of add outside of array bounds");
        c.splice(t.key, 0, a);
      }
    } else if (D_(c)) c[t.key] = a;else throw new t5("target of add must be an object or array " + t.key);
  }
  function jc1(t, a) {
    var c = a.context;
    return c !== void 0 && (c = {
      before: c.before,
      after: Eh.cons(a.value, c.after)
    }), t.push({
      op: "test",
      path: a.path,
      value: a.value,
      context: c
    }), t.push({
      op: "remove",
      path: a.path,
      context: c
    }), 1;
  }
  function Z_(t, a) {
    if (t.path === a.path && a.op === "remove") throw new TypeError("Can't commute add,remove -> remove,add for same path");
    return Kr(t, a);
  }
  function qc1(t, a, c) {
    var r = d8(t, a.path, c.findContext, a.context);
    if (Wh(r) || E_(r)) throw new t5("path does not exist " + a.path);
    if (a.value === void 0) throw new t5("missing value");
    var e = xm(a.value);
    if (r.key === void 0) return e;
    var l = r.target;
    return Array.isArray(l) ? l[Dh(r.key)] = e : l[r.key] = e, t;
  }
  function Nc1(t, a, c, r) {
    var e = r[c - 1];
    if (e === void 0 || e.op !== "test" || e.path !== a.path) throw new Cm("cannot invert replace w/o test");
    var l = e.context;
    return l !== void 0 && (l = {
      before: l.before,
      after: Eh.cons(e.value, Eh.tail(l.after))
    }), t.push({
      op: "test",
      path: e.path,
      value: a.value
    }), t.push({
      op: "replace",
      path: e.path,
      value: e.value
    }), 2;
  }
  function Uc1(t, a) {
    if (t.path === a.path && a.op === "remove") throw new TypeError("Can't commute replace,remove -> remove,replace for same path");
    return a.op === "test" || a.op === "replace" ? [a, t] : Kr(t, a);
  }
  function Kc1(t, a, c) {
    var r = d8(t, a.path, c.findContext, a.context);
    if (Wh(r) || r.target[r.key] === void 0) throw new t5("path does not exist " + a.path);
    return O_(r), t;
  }
  function O_(t) {
    var a = t.target,
      c;
    if (Array.isArray(a)) return c = a.splice(Dh(t.key), 1), c[0];
    if (D_(a)) return c = a[t.key], delete a[t.key], c;
    throw new t5("target of remove must be an object or array");
  }
  function $c1(t, a, c, r) {
    var e = r[c - 1];
    if (e === void 0 || e.op !== "test" || e.path !== a.path) throw new Cm("cannot invert remove w/o test");
    var l = e.context;
    return l !== void 0 && (l = {
      before: l.before,
      after: Eh.tail(l.after)
    }), t.push({
      op: "add",
      path: e.path,
      value: e.value,
      context: l
    }), 2;
  }
  function Qc1(t, a) {
    return t.path === a.path && a.op === "remove" ? [a, t] : Kr(t, a);
  }
  function Xc1(t, a, c) {
    if (Mm.contains(a.path, a.from)) throw new t5("move.from cannot be ancestor of move.path");
    var r = d8(t, a.path, c.findContext, a.context),
      e = d8(t, a.from, c.findContext, a.fromContext);
    return Lm(r, O_(e)), t;
  }
  function Yc1(t, a) {
    return t.push({
      op: "move",
      path: a.from,
      context: a.fromContext,
      from: a.path,
      fromContext: a.context
    }), 1;
  }
  function Jc1(t, a) {
    if (t.path === a.path && a.op === "remove") throw new TypeError("Can't commute move,remove -> move,replace for same path");
    return Kr(t, a);
  }
  function tr1(t, a, c) {
    var r = d8(t, a.path, c.findContext, a.context),
      e = d8(t, a.from, c.findContext, a.fromContext);
    if (Wh(e) || E_(e)) throw new t5("copy.from must exist");
    var l = e.target,
      i;
    return Array.isArray(l) ? i = l[Dh(e.key)] : i = l[e.key], Lm(r, xm(i)), t;
  }
  function ar1(t, a) {
    throw new Cm("cannot invert " + a.op);
  }
  function Wh(t) {
    return t === void 0 || t.target == null && t.key !== void 0;
  }
  function E_(t) {
    return t.key !== void 0 && t.target[t.key] === void 0;
  }
  function D_(t) {
    return t !== null && typeof t == "object";
  }
});
var q_ = L1(_t => {
  var cr1 = Hm(),
    W_ = um(),
    rr1 = Zh();
  _t.apply = lr1;
  _t.applyInPlace = __;
  _t.clone = W_;
  _t.isValidObject = j_;
  _t.defaultHash = ir1;
  var er1 = {};
  function lr1(t, a, c) {
    return __(t, W_(a), c);
  }
  function __(t, a, c) {
    if (c || (c = er1), !Array.isArray(t)) return a;
    for (var r, e, l = 0; l < t.length; ++l) {
      if (e = t[l], r = cr1[e.op], r === void 0) throw new rr1("invalid op " + JSON.stringify(e));
      a = r.apply(a, e, c);
    }
    return a;
  }
  function ir1(t) {
    return j_(t) || or1(t) ? JSON.stringify(t) : t;
  }
  function j_(t) {
    return t !== null && Object.prototype.toString.call(t) === "[object Object]";
  }
  function or1(t) {
    return Object.prototype.toString.call(t) === "[object Array]";
  }
});
var U_ = L1((vj1, N_) => {
  var nr1 = Hm();
  N_.exports = function (a) {
    var c = [],
      r,
      e;
    for (r = a.length - 1; r >= 0; r -= e) e = hr1(c, a[r], r, a);
    return c;
  };
  function hr1(t, a, c, r) {
    var e = nr1[a.op];
    return e !== void 0 && typeof e.inverse == "function" ? e.inverse(t, a, c, r) : 1;
  }
});
var J_ = L1(O5 => {
  var _h = H_(),
    K_ = gm(),
    $r = q_(),
    vr1 = U_(),
    gr1 = Ph(),
    $_ = gr1.encodeSegment;
  O5.diff = dr1;
  O5.patch = $r.apply;
  O5.patchInPlace = $r.applyInPlace;
  O5.inverse = vr1;
  O5.clone = $r.clone;
  O5.InvalidPatchOperationError = Zh();
  O5.TestFailedError = mm();
  O5.PatchNotInvertibleError = fm();
  var Q_ = $r.isValidObject,
    X_ = $r.defaultHash;
  function dr1(t, a, c) {
    return Bm(t, a, "", sr1(c, [])).patch;
  }
  function sr1(t, a) {
    return typeof t == "object" ? {
      patch: a,
      hash: Vm(wm, t.hash, X_),
      makeContext: Vm(wm, t.makeContext, Y_),
      invertible: t.invertible !== !1
    } : {
      patch: a,
      hash: Vm(wm, t, X_),
      makeContext: Y_,
      invertible: !0
    };
  }
  function Bm(t, a, c, r) {
    return Array.isArray(t) && Array.isArray(a) ? ur1(t, a, c, r) : Q_(t) && Q_(a) ? zr1(t, a, c, r) : mr1(t, a, c, r);
  }
  function zr1(t, a, c, r) {
    var e = Object.keys(a),
      l = r.patch,
      i,
      o;
    for (i = e.length - 1; i >= 0; --i) {
      o = e[i];
      var n = c + "/" + $_(o);
      t[o] !== void 0 ? Bm(t[o], a[o], n, r) : l.push({
        op: "add",
        path: n,
        value: a[o]
      });
    }
    for (e = Object.keys(t), i = e.length - 1; i >= 0; --i) if (o = e[i], a[o] === void 0) {
      var h = c + "/" + $_(o);
      r.invertible && l.push({
        op: "test",
        path: h,
        value: t[o]
      }), l.push({
        op: "remove",
        path: h
      });
    }
    return r;
  }
  function ur1(t, a, c, r) {
    var e = K_.map(r.hash, t),
      l = K_.map(r.hash, a),
      i = _h.compare(e, l);
    return pr1(t, a, c, r, i);
  }
  function pr1(t, a, c, r, e) {
    var l = 0;
    return _h.reduce(function (i, o, n, h) {
      var v,
        g,
        s = i.patch,
        d = c + "/" + (h + l);
      return o === _h.REMOVE ? (v = s[s.length - 1], g = i.makeContext(h, t), i.invertible && s.push({
        op: "test",
        path: d,
        value: t[h],
        context: g
      }), v !== void 0 && v.op === "add" && v.path === d ? (v.op = "replace", v.context = g) : s.push({
        op: "remove",
        path: d,
        context: g
      }), l -= 1) : o === _h.ADD ? (s.push({
        op: "add",
        path: d,
        value: a[n],
        context: i.makeContext(h, t)
      }), l += 1) : Bm(t[h], a[n], d, i), i;
    }, r, e);
  }
  function mr1(t, a, c, r) {
    return t !== a && (r.invertible && r.patch.push({
      op: "test",
      path: c,
      value: t
    }), r.patch.push({
      op: "replace",
      path: c,
      value: a
    })), r;
  }
  function Vm(t, a, c) {
    return t(a) ? a : c;
  }
  function Y_() {}
  function wm(t) {
    return typeof t == "function";
  }
});
var s8 = L1((dj1, tj) => {
  "use strict";

  function fr1(t, a) {
    for (var c = 0, r = a.length - 1; c < r; c++) {
      if (!t[a[c]]) return null;
      t = t[a[c]];
    }
    return t;
  }
  tj.exports = fr1;
});
var E5 = L1((sj1, aj) => {
  "use strict";

  function Mr1(t) {
    return t === "~0" ? "~" : "/";
  }
  function xr1(t) {
    var a = t.split("/");
    if (t.indexOf("~") === -1) return a;
    for (var c = 0, r = a.length; c < r; c++) a[c].indexOf("~") !== -1 && (a[c] = a[c].replace(/~[01]/g, Mr1));
    return a;
  }
  aj.exports = xr1;
});
var rj = L1((zj1, cj) => {
  "use strict";

  var Cr1 = s8(),
    Lr1 = E5();
  function Hr1(t, a) {
    var c = Lr1(a),
      r = c[c.length - 1],
      e = Cr1(t, c);
    return e ? e[r] : void 0;
  }
  cj.exports = Hr1;
});
var Qr = L1((uj1, ej) => {
  "use strict";

  function ym(t, a) {
    if (t === a) return !0;
    if (!(t && a) || typeof t != "object" || typeof a != "object" || t.length !== a.length) return !1;
    if (Array.isArray(t)) {
      if (!Array.isArray(a)) return !1;
      for (var c = 0, r = t.length; c < r; c++) if (!ym(t[c], a[c])) return !1;
      return !0;
    }
    var e = Object.keys(t);
    if (e.length !== Object.keys(a).length) return !1;
    for (var l = 0, i = e.length; l < i; l++) {
      var o = e[l];
      if (!ym(t[o], a[o])) return !1;
    }
    return !0;
  }
  ej.exports = ym;
});
var Xr = L1((pj1, lj) => {
  "use strict";

  function Vr1(t, a) {
    if (a === "-") return t.length;
    for (var c = 0, r = a.length; c < r; c++) {
      var e = a.charCodeAt(c);
      if (57 < e || e < 48) return 1 / 0;
    }
    return +a;
  }
  lj.exports = Vr1;
});
var Yr = L1((mj1, ij) => {
  "use strict";

  var wr1 = Qr(),
    Br1 = s8(),
    yr1 = Xr(),
    Sr1 = E5();
  function kr1(t, a, c, r) {
    if (typeof c == "undefined") return "[op:add] require value, but got undefined";
    var e = Sr1(a),
      l = e[e.length - 1],
      i = Br1(t, e);
    if (i === null) return "[op:add] path not found: " + a;
    if (Array.isArray(i)) {
      var o = yr1(i, l);
      if (i.length < o) return "[op:add] invalid array index: " + a;
      r(t, e).splice(o, 0, c);
    } else wr1(i[l], c) || (r(t, e)[l] = c);
  }
  ij.exports = kr1;
});
var Sm = L1((fj1, oj) => {
  "use strict";

  var Ar1 = s8(),
    Rr1 = Xr(),
    br1 = E5();
  function Fr1(t, a, c) {
    var r = br1(a),
      e = r[r.length - 1],
      l = Ar1(t, r);
    if (l === null) return "[op:remove] path not found: " + a;
    if (Array.isArray(l)) {
      var i = Rr1(l, e);
      if (l.length <= i) return "[op:remove] invalid array index: " + a;
      c(t, r).splice(i, 1);
    } else delete c(t, r)[e];
  }
  oj.exports = Fr1;
});
var km = L1((Mj1, hj) => {
  "use strict";

  var nj = Qr(),
    Ir1 = s8(),
    Pr1 = Xr(),
    Gr1 = E5();
  function Tr1(t, a, c, r) {
    if (typeof c == "undefined") return "[op:replace] require value, but got undefined";
    var e = Gr1(a),
      l = e[e.length - 1],
      i = Ir1(t, e);
    if (i === null) return "[op:replace] path not found: " + a;
    if (Array.isArray(i)) {
      var o = Pr1(i, l);
      if (i.length <= o) return "[op:replace] invalid array index: " + a;
      nj(i[o], c) || r(t, e).splice(o, 1, c);
    } else nj(i[l], c) || (r(t, e)[l] = c);
  }
  hj.exports = Tr1;
});
var Am = L1((xj1, vj) => {
  "use strict";

  var Zr1 = Yr(),
    Or1 = s8(),
    Er1 = Xr(),
    Dr1 = E5();
  function Wr1(t, a, c, r) {
    if (c !== a) {
      var e = Dr1(a),
        l = e[e.length - 1],
        i = Or1(t, e);
      if (i === null) return "[op:move] path not found: " + a;
      var o = void 0;
      if (Array.isArray(i)) {
        var n = Er1(i, l);
        if (i.length <= n) return "[op:move] invalid array index: " + c;
        o = i[n], r(t, e).splice(n, 1);
      } else o = i[l], delete r(t, e)[l];
      return Zr1(t, c, o, r);
    }
  }
  vj.exports = Wr1;
});
var Rm = L1((Cj1, gj) => {
  "use strict";

  var _r1 = s8(),
    jr1 = E5(),
    qr1 = Yr();
  function Nr1(t, a, c, r) {
    var e = jr1(a),
      l = e[e.length - 1],
      i = _r1(t, e);
    return i === null ? "[op:copy] path not found: " + a : qr1(t, c, i[l], r);
  }
  gj.exports = Nr1;
});
var bm = L1((Lj1, dj) => {
  "use strict";

  var Ur1 = Qr(),
    Kr1 = s8(),
    $r1 = E5();
  function Qr1(t, a, c) {
    var r = $r1(a),
      e = r[r.length - 1],
      l = Kr1(t, r);
    if (l === null) return "[op:test] path not found: " + a;
    if (!Ur1(l[e], c)) {
      var i = JSON.stringify(l[e]),
        o = JSON.stringify(c);
      return "[op:test] not matched: " + i + " " + o;
    }
  }
  dj.exports = Qr1;
});
var jh = L1((Hj1, sj) => {
  "use strict";

  function Xr1(t) {
    if (!t || typeof t != "object") return t;
    if (Array.isArray(t)) {
      for (var a = t.length, c = new Array(a), r = 0; r < a; r++) c[r] = t[r];
      return c;
    }
    for (var e = Object.keys(t), l = {}, i = 0, o = e.length; i < o; i++) {
      var n = e[i];
      l[n] = t[n];
    }
    return l;
  }
  sj.exports = Xr1;
});
var uj = L1((Vj1, zj) => {
  "use strict";

  var Yr1 = rj(),
    Jr1 = Yr(),
    te1 = Sm(),
    ae1 = km(),
    ce1 = Am(),
    re1 = Rm(),
    ee1 = bm(),
    le1 = Qr(),
    ie1 = jh(),
    oe1 = E5();
  function ne1(t, a) {
    return {
      get: function (c) {
        return Yr1(t, c);
      },
      add: function (c, r) {
        return Jr1(t, c, r, a);
      },
      remove: function (c) {
        return te1(t, c, a);
      },
      replace: function (c, r) {
        return ae1(t, c, r, a);
      },
      move: function (c, r) {
        return ce1(t, c, r, a);
      },
      copy: function (c, r) {
        return re1(t, c, r, a);
      },
      test: function (c, r) {
        return ee1(t, c, r);
      },
      deepEqual: le1,
      shallowCopy: ie1,
      toKeys: oe1
    };
  }
  zj.exports = ne1;
});
var mj = L1((wj1, pj) => {
  "use strict";

  function he1(t, a, c, r) {
    return r.error = c, r.partial ? a[""] : t;
  }
  pj.exports = he1;
});
var Mj = L1((Bj1, fj) => {
  "use strict";

  function ve1(t) {
    return !!t;
  }
  fj.exports = ve1;
});
var Cj = L1((yj1, xj) => {
  "use strict";

  function ge1(t) {
    if (t) throw new TypeError(t);
  }
  xj.exports = ge1;
});
var Hj = L1((Sj1, Lj) => {
  "use strict";

  var de1 = jh();
  function se1(t, a) {
    for (var c = 0, r = a.length - 1; c < r; c++) t = t[a[c]] = de1(t[a[c]]);
    return t;
  }
  Lj.exports = se1;
});
var wj = L1((kj1, Vj) => {
  "use strict";

  var ze1 = jh();
  function ue1(t, a, c) {
    var r = t[a];
    return c.has(r) || (r = ze1(r), c.add(r)), r;
  }
  function pe1(t, a, c) {
    for (var r = 0, e = a.length - 1; r < e; r++) t = t[a[r]] = ue1(t, a[r], c);
    return t;
  }
  Vj.exports = pe1;
});
var yj = L1((Aj1, Bj) => {
  "use strict";

  var me1 = uj(),
    z8 = mj(),
    fe1 = Mj(),
    Me1 = Cj(),
    xe1 = Hj(),
    Ce1 = wj(),
    Le1 = Yr(),
    He1 = Sm(),
    Ve1 = km(),
    we1 = Am(),
    Be1 = Rm(),
    ye1 = bm(),
    Se1 = Set || function () {
      var t = [];
      return t.has = function (a) {
        return this.indexOf(a) !== -1;
      }, t.add = function (a) {
        this.push(a);
      }, t;
    };
  function ke1(t, a, c) {
    if (a.length === 0) return t;
    c = c || {};
    for (var r = c.strict ? Me1 : fe1, e = a.length === 1 ? xe1 : function (v) {
        return function (g, s) {
          return Ce1(g, s, v);
        };
      }(new Se1()), l = {
        "": t
      }, i, o = 0, n = a.length; o < n; o++) {
      var h = a[o];
      switch (h.op) {
        case "add":
          if (r(Le1(l, "" + h.path, h.value, e))) return z8(t, l, h, c);
          break;
        case "remove":
          if (r(He1(l, "" + h.path, e))) return z8(t, l, h, c);
          break;
        case "replace":
          if (r(Ve1(l, "" + h.path, h.value, e))) return z8(t, l, h, c);
          break;
        case "move":
          if (r(we1(l, "" + h.from, "" + h.path, e))) return z8(t, l, h, c);
          break;
        case "copy":
          if (r(Be1(l, "" + h.from, "" + h.path, e))) return z8(t, l, h, c);
          break;
        case "test":
          if (r(ye1(l, "" + h.path, h.value))) return z8(t, l, h, c);
          break;
        default:
          if (c.custom && c.custom[h.op]) {
            if (i = i || me1(l, e), r(c.custom[h.op](i, h, o, a))) return z8(t, l, h, c);
          } else return r("[op:" + h.op + "] unknown"), z8(t, l, h, c);
          break;
      }
    }
    return l[""];
  }
  Bj.exports = ke1;
});
var kj = L1((Rj1, Sj) => {
  Sj.exports = yj();
});
var zq = L1((rv, pf) => {
  (function (t, a) {
    typeof rv == "object" && typeof pf == "object" ? pf.exports = a() : typeof define == "function" && define.amd ? define([], a) : typeof rv == "object" ? rv.blobCompare = a() : t.blobCompare = a();
  })(window, function () {
    return function (t) {
      var a = {};
      function c(r) {
        if (a[r]) return a[r].exports;
        var e = a[r] = {
          i: r,
          l: !1,
          exports: {}
        };
        return t[r].call(e.exports, e, e.exports, c), e.l = !0, e.exports;
      }
      return c.m = t, c.c = a, c.d = function (r, e, l) {
        c.o(r, e) || Object.defineProperty(r, e, {
          enumerable: !0,
          get: l
        });
      }, c.r = function (r) {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(r, Symbol.toStringTag, {
          value: "Module"
        }), Object.defineProperty(r, "__esModule", {
          value: !0
        });
      }, c.t = function (r, e) {
        if (1 & e && (r = c(r)), 8 & e || 4 & e && typeof r == "object" && r && r.__esModule) return r;
        var l = Object.create(null);
        if (c.r(l), Object.defineProperty(l, "default", {
          enumerable: !0,
          value: r
        }), 2 & e && typeof r != "string") for (var i in r) c.d(l, i, function (o) {
          return r[o];
        }.bind(null, i));
        return l;
      }, c.n = function (r) {
        var e = r && r.__esModule ? function () {
          return r.default;
        } : function () {
          return r;
        };
        return c.d(e, "a", e), e;
      }, c.o = function (r, e) {
        return Object.prototype.hasOwnProperty.call(r, e);
      }, c.p = "", c(c.s = 4);
    }([function (t, a, c) {
      "use strict";

      var r = function (n, h) {
          if (Array.isArray(n)) return n;
          if (Symbol.iterator in Object(n)) return function (v, g) {
            var s = [],
              d = !0,
              z = !1,
              u = void 0;
            try {
              for (var f, p = v[Symbol.iterator](); !(d = (f = p.next()).done) && (s.push(f.value), !g || s.length !== g); d = !0);
            } catch (m) {
              z = !0, u = m;
            } finally {
              try {
                !d && p.return && p.return();
              } finally {
                if (z) throw u;
              }
            }
            return s;
          }(n, h);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        },
        e = function () {
          function n(h, v) {
            for (var g = 0; g < v.length; g++) {
              var s = v[g];
              s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(h, s.key, s);
            }
          }
          return function (h, v, g) {
            return v && n(h.prototype, v), g && n(h, g), h;
          };
        }();
      function l(n) {
        if (Array.isArray(n)) {
          for (var h = 0, v = Array(n.length); h < n.length; h++) v[h] = n[h];
          return v;
        }
        return Array.from(n);
      }
      var i = c(2),
        o = function (n) {
          function h(v) {
            (function (s, d) {
              if (!(s instanceof d)) throw new TypeError("Cannot call a class as a function");
            })(this, h);
            var g = function (s, d) {
              if (!s) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return !d || typeof d != "object" && typeof d != "function" ? s : d;
            }(this, (h.__proto__ || Object.getPrototypeOf(h)).call(this));
            return g._messageId = 1, g._messages = new Map(), g._worker = v, g._worker.onmessage = g._onMessage.bind(g), g._id = Math.ceil(1e7 * Math.random()), g;
          }
          return function (v, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof g);
            v.prototype = Object.create(g && g.prototype, {
              constructor: {
                value: v,
                enumerable: !1,
                writable: !0,
                configurable: !0
              }
            }), g && (Object.setPrototypeOf ? Object.setPrototypeOf(v, g) : v.__proto__ = g);
          }(h, n), e(h, [{
            key: "terminate",
            value: function () {
              this._worker.terminate();
            }
          }, {
            key: "isFree",
            value: function () {
              return this._messages.size === 0;
            }
          }, {
            key: "jobsLength",
            value: function () {
              return this._messages.size;
            }
          }, {
            key: "exec",
            value: function (v) {
              var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
                s = this,
                d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [],
                z = arguments[3];
              return new Promise(function (u, f) {
                var p = s._messageId++;
                s._messages.set(p, [u, f, z]), s._worker.postMessage([p, g, v], d || []);
              });
            }
          }, {
            key: "postMessage",
            value: function () {
              var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null,
                g = this,
                s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
                d = arguments[2];
              return new Promise(function (z, u) {
                var f = g._messageId++;
                g._messages.set(f, [z, u, d]), g._worker.postMessage([f, v], s || []);
              });
            }
          }, {
            key: "emit",
            value: function (v) {
              for (var g = arguments.length, s = Array(g > 1 ? g - 1 : 0), d = 1; d < g; d++) s[d - 1] = arguments[d];
              this._worker.postMessage({
                eventName: v,
                args: s
              });
            }
          }, {
            key: "_onMessage",
            value: function (v) {
              var g;
              if (!Array.isArray(v.data) && v.data.eventName) return (g = function f(p, m, M) {
                p === null && (p = Function.prototype);
                var w = Object.getOwnPropertyDescriptor(p, m);
                if (w === void 0) {
                  var H = Object.getPrototypeOf(p);
                  return H === null ? void 0 : f(H, m, M);
                }
                if ("value" in w) return w.value;
                var y = w.get;
                return y !== void 0 ? y.call(M) : void 0;
              }(h.prototype.__proto__ || Object.getPrototypeOf(h.prototype), "emit", this)).call.apply(g, [this, v.data.eventName].concat(l(v.data.args)));
              var s,
                d = (s = v.data, Array.isArray(s) ? s : Array.from(s)),
                z = d[0],
                u = d.slice(1);
              if (z === 1) this._onEvent.apply(this, l(u));else {
                if (z !== 0) throw new Error("Wrong message type '" + z + "'");
                this._onResult.apply(this, l(u));
              }
            }
          }, {
            key: "_onResult",
            value: function (v, g, s) {
              var d = this._messages.get(v),
                z = r(d, 2),
                u = z[0],
                f = z[1];
              return this._messages.delete(v), g === 1 ? u(s) : f(s);
            }
          }, {
            key: "_onEvent",
            value: function (v, g, s) {
              var d = this._messages.get(v),
                z = r(d, 3)[2];
              z && z(g, s);
            }
          }]), h;
        }(i);
      t.exports = o;
    }, function (t, a, c) {
      t.exports = function () {
        return c(3)('!function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=2)}([function(e,t,r){"use strict";var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),o=function e(t,r,n){null===t&&(t=Function.prototype);var o=Object.getOwnPropertyDescriptor(t,r);if(void 0===o){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,r,n)}if("value"in o)return o.value;var a=o.get;return void 0!==a?a.call(n):void 0},i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function a(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)}function u(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var f=r(1),c=0,l=1,s=0,y=1,p="main",b=function(e){return"object"===(void 0===e?"undefined":i(e))&&"function"==typeof e.then&&"function"==typeof e.catch};var v=function e(t,r){u(this,e),this.payload=t,this.transferable=r};e.exports=function(e){var t,r,i,h=(i=e,(r=p)in(t={})?Object.defineProperty(t,r,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[r]=i,t),d=self.postMessage.bind(self),m=new(function(e){function t(){return u(this,t),function(e,t){if(!e)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,e),n(t,[{key:"emit",value:function(e){for(var t=arguments.length,r=Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];return d({eventName:e,args:r}),this}},{key:"emitLocally",value:function(e){for(var r,n=arguments.length,i=Array(n>1?n-1:0),a=1;a<n;a++)i[a-1]=arguments[a];(r=o(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"emit",this)).call.apply(r,[this,e].concat(i))}},{key:"operation",value:function(e,t){return h[e]=t,this}}]),t}(f)),g=function(e,t,r){var n=function(t){t&&t instanceof v?w(e,y,t.payload,t.transferable):w(e,y,t)},o=function(t){w(e,s,{message:t.message,stack:t.stack})};try{var i=_(e,t,r);b(i)?i.then(n).catch(o):n(i)}catch(e){o(e)}},_=function(e,t,r){var n=h[r||p];if(!n)throw new Error("Not found handler for this request");return n(t,O.bind(null,e))},w=function(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];d([c,e,t,r],n)},O=function(e,t,r){if(!t)throw new Error("eventName is required");if("string"!=typeof t)throw new Error("eventName should be string");d([l,e,t,r])};return self.addEventListener("message",(function(e){var t=e.data;Array.isArray(t)?g.apply(void 0,a(t)):t&&t.eventName&&m.emitLocally.apply(m,[t.eventName].concat(a(t.args)))})),m},e.exports.TransferableResponse=v},function(e,t,r){"use strict";var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}();var o=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),Object.defineProperty(this,"__listeners",{value:{},enumerable:!1,writable:!1})}return n(e,[{key:"emit",value:function(e){if(!this.__listeners[e])return this;for(var t=arguments.length,r=Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];var o=!0,i=!1,a=void 0;try{for(var u,f=this.__listeners[e][Symbol.iterator]();!(o=(u=f.next()).done);o=!0){var c=u.value;c.apply(void 0,r)}}catch(e){i=!0,a=e}finally{try{!o&&f.return&&f.return()}finally{if(i)throw a}}return this}},{key:"once",value:function(e,t){var r=this,n=function n(){r.off(e,n),t.apply(void 0,arguments)};return this.on(e,n)}},{key:"on",value:function(e,t){return this.__listeners[e]||(this.__listeners[e]=[]),this.__listeners[e].push(t),this}},{key:"off",value:function(e,t){return this.__listeners[e]=t?this.__listeners[e].filter((function(e){return e!==t})):[],this}}]),e}();e.exports=o},function(e,t,r){"use strict";r.r(t);var n=r(0);r.n(n)()().operation("binary",async({blob:e,chunk:t})=>await function(e,t){return new Promise((r,n)=>{const o=new FileReader,i=t?Math.min(t,e.size):e.size,a=e.slice(0,i);o.onload=()=>r(o.result),o.onerror=n,o.readAsBinaryString(a)})}(e,t)).operation("buffer",async({blob:e,chunk:t})=>await function(e,t){return new Promise((r,n)=>{const o=new FileReader,i=t?Math.min(t,e.size):e.size,a=e.slice(0,i);o.onload=()=>r(o.result),o.onerror=n,o.readAsArrayBuffer(a)})}(e,t)).operation("compare",({buf1:e,buf2:t})=>(function(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;const r=new DataView(e),n=new DataView(t);for(var o=e.byteLength;o--;)if(r.getUint8(o)!==n.getUint8(o))return!1;return!0})(e,t))}]);', null);
      };
    }, function (t, a, c) {
      "use strict";

      var r = function () {
          function l(i, o) {
            for (var n = 0; n < o.length; n++) {
              var h = o[n];
              h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(i, h.key, h);
            }
          }
          return function (i, o, n) {
            return o && l(i.prototype, o), n && l(i, n), i;
          };
        }(),
        e = function () {
          function l() {
            (function (i, o) {
              if (!(i instanceof o)) throw new TypeError("Cannot call a class as a function");
            })(this, l), Object.defineProperty(this, "__listeners", {
              value: {},
              enumerable: !1,
              writable: !1
            });
          }
          return r(l, [{
            key: "emit",
            value: function (i) {
              if (!this.__listeners[i]) return this;
              for (var o = arguments.length, n = Array(o > 1 ? o - 1 : 0), h = 1; h < o; h++) n[h - 1] = arguments[h];
              var v = !0,
                g = !1,
                s = void 0;
              try {
                for (var d, z = this.__listeners[i][Symbol.iterator](); !(v = (d = z.next()).done); v = !0) {
                  var u = d.value;
                  u.apply(void 0, n);
                }
              } catch (f) {
                g = !0, s = f;
              } finally {
                try {
                  !v && z.return && z.return();
                } finally {
                  if (g) throw s;
                }
              }
              return this;
            }
          }, {
            key: "once",
            value: function (i, o) {
              var n = this,
                h = function v() {
                  n.off(i, v), o.apply(void 0, arguments);
                };
              return this.on(i, h);
            }
          }, {
            key: "on",
            value: function (i, o) {
              return this.__listeners[i] || (this.__listeners[i] = []), this.__listeners[i].push(o), this;
            }
          }, {
            key: "off",
            value: function (i, o) {
              return this.__listeners[i] = o ? this.__listeners[i].filter(function (n) {
                return n !== o;
              }) : [], this;
            }
          }]), l;
        }();
      t.exports = e;
    }, function (t, a, c) {
      "use strict";

      var r = window.URL || window.webkitURL;
      t.exports = function (e, l) {
        try {
          try {
            var i;
            try {
              (i = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder)()).append(e), i = i.getBlob();
            } catch (o) {
              i = new Blob([e]);
            }
            return new Worker(r.createObjectURL(i));
          } catch (o) {
            return new Worker("data:application/javascript," + encodeURIComponent(e));
          }
        } catch (o) {
          if (!l) throw Error("Inline worker is not supported");
          return new Worker(l);
        }
      };
    }, function (t, a, c) {
      "use strict";

      c.r(a);
      var r = c(0),
        e = c.n(r),
        l = c(1),
        i = c.n(l);
      c.d(a, "workersEnabled", function () {
        return o;
      }), c.d(a, "default", function () {
        return n;
      });
      let o = !!window.Worker;
      class n {
        static toBinaryStringWithWorker(v, g) {
          return e2(this, null, function* () {
            let s = new e.a(new i.a()),
              d = yield s.exec("binary", {
                blob: v,
                chunk: g
              });
            return s.terminate(), d;
          });
        }
        static toBinaryStringWithoutWorker(v, g) {
          return function (s, d) {
            return new Promise((z, u) => {
              let f = new FileReader(),
                p = d ? Math.min(d, s.size) : s.size,
                m = s.slice(0, p);
              f.onload = () => z(f.result), f.onerror = u, f.readAsBinaryString(m);
            });
          }(v, g);
        }
        static toBinaryString(v, g, s = !0) {
          return s && o ? this.toBinaryStringWithWorker(v, g) : this.toBinaryStringWithoutWorker(v, g);
        }
        static toArrayBufferWithWorker(v, g) {
          return e2(this, null, function* () {
            let s = new e.a(new i.a()),
              d = yield s.exec("buffer", {
                blob: v,
                chunk: g
              });
            return s.terminate(), d;
          });
        }
        static toArrayBufferWithoutWorker(v, g) {
          return function (s, d) {
            return new Promise((z, u) => {
              let f = new FileReader(),
                p = d ? Math.min(d, s.size) : s.size,
                m = s.slice(0, p);
              f.onload = () => z(f.result), f.onerror = u, f.readAsArrayBuffer(m);
            });
          }(v, g);
        }
        static toArrayBuffer(v, g, s = !0) {
          return s && o ? this.toArrayBufferWithWorker(v, g) : this.toArrayBufferWithoutWorker(v, g);
        }
        static compareBuffersWithWorker(v, g) {
          return e2(this, null, function* () {
            if (v === g) return !0;
            let s = new e.a(new i.a()),
              d = yield s.exec("compare", {
                buf1: v,
                buf2: g
              }, [v, g]);
            return s.terminate(), d;
          });
        }
        static compareBuffersWithoutWorker(v, g) {
          return function (s, d) {
            if (s === d) return !0;
            if (s.byteLength !== d.byteLength) return !1;
            let z = new DataView(s),
              u = new DataView(d);
            for (var f = s.byteLength; f--;) if (z.getUint8(f) !== u.getUint8(f)) return !1;
            return !0;
          }(v, g);
        }
        static compareBuffers(v, g, s = !0) {
          return s && o ? this.compareBuffersWithWorker(v, g) : this.compareBuffersWithoutWorker(v, g);
        }
        static sizeEqual(v, g) {
          return v.size === g.size;
        }
        static typeEqual(v, g) {
          return v.type === g.type;
        }
        static magicNumbersEqual(v, g, s = !0) {
          return e2(this, null, function* () {
            if (v === g) return !0;
            let d = [24, 16, 14, 12, 8, 6, 4],
              [z, u] = yield Promise.all([this.toBinaryString(v, 24, s), this.toBinaryString(g, 24, s)]);
            for (let f of d) if (z.substring(0, f) === u.substring(0, f)) return !0;
            return !1;
          });
        }
        static bytesEqualWithBinaryString(v, g, s, d = !0) {
          return e2(this, null, function* () {
            if (v === g) return !0;
            let [z, u] = yield Promise.all([this.toBinaryString(v, s, d), this.toBinaryString(g, s, d)]);
            return z === u;
          });
        }
        static bytesEqualWithArrayBuffer(v, g, s, d = !0) {
          return e2(this, null, function* () {
            if (v === g) return !0;
            let [z, u] = yield Promise.all([this.toArrayBuffer(v, s, d), this.toArrayBuffer(g, s, d)]);
            return this.compareBuffers(z, u, d);
          });
        }
        static isEqual(p, m) {
          return e2(this, arguments, function* (v, g, {
            methods: s = ["size", "type", "magic", "byte"],
            byte: d = "buffer",
            partial: z = !1,
            chunks: u = null,
            worker: f = !0
          } = {}) {
            let M = null;
            for (let w of s) {
              if (M === !1 || z && M === !0) break;
              switch (w) {
                case "byte":
                case "bytes":
                case "content":
                  u = u instanceof Array ? u : [v.size], M = !0;
                  for (let H of u) {
                    let y = !1;
                    y = d === "buffer" ? yield this.bytesEqualWithArrayBuffer(v, g, H, f) : yield this.bytesEqualWithBinaryString(v, g, H, f), y || (M = !1);
                  }
                  break;
                case "magic":
                case "headers":
                case "numbers":
                case "mime":
                  M = yield this.magicNumbersEqual(v, g, f);
                  break;
                case "size":
                case "sizes":
                  M = this.sizeEqual(v, g);
                  break;
                case "type":
                case "types":
                  M = this.typeEqual(v, g);
                  break;
                default:
                  throw new Error("Blob-compare : Unknown comparison method");
              }
            }
            return M;
          });
        }
      }
    }]);
  });
});
var gl1 = {};
Lf(gl1, {
  ToolbarDropdownSelect: () => Cq,
  default: () => hl1
});
module.exports = Rq(gl1);
f1();
de();
var sv = require("@theatre/dataverse");
N5();
var Pq = 0,
  Jt = class {
    constructor(a) {
      this._studio = a;
      y1(this, "_id");
      y1(this, "_state", {
        type: "Ready"
      });
      this._id = String(Pq++);
    }
    get status() {
      return this._state.type;
    }
    reset() {
      let {
        _state: a
      } = this;
      if (a.type !== "Ready") if (a.type === "Captured") this._state = {
        type: "Ready"
      }, a.transaction.discard(), a.flagsTransaction.discard();else throw a.type === "Committed" ? new Error("This scrub is already committed and can't be reset.") : new Error("This scrub is already discarded and can't be reset.");
    }
    commit() {
      let {
        _state: a
      } = this;
      if (a.type === "Captured") a.transaction.commit(), a.flagsTransaction.discard(), this._state = {
        type: "Committed"
      };else if (a.type === "Ready") {
        console.warn("Scrub is empty. Nothing to commit.");
        return;
      } else throw a.type === "Committed" ? new Error("This scrub is already committed.") : new Error("This scrub is already discarded and can't be comitted.");
    }
    capture(a) {
      if (this._state.type === "Captured" && this.reset(), this._state.type === "Ready") {
        let c = !0;
        try {
          this._state = S({
            type: "Captured"
          }, this._capture(a)), c = !1;
        } finally {
          c && (console.error("This scrub's callback threw an error. We're undo-ing all of the changes made by this scrub, and marking it as discarded."), this._state = {
            type: "Discarded"
          });
        }
      } else throw this._state.type === "Committed" ? new Error("This scrub is already committed and cannot capture again. If you wish to capture more, you can start a new studio.scrub() or do so before scrub.commit()") : new Error("This scrub is already discarded and cannot capture again. If you wish to capture more, you can start a new studio.scrub() or do so before scrub.discard()");
    }
    _capture(a) {
      let c = [],
        r = this._studio.tempTransaction(l => {
          let i = !0,
            o = {
              set: (n, h) => {
                if (!i) throw new Error("You seem to have called the scrub api after scrub.capture()");
                let {
                  root: v,
                  path: g
                } = (0, sv.getPointerParts)(n);
                if (!c0(v)) throw new Error("We can only scrub props of Sheet Objects for now");
                l.set(n, h), c.push(n);
              }
            };
          try {
            a(o);
          } finally {
            i = !1;
          }
        }),
        e = this._studio.tempTransaction(({
          stateEditors: l
        }) => {
          c.forEach(i => {
            let {
              root: o,
              path: n
            } = (0, sv.getPointerParts)(i);
            if (!c0(o)) return;
            let h = o.template.getDefaultsAtPointer(i);
            q5(h, (v, g) => {
              l.studio.ephemeral.projects.stateByProjectId.stateBySheetId.stateByObjectKey.propsBeingScrubbed.flag(D(S({}, o.address), {
                pathToProp: g
              }));
            }, n);
          });
        });
      return {
        transaction: r,
        flagsTransaction: e
      };
    }
    discard() {
      let {
        _state: a
      } = this;
      if (a.type === "Captured" || a.type === "Ready") a.type === "Captured" && (a.transaction.discard(), a.flagsTransaction.discard()), this._state = {
        type: "Discarded"
      };else throw a.type === "Committed" ? new Error("This scrub is already committed and can't be discarded.") : new Error("This scrub is already discarded");
    }
  };
var L_ = require("@theatre/dataverse");
var C_ = typeof window != "undefined" ? Promise.resolve().then(() => (x_(), M_)).then(t => t.default) : null,
  Ur = class {
    constructor(a) {
      this.studio = a;
      y1(this, "_rendered", !1);
      y1(this, "_nonSSRBits", C_ ? C_.then(a => new a()) : Promise.reject());
      y1(this, "ready", this._nonSSRBits.then(() => {}, () => {}));
    }
    render() {
      this._rendered || (this._rendered = !0, this._nonSSRBits.then(a => {
        a.render();
      }).catch(a => {
        throw console.error(a), a;
      }));
    }
    hide() {
      this.studio.transaction(({
        drafts: a
      }) => {
        a.ahistoric.visibilityState = "everythingIsHidden";
      });
    }
    restore() {
      this.render(), this.studio.transaction(({
        drafts: a
      }) => {
        a.ahistoric.visibilityState = "everythingIsVisible";
      });
    }
    get isHidden() {
      return (0, L_.val)(this.studio.atomP.ahistoric.visibilityState) === "everythingIsHidden";
    }
    renderToolset(a, c) {
      let r = !1,
        e = null;
      return this._nonSSRBits.then(l => {
        r || (e = l.renderToolset(a, c));
      }).catch(l => {
        console.error(l);
      }), () => {
        if (e) {
          e();
          return;
        }
        r || (r = !0);
      };
    }
  };
var C7 = require("@theatre/dataverse");
function Xa1(t) {
  return t;
}
var Ya1 = (t, a = Xa1) => {
    let c = r => ({
      type: t,
      payload: a(r)
    });
    return c.type = t, c.is = r => r && r.type && r.type === t, c;
  },
  Z3 = Ya1;
var Gm = I(J_()),
  Tm = I(kj());
ma();
var qh,
  Ae1 = new Uint8Array(16);
function Fm() {
  if (!qh && (qh = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !qh)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return qh(Ae1);
}
var Aj = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function Re1(t) {
  return typeof t == "string" && Aj.test(t);
}
var Rj = Re1;
var J2 = [];
for (Nh = 0; Nh < 256; ++Nh) J2.push((Nh + 256).toString(16).substr(1));
var Nh;
function be1(t) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    c = (J2[t[a + 0]] + J2[t[a + 1]] + J2[t[a + 2]] + J2[t[a + 3]] + "-" + J2[t[a + 4]] + J2[t[a + 5]] + "-" + J2[t[a + 6]] + J2[t[a + 7]] + "-" + J2[t[a + 8]] + J2[t[a + 9]] + "-" + J2[t[a + 10]] + J2[t[a + 11]] + J2[t[a + 12]] + J2[t[a + 13]] + J2[t[a + 14]] + J2[t[a + 15]]).toLowerCase();
  if (!Rj(c)) throw TypeError("Stringified UUID is invalid");
  return c;
}
var bj = be1;
function Fe1(t, a, c) {
  t = t || {};
  var r = t.random || (t.rng || Fm)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, a) {
    c = c || 0;
    for (var e = 0; e < 16; ++e) a[c + e] = r[e];
    return a;
  }
  return bj(r);
}
var Im = Fe1;
var jt = {
  replaceHistory: Z3("@history/replaceHistory"),
  startHistoryFromScratch: Z3("@history/startHistoryFromScratch"),
  undo: Z3("@history/undo"),
  redo: Z3("@history/redo")
};
var Ie1 = {
    type: "@history/unknownAction",
    payload: ""
  },
  Pe1 = {
    maxNumberOfCommits: 100
  },
  Fj = (t, a = Pe1) => {
    let c = Pm(t(void 0, Ie1));
    return function (e, l) {
      return jt.startHistoryFromScratch.is(l) ? Pm(t(void 0, l.payload)) : jt.replaceHistory.is(l) ? l.payload : jt.undo.is(l) ? e ? Ze1(e) : c : jt.redo.is(l) ? e ? Oe1(e) : c : e ? Ge1(e, t(e.innerState, l), a) : Pm(t(void 0, l));
    };
  };
function Pm(t) {
  return {
    currentCommitHash: void 0,
    commitsByHash: {},
    listOfCommitHashes: [],
    innerState: t
  };
}
function Ge1(t, a, c) {
  if (a === t.innerState) return t;
  let r = Te1(t.innerState, a);
  if (r.forwardDiff.length === 0) return t;
  let e = M3(t.listOfCommitHashes),
    l = {
      currentCommitHash: r.hash,
      commitsByHash: S({}, t.commitsByHash),
      listOfCommitHashes: [...t.listOfCommitHashes],
      innerState: a
    };
  if (t.currentCommitHash !== e) {
    let i = t.listOfCommitHashes.findIndex(n => n === t.currentCommitHash);
    t.listOfCommitHashes.slice(i + 1).forEach(n => {
      delete l.commitsByHash[n];
    }), l.listOfCommitHashes.splice(i + 1, l.listOfCommitHashes.length);
  }
  if (l.listOfCommitHashes.push(r.hash), l.commitsByHash[r.hash] = r, l.listOfCommitHashes.length > c.maxNumberOfCommits) {
    let i = l.listOfCommitHashes.length - c.maxNumberOfCommits;
    l.listOfCommitHashes.slice(0, i).forEach(n => {
      delete l.commitsByHash[n];
    }), l.listOfCommitHashes.splice(0, i);
  }
  return l;
}
function Te1(t, a) {
  let c = Gm.default.diff(t, a, {
      invertible: !1
    }),
    r = Gm.default.diff(a, t, {
      invertible: !1
    }),
    e = Date.now(),
    l = Im();
  return {
    forwardDiff: c,
    backwardDiff: r,
    timestamp: e,
    hash: l
  };
}
function Ze1(t) {
  if (t.currentCommitHash === void 0) return t;
  let a = t.listOfCommitHashes.findIndex(o => o === t.currentCommitHash);
  if (a === -1) throw new Error("This should never happen");
  let c = t.commitsByHash[t.currentCommitHash],
    r = (0, Tm.default)(t.innerState, c.backwardDiff),
    e = a - 1,
    l = e === -1 ? void 0 : t.listOfCommitHashes[e];
  return D(S({}, t), {
    currentCommitHash: l,
    innerState: r
  });
}
function Oe1(t) {
  if (t.listOfCommitHashes.length === 0) return t;
  let a = t.listOfCommitHashes.findIndex(o => o === t.currentCommitHash);
  if (a === t.listOfCommitHashes.length - 1) return t;
  let c = a + 1,
    r = t.listOfCommitHashes[c],
    e = t.commitsByHash[r],
    l = (0, Tm.default)(t.innerState, e.forwardDiff);
  return D(S({}, t), {
    currentCommitHash: r,
    innerState: l
  });
}
_r();
var Uh = {
    ahistoric: {
      visibilityState: "everythingIsVisible",
      theTrigger: {
        position: {
          closestCorner: "bottomLeft",
          distanceFromHorizontalEdge: .02,
          distanceFromVerticalEdge: .02
        }
      },
      coreByProject: {},
      projects: {
        stateByProjectId: {}
      }
    },
    historic: {
      projects: {
        stateByProjectId: {}
      },
      autoKey: !0,
      coreByProject: {},
      panelInstanceDesceriptors: {}
    },
    ephemeral: {
      initialised: !1,
      coreByProject: {},
      projects: {
        stateByProjectId: {}
      },
      extensions: {
        byId: {},
        paneClasses: {}
      },
      showOutline: !1
    }
  },
  Pj = Z3("@storeBundle/replacePersistentState", t => t),
  Gj = Z3("@storeBundle/reduceParts", t => t),
  u8 = {
    historic: jt,
    replacePersistentState: Pj,
    reduceParts: Gj
  },
  Tj = Z3("@storeBundle/setInnerHistoricState", t => t),
  Ee1 = (t = Uh.historic, a) => Tj.is(a) ? a.payload : t,
  Zm = Fj(Ee1),
  Ij = (t, a) => {
    if (Pj.is(a)) {
      let {
          historic: c,
          ahistoric: r
        } = a.payload,
        e = (t == null ? void 0 : t.ephemeral) || Uh.ephemeral;
      return {
        $persistent: {
          historic: c,
          ahistoric: r
        },
        ephemeral: e
      };
    } else if (t) {
      let {
          historic: c,
          ahistoric: r
        } = t.$persistent,
        {
          ephemeral: e
        } = t;
      if (Gj.is(a)) {
        let i = {
            historic: t.$persistent.historic.innerState,
            ahistoric: t.$persistent.ahistoric,
            ephemeral: t.ephemeral
          },
          o = a.payload(i);
        if (o === i) return t;
        c.innerState !== o.historic && (c = Zm(c, Tj(o.historic))), r = o.ahistoric, e = o.ephemeral;
      } else {
        let i = Zm(c, a);
        if (i === c) return t;
        c = i;
      }
      return {
        $persistent: c === t.$persistent.historic && r === t.$persistent.ahistoric ? t.$persistent : {
          historic: c,
          ahistoric: r
        },
        ephemeral: e
      };
    } else {
      let c = Zm(void 0, {}),
        r = Uh.ahistoric,
        e = Uh.ephemeral;
      return {
        $persistent: {
          historic: c,
          ahistoric: r
        },
        ephemeral: e
      };
    }
  },
  Zj = Z3("@history/pushTempAction", t => t),
  Oj = Z3("@history/discardTempAction", t => t),
  Ej = Z3("@history/commitTempAction", t => t),
  De1 = 0,
  Dj = () => {
    let t = De1++;
    return {
      push: e => Zj({
        id: t,
        originalAction: e
      }),
      discard: () => Oj(t),
      commit: () => Ej(t)
    };
  },
  Wj = (t, a) => {
    if (t) {
      let {
          tempActions: c,
          permanent: r
        } = t.$temps,
        e;
      if (Zj.is(a)) c = [...c, a];else if (Ej.is(a)) {
        let i = c.find(o => o.payload.id === a.payload);
        i ? (e = i.payload.originalAction, c = c.filter(o => o.payload.id !== a.payload)) : kt.error("Comitting temp action group ".concat(a.payload, " isn't possible as this group doesn't exist"));
      } else Oj.is(a) ? c = c.filter(i => i.payload.id !== a.payload) : e = a;
      e && (r = Ij(t.$temps.permanent, e));
      let l = {
        historic: r.$persistent.historic.innerState,
        ahistoric: r.$persistent.ahistoric,
        ephemeral: r.ephemeral
      };
      for (let i of c) l = i.payload.originalAction.payload(l);
      return S({
        $temps: {
          tempActions: c,
          permanent: r
        },
        $persistent: r.$persistent
      }, l);
    } else {
      let c = Ij(void 0, a);
      return {
        $temps: {
          permanent: c,
          tempActions: []
        },
        $persistent: c.$persistent,
        historic: c.$persistent.historic.innerState,
        ahistoric: c.$persistent.ahistoric,
        ephemeral: c.ephemeral
      };
    }
  };
o4();
o4();
O4();
function Kh(t, a) {
  if (typeof t != "object" || t === null) return;
  if (a.length === 0) {
    for (let i of Object.keys(t)) delete t[i];
    return;
  }
  let c = a.slice(0, a.length - 1),
    r = t,
    e = new WeakMap();
  for (let i of c) {
    let o = r,
      n = o[i];
    if (typeof n != "object" || n === null) return;
    e.set(n, o), r = n;
  }
  let l = a.slice().reverse();
  for (let i of l) {
    if (delete r[i], Object.keys(r).length > 0) return;
    r = e.get(r);
  }
}
function _j(t, {
  scale: a,
  origin: c,
  translate: r
}) {
  let e = c + (t - c) * a;
  return r + e;
}
function u4(t) {
  for (var a = arguments.length, c = Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++) c[r - 1] = arguments[r];
  if (!1) var e, l;
  throw Error("[Immer] minified error nr: " + t + (c.length ? " " + c.map(function (i) {
    return "'" + i + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function qt(t) {
  return !!t && !!t[u3];
}
function x7(t) {
  return !!t && (function (a) {
    if (!a || typeof a != "object") return !1;
    var c = Object.getPrototypeOf(a);
    if (c === null) return !0;
    var r = Object.hasOwnProperty.call(c, "constructor") && c.constructor;
    return r === Object || typeof r == "function" && Function.toString.call(r) === Ke1;
  }(t) || Array.isArray(t) || !!t[Xj] || !!t.constructor[Xj] || Um(t) || Km(t));
}
function Jr(t, a, c) {
  c === void 0 && (c = !1), Nt(t) === 0 ? (c ? Object.keys : Jm)(t).forEach(function (r) {
    c && typeof r == "symbol" || a(r, t[r], t);
  }) : t.forEach(function (r, e) {
    return a(e, r, t);
  });
}
function Nt(t) {
  var a = t[u3];
  return a ? a.i > 3 ? a.i - 4 : a.i : Array.isArray(t) ? 1 : Um(t) ? 2 : Km(t) ? 3 : 0;
}
function _m(t, a) {
  return Nt(t) === 2 ? t.has(a) : Object.prototype.hasOwnProperty.call(t, a);
}
function We1(t, a) {
  return Nt(t) === 2 ? t.get(a) : t[a];
}
function Yj(t, a, c) {
  var r = Nt(t);
  r === 2 ? t.set(a, c) : r === 3 ? (t.delete(a), t.add(c)) : t[a] = c;
}
function _e1(t, a) {
  return t === a ? t !== 0 || 1 / t == 1 / a : t != t && a != a;
}
function Um(t) {
  return Ne1 && t instanceof Map;
}
function Km(t) {
  return Ue1 && t instanceof Set;
}
function M7(t) {
  return t.o || t.t;
}
function $m(t) {
  if (Array.isArray(t)) return Array.prototype.slice.call(t);
  var a = $e1(t);
  delete a[u3];
  for (var c = Jm(a), r = 0; r < c.length; r++) {
    var e = c[r],
      l = a[e];
    l.writable === !1 && (l.writable = !0, l.configurable = !0), (l.get || l.set) && (a[e] = {
      configurable: !0,
      writable: !0,
      enumerable: l.enumerable,
      value: t[e]
    });
  }
  return Object.create(Object.getPrototypeOf(t), a);
}
function Qm(t, a) {
  return a === void 0 && (a = !1), Xm(t) || qt(t) || !x7(t) || (Nt(t) > 1 && (t.set = t.add = t.clear = t.delete = je1), Object.freeze(t), a && Jr(t, function (c, r) {
    return Qm(r, !0);
  }, !0)), t;
}
function je1() {
  u4(2);
}
function Xm(t) {
  return t == null || typeof t != "object" || Object.isFrozen(t);
}
function D5(t) {
  var a = Qe1[t];
  return a || u4(18, t), a;
}
function jj() {
  return te;
}
function Om(t, a) {
  a && (D5("Patches"), t.u = [], t.s = [], t.v = a);
}
function Xh(t) {
  jm(t), t.p.forEach(qe1), t.p = null;
}
function jm(t) {
  t === te && (te = t.l);
}
function qj(t) {
  return te = {
    p: [],
    l: te,
    h: t,
    m: !0,
    _: 0
  };
}
function qe1(t) {
  var a = t[u3];
  a.i === 0 || a.i === 1 ? a.j() : a.O = !0;
}
function Em(t, a) {
  a._ = a.p.length;
  var c = a.p[0],
    r = t !== void 0 && t !== c;
  return a.h.g || D5("ES5").S(a, t, r), r ? (c[u3].P && (Xh(a), u4(4)), x7(t) && (t = Yh(a, t), a.l || Jh(a, t)), a.u && D5("Patches").M(c[u3], t, a.u, a.s)) : t = Yh(a, c, []), Xh(a), a.u && a.v(a.u, a.s), t !== Jj ? t : void 0;
}
function Yh(t, a, c) {
  if (Xm(a)) return a;
  var r = a[u3];
  if (!r) return Jr(a, function (l, i) {
    return Nj(t, r, a, l, i, c);
  }, !0), a;
  if (r.A !== t) return a;
  if (!r.P) return Jh(t, r.t, !0), r.t;
  if (!r.I) {
    r.I = !0, r.A._--;
    var e = r.i === 4 || r.i === 5 ? r.o = $m(r.k) : r.o;
    Jr(r.i === 3 ? new Set(e) : e, function (l, i) {
      return Nj(t, r, e, l, i, c);
    }), Jh(t, e, !1), c && t.u && D5("Patches").R(r, c, t.u, t.s);
  }
  return r.o;
}
function Nj(t, a, c, r, e, l) {
  if (qt(e)) {
    var i = Yh(t, e, l && a && a.i !== 3 && !_m(a.D, r) ? l.concat(r) : void 0);
    if (Yj(c, r, i), !qt(i)) return;
    t.m = !1;
  }
  if (x7(e) && !Xm(e)) {
    if (!t.h.F && t._ < 1) return;
    Yh(t, e), a && a.A.l || Jh(t, e);
  }
}
function Jh(t, a, c) {
  c === void 0 && (c = !1), t.h.F && t.m && Qm(a, c);
}
function Dm(t, a) {
  var c = t[u3];
  return (c ? M7(c) : t)[a];
}
function Uj(t, a) {
  if (a in t) for (var c = Object.getPrototypeOf(t); c;) {
    var r = Object.getOwnPropertyDescriptor(c, a);
    if (r) return r;
    c = Object.getPrototypeOf(c);
  }
}
function qm(t) {
  t.P || (t.P = !0, t.l && qm(t.l));
}
function Wm(t) {
  t.o || (t.o = $m(t.t));
}
function Nm(t, a, c) {
  var r = Um(a) ? D5("MapSet").N(a, c) : Km(a) ? D5("MapSet").T(a, c) : t.g ? function (e, l) {
    var i = Array.isArray(e),
      o = {
        i: i ? 1 : 0,
        A: l ? l.A : jj(),
        P: !1,
        I: !1,
        D: {},
        l,
        t: e,
        k: null,
        o: null,
        j: null,
        C: !1
      },
      n = o,
      h = $h;
    i && (n = [o], h = Qh);
    var v = Proxy.revocable(n, h),
      g = v.revoke,
      s = v.proxy;
    return o.k = s, o.j = g, s;
  }(a, c) : D5("ES5").J(a, c);
  return (c ? c.A : jj()).p.push(r), r;
}
function ae(t) {
  return qt(t) || u4(22, t), function a(c) {
    if (!x7(c)) return c;
    var r,
      e = c[u3],
      l = Nt(c);
    if (e) {
      if (!e.P && (e.i < 4 || !D5("ES5").K(e))) return e.t;
      e.I = !0, r = Kj(c, l), e.I = !1;
    } else r = Kj(c, l);
    return Jr(r, function (i, o) {
      e && We1(e.t, i) === o || Yj(r, i, a(o));
    }), l === 3 ? new Set(r) : r;
  }(t);
}
function Kj(t, a) {
  switch (a) {
    case 2:
      return new Map(t);
    case 3:
      return Array.from(t);
  }
  return $m(t);
}
var $j,
  te,
  Ym = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol",
  Ne1 = typeof Map != "undefined",
  Ue1 = typeof Set != "undefined",
  Qj = typeof Proxy != "undefined" && Proxy.revocable !== void 0 && typeof Reflect != "undefined",
  Jj = Ym ? Symbol.for("immer-nothing") : (($j = {})["immer-nothing"] = !0, $j),
  Xj = Ym ? Symbol.for("immer-draftable") : "__$immer_draftable",
  u3 = Ym ? Symbol.for("immer-state") : "__$immer_state";
var Ke1 = "" + Object.prototype.constructor,
  Jm = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function (t) {
    return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
  } : Object.getOwnPropertyNames,
  $e1 = Object.getOwnPropertyDescriptors || function (t) {
    var a = {};
    return Jm(t).forEach(function (c) {
      a[c] = Object.getOwnPropertyDescriptor(t, c);
    }), a;
  },
  Qe1 = {},
  $h = {
    get: function (t, a) {
      if (a === u3) return t;
      var c = M7(t);
      if (!_m(c, a)) return function (e, l, i) {
        var o,
          n = Uj(l, i);
        return n ? "value" in n ? n.value : (o = n.get) === null || o === void 0 ? void 0 : o.call(e.k) : void 0;
      }(t, c, a);
      var r = c[a];
      return t.I || !x7(r) ? r : r === Dm(t.t, a) ? (Wm(t), t.o[a] = Nm(t.A.h, r, t)) : r;
    },
    has: function (t, a) {
      return a in M7(t);
    },
    ownKeys: function (t) {
      return Reflect.ownKeys(M7(t));
    },
    set: function (t, a, c) {
      var r = Uj(M7(t), a);
      if (r != null && r.set) return r.set.call(t.k, c), !0;
      if (!t.P) {
        var e = Dm(M7(t), a),
          l = e == null ? void 0 : e[u3];
        if (l && l.t === c) return t.o[a] = c, t.D[a] = !1, !0;
        if (_e1(c, e) && (c !== void 0 || _m(t.t, a))) return !0;
        Wm(t), qm(t);
      }
      return t.o[a] === c && typeof c != "number" && (c !== void 0 || a in t.o) || (t.o[a] = c, t.D[a] = !0, !0);
    },
    deleteProperty: function (t, a) {
      return Dm(t.t, a) !== void 0 || a in t.t ? (t.D[a] = !1, Wm(t), qm(t)) : delete t.D[a], t.o && delete t.o[a], !0;
    },
    getOwnPropertyDescriptor: function (t, a) {
      var c = M7(t),
        r = Reflect.getOwnPropertyDescriptor(c, a);
      return r && {
        writable: !0,
        configurable: t.i !== 1 || a !== "length",
        enumerable: r.enumerable,
        value: c[a]
      };
    },
    defineProperty: function () {
      u4(11);
    },
    getPrototypeOf: function (t) {
      return Object.getPrototypeOf(t.t);
    },
    setPrototypeOf: function () {
      u4(12);
    }
  },
  Qh = {};
Jr($h, function (t, a) {
  Qh[t] = function () {
    return arguments[0] = arguments[0][0], a.apply(this, arguments);
  };
}), Qh.deleteProperty = function (t, a) {
  return $h.deleteProperty.call(this, t[0], a);
}, Qh.set = function (t, a, c) {
  return $h.set.call(this, t[0], a, c, t[0]);
};
var Xe1 = function () {
    function t(c) {
      var r = this;
      this.g = Qj, this.F = !0, this.produce = function (e, l, i) {
        if (typeof e == "function" && typeof l != "function") {
          var o = l;
          l = e;
          var n = r;
          return function (d) {
            var z = this;
            d === void 0 && (d = o);
            for (var u = arguments.length, f = Array(u > 1 ? u - 1 : 0), p = 1; p < u; p++) f[p - 1] = arguments[p];
            return n.produce(d, function (m) {
              var M;
              return (M = l).call.apply(M, [z, m].concat(f));
            });
          };
        }
        var h;
        if (typeof l != "function" && u4(6), i !== void 0 && typeof i != "function" && u4(7), x7(e)) {
          var v = qj(r),
            g = Nm(r, e, void 0),
            s = !0;
          try {
            h = l(g), s = !1;
          } finally {
            s ? Xh(v) : jm(v);
          }
          return typeof Promise != "undefined" && h instanceof Promise ? h.then(function (d) {
            return Om(v, i), Em(d, v);
          }, function (d) {
            throw Xh(v), d;
          }) : (Om(v, i), Em(h, v));
        }
        if (!e || typeof e != "object") return (h = l(e)) === Jj ? void 0 : (h === void 0 && (h = e), r.F && Qm(h, !0), h);
        u4(21, e);
      }, this.produceWithPatches = function (e, l) {
        return typeof e == "function" ? function (n) {
          for (var h = arguments.length, v = Array(h > 1 ? h - 1 : 0), g = 1; g < h; g++) v[g - 1] = arguments[g];
          return r.produceWithPatches(n, function (s) {
            return e.apply(void 0, [s].concat(v));
          });
        } : [r.produce(e, l, function (n, h) {
          i = n, o = h;
        }), i, o];
        var i, o;
      }, typeof (c == null ? void 0 : c.useProxies) == "boolean" && this.setUseProxies(c.useProxies), typeof (c == null ? void 0 : c.autoFreeze) == "boolean" && this.setAutoFreeze(c.autoFreeze);
    }
    var a = t.prototype;
    return a.createDraft = function (c) {
      x7(c) || u4(8), qt(c) && (c = ae(c));
      var r = qj(this),
        e = Nm(this, c, void 0);
      return e[u3].C = !0, jm(r), e;
    }, a.finishDraft = function (c, r) {
      var e = c && c[u3],
        l = e.A;
      return Om(l, r), Em(void 0, l);
    }, a.setAutoFreeze = function (c) {
      this.F = c;
    }, a.setUseProxies = function (c) {
      c && !Qj && u4(20), this.g = c;
    }, a.applyPatches = function (c, r) {
      var e;
      for (e = r.length - 1; e >= 0; e--) {
        var l = r[e];
        if (l.path.length === 0 && l.op === "replace") {
          c = l.value;
          break;
        }
      }
      var i = D5("Patches").$;
      return qt(c) ? i(c, r) : this.produce(c, function (o) {
        return i(o, r.slice(e + 1));
      });
    }, t;
  }(),
  p3 = new Xe1(),
  aq1 = p3.produce,
  cq1 = p3.produceWithPatches.bind(p3),
  rq1 = p3.setAutoFreeze.bind(p3),
  eq1 = p3.setUseProxies.bind(p3),
  lq1 = p3.applyPatches.bind(p3),
  tv = p3.createDraft.bind(p3),
  av = p3.finishDraft.bind(p3);
HL();
kL();
KL();
Xe();
XL();
Er();
H2();
N5();
var O3 = {
  create(t) {
    let a = {
      byId: {},
      allIds: {}
    };
    if (t) for (let [c, r] of t) a.byId[c] = r, a.allIds[c] = !0;
    return a;
  },
  shallowCopy(t) {
    return {
      byId: S({}, t == null ? void 0 : t.byId),
      allIds: S({}, t == null ? void 0 : t.allIds)
    };
  },
  add(t, a, c) {
    return {
      byId: D(S({}, t == null ? void 0 : t.byId), {
        [a]: c
      }),
      allIds: D(S({}, t == null ? void 0 : t.allIds), {
        [a]: !0
      })
    };
  },
  merge(t) {
    let a = O3.create();
    for (let c = 0; c < t.length; c++) a.byId = S(S({}, a.byId), t[c].byId), a.allIds = S(S({}, a.allIds), t[c].allIds);
    return a;
  },
  remove(t, a) {
    let c = O3.shallowCopy(t);
    return delete c.allIds[a], delete c.byId[a], c;
  },
  filter(t, a) {
    let c = O3.shallowCopy(t);
    for (let [r, e] of Object.entries(c.byId)) a(e) || (delete c.allIds[r], delete c.byId[r]);
    return c;
  }
};
var cf = t => (tf = t, af),
  tf,
  t0 = () => {
    if (tf === void 0) throw new Error("Calling stateEditors outside of a transaction is not allowed.");
    return tf;
  },
  af;
(c => {
  let t;
  (i => {
    let r;
    (v => {
      let o;
      (s => {
        function g(d) {
          var u;
          let z = t0().historic;
          (u = z.panelPositions) != null || (z.panelPositions = {}), z.panelPositions[d.panelId] = d.position;
        }
        s.setPanelPosition = g;
      })(o = v.panelPositions || (v.panelPositions = {}));
      let n;
      (z => {
        function g() {
          var u, f;
          return (f = (u = t0().historic).panels) != null || (u.panels = {}), t0().historic.panels;
        }
        z._ensure = g;
        let s;
        (p => {
          function u() {
            var M;
            let m = c.studio.historic.panels._ensure();
            return (M = m.outlinePanel) != null || (m.outlinePanel = {}), m.outlinePanel;
          }
          p._ensure = u;
          let f;
          (w => {
            function m(H) {
              let y = [];
              for (let k of x3(H)) se(k) ? y.push(S({
                type: "Project"
              }, k.address)) : H7(k) ? (y.push(S({
                type: "Sheet"
              }, k.template.address)), c.studio.historic.projects.stateByProjectId.stateBySheetId.setSelectedInstanceId(k.address)) : yf(k) ? y.push(S({
                type: "Sheet"
              }, k.address)) : c0(k) ? (y.push(S({
                type: "SheetObject"
              }, k.template.address)), c.studio.historic.projects.stateByProjectId.stateBySheetId.setSelectedInstanceId(k.sheet.address)) : kf(k) && y.push(S({
                type: "SheetObject"
              }, k.address));
              p._ensure().selection = y;
            }
            w.set = m;
            function M() {
              p._ensure().selection = [];
            }
            w.unset = M;
          })(f = p.selection || (p.selection = {}));
        })(s = z.outline || (z.outline = {}));
        let d;
        (p => {
          function u() {
            var M;
            let m = c.studio.historic.panels._ensure();
            return (M = m.sequenceEditor) != null || (m.sequenceEditor = {}), m.sequenceEditor;
          }
          p._ensure = u;
          let f;
          (w => {
            function m() {
              var y;
              let H = p._ensure();
              return (y = H.graphEditor) != null || (H.graphEditor = {
                height: .5,
                isOpen: !1
              }), H.graphEditor;
            }
            function M(H) {
              m().isOpen = H.isOpen;
            }
            w.setIsOpen = M;
          })(f = p.graphEditor || (p.graphEditor = {}));
        })(d = z.sequenceEditor || (z.sequenceEditor = {}));
      })(n = v.panels || (v.panels = {}));
      let h;
      (s => {
        let g;
        (u => {
          function d(f) {
            let p = t0().historic;
            return p.projects.stateByProjectId[f.projectId] || (p.projects.stateByProjectId[f.projectId] = {
              stateBySheetId: {}
            }), p.projects.stateByProjectId[f.projectId];
          }
          u._ensure = d;
          let z;
          (M => {
            function f(w) {
              let H = c.studio.historic.projects.stateByProjectId._ensure(w);
              return H.stateBySheetId[w.sheetId] || (H.stateBySheetId[w.sheetId] = {
                selectedInstanceId: void 0,
                sequenceEditor: {
                  selectedPropsByObject: {}
                }
              }), H.stateBySheetId[w.sheetId];
            }
            M._ensure = f;
            function p(w) {
              c.studio.historic.projects.stateByProjectId.stateBySheetId._ensure(w).selectedInstanceId = w.sheetInstanceId;
            }
            M.setSelectedInstanceId = p;
            let m;
            (A => {
              function w(P) {
                let {
                  selectedPropsByObject: C
                } = M._ensure(P).sequenceEditor;
                C[P.objectKey] || (C[P.objectKey] = {});
                let E = C[P.objectKey],
                  a1 = h3(P.pathToProp),
                  j = new Set(Object.keys(v7));
                for (let [Z, J] of Object.entries(ae(C))) for (let [W, _] of Object.entries(J)) j.delete(_);
                let K = j.size > 0 ? j.values().next().value : Object.keys(v7)[0];
                E[a1] = K;
              }
              A.addPropToGraphEditor = w;
              function H(P) {
                let {
                  selectedPropsByObject: C
                } = M._ensure(P).sequenceEditor;
                if (!C[P.objectKey]) return;
                let E = C[P.objectKey],
                  a1 = h3(P.pathToProp);
                E[a1] && Kh(C, [P.objectKey, a1]);
              }
              A.removePropFromGraphEditor = H;
              function y(P) {
                let C = c.studio.historic.projects.stateByProjectId.stateBySheetId._ensure(P).sequenceEditor;
                return C.markerSet || (C.markerSet = O3.create()), C.markerSet;
              }
              function k(P) {
                let C = y(P.sheetAddress),
                  E = P.markers.filter(Z => !!isFinite(Z.position)).map(Z => D(S({}, Z), {
                    position: P.snappingFunction(Z.position)
                  })),
                  a1 = Ma(E, "id"),
                  j = O3.filter(C, Z => Z && !a1[Z.id]),
                  K = Ma(Object.values(j.byId), "position");
                E.forEach(({
                  position: Z
                }) => {
                  let J = K[Z];
                  J && (j = O3.remove(j, J.id));
                }), Object.assign(C, O3.merge([j, O3.create(E.map(Z => [Z.id, Z]))]));
              }
              A.replaceMarkers = k;
              function F(P) {
                let C = y(P.sheetAddress);
                Object.assign(C, O3.remove(C, P.markerId));
              }
              A.removeMarker = F;
              function U(P) {
                let E = y(P.sheetAddress).byId[P.markerId];
                E !== void 0 && (E.label = P.label);
              }
              A.updateMarker = U;
            })(m = M.sequenceEditor || (M.sequenceEditor = {}));
          })(z = u.stateBySheetId || (u.stateBySheetId = {}));
        })(g = s.stateByProjectId || (s.stateByProjectId = {}));
      })(h = v.projects || (v.projects = {}));
    })(r = i.historic || (i.historic = {}));
    let e;
    (h => {
      function o(v) {
        t0().ephemeral.showOutline = v;
      }
      h.setShowOutline = o;
      let n;
      (g => {
        let v;
        (z => {
          function s(u) {
            let f = t0().ephemeral;
            return f.projects.stateByProjectId[u.projectId] || (f.projects.stateByProjectId[u.projectId] = {
              stateBySheetId: {}
            }), f.projects.stateByProjectId[u.projectId];
          }
          z._ensure = s;
          let d;
          (p => {
            function u(m) {
              let M = c.studio.ephemeral.projects.stateByProjectId._ensure(m);
              return M.stateBySheetId[m.sheetId] || (M.stateBySheetId[m.sheetId] = {
                stateByObjectKey: {}
              }), M.stateBySheetId[m.sheetId];
            }
            p._ensure = u;
            let f;
            (w => {
              function m(H) {
                var k, F;
                let y = c.studio.ephemeral.projects.stateByProjectId.stateBySheetId._ensure(H).stateByObjectKey;
                return (F = y[k = H.objectKey]) != null || (y[k] = {}), y[H.objectKey];
              }
              w._ensure = m;
              let M;
              (k => {
                function H(F) {
                  var A;
                  let U = c.studio.ephemeral.projects.stateByProjectId.stateBySheetId.stateByObjectKey._ensure(F);
                  return (A = U.valuesBeingScrubbed) != null || (U.valuesBeingScrubbed = {}), U.valuesBeingScrubbed;
                }
                k._ensure = H;
                function y(F) {
                  i6(H(F), F.pathToProp, !0);
                }
                k.flag = y;
              })(M = w.propsBeingScrubbed || (w.propsBeingScrubbed = {}));
            })(f = p.stateByObjectKey || (p.stateByObjectKey = {}));
          })(d = z.stateBySheetId || (z.stateBySheetId = {}));
        })(v = g.stateByProjectId || (g.stateByProjectId = {}));
      })(n = h.projects || (h.projects = {}));
    })(e = i.ephemeral || (i.ephemeral = {}));
    let l;
    (d => {
      function o(z) {
        t0().ahistoric.pinOutline = z;
      }
      d.setPinOutline = o;
      function n(z) {
        t0().ahistoric.pinDetails = z;
      }
      d.setPinDetails = n;
      function h(z) {
        t0().ahistoric.pinNotifications = z;
      }
      d.setPinNotifications = h;
      function v(z) {
        t0().ahistoric.visibilityState = z;
      }
      d.setVisibilityState = v;
      function g(z) {
        let u = J6(z.map(m => m.pathToProp)),
          f = z.map(({
            keyframe: m,
            pathToProp: M
          }) => ({
            keyframe: m,
            pathToProp: M.slice(u.length)
          })),
          p = t0();
        p.ahistoric.clipboard ? p.ahistoric.clipboard.keyframesWithRelativePaths = f : p.ahistoric.clipboard = {
          keyframesWithRelativePaths: f
        };
      }
      d.setClipboardKeyframes = g;
      let s;
      (u => {
        let z;
        (M => {
          function f(w) {
            let H = t0().ahistoric;
            return H.projects.stateByProjectId[w.projectId] || (H.projects.stateByProjectId[w.projectId] = {
              stateBySheetId: {}
            }), H.projects.stateByProjectId[w.projectId];
          }
          M._ensure = f;
          let p;
          (y => {
            function w(k) {
              let F = c.studio.ahistoric.projects.stateByProjectId._ensure(k);
              return F.collapsedItemsInOutline || (F.collapsedItemsInOutline = {}), F.collapsedItemsInOutline;
            }
            y._ensure = w;
            function H(k) {
              let F = c.studio.ahistoric.projects.stateByProjectId.collapsedItemsInOutline._ensure(k);
              k.isCollapsed ? F[k.itemKey] = !0 : delete F[k.itemKey];
            }
            y.set = H;
          })(p = M.collapsedItemsInOutline || (M.collapsedItemsInOutline = {}));
          let m;
          (y => {
            function w(k) {
              let F = c.studio.ahistoric.projects.stateByProjectId._ensure(k);
              return F.stateBySheetId[k.sheetId] || (F.stateBySheetId[k.sheetId] = {}), F.stateBySheetId[k.sheetId];
            }
            y._ensure = w;
            let H;
            (P => {
              function k(C) {
                let E = c.studio.ahistoric.projects.stateByProjectId.stateBySheetId._ensure(C);
                return E.sequence || (E.sequence = {}), E.sequence;
              }
              P._ensure = k;
              let F;
              (a1 => {
                function C(j) {
                  c.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence._ensure(j).focusRange = {
                    range: j.range,
                    enabled: j.enabled
                  };
                }
                a1.set = C;
                function E(j) {
                  c.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence._ensure(j).focusRange = void 0;
                }
                a1.unset = E;
              })(F = P.focusRange || (P.focusRange = {}));
              let U;
              (E => {
                function C(a1) {
                  c.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence._ensure(a1).clippedSpaceRange = S({}, a1.range);
                }
                E.set = C;
              })(U = P.clippedSpaceRange || (P.clippedSpaceRange = {}));
              let A;
              (a1 => {
                function C(j) {
                  let K = c.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence._ensure(j),
                    Z = K.collapsableItems;
                  return Z || (Z = K.collapsableItems = O3.create()), Z;
                }
                function E(j) {
                  let K = C(j);
                  Object.assign(K, O3.add(K, j.studioSheetItemKey, {
                    isCollapsed: j.isCollapsed
                  }));
                }
                a1.set = E;
              })(A = P.sequenceEditorCollapsableItems || (P.sequenceEditorCollapsableItems = {}));
            })(H = y.sequence || (y.sequence = {}));
          })(m = M.stateBySheetId || (M.stateBySheetId = {}));
        })(z = u.stateByProjectId || (u.stateByProjectId = {}));
      })(s = d.projects || (d.projects = {}));
    })(l = i.ahistoric || (i.ahistoric = {}));
  })(t = c.studio || (c.studio = {}));
  let a;
  (e => {
    let r;
    (o => {
      let l;
      (h => {
        function n(v) {
          let g = t0().historic.coreByProject[v.projectId].revisionHistory,
            s = 50;
          g.unshift(v.revision), g.length > s && (g.length = s);
        }
        h.add = n;
      })(l = o.revisionHistory || (o.revisionHistory = {}));
      let i;
      (d => {
        function n(z) {
          let u = t0().historic.coreByProject[z.projectId].sheetsById;
          return u[z.sheetId] || (u[z.sheetId] = {
            staticOverrides: {
              byObject: {}
            }
          }), u[z.sheetId];
        }
        d._ensure = n;
        function h(z) {
          let u = t0().historic.coreByProject[z.projectId].sheetsById[z.sheetId];
          if (!u) return;
          delete u.staticOverrides.byObject[z.objectKey];
          let f = u.sequence;
          f && delete f.tracksByObject[z.objectKey];
        }
        d.forgetObject = h;
        function v(z) {
          t0().historic.coreByProject[z.projectId].sheetsById[z.sheetId] && delete t0().historic.coreByProject[z.projectId].sheetsById[z.sheetId];
        }
        d.forgetSheet = v;
        let g;
        (j => {
          function z(K) {
            var J;
            let Z = c.coreByProject.historic.sheetsById._ensure(K);
            return (J = Z.sequence) != null || (Z.sequence = {
              subUnitsPerUnit: 30,
              length: 10,
              type: "PositionalSequence",
              tracksByObject: {}
            }), Z.sequence;
          }
          j._ensure = z;
          function u(K) {
            z(K).length = b1(parseFloat(K.length.toFixed(2)), .01, 1 / 0);
          }
          j.setLength = u;
          function f(K) {
            z(K).subUnitsPerUnit = b1(K.subUnitsPerUnit, 1, vv(2, 12));
          }
          j.setSubUnitsPerUnit = f;
          function p(K) {
            var J, W;
            let Z = c.coreByProject.historic.sheetsById.sequence._ensure(K).tracksByObject;
            return (W = Z[J = K.objectKey]) != null || (Z[J] = {
              trackData: {},
              trackIdByPropPath: {}
            }), Z[K.objectKey];
          }
          function m(K, Z) {
            let J = p(K),
              W = h3(K.pathToProp);
            if (typeof J.trackIdByPropPath[W] == "string") return;
            let g1 = HF(),
              X = {
                type: "BasicKeyframedTrack",
                __debugName: "".concat(K.objectKey, ":").concat(W),
                keyframes: []
              };
            J.trackData[g1] = X, J.trackIdByPropPath[W] = g1;
          }
          j.setPrimitivePropAsSequenced = m;
          function M(K) {
            let Z = p(K),
              J = h3(K.pathToProp),
              W = Z.trackIdByPropPath[J];
            typeof W == "string" && (delete Z.trackIdByPropPath[J], delete Z.trackData[W], c.coreByProject.historic.sheetsById.staticOverrides.byObject.setValueOfPrimitiveProp(K));
          }
          j.setPrimitivePropAsStatic = M;
          function w(K) {
            let Z = p(K);
            for (let J of Object.keys(Z.trackIdByPropPath)) {
              let W = JSON.parse(J);
              if (K.pathToProp.every((g1, X) => W[X] === g1)) {
                let g1 = Z.trackIdByPropPath[J];
                if (typeof g1 != "string") continue;
                delete Z.trackIdByPropPath[J], delete Z.trackData[g1];
              }
            }
            c.coreByProject.historic.sheetsById.staticOverrides.byObject.setValueOfCompoundProp(K);
          }
          j.setCompoundPropAsStatic = w;
          function H(K) {
            return p(K).trackData[K.trackId];
          }
          function y(K) {
            let Z = H(K);
            if (Z) return Z.keyframes.find(J => J.id === K.keyframeId);
          }
          function k(K) {
            let Z = K.snappingFunction(K.position),
              J = H(K);
            if (!J) return;
            let {
                keyframes: W
              } = J,
              _ = W.findIndex($ => $.position === Z);
            if (_ !== -1) {
              let $ = W[_];
              $.value = K.value;
              return;
            }
            let g1 = LL(W, $ => $.position < Z);
            if (g1 === -1) {
              W.unshift({
                id: zu(),
                position: Z,
                connectedRight: !0,
                handles: K.handles || [.5, 1, .5, 0],
                type: K.type || "bezier",
                value: K.value
              });
              return;
            }
            let X = W[g1];
            W.splice(g1 + 1, 0, {
              id: zu(),
              position: Z,
              connectedRight: X.connectedRight,
              handles: K.handles || [.5, 1, .5, 0],
              type: K.type || "bezier",
              value: K.value
            });
          }
          j.setKeyframeAtPosition = k;
          function F(K) {
            let Z = H(K);
            if (!Z) return;
            let {
                keyframes: J
              } = Z,
              W = J.findIndex(_ => _.position === K.position);
            W !== -1 && J.splice(W, 1);
          }
          j.unsetKeyframeAtPosition = F;
          function U(K) {
            let Z = H(K);
            if (!Z) return;
            let _ = ae(Z.keyframes).filter(g1 => K.keyframeIds.includes(g1.id)).map(g1 => {
              let X = g1.position,
                $ = K.snappingFunction(_j(X, K));
              return D(S({}, g1), {
                position: $
              });
            });
            a1(D(S({}, K), {
              keyframes: _
            }));
          }
          j.transformKeyframes = U;
          function A(K) {
            let Z = H(K);
            Z && (Z.keyframes = Z.keyframes.map((J, W) => {
              let _ = Z.keyframes[W - 1],
                g1 = K.keyframeIds.includes(J.id),
                X = K.keyframeIds.includes(_ == null ? void 0 : _.id);
              return g1 && !X ? D(S({}, J), {
                handles: [J.handles[0], J.handles[1], K.handles[0], K.handles[1]]
              }) : g1 && X ? D(S({}, J), {
                handles: [K.handles[2], K.handles[3], K.handles[0], K.handles[1]]
              }) : X ? D(S({}, J), {
                handles: [K.handles[2], K.handles[3], J.handles[2], J.handles[3]]
              }) : J;
            }));
          }
          j.setTweenBetweenKeyframes = A;
          function P(K) {
            var J, W, _, g1, X, $, o1, u1;
            let Z = y(K);
            Z && (Z.handles = [(W = (J = K.end) == null ? void 0 : J[0]) != null ? W : Z.handles[0], (g1 = (_ = K.end) == null ? void 0 : _[1]) != null ? g1 : Z.handles[1], ($ = (X = K.start) == null ? void 0 : X[0]) != null ? $ : Z.handles[2], (u1 = (o1 = K.start) == null ? void 0 : o1[1]) != null ? u1 : Z.handles[3]]);
          }
          j.setHandlesForKeyframe = P;
          function C(K) {
            let Z = H(K);
            Z && (Z.keyframes = Z.keyframes.filter(J => K.keyframeIds.indexOf(J.id) === -1));
          }
          j.deleteKeyframes = C;
          function E(K) {
            let Z = y(K);
            Z && (Z.type = K.keyframeType);
          }
          j.setKeyframeType = E;
          function a1(K) {
            let Z = H(K);
            if (!Z) return;
            let J = ae(Z.keyframes),
              W = K.keyframes.filter(o1 => !(typeof o1.value == "number" && !isFinite(o1.value) || !o1.handles.every(u1 => isFinite(u1)))).map(o1 => D(S({}, o1), {
                position: K.snappingFunction(o1.position)
              })),
              _ = Ma(W, "id"),
              g1 = J.filter(o1 => !_[o1.id]),
              X = Ma(g1, "position");
            W.forEach(({
              position: o1
            }) => {
              let u1 = X[o1];
              u1 && UL(g1, u1);
            });
            let $ = QL([...g1, ...W], "position");
            Z.keyframes = $;
          }
          j.replaceKeyframes = a1;
        })(g = d.sequence || (d.sequence = {}));
        let s;
        (u => {
          let z;
          (w => {
            function f(H) {
              var k, F;
              let y = c.coreByProject.historic.sheetsById._ensure(H).staticOverrides.byObject;
              return (F = y[k = H.objectKey]) != null || (y[k] = {}), y[H.objectKey];
            }
            function p(H) {
              let y = f(H);
              i6(y, H.pathToProp, H.value);
            }
            w.setValueOfCompoundProp = p;
            function m(H) {
              let y = f(H);
              i6(y, H.pathToProp, H.value);
            }
            w.setValueOfPrimitiveProp = m;
            function M(H) {
              let y = c.coreByProject.historic.sheetsById._ensure(H).staticOverrides.byObject[H.objectKey];
              y && Kh(y, H.pathToProp);
            }
            w.unsetValueOfPrimitiveProp = M;
          })(z = u.byObject || (u.byObject = {}));
        })(s = d.staticOverrides || (d.staticOverrides = {}));
      })(i = o.sheetsById || (o.sheetsById = {}));
    })(r = e.historic || (e.historic = {}));
  })(a = c.coreByProject || (c.coreByProject = {}));
})(af || (af = {}));
function Ut() {
  let t,
    a,
    c = new Promise((e, l) => {
      t = i => {
        e(i), r.status = "resolved";
      }, a = i => {
        l(i), r.status = "rejected";
      };
    }),
    r = {
      resolve: t,
      reject: a,
      promise: c,
      status: "pending"
    };
  return r;
}
var tq = require("@theatre/dataverse");
function rf(t) {
  let a = t.getState(),
    c = new tq.Atom(a);
  return t.subscribe(() => {
    let r = t.getState();
    c.set(r), a = r;
  }), c;
}
Fv();
function ef(t) {
  var a,
    c = t.Symbol;
  return typeof c == "function" ? c.observable ? a = c.observable : (a = c("observable"), c.observable = a) : a = "@@observable", a;
}
var Kt;
typeof self != "undefined" ? Kt = self : typeof window != "undefined" ? Kt = window : typeof global != "undefined" ? Kt = global : typeof module != "undefined" ? Kt = module : Kt = Function("return this")();
var Ye1 = ef(Kt),
  lf = Ye1;
var of = {
  INIT: "@@redux/INIT"
};
function ce(t, a, c) {
  var r;
  if (typeof a == "function" && typeof c == "undefined" && (c = a, a = void 0), typeof c != "undefined") {
    if (typeof c != "function") throw new Error("Expected the enhancer to be a function.");
    return c(ce)(t, a);
  }
  if (typeof t != "function") throw new Error("Expected the reducer to be a function.");
  var e = t,
    l = a,
    i = [],
    o = i,
    n = !1;
  function h() {
    o === i && (o = i.slice());
  }
  function v() {
    return l;
  }
  function g(u) {
    if (typeof u != "function") throw new Error("Expected listener to be a function.");
    var f = !0;
    return h(), o.push(u), function () {
      if (f) {
        f = !1, h();
        var m = o.indexOf(u);
        o.splice(m, 1);
      }
    };
  }
  function s(u) {
    if (!M8(u)) throw new Error("Actions must be plain objects. Use custom middleware for async actions.");
    if (typeof u.type == "undefined") throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
    if (n) throw new Error("Reducers may not dispatch actions.");
    try {
      n = !0, l = e(l, u);
    } finally {
      n = !1;
    }
    for (var f = i = o, p = 0; p < f.length; p++) {
      var m = f[p];
      m();
    }
    return u;
  }
  function d(u) {
    if (typeof u != "function") throw new Error("Expected the nextReducer to be a function.");
    e = u, s({
      type: of.INIT
    });
  }
  function z() {
    var u,
      f = g;
    return u = {
      subscribe: function (m) {
        if (typeof m != "object") throw new TypeError("Expected the observer to be an object.");
        function M() {
          m.next && m.next(v());
        }
        M();
        var w = f(M);
        return {
          unsubscribe: w
        };
      }
    }, u[lf] = function () {
      return this;
    }, u;
  }
  return s({
    type: of.INIT
  }), r = {
    dispatch: s,
    subscribe: g,
    getState: v,
    replaceReducer: d
  }, r[lf] = z, r;
}
function re() {
  for (var t = arguments.length, a = Array(t), c = 0; c < t; c++) a[c] = arguments[c];
  return a.length === 0 ? function (r) {
    return r;
  } : a.length === 1 ? a[0] : a.reduce(function (r, e) {
    return function () {
      return r(e.apply(void 0, arguments));
    };
  });
}
function nf(t) {
  let c = re(...[]);
  return ce(t.rootReducer, void 0, c);
}
_r();
Kv();
var hf = new WeakMap(),
  aq = (t, a, c) => {
    let r = n => {
        t.dispatch(u8.replacePersistentState(n));
      },
      e = rq(c),
      l = () => t.getState().$persistent;
    o();
    let i = () => {
      let n = l(),
        h = hf.get(t);
      n !== h && (hf.set(t, n), localStorage.setItem(e, JSON.stringify(n)));
    };
    t.subscribe(pa(i, 1e3)), window && window.addEventListener("beforeunload", i);
    function o() {
      let n = localStorage.getItem(e);
      if (n) {
        let h,
          v = !0;
        try {
          h = JSON.parse(n), v = !1;
        } catch (g) {
          kt.warn("Could not parse Theatre's persisted state. This must be a bug. Please report it.");
        } finally {
          v || r(h), a();
        }
      } else a();
    }
  },
  cq = (t, a) => {
    let c = rq(a),
      r = t.getState().$persistent;
    localStorage.removeItem(c), hf.set(t, r);
  };
function rq(t) {
  return t + ".persistent";
}
yu();
N5();
D7();
$v();
de();
rr();
var ee = require("@theatre/dataverse");
H5();
H2();
Yp();
function vf(t) {
  if (typeof t == "boolean" || typeof t == "string" || typeof t == "number") return t;
  if (M8(t)) {
    let a = {},
      c = !1;
    for (let [r, e] of Object.entries(t)) vf(e) !== void 0 && (a[r] = e, c = !0);
    if (c) return a;
  } else return;
}
function eq(t, a, c) {
  for (let [r, e] of Object.entries(t.props)) if (e.type === "compound") eq(e, [...a, r], c);else {
    if (e.type === "enum") throw new Error("Not yet implemented");
    c(e, [...a, r]);
  }
}
function gf(t, a, c) {
  return {
    set: (r, e) => {
      t();
      let l = vf(e);
      if (typeof l == "undefined") return;
      let {
        root: i,
        path: o
      } = (0, ee.getPointerParts)(r);
      if (c0(i)) {
        let n = i.template.getMapOfValidSequenceTracks_forStudio().getValue(),
          h = U9(i.template.staticConfig, o);
        if (!h) throw new Error("Object ".concat(i.address.objectKey, " does not have a prop at ").concat(JSON.stringify(o)));
        let v = (g, s, d) => {
          if (g == null) return;
          if (vf(s.deserializeAndSanitize(g)) === void 0) throw new Error("Invalid value ".concat(wh(g), " for object.props").concat(d.map(p => "[".concat(JSON.stringify(p), "]")).join(""), " is invalid"));
          let u = D(S({}, i.address), {
              pathToProp: d
            }),
            f = D3(n, d);
          if (typeof f == "string") {
            let p = i.sheet.getSequence();
            p.position = p.closestGridPosition(p.position), a.coreByProject.historic.sheetsById.sequence.setKeyframeAtPosition(D(S({}, u), {
              trackId: f,
              position: p.position,
              value: g,
              snappingFunction: p.closestGridPosition,
              type: "bezier"
            }));
          } else a.coreByProject.historic.sheetsById.staticOverrides.byObject.setValueOfPrimitiveProp(D(S({}, u), {
            value: g
          }));
        };
        if (h.type === "compound") {
          let g = (0, ee.getPointerParts)(r).path,
            s = g.length;
          eq(h, g, (d, z) => {
            let u = z.slice(s),
              f = l3(l, u);
            if (typeof f != "undefined") v(f, d, z);else throw new Error("Property object.props".concat(z.map(p => "[".concat(JSON.stringify(p), "]")).join(""), " is required but not provided"));
          });
        } else {
          if (h.type === "enum") throw new Error("Enums aren't implemented yet");
          v(l, h, o);
        }
      } else if (Sf(i)) {
        let [n] = o;
        if (n === "subUnitsPerUnit") {
          if (typeof l != "number" || !fa(l) || l < 1) throw new Error("Value ".concat(l, " is not an integer, which is required for setting sequence prop ").concat(n));
          a.coreByProject.historic.sheetsById.sequence.setSubUnitsPerUnit(D(S({}, i.address), {
            subUnitsPerUnit: l
          }));
        } else if (n === "length") {
          if (typeof l != "number" || l <= .001) throw new Error("Value ".concat(l, " is not a positive number, which is required for setting sequence prop ").concat(n));
          a.coreByProject.historic.sheetsById.sequence.setLength(D(S({}, i.address), {
            length: l
          }));
        } else throw new Error("Setting sequence prop ".concat(n, " is not supported"));
      } else throw new Error("Only setting props of SheetObject-s and sequences is supported in a transaction so far");
    },
    unset: r => {
      t();
      let {
        root: e,
        path: l
      } = (0, ee.getPointerParts)(r);
      if (c0(e)) {
        let i = e.template.getMapOfValidSequenceTracks_forStudio().getValue(),
          o = l3(e.template.getDefaultValues().getValue(), l),
          n = U9(e.template.staticConfig, l),
          h = (v, g) => {
            let s = D(S({}, e.address), {
                pathToProp: g
              }),
              d = D3(i, g);
            typeof d == "string" ? a.coreByProject.historic.sheetsById.sequence.unsetKeyframeAtPosition(D(S({}, s), {
              trackId: d,
              position: e.sheet.getSequence().positionSnappedToGrid
            })) : n !== void 0 && a.coreByProject.historic.sheetsById.staticOverrides.byObject.unsetValueOfPrimitiveProp(s);
          };
        n.type === "compound" ? q5(o, (v, g) => {
          h(v, g);
        }, (0, ee.getPointerParts)(r).path) : h(o, l);
      } else throw new Error("Only setting props of SheetObject-s is supported in a transaction so far");
    },
    get drafts() {
      return t(), c;
    },
    get stateEditors() {
      return a;
    }
  };
}
var le = class {
  constructor() {
    y1(this, "_reduxStore");
    y1(this, "_atom");
    y1(this, "atomP");
    this._reduxStore = nf({
      rootReducer: Wj,
      devtoolsOptions: {
        name: "Theatre.js Studio"
      }
    }), this._atom = rf(this._reduxStore), this.atomP = this._atom.pointer;
  }
  initialize(a) {
    let c = Ut();
    return a.usePersistentStorage === !0 ? aq(this._reduxStore, () => {
      this.tempTransaction(({
        drafts: r
      }) => {
        r.ephemeral.initialised = !0;
      }).commit(), c.resolve();
    }, a.persistenceKey) : (this.tempTransaction(({
      drafts: r
    }) => {
      r.ephemeral.initialised = !0;
    }).commit(), c.resolve()), c.promise;
  }
  getState() {
    return this._reduxStore.getState();
  }
  __experimental_clearPersistentStorage(a) {
    return cq(this._reduxStore, a), this.getState();
  }
  __dev_startHistoryFromScratch(a) {
    this._reduxStore.dispatch(u8.historic.startHistoryFromScratch(u8.reduceParts(c => D(S({}, c), {
      historic: a
    }))));
  }
  tempTransaction(a) {
    let c = Dj(),
      r,
      e = c.push(u8.reduceParts(l => {
        let i = {
            historic: tv(l.historic),
            ahistoric: tv(l.ahistoric),
            ephemeral: tv(l.ephemeral)
          },
          o = !0,
          n = () => {
            if (!o) throw new Error("You seem to have called the transaction api after studio.transaction() has finished running");
          },
          h = cf(i),
          v = gf(n, h, i);
        try {
          return a(v), o = !1, {
            historic: av(i.historic),
            ahistoric: av(i.ahistoric),
            ephemeral: av(i.ephemeral)
          };
        } catch (g) {
          return r = g, l;
        } finally {
          cf(void 0);
        }
      }));
    if (this._reduxStore.dispatch(e), r) throw this._reduxStore.dispatch(c.discard()), r;
    return {
      commit: () => {
        this._reduxStore.dispatch(c.commit());
      },
      discard: () => {
        this._reduxStore.dispatch(c.discard());
      }
    };
  }
  undo() {
    this._reduxStore.dispatch(u8.historic.undo());
  }
  redo() {
    this._reduxStore.dispatch(u8.historic.redo());
  }
  createContentOfSaveFile(a) {
    if (!this._reduxStore.getState().$persistent.historic.innerState.coreByProject[a]) throw new Error("Project ".concat(a, " has not been initialized."));
    let r = Jo();
    this.tempTransaction(({
      stateEditors: i
    }) => {
      i.coreByProject.historic.revisionHistory.add({
        projectId: a,
        revision: r
      });
    }).commit();
    let e = this._reduxStore.getState().$persistent.historic.innerState.coreByProject[a];
    return S({}, e);
  }
};
var lq = require("@theatre/dataverse");
var W5 = class {
  constructor() {
    y1(this, "_values", {});
  }
  get(a, c) {
    if (this.has(a)) return this._values[a];
    {
      let r = c();
      return this._values[a] = r, r;
    }
  }
  has(a) {
    return this._values.hasOwnProperty(a);
  }
};
N5();
C5();
f1();
H2();
xh();
var ie = class {
  constructor(a) {
    y1(this, "ui", {
      hide() {
        T().ui.hide();
      },
      get isHidden() {
        return T().ui.isHidden;
      },
      restore() {
        T().ui.restore();
      },
      renderToolset(a, c) {
        return T().ui.renderToolset(a, c);
      }
    });
    y1(this, "_cache", new W5());
    y1(this, "__experimental", {
      __experimental_disblePlayPauseKeyboardShortcut() {
        gD();
      },
      __experimental_enablePlayPauseKeyboardShortcut() {
        dD();
      },
      __experimental_clearPersistentStorage(a) {
        return T().clearPersistentStorage(a);
      },
      __experimental_createContentOfSaveFileTyped(a) {
        return T().createContentOfSaveFile(a);
      }
    });
  }
  initialize(a) {
    return T().initialize(a);
  }
  extend(a, c) {
    T().extend(a, c);
  }
  transaction(a) {
    return T().transaction(({
      set: c,
      unset: r,
      stateEditors: e
    }) => a({
      set: c,
      unset: r,
      __experimental_forgetObject: o => {
        if (!dv(o)) throw new Error("object in transactionApi.__experimental_forgetObject(object) must be the return type of sheet.object(...)");
        e.coreByProject.historic.sheetsById.forgetObject(o.address);
      },
      __experimental_forgetSheet: o => {
        if (!gv(o)) throw new Error("sheet in transactionApi.__experimental_forgetSheet(sheet) must be the return type of project.sheet()");
        e.coreByProject.historic.sheetsById.forgetSheet(o.address);
      }
    }));
  }
  _getSelectionPrism() {
    return this._cache.get("_getSelectionPrism()", () => (0, lq.prism)(() => c3().filter(a => a.type === "Theatre_SheetObject" || a.type === "Theatre_Sheet").map(a => a.publicApi)));
  }
  _getSelection() {
    return this._getSelectionPrism().getValue();
  }
  setSelection(a) {
    let c = [...a].filter(r => dv(r) || gv(r)).map(r => T().corePrivateAPI(r));
    T().transaction(({
      stateEditors: r
    }) => {
      r.studio.historic.panels.outline.selection.set(c);
    });
  }
  onSelectionChange(a) {
    let c = T();
    return this._getSelectionPrism().onChange(c.ticker, a, !0);
  }
  get selection() {
    return this._getSelection();
  }
  scrub() {
    return T().scrub();
  }
  getStudioProject() {
    let a = T().core;
    if (!a) throw new Error("You're calling studio.getStudioProject() before `@theatre/core` is loaded. To fix this:\n1. Check if `@theatre/core` is import/required in your bundle.\n2. Check the stack trace of this error and make sure the funciton that calls getStudioProject() is run after `@theatre/core` is loaded.");
    return T().getStudioProject(a);
  }
  debouncedScrub(a = 1e3) {
    let c,
      r = pa(() => {
        let l = c;
        l && (c = void 0, l.commit());
      }, a);
    return {
      capture: l => {
        c || (c = this.scrub());
        let i = !0;
        try {
          c.capture(l), i = !1;
        } finally {
          if (i) {
            let o = c;
            c = void 0, o.discard();
          } else r();
        }
      }
    };
  }
  createPane(a) {
    return T().paneManager.createPane(a);
  }
  destroyPane(a) {
    return T().paneManager.destroyPane(a);
  }
  createContentOfSaveFile(a) {
    return T().createContentOfSaveFile(a);
  }
};
su();
var _5 = require("@theatre/dataverse");
var oe = class {
  constructor(a) {
    this._studio = a;
    y1(this, "_cache", new W5());
    this._instantiatePanesAsTheyComeIn();
  }
  _instantiatePanesAsTheyComeIn() {
    let a = this._getAllPanes();
    a.onStale(() => {
      a.getValue();
    });
  }
  _getAllPanes() {
    return this._cache.get("_getAllPanels()", () => (0, _5.prism)(() => {
      if (!(0, _5.val)(this._studio.coreP)) return {};
      let c = (0, _5.val)(this._studio.atomP.historic.panelInstanceDesceriptors),
        r = (0, _5.val)(this._studio.atomP.ephemeral.extensions.paneClasses),
        e = {};
      for (let l of Object.values(c)) {
        if (!l) continue;
        let i = r[l.paneClass];
        if (!i) continue;
        let {
            instanceId: o
          } = l,
          {
            extensionId: n,
            classDefinition: h
          } = i,
          v = _5.prism.memo("instance-".concat(l.instanceId), () => ({
            extensionId: n,
            instanceId: o,
            definition: h
          }), [h]);
        e[o] = v;
      }
      return e;
    }));
  }
  get allPanesD() {
    return this._getAllPanes();
  }
  createPane(a) {
    if (!this._studio.core) throw new Error("Can't create a pane because @theatre/core is not yet loaded");
    let r = (0, _5.val)(this._studio.atomP.ephemeral.extensions.paneClasses[a].extensionId),
      e = (0, _5.val)(this._studio.atomP.historic.panelInstanceDesceriptors),
      l;
    for (let i = 1; i < 1e3 && (l = "".concat(a, " #").concat(i), !!e[l]); i++);
    if (!r) throw new Error('Pane class "'.concat(a, '" is not registered.'));
    return this._studio.transaction(({
      drafts: i
    }) => {
      i.historic.panelInstanceDesceriptors[l] = {
        instanceId: l,
        paneClass: a
      };
    }), this._getAllPanes().getValue()[l];
  }
  destroyPane(a) {
    if (!this._studio.core) throw new Error("Can't do this yet because @theatre/core is not yet loaded");
    this._studio.transaction(({
      drafts: r
    }) => {
      delete r.historic.panelInstanceDesceriptors[a];
    });
  }
};
var $t = require("@theatre/dataverse");
f1();
var iq = 30 * 60 * 1e3,
  Je1 = 1e3 * 60 * 60;
function tl1() {
  return e2(this, null, function* () {
    let t = T().atomP.ahistoric.visibilityState;
    if ((0, $t.val)(t) === "everythingIsVisible") return;
    let a = Ut(),
      c = (0, $t.pointerToPrism)(t).onStale(() => {
        (0, $t.val)(t) === "everythingIsVisible" && (c(), a.resolve(void 0));
      });
    return a.promise;
  });
}
function df() {
  return e2(this, null, function* () {
    if (!("0.7.2" != null && "0.7.2".match(/COMPAT/))) for (yield cv(500), yield tl1();;) {
      let t = (0, $t.val)(T().atomP.ahistoric.updateChecker);
      if (t && t.result !== "error") {
        let a = t.lastChecked,
          c = Date.now(),
          r = Math.abs(c - a);
        r < iq && (yield cv(iq - r));
      }
      try {
        let a = yield fetch(new Request("https://updates.theatrejs.com/updates/0.7.2"));
        if (a.ok) {
          let c = yield a.json();
          if (!al1(c)) throw new Error("Bad response");
          T().transaction(({
            drafts: r
          }) => {
            r.ahistoric.updateChecker = {
              lastChecked: Date.now(),
              result: S({}, c)
            };
          }), yield cv(1e3);
        } else throw new Error("HTTP Error ".concat(a.statusText));
      } catch (a) {
        yield cv(Je1);
      }
    }
  });
}
var cv = t => new Promise(a => setTimeout(a, t));
function al1(t) {
  if (typeof t != "object") return !1;
  let a = t;
  return typeof a.hasUpdates != "boolean" ? !1 : a.hasUpdates === !0 && typeof a.newVersion == "string" && typeof a.releasePage == "string" || a.hasUpdates === !1;
}
var pq = I(fs());
function j5(t) {
  return new Promise((a, c) => {
    t.oncomplete = t.onsuccess = () => a(t.result), t.onabort = t.onerror = () => c(t.error);
  });
}
function zf(t, a) {
  let c = indexedDB.open(t);
  c.onupgradeneeded = () => c.result.createObjectStore(a);
  let r = j5(c);
  return (e, l) => r.then(i => l(i.transaction(a, e).objectStore(a)));
}
var sf;
function Qt() {
  return sf || (sf = zf("keyval-store", "keyval")), sf;
}
function oq(t, a = Qt()) {
  return a("readonly", c => j5(c.get(t)));
}
function nq(t, a, c = Qt()) {
  return c("readwrite", r => (r.put(a, t), j5(r.transaction)));
}
function hq(t, a = Qt()) {
  return a("readwrite", c => (c.delete(t), j5(c.transaction)));
}
function uf(t, a) {
  return t.openCursor().onsuccess = function () {
    this.result && (a(this.result), this.result.continue());
  }, j5(t.transaction);
}
function vq(t = Qt()) {
  return t("readonly", a => {
    if (a.getAllKeys) return j5(a.getAllKeys());
    let c = [];
    return uf(a, r => c.push(r.key)).then(() => c);
  });
}
function gq(t = Qt()) {
  return t("readonly", a => {
    if (a.getAll) return j5(a.getAll());
    let c = [];
    return uf(a, r => c.push(r.value)).then(() => c);
  });
}
function dq(t = Qt()) {
  return t("readonly", a => {
    if (a.getAll && a.getAllKeys) return Promise.all([j5(a.getAllKeys()), j5(a.getAll())]).then(([r, e]) => r.map((l, i) => [l, e[i]]));
    let c = [];
    return t("readonly", r => uf(r, e => c.push([e.key, e.value])).then(() => c));
  });
}
var sq = t => {
  let a = zf("theatrejs-".concat(t), "default-store");
  return {
    set: (c, r) => nq(c, r, a),
    get: c => oq(c, a),
    del: c => hq(c, a),
    keys: () => vq(a),
    entries: () => dq(a),
    values: () => gq(a)
  };
};
Gu();
vt();
var uq = "theatre-0.4",
  rl1 = "You seem to have imported '@theatre/studio' but haven't initialized it. You can initialize the studio by:\n```\nimport studio from '@theatre/studio'\nstudio.initialize()\n```\n\n* If you didn't mean to import '@theatre/studio', this means that your bundler is not tree-shaking it. This is most likely a bundler misconfiguration.\n\n* If you meant to import '@theatre/studio' without showing its UI, you can do that by running:\n\n```\nimport studio from '@theatre/studio'\nstudio.initialize()\nstudio.ui.hide()\n```\n",
  el1 = "You seem to have imported '@theatre/studio' but called `studio.initialize()` after some delay.\nTheatre.js projects remain in pending mode (won't play their sequences) until the studio is initialized, so you should place the `studio.initialize()` line right after the import line:\n\n```\nimport studio from '@theatre/studio'\n// ... and other imports\n\nstudio.initialize()\n```\n",
  ev = class {
    constructor() {
      y1(this, "ui");
      y1(this, "publicApi");
      y1(this, "address");
      y1(this, "_projectsProxy", new C7.PointerProxy(new C7.Atom({}).pointer));
      y1(this, "projectsP", this._projectsProxy.pointer);
      y1(this, "_store", new le());
      y1(this, "_corePrivateApi");
      y1(this, "_cache", new W5());
      y1(this, "paneManager");
      y1(this, "_coreAtom", new C7.Atom({}));
      y1(this, "_initializedDeferred", Ut());
      y1(this, "_initializeFnCalled", !1);
      y1(this, "_didWarnAboutNotInitializing", !1);
      y1(this, "_coreBits");
      y1(this, "_rafDriver");
      this.address = {
        studioId: J9(10)
      }, this.publicApi = new ie(this), this.ui = new Ur(this), this._attachToIncomingProjects(), this.paneManager = new oe(this), typeof window != "undefined" && setTimeout(() => {
        this._initializeFnCalled || (console.error(rl1), this._didWarnAboutNotInitializing = !0);
      }, 100);
    }
    get ticker() {
      if (!this._rafDriver) throw new Error("`studio.ticker` was read before studio.initialize() was called.");
      return this._rafDriver.ticker;
    }
    get atomP() {
      return this._store.atomP;
    }
    initialize(a) {
      return e2(this, null, function* () {
        if (!this._coreBits) throw new Error("You seem to have imported `@theatre/studio` without importing `@theatre/core`. Make sure to include an import of `@theatre/core` before calling `studio.initializer()`.");
        if (this._initializeFnCalled) return this._initializedDeferred.promise;
        this._initializeFnCalled = !0, this._didWarnAboutNotInitializing && console.warn(el1);
        let c = {
          persistenceKey: uq,
          usePersistentStorage: !0
        };
        if (typeof (a == null ? void 0 : a.persistenceKey) == "string" && (c.persistenceKey = a.persistenceKey), ((a == null ? void 0 : a.usePersistentStorage) === !1 || typeof window == "undefined") && (c.usePersistentStorage = !1), a != null && a.__experimental_rafDriver) {
          if (a.__experimental_rafDriver.type !== "Theatre_RafDriver_PublicAPI") throw new Error("parameter `rafDriver` in `studio.initialize({__experimental_rafDriver})` must be either be undefined, or the return type of core.createRafDriver()");
          let r = this._coreBits.privateAPI(a.__experimental_rafDriver);
          if (!r) throw new Error("parameter `rafDriver` in `studio.initialize({__experimental_rafDriver})` seems to come from a different version of `@theatre/core` than the version that is attached to `@theatre/studio`");
          this._rafDriver = r;
        } else this._rafDriver = this._coreBits.getCoreRafDriver();
        try {
          yield this._store.initialize(c);
        } catch (r) {
          this._initializedDeferred.reject(r);
          return;
        }
        typeof window != "undefined" && (yield this.ui.ready), this._initializedDeferred.resolve(), this.ui.render(), df().catch(r => {
          console.error(r);
        });
      });
    }
    get initialized() {
      return this._initializedDeferred.promise;
    }
    _attachToIncomingProjects() {
      let a = (0, C7.pointerToPrism)(this.projectsP),
        c = r => {
          for (let e of Object.values(r)) e.isAttachedToStudio || e.attachToStudio(this);
        };
      a.onStale(() => {
        c(a.getValue());
      }), c(a.getValue());
    }
    setCoreBits(a) {
      this._coreBits = a, this._corePrivateApi = a.privateAPI, this._coreAtom.setByPointer(c => c.core, a.coreExports), this._setProjectsP(a.projectsP);
    }
    _setProjectsP(a) {
      this._projectsProxy.setPointer(a);
    }
    scrub() {
      return new Jt(this);
    }
    tempTransaction(a) {
      return this._store.tempTransaction(a);
    }
    transaction(a) {
      return this.tempTransaction(a).commit();
    }
    __dev_startHistoryFromScratch(a) {
      return this._store.__dev_startHistoryFromScratch(a);
    }
    get corePrivateAPI() {
      return this._corePrivateApi;
    }
    get core() {
      return this._coreAtom.get().core;
    }
    get coreP() {
      return this._coreAtom.pointer.core;
    }
    extend(a, c) {
      if (!a || typeof a != "object") throw new Error("Extensions must be JS objects");
      if (typeof a.id != "string") throw new Error("extension.id must be a string");
      let r = (c == null ? void 0 : c.__experimental_reconfigure) === !0,
        e = a.id,
        l = this._store.getState().ephemeral.extensions.byId[e];
      if (l && !r) {
        if (a === l || (0, pq.default)(a, l)) return;
        throw new Error('Extension id "'.concat(a.id, '" is already defined. If you mean to re-configure the extension, do it like this: studio.extend(extension, {__experimental_reconfigure: true})})'));
      }
      this.transaction(({
        drafts: i
      }) => {
        var n, h;
        i.ephemeral.extensions.byId[a.id] = a;
        let o = i.ephemeral.extensions.paneClasses;
        r && l && ((n = l.panes) == null || n.forEach(v => {
          delete o[v.class];
        })), (h = a.panes) == null || h.forEach(v => {
          if (typeof v.class != "string") throw new Error("pane.class must be a string");
          if (v.class.length < 3) throw new Error("pane.class should be a string with 3 or more characters");
          let g = o[v.class];
          if (g) if (r && g.extensionId === a.id) console.warn('Pane class "'.concat(v.class, '" already exists. This is a bug in Theatre.js. Please report it at https://github.com/theatre-js/theatre/issues/new'));else throw new Error('Pane class "'.concat(v.class, '" already exists and is supplied by extension ').concat(g));
          o[v.class] = {
            extensionId: a.id,
            classDefinition: v
          };
        });
      });
    }
    getStudioProject(a) {
      return this._cache.get("getStudioProject", () => a.getProject("Studio"));
    }
    getExtensionSheet(a, c) {
      return this._cache.get("extensionSheet-" + a, () => this.getStudioProject(c).sheet("Extension " + a));
    }
    undo() {
      this._store.undo();
    }
    redo() {
      this._store.redo();
    }
    createContentOfSaveFile(a) {
      return this._store.createContentOfSaveFile(a);
    }
    createAssetStorage(a, c) {
      return e2(this, null, function* () {
        if (typeof window == "undefined") return {
          getAssetUrl: () => "",
          createAsset: () => Promise.resolve(null)
        };
        if (!("indexedDB" in window)) return console.log("This browser doesn't support IndexedDB."), {
          getAssetUrl: v => {
            throw new Error("IndexedDB is required by the default asset manager, but it's not supported by this browser. To use assets, please provide your own asset manager to the project config.");
          },
          createAsset: v => {
            throw new Error("IndexedDB is required by the default asset manager, but it's not supported by this browser. To use assets, please provide your own asset manager to the project config.");
          }
        };
        let r = sq("".concat(a.address.projectId, "-assets")),
          e = pr(a),
          l = yield r.keys();
        yield Promise.all(l.map(v => e2(this, null, function* () {
          e.includes(v) || (yield r.del(v));
        }))), yield Promise.all(l.map(v => e2(this, null, function* () {
          var s, d;
          let g = "".concat(c, "/").concat(v);
          try {
            (yield fetch(g, {
              method: "HEAD"
            })).ok && (yield r.del(v));
          } catch (z) {
            c7.error("Failed to access assets", "Failed to access assets at ".concat((d = (s = a.config.assets) == null ? void 0 : s.baseUrl) != null ? d : "/", ". This is likely due to a CORS issue."));
          }
        })));
        let i = new Map(yield r.entries()),
          o = new Map(),
          n = v => {
            if (o.has(v)) return o.get(v);
            {
              let g = URL.createObjectURL(v);
              return o.set(v, g), g;
            }
          },
          h = v => {
            let g = i.get(v);
            if (!g) throw new Error("Asset with id ".concat(v, " not found"));
            return n(g);
          };
        return {
          getAssetUrl: v => i.has(v) ? h(v) : "".concat(c, "/").concat(v),
          createAsset: v => e2(this, null, function* () {
            var d, z, u;
            let g = pr(a),
              s = !1;
            if (g.includes(v.name)) {
              let f;
              try {
                f = (d = i.get(v.name)) != null ? d : yield fetch("".concat(c, "/").concat(v.name)).then(p => p.ok ? p.blob() : void 0);
              } catch (p) {
                return c7.error("Failed to access assets", "Failed to access assets at ".concat((u = (z = a.config.assets) == null ? void 0 : z.baseUrl) != null ? u : "/", ". This is likely due to a CORS issue.")), Promise.resolve(null);
              }
              if (f) {
                if (s = yield (yield Promise.resolve().then(() => I(zq()))).default.isEqual(v, f), s) return v.name;
                {
                  let m = w => {
                    let H = prompt(w, v.name);
                    return H === null ? !1 : H === "" ? m("Asset name cannot be empty. Please choose a different file name for this asset.") : g.includes(H) ? (console.log(g), m("An asset with this name already exists. Please choose a different file name for this asset.")) : (v = new File([v], H, {
                      type: v.type
                    }), !0);
                  };
                  if (!m("An asset with this name already exists. Please choose a different file name for this asset.")) return null;
                }
              }
            }
            return i.set(v.name, v), yield r.set(v.name, v), v.name;
          })
        };
      });
    }
    clearPersistentStorage(a = uq) {
      this._store.__experimental_clearPersistentStorage(a);
    }
  };
var lv = "__TheatreJS_StudioBundle",
  mq = "__TheatreJS_CoreBundle",
  fq = "__TheatreJS_Notifications";
var ne = class {
  constructor(a) {
    this._studio = a;
    y1(this, "_coreBundle");
  }
  get type() {
    return "Theatre_StudioBundle";
  }
  registerCoreBundle(a) {
    if (this._coreBundle) throw new Error("StudioBundle.coreBundle is already registered. This is a bug.");
    this._coreBundle = a;
    let c;
    a.getBitsForStudio(this._studio, r => {
      c = r;
    }), this._studio.setCoreBits(c);
  }
};
var xq = I(G());
c1();
var Mq,
  il1 = B.div(Mq || (Mq = V([""]))),
  ol1 = t => xq.default.createElement(il1, null),
  Cq = ol1;
vt();
var mf = new ev();
Bf(mf);
var nl1 = mf.publicApi,
  hl1 = nl1;
vl1();
function vl1() {
  if (typeof window == "undefined") return;
  let t = window[lv];
  if (typeof t != "undefined") throw typeof t == "object" && t && typeof t.version == "string" ? new Error("It seems that the module '@theatre/studio' is loaded more than once. This could have two possible causes:\n1. You might have two separate versions of Theatre.js in node_modules.\n2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.\n\nNote that it **is okay** to import '@theatre/studio' multiple times. But those imports should point to the same module.") : new Error("The variable window.".concat(lv, " seems to be already set by a module other than @theatre/core."));
  let a = new ne(mf);
  window[lv] = a;
  let c = window[mq];
  c && c !== null && c.type === "Theatre_CoreBundle" && a.registerCoreBundle(c);
}
typeof window != "undefined" && (window[fq] = {
  notify: c7
});
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.production.min.js:
  (** @license React v17.0.2
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)

jiff/lib/lcs.js:
  (** @license MIT License (c) copyright 2010-2014 original author or authors *)

jiff/lib/array.js:
  (** @license MIT License (c) copyright 2010-2014 original author or authors *)

jiff/lib/jsonPointerParse.js:
  (** @license MIT License (c) copyright 2010-2014 original author or authors *)

jiff/lib/jsonPointer.js:
  (** @license MIT License (c) copyright 2010-2014 original author or authors *)

jiff/lib/clone.js:
  (** @license MIT License (c) copyright 2010-2014 original author or authors *)

jiff/lib/jsonPatch.js:
  (** @license MIT License (c) copyright 2010-2014 original author or authors *)

jiff/jiff.js:
  (** @license MIT License (c) copyright 2010-2014 original author or authors *)
*/
},{"@theatre/dataverse":"node_modules/@theatre/dataverse/dist/index.js","process":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js","buffer":"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"assets/fonts/TrajanPro-Bold.otf":[function(require,module,exports) {
module.exports = "/TrajanPro-Bold.6e95cdba.otf";
},{}],"js/main.ts":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var THREE = __importStar(require("three"));
var OrbitControls_js_1 = require("three/examples/jsm/controls/OrbitControls.js");
var troika_three_text_1 = require("troika-three-text");
var lil_gui_1 = __importDefault(require("lil-gui"));
var EffectComposer_js_1 = require("three/examples/jsm/postprocessing/EffectComposer.js");
var RenderPass_js_1 = require("three/examples/jsm/postprocessing/RenderPass.js");
var ShaderPass_js_1 = require("three/examples/jsm/postprocessing/ShaderPass.js");
var CustomPass_js_1 = require("./CustomPass.js");
var RGBShiftShader_js_1 = require("three/examples/jsm/shaders/RGBShiftShader.js");
var OutputPass_js_1 = require("three/examples/jsm/postprocessing/OutputPass.js");
var core_1 = require("@theatre/core");
var Homebg_theatre_project_state_json_1 = __importDefault(require("../assets/Homebg.theatre-project-state.json"));
var studio_1 = __importDefault(require("@theatre/studio"));
var proj;
if (import.meta.env.DEV) {
  studio_1.default.initialize();
  var proj_1 = (0, core_1.getProject)("Homebg");
} else {
  var proj_2 = (0, core_1.getProject)("Homebg", {
    state: Homebg_theatre_project_state_json_1.default
  });
}
var sheet = proj.sheet("Scene1");
var distortion = sheet.object("Distortion", {
  progress: core_1.types.number(0, {
    range: [0, 1]
  }),
  bar: true,
  baz: "A string"
});
var TrajanPro_Bold_otf_1 = __importDefault(require("../assets/fonts/TrajanPro-Bold.otf"));
var Sketch = /** @class */function () {
  function Sketch(options) {
    var _this = this;
    this.scene = new THREE.Scene();
    this.container = options.dom;
    this.width = this.container.offsetWidth;
    this.height = this.container.offsetHeight;
    this.renderer = new THREE.WebGLRenderer({
      alpha: true,
      antialias: true
    });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.width, this.height);
    this.renderer.setClearColor(0x000000, 0);
    this.renderer.outputEncoding = THREE.sRGBEncoding;
    this.container.appendChild(this.renderer.domElement);
    this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.001, 1000);
    this.camera.position.set(0, 0, 2);
    this.controls = new OrbitControls_js_1.OrbitControls(this.camera, this.renderer.domElement);
    this.time = 0;
    this.initPost();
    this.addObjects();
    this.resize();
    this.render();
    this.setupResize();
    this.settings();
    distortion.onValuesChange(function (newValues) {
      console.log(newValues);
      _this.customPass.uniforms['progress'].value = newValues.progress;
      // Link the progress value to other effects
      _this.rgbShiftPass.uniforms['amount'].value = THREE.MathUtils.lerp(0.0015, 0.003, newValues.progress);
      _this.camera.position.z = THREE.MathUtils.lerp(2, 0.32, newValues.progress);
      _this.textMesh.rotation.z = THREE.MathUtils.lerp(0, -Math.PI / 2, newValues.progress);
    });
  }
  Sketch.prototype.initPost = function () {
    this.composer = new EffectComposer_js_1.EffectComposer(this.renderer);
    this.composer.addPass(new RenderPass_js_1.RenderPass(this.scene, this.camera));
    this.rgbShiftPass = new ShaderPass_js_1.ShaderPass(RGBShiftShader_js_1.RGBShiftShader);
    this.rgbShiftPass.uniforms['amount'].value = 0.0015;
    this.composer.addPass(this.rgbShiftPass);
    this.customPass = new ShaderPass_js_1.ShaderPass(CustomPass_js_1.CustomPass);
    this.composer.addPass(this.customPass);
    this.outputPass = new OutputPass_js_1.OutputPass();
    this.composer.addPass(this.outputPass);
  };
  Sketch.prototype.addObjects = function () {
    this.textMesh = new troika_three_text_1.Text();
    this.textMesh.text = "Cogito, ergo sum\nI                     think\ntherefore    I    am";
    this.textMesh.fontSize = 0.3;
    this.textMesh.lineHeight = 1.;
    this.textMesh.font = TrajanPro_Bold_otf_1.default;
    this.textMesh.position.set(0, 0, 0);
    this.textMesh.color = 0xffefef;
    this.textMesh.anchorX = 'center';
    this.textMesh.anchorY = 'middle';
    this.textMesh.sync();
    this.scene.add(this.textMesh);
  };
  Sketch.prototype.render = function () {
    this.time += 0.01;
    this.customPass.uniforms['time'].value = this.time;
    this.customPass.uniforms['scale'].value = this.settings.scale;
    requestAnimationFrame(this.render.bind(this));
    this.composer.render();
  };
  Sketch.prototype.settings = function () {
    this.settings = {
      progress: 0,
      scale: 1
    };
    this.gui = new lil_gui_1.default();
    this.gui.add(this.settings, "progress", 0, 1, 0.01).onChange(function (val) {});
    this.gui.add(this.settings, "scale", 0, 10, 0.01).onChange(function (val) {});
  };
  Sketch.prototype.setupResize = function () {
    window.addEventListener("resize", this.resize.bind(this));
  };
  Sketch.prototype.resize = function () {
    this.width = this.container.offsetWidth;
    this.height = this.container.offsetHeight;
    this.renderer.setSize(this.width, this.height);
    this.camera.aspect = this.width / this.height;
    this.camera.updateProjectionMatrix();
  };
  return Sketch;
}();
exports.default = Sketch;
new Sketch({
  dom: document.getElementById("container")
});
},{"three":"node_modules/three/build/three.module.js","three/examples/jsm/controls/OrbitControls.js":"node_modules/three/examples/jsm/controls/OrbitControls.js","troika-three-text":"node_modules/troika-three-text/dist/troika-three-text.esm.js","lil-gui":"node_modules/lil-gui/dist/lil-gui.esm.js","three/examples/jsm/postprocessing/EffectComposer.js":"node_modules/three/examples/jsm/postprocessing/EffectComposer.js","three/examples/jsm/postprocessing/RenderPass.js":"node_modules/three/examples/jsm/postprocessing/RenderPass.js","three/examples/jsm/postprocessing/ShaderPass.js":"node_modules/three/examples/jsm/postprocessing/ShaderPass.js","./CustomPass.js":"js/CustomPass.js","three/examples/jsm/shaders/RGBShiftShader.js":"node_modules/three/examples/jsm/shaders/RGBShiftShader.js","three/examples/jsm/postprocessing/OutputPass.js":"node_modules/three/examples/jsm/postprocessing/OutputPass.js","@theatre/core":"node_modules/@theatre/core/dist/index.js","../assets/Homebg.theatre-project-state.json":"assets/Homebg.theatre-project-state.json","@theatre/studio":"node_modules/@theatre/studio/dist/index.js","../assets/fonts/TrajanPro-Bold.otf":"assets/fonts/TrajanPro-Bold.otf"}],"../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "61420" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","js/main.ts"], null)
//# sourceMappingURL=/main.7ebd0bc5.js.map